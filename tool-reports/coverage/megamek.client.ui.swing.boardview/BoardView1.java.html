<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="nl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BoardView1.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PlayerTest Coverage Results</a> &gt; <a href="index.source.html" class="el_package">megamek.client.ui.swing.boardview</a> &gt; <span class="el_source">BoardView1.java</span></div><h1>BoardView1.java</h1><pre class="source lang-java linenums">/*
* MegaMek -
* Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Ben Mazur (bmazur@sev.org)
* Copyright (C) 2018 The MegaMek Team
*
* This program is free software; you can redistribute it and/or modify it under
* the terms of the GNU General Public License as published by the Free Software
* Foundation; either version 2 of the License, or (at your option) any later
* version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
* details.
*/

package megamek.client.ui.swing.boardview;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Component;
import java.awt.Composite;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsEnvironment;
import java.awt.Image;
import java.awt.MediaTracker;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Toolkit;
import java.awt.Transparency;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.font.GlyphVector;
import java.awt.geom.AffineTransform;
import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.ImageObserver;
import java.awt.image.ImageProducer;
import java.awt.image.Kernel;
import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

import javax.imageio.ImageIO;
import javax.swing.AbstractAction;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JViewport;
import javax.swing.ScrollPaneLayout;
import javax.swing.Scrollable;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.plaf.metal.DefaultMetalTheme;
import javax.swing.plaf.metal.MetalTheme;

import megamek.MegaMek;
import megamek.client.TimerSingleton;
import megamek.client.bot.princess.BotGeometry.ConvexBoardArea;
import megamek.client.bot.princess.PathEnumerator;
import megamek.client.bot.princess.Princess;
import megamek.client.event.BoardViewEvent;
import megamek.client.event.BoardViewListener;
import megamek.client.event.MechDisplayEvent;
import megamek.client.ui.IBoardView;
import megamek.client.ui.IDisplayable;
import megamek.client.ui.Messages;
import megamek.client.ui.SharedUtility;
import megamek.client.ui.swing.ChatterBox2;
import megamek.client.ui.swing.ClientGUI;
import megamek.client.ui.swing.GUIPreferences;
import megamek.client.ui.swing.MovementDisplay;
import megamek.client.ui.swing.tileset.HexTileset;
import megamek.client.ui.swing.tileset.TilesetManager;
import megamek.client.ui.swing.util.CommandAction;
import megamek.client.ui.swing.util.ImageCache;
import megamek.client.ui.swing.util.KeyCommandBind;
import megamek.client.ui.swing.util.MegaMekController;
import megamek.client.ui.swing.widget.MegamekBorder;
import megamek.client.ui.swing.widget.SkinSpecification;
import megamek.client.ui.swing.widget.SkinXMLHandler;
import megamek.common.ArtilleryTracker;
import megamek.common.Building;
import megamek.common.Building.BasementType;
import megamek.common.Compute;
import megamek.common.ComputeECM;
import megamek.common.Configuration;
import megamek.common.Coords;
import megamek.common.ECMInfo;
import megamek.common.Entity;
import megamek.common.EntityVisibilityUtils;
import megamek.common.Flare;
import megamek.common.GunEmplacement;
import megamek.common.IBoard;
import megamek.common.IGame;
import megamek.common.IGame.Phase;
import megamek.common.IHex;
import megamek.common.IPlayer;
import megamek.common.ITerrain;
import megamek.common.Infantry;
import megamek.common.LosEffects;
import megamek.common.Mech;
import megamek.common.Minefield;
import megamek.common.Mounted;
import megamek.common.MovePath;
import megamek.common.MovePath.MoveStepType;
import megamek.common.MoveStep;
import megamek.common.PlanetaryConditions;
import megamek.common.QuadMech;
import megamek.common.SpecialHexDisplay;
import megamek.common.TargetRoll;
import megamek.common.Targetable;
import megamek.common.Terrains;
import megamek.common.ToHitData;
import megamek.common.TripodMech;
import megamek.common.UnitLocation;
import megamek.common.WeaponType;
import megamek.common.actions.ArtilleryAttackAction;
import megamek.common.actions.AttackAction;
import megamek.common.actions.ChargeAttackAction;
import megamek.common.actions.ClubAttackAction;
import megamek.common.actions.DfaAttackAction;
import megamek.common.actions.EntityAction;
import megamek.common.actions.KickAttackAction;
import megamek.common.actions.PhysicalAttackAction;
import megamek.common.actions.ProtomechPhysicalAttackAction;
import megamek.common.actions.PunchAttackAction;
import megamek.common.actions.PushAttackAction;
import megamek.common.actions.SearchlightAttackAction;
import megamek.common.actions.WeaponAttackAction;
import megamek.common.event.BoardEvent;
import megamek.common.event.BoardListener;
import megamek.common.event.GameBoardChangeEvent;
import megamek.common.event.GameBoardNewEvent;
import megamek.common.event.GameEntityChangeEvent;
import megamek.common.event.GameEntityNewEvent;
import megamek.common.event.GameEntityRemoveEvent;
import megamek.common.event.GameListener;
import megamek.common.event.GameListenerAdapter;
import megamek.common.event.GameNewActionEvent;
import megamek.common.event.GamePhaseChangeEvent;
import megamek.common.logging.LogLevel;
import megamek.common.options.GameOptions;
import megamek.common.options.OptionsConstants;
import megamek.common.pathfinder.BoardClusterTracker;
import megamek.common.pathfinder.BoardClusterTracker.BoardCluster;
import megamek.common.preference.IClientPreferences;
import megamek.common.preference.IPreferenceChangeListener;
import megamek.common.preference.PreferenceChangeEvent;
import megamek.common.preference.PreferenceManager;
import megamek.common.util.FiringSolution;
import megamek.common.util.ImageUtil;
import megamek.common.util.fileUtils.MegaMekFile;

/**
 * Displays the board; lets the user scroll around and select points on it.
 */
public class BoardView1 extends JPanel implements IBoardView, Scrollable,
        BoardListener, MouseListener, IPreferenceChangeListener {

    private static final long serialVersionUID = -5582195884759007416L;

    static final int TRANSPARENT = 0xFFFF00FF;

    private static final int BOARD_HEX_CLICK = 1;
    private static final int BOARD_HEX_DOUBLECLICK = 2;
    private static final int BOARD_HEX_DRAG = 3;
    private static final int BOARD_HEX_POPUP = 4;

    // the dimensions of megamek's hex images
    public static final int HEX_W = HexTileset.HEX_W;
    public static final int HEX_H = HexTileset.HEX_H;
<span class="nc" id="L197">    public static final int HEX_DIAG = (int)Math.round(Math.sqrt(HEX_W * HEX_W + HEX_H * HEX_H));</span>

    private static final int HEX_WC = HEX_W - (HEX_W / 4);
    static final int HEX_ELEV = 12;

<span class="nc" id="L202">    private static final float[] ZOOM_FACTORS = { 0.30f, 0.41f, 0.50f, 0.60f,</span>
            0.68f, 0.79f, 0.90f, 1.00f, 1.09f, 1.17f, 1.3f };

<span class="nc" id="L205">    private static final int[] ZOOM_SCALE_TYPES = {</span>
            ImageUtil.IMAGE_SCALE_AVG_FILTER, ImageUtil.IMAGE_SCALE_AVG_FILTER,
            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
            ImageUtil.IMAGE_SCALE_BICUBIC };

<span class="nc" id="L213">    public static final int [] allDirections = {0,1,2,3,4,5};</span>

    // Set to TRUE to draw hexes with isometric elevation.
<span class="nc" id="L216">    private boolean drawIsometric = GUIPreferences.getInstance()</span>
<span class="nc" id="L217">                                                  .getIsometricEnabled();</span>

<span class="nc" id="L219">    int DROPSHDW_DIST = 20;</span>

    // the index of zoom factor 1.00f
    static final int BASE_ZOOM_INDEX = 7;

    // Initial zoom index
<span class="nc" id="L225">    public int zoomIndex = BASE_ZOOM_INDEX;</span>

    // line width of the c3 network lines
    static final int C3_LINE_WIDTH = 1;

    // line width of the fly over lines
    static final int FLY_OVER_LINE_WIDTH = 3;

<span class="nc" id="L233">    private static Font FONT_7 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 7); //$NON-NLS-1$</span>
<span class="nc" id="L234">    private static Font FONT_8 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 8); //$NON-NLS-1$</span>
<span class="nc" id="L235">    private static Font FONT_9 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 9); //$NON-NLS-1$</span>
<span class="nc" id="L236">    private static Font FONT_10 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 10); //$NON-NLS-1$</span>
<span class="nc" id="L237">    private static Font FONT_12 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 12); //$NON-NLS-1$</span>

<span class="nc" id="L239">    Dimension hex_size = null;</span>

<span class="nc" id="L241">    private Font font_note = FONT_10;</span>
<span class="nc" id="L242">    private Font font_hexnum = FONT_10;</span>
<span class="nc" id="L243">    private Font font_elev = FONT_9;</span>
<span class="nc" id="L244">    private Font font_minefield = FONT_12;</span>

    public final IGame game;
    ClientGUI clientgui;

    private Dimension boardSize;
<span class="nc" id="L250">    private Dimension preferredSize = new Dimension(0, 0);</span>

    // scrolly stuff:
<span class="nc" id="L253">    private JScrollPane scrollpane = null;</span>
    private JScrollBar vbar;
    private JScrollBar hbar;
<span class="nc" id="L256">    private int scrollXDifference = 0;</span>
<span class="nc" id="L257">    private int scrollYDifference = 0;</span>
    // are we drag-scrolling?
<span class="nc" id="L259">    private boolean dragging = false;</span>
    /** True when the right mouse button was pressed to start a drag */
<span class="nc" id="L261">    private boolean shouldScroll = false;</span>

    // entity sprites
<span class="nc" id="L264">    private Queue&lt;EntitySprite&gt; entitySprites = new PriorityQueue&lt;EntitySprite&gt;();</span>
<span class="nc" id="L265">    private Queue&lt;IsometricSprite&gt; isometricSprites = new PriorityQueue&lt;IsometricSprite&gt;();</span>

<span class="nc" id="L267">    private ArrayList&lt;FlareSprite&gt; flareSprites = new ArrayList&lt;FlareSprite&gt;();</span>
    /**
     * A Map that maps an Entity ID and a secondary position to a Sprite. Note
     * that the key is a List where the first entry will be the Entity ID and
     * the second entry will be which secondary position the sprite belongs to;
     * if the Entity has no secondary positions, the first element will be the
     * ID and the second element will be -1.
     */
<span class="nc" id="L275">    private Map&lt;List&lt;Integer&gt;, EntitySprite&gt; entitySpriteIds = new HashMap&lt;&gt;();</span>
    /**
     * A Map that maps an Entity ID and a secondary position to a Sprite. Note
     * that the key is a List where the first entry will be the Entity ID and
     * the second entry will be which secondary position the sprite belongs to;
     * if the Entity has no secondary positions, the first element will be the
     * ID and the second element will be -1.
     */
<span class="nc" id="L283">    private Map&lt;List&lt;Integer&gt;, IsometricSprite&gt; isometricSpriteIds = new HashMap&lt;&gt;();</span>

    // sprites for the three selection cursors
    private CursorSprite cursorSprite;
    private CursorSprite highlightSprite;
    private CursorSprite selectedSprite;
    private CursorSprite firstLOSSprite;
    private CursorSprite secondLOSSprite;

    // sprite for current movement
<span class="nc" id="L293">    ArrayList&lt;StepSprite&gt; pathSprites = new ArrayList&lt;StepSprite&gt;();</span>

<span class="nc" id="L295">    private ArrayList&lt;Coords&gt; strafingCoords = new ArrayList&lt;Coords&gt;(5);</span>

<span class="nc" id="L297">    private ArrayList&lt;FiringSolutionSprite&gt; firingSprites = new ArrayList&lt;FiringSolutionSprite&gt;();</span>

<span class="nc" id="L299">    private ArrayList&lt;MovementEnvelopeSprite&gt; moveEnvSprites = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L300">    private ArrayList&lt;MovementModifierEnvelopeSprite&gt; moveModEnvSprites = new ArrayList&lt;&gt;();</span>

    // vector of sprites for all firing lines
<span class="nc" id="L303">    ArrayList&lt;AttackSprite&gt; attackSprites = new ArrayList&lt;AttackSprite&gt;();</span>

    // vector of sprites for all movement paths (using vectored movement)
<span class="nc" id="L306">    private ArrayList&lt;MovementSprite&gt; movementSprites = new ArrayList&lt;MovementSprite&gt;();</span>

    // vector of sprites for C3 network lines
<span class="nc" id="L309">    private ArrayList&lt;C3Sprite&gt; c3Sprites = new ArrayList&lt;C3Sprite&gt;();</span>

    // list of sprites for declared VTOL/airmech bombing/strafing targets
<span class="nc" id="L312">    private ArrayList&lt;VTOLAttackSprite&gt; vtolAttackSprites = new ArrayList&lt;&gt;();</span>

    // vector of sprites for aero flyover lines
<span class="nc" id="L315">    private ArrayList&lt;FlyOverSprite&gt; flyOverSprites = new ArrayList&lt;FlyOverSprite&gt;();</span>

    // List of sprites for the weapon field of fire
<span class="nc" id="L318">    private ArrayList&lt;HexSprite&gt; fieldofFireSprites = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L319">    public int[][] fieldofFireRanges = { new int[5], new int[5] };</span>
    public int fieldofFireWpArc;
    public Entity fieldofFireUnit;
    public int fieldofFireWpLoc;
    // int because it acts as an array index
<span class="nc" id="L324">    public int fieldofFireWpUnderwater = 0;</span>
<span class="nc" id="L325">    private static final String[] rangeTexts = { &quot;min&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;E&quot; };</span>

<span class="nc" id="L327">    TilesetManager tileManager = null;</span>

    // polygons for a few things
    static Polygon hexPoly;
    static {
        // hex polygon
<span class="nc" id="L333">        hexPoly = new Polygon();</span>
<span class="nc" id="L334">        hexPoly.addPoint(21, 0);</span>
<span class="nc" id="L335">        hexPoly.addPoint(62, 0);</span>
<span class="nc" id="L336">        hexPoly.addPoint(83, 35);</span>
<span class="nc" id="L337">        hexPoly.addPoint(83, 36);</span>
<span class="nc" id="L338">        hexPoly.addPoint(62, 71);</span>
<span class="nc" id="L339">        hexPoly.addPoint(21, 71);</span>
<span class="nc" id="L340">        hexPoly.addPoint(0, 36);</span>
<span class="nc" id="L341">        hexPoly.addPoint(0, 35);</span>
    }

    Shape[] movementPolys;
    Shape[] facingPolys;
    Shape[] finalFacingPolys;
    Shape upArrow;
    Shape downArrow;

    // Image to hold the complete board shadow map
    BufferedImage shadowMap;
<span class="nc" id="L352">    double[] lightDirection = { -19, 7 };</span>
<span class="nc" id="L353">    private static Kernel kernel = new Kernel(5, 5,</span>
            new float[] {
                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f,
                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f,
                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f,
                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f,
                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f});
<span class="nc" id="L360">    private static BufferedImageOp blurOp = new ConvolveOp(kernel);</span>

    // the player who owns this BoardView's client
<span class="nc" id="L363">    private IPlayer localPlayer = null;</span>

    /**
     * Stores the currently deploying entity, used for highlighting deployment
     * hexes.
     */
<span class="nc" id="L369">    private Entity en_Deployer = null;</span>

    // should be able to turn it off(board editor)
<span class="nc" id="L372">    private boolean useLOSTool = true;</span>

    // Initial scale factor for sprites and map
<span class="nc" id="L375">    float scale = 1.00f;</span>
<span class="nc" id="L376">    private ImageCache&lt;Integer, Image&gt; scaledImageCache =</span>
            new ImageCache&lt;Integer, Image&gt;();
<span class="nc" id="L378">    private ImageCache&lt;Integer, BufferedImage&gt; shadowImageCache =</span>
            new ImageCache&lt;Integer, BufferedImage&gt;();

<span class="nc" id="L381">    private Set&lt;Integer&gt; animatedImages = new HashSet&lt;Integer&gt;();</span>

    // Displayables (Chat box, etc.)
<span class="nc" id="L384">    ArrayList&lt;IDisplayable&gt; displayables = new ArrayList&lt;IDisplayable&gt;();</span>

    // Move units step by step
<span class="nc" id="L387">    private ArrayList&lt;MovingUnit&gt; movingUnits = new ArrayList&lt;MovingUnit&gt;();</span>

<span class="nc" id="L389">    private long moveWait = 0;</span>

    // moving entity sprites
<span class="nc" id="L392">    private List&lt;MovingEntitySprite&gt; movingEntitySprites = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L393">    private HashMap&lt;Integer, MovingEntitySprite&gt; movingEntitySpriteIds = new HashMap&lt;&gt;();</span>
<span class="nc" id="L394">    private ArrayList&lt;GhostEntitySprite&gt; ghostEntitySprites = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L396">    protected transient ArrayList&lt;BoardViewListener&gt; boardListeners = new ArrayList&lt;&gt;();</span>

    // wreck sprites
<span class="nc" id="L399">    private ArrayList&lt;WreckSprite&gt; wreckSprites = new ArrayList&lt;WreckSprite&gt;();</span>
<span class="nc" id="L400">    private ArrayList&lt;IsometricWreckSprite&gt; isometricWreckSprites = new ArrayList&lt;&gt;();</span>

    private Coords rulerStart;
    private Coords rulerEnd;
    private Color rulerStartColor;
    private Color rulerEndColor;

    private Coords lastCursor;
    private Coords highlighted;
    Coords selected;
    private Coords firstLOS;

    /** stores the theme last selected to override all hex themes */
<span class="nc" id="L413">    private String selectedTheme = null;</span>

    // selected entity and weapon for artillery display
<span class="nc" id="L416">    Entity selectedEntity = null;</span>
<span class="nc" id="L417">    private Mounted selectedWeapon = null;</span>

    // hexes with ECM effect
<span class="nc" id="L420">    private Map&lt;Coords, Color&gt; ecmHexes = null;</span>
    // hexes that are teh centers of ECM effects
<span class="nc" id="L422">    private Map&lt;Coords, Color&gt; ecmCenters = null;</span>
    // hexes with ECM effect
<span class="nc" id="L424">    private Map&lt;Coords, Color&gt; eccmHexes = null;</span>
    // hexes that are teh centers of ECCM effects
<span class="nc" id="L426">    private Map&lt;Coords, Color&gt; eccmCenters = null;</span>

    // reference to our timertask for redraw
<span class="nc" id="L429">    private TimerTask ourTask = null;</span>

<span class="nc" id="L431">    BufferedImage bvBgImage = null;</span>
<span class="nc" id="L432">    boolean bvBgShouldTile = false;</span>
<span class="nc" id="L433">    BufferedImage scrollPaneBgBuffer = null;</span>
<span class="nc" id="L434">    Image scrollPaneBgImg = null;</span>

<span class="nc" id="L436">    List&lt;Image&gt; boardBackgrounds = new ArrayList&lt;&gt;();</span>

    private static final int FRAMES = 24;
    private long totalTime;
    private long averageTime;
    private int frameCount;
<span class="nc" id="L442">    private Font fpsFont = new Font(&quot;SansSerif&quot;, 0, 20); //$NON-NLS-1$</span>


    /**
     * Keeps track of whether we have an active ChatterBox2
     */
<span class="nc" id="L448">    private boolean chatterBoxActive = false;</span>

    /**
     * Keeps track of whether an outside source tells the BoardView that it
     * should ignore keyboard commands.
     */
<span class="nc" id="L454">    private boolean shouldIgnoreKeys = false;</span>

    FovHighlightingAndDarkening fovHighlightingAndDarkening;

<span class="nc" id="L458">    private String FILENAME_FLARE_IMAGE = &quot;flare.png&quot;;</span>

<span class="nc" id="L460">    private String FILENAME_RADAR_BLIP_IMAGE = &quot;radarBlip.png&quot;;</span>

    private Image flareImage;

    private Image radarBlipImage;

    /**
    * Cache that stores hex images for different coords
    */
    ImageCache&lt;Coords, HexImageCacheEntry&gt; hexImageCache;


    /**
     * Keeps track of whether all deployment zones should
     * be shown in the Arty Auto Hit Designation phase
     */
<span class="nc" id="L476">    public boolean showAllDeployment = false;</span>

    private long paintCompsStartTime;

<span class="nc" id="L480">    private Rectangle displayablesRect = new Rectangle();</span>

    // Soft Centering ---

    /** True when the board is in the process of centering to a spot. */
<span class="nc" id="L485">    private boolean isSoftCentering = false;</span>
    /** The final position of a soft centering relative to board size (x, y=0...1). */
<span class="nc" id="L487">    private Point2D softCenterTarget = new Point2D.Double();</span>
<span class="nc" id="L488">    private Point2D oldCenter = new Point2D.Double();</span>
    private long waitTimer;
    /** Speed of soft centering of the board, less is faster */
    private static final int SOFT_CENTER_SPEED = 8;

    // Tooltip Info ---
    /** Holds the final Coords for a planned movement. Set by MovementDisplay,
     *  used to display the distance in the board tooltip. */
    private Coords movementTarget;

    // Used to track the previous x/y for tooltip display
<span class="nc" id="L499">    int prevTipX = -1, prevTipY = -1;</span>

    /**
     * Flag to indicate if we should display informatin about illegal terrain in hexes.
     */
<span class="nc" id="L504">    boolean displayInvalidHexInfo = false;</span>

    /** Stores the correct tooltip dismiss delay so it can be restored when exiting the boardview */
<span class="nc" id="L507">    private int dismissDelay = ToolTipManager.sharedInstance().getDismissDelay();</span>
    
    /** A map overlay showing some important keybinds. */ 
    KeyBindingsOverlay keybindOverlay;


    /**
     * Construct a new board view for the specified game
     */
    public BoardView1(final IGame game, final MegaMekController controller, ClientGUI clientgui)
<span class="nc" id="L517">            throws java.io.IOException {</span>
<span class="nc" id="L518">        this.game = game;</span>
<span class="nc" id="L519">        this.clientgui = clientgui;</span>

<span class="nc" id="L521">        hexImageCache = new ImageCache&lt;Coords, HexImageCacheEntry&gt;();</span>

<span class="nc" id="L523">        tileManager = new TilesetManager(this);</span>
<span class="nc" id="L524">        ToolTipManager.sharedInstance().registerComponent(this);</span>

<span class="nc" id="L526">        game.addGameListener(gameListener);</span>
<span class="nc" id="L527">        game.getBoard().addBoardListener(this);</span>
        
<span class="nc" id="L529">        keybindOverlay = new KeyBindingsOverlay(game, clientgui);</span>
<span class="nc" id="L530">        addDisplayable(keybindOverlay);</span>
<span class="nc" id="L531">        ourTask = scheduleRedrawTimer();// call only once</span>
<span class="nc" id="L532">        clearSprites();</span>
<span class="nc" id="L533">        addMouseListener(this);</span>
<span class="nc" id="L534">        addMouseWheelListener(new MouseWheelListener() {</span>
            public void mouseWheelMoved(MouseWheelEvent we) {
<span class="nc" id="L536">                Point mousePoint = we.getPoint();</span>
<span class="nc" id="L537">                Point dispPoint = new Point(mousePoint.x + getBounds().x, mousePoint.y + getBounds().y);</span>
                
                // If the mouse is over an IDisplayable, have it react instead of the board
                // Currently only implemented for the ChatterBox
<span class="nc bnc" id="L541" title="All 2 branches missed.">                for (int i = 0; i &lt; displayables.size(); i++) {</span>
<span class="nc" id="L542">                    IDisplayable disp = displayables.get(i);</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">                    if (!(disp instanceof ChatterBox2)) {</span>
<span class="nc" id="L544">                        continue;</span>
                    }
<span class="nc" id="L546">                    double width = scrollpane.getViewport().getSize().getWidth();</span>
<span class="nc" id="L547">                    double height = scrollpane.getViewport().getSize().getHeight();</span>
<span class="nc" id="L548">                    Dimension drawDimension = new Dimension();</span>
<span class="nc" id="L549">                    drawDimension.setSize(width, height);</span>
                    // we need to adjust the point, because it should be against
                    // the displayable dimension
<span class="nc bnc" id="L552" title="All 2 branches missed.">                    if (disp.isMouseOver(dispPoint, drawDimension)) {</span>
<span class="nc" id="L553">                        ChatterBox2 cb2 = (ChatterBox2) disp;</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                        if (we.getWheelRotation() &gt; 0) {</span>
<span class="nc" id="L555">                            cb2.scrollDown();</span>
                        } else {
<span class="nc" id="L557">                            cb2.scrollUp();</span>
                        }
<span class="nc" id="L559">                        refreshDisplayables();</span>
<span class="nc" id="L560">                        return;</span>
                    }
                }
                
                // calculate a few things to reposition the map
<span class="nc" id="L565">                Coords zoomCenter = getCoordsAt(we.getPoint());</span>
<span class="nc" id="L566">                Point hexL = getCentreHexLocation(zoomCenter);</span>
<span class="nc" id="L567">                Point inhexDelta = new Point(we.getPoint());</span>
<span class="nc" id="L568">                inhexDelta.translate(-HEX_W, -HEX_H);</span>
<span class="nc" id="L569">                inhexDelta.translate(-hexL.x, -hexL.y);</span>
<span class="nc" id="L570">                double ihdx = ((double)inhexDelta.x)/((double)HEX_W)/scale;</span>
<span class="nc" id="L571">                double ihdy = ((double)inhexDelta.y)/((double)HEX_H)/scale;</span>
<span class="nc" id="L572">                int oldzoomIndex = zoomIndex;</span>
                
<span class="nc" id="L574">                boolean ZoomNoCtrl = GUIPreferences.getInstance().getMouseWheelZoom();</span>
<span class="nc" id="L575">                boolean wheelFlip = GUIPreferences.getInstance().getMouseWheelZoomFlip();</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">                boolean zoomIn = (we.getWheelRotation() &gt; 0) ^ wheelFlip; // = XOR</span>
<span class="nc" id="L577">                boolean doZoom = ZoomNoCtrl ^ we.isControlDown(); // = XOR</span>
<span class="nc bnc" id="L578" title="All 4 branches missed.">                boolean horizontalScroll = !doZoom &amp;&amp; we.isShiftDown();</span>

<span class="nc bnc" id="L580" title="All 2 branches missed.">                if (doZoom) {</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">                    if (zoomIn) {</span>
<span class="nc" id="L582">                        zoomIn();</span>
                    } else {
<span class="nc" id="L584">                        zoomOut();</span>
                    }
<span class="nc bnc" id="L586" title="All 2 branches missed.">                    if (zoomIndex != oldzoomIndex) {</span>
<span class="nc" id="L587">                        adjustVisiblePosition(zoomCenter, dispPoint, ihdx, ihdy);</span>
                    }
                } else { // SCROLL
<span class="nc bnc" id="L590" title="All 2 branches missed.">                    if (horizontalScroll) {</span>
<span class="nc" id="L591">                        hbar.setValue((int) (hbar.getValue() + (HEX_H * scale * (we.getWheelRotation()))));</span>
                    } else {
<span class="nc" id="L593">                        vbar.setValue((int) (vbar.getValue() + (HEX_H * scale * (we.getWheelRotation()))));</span>
                    }
<span class="nc" id="L595">                    stopSoftCentering();</span>
                }
                
<span class="nc" id="L598">                pingMinimap();</span>
<span class="nc" id="L599">            }</span>
        });

<span class="nc" id="L602">        MouseMotionListener mouseMotionListener = new MouseMotionAdapter() {</span>
            @Override
            public void mouseMoved(MouseEvent e) {
<span class="nc" id="L605">                Point point = e.getPoint();</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">                if (null == point) {</span>
<span class="nc" id="L607">                    return;</span>
                }

<span class="nc bnc" id="L610" title="All 2 branches missed.">                for (IDisplayable disp: displayables) {</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">                    if (disp.isBeingDragged()) {</span>
<span class="nc" id="L612">                        return;</span>
                    }
<span class="nc" id="L614">                    double width = Math.min(boardSize.getWidth(), scrollpane</span>
<span class="nc" id="L615">                            .getViewport().getSize().getWidth());</span>
<span class="nc" id="L616">                    double height = Math.min(boardSize.getHeight(), scrollpane</span>
<span class="nc" id="L617">                            .getViewport().getSize().getHeight());</span>
<span class="nc" id="L618">                    Dimension drawDimension = new Dimension();</span>
<span class="nc" id="L619">                    drawDimension.setSize(width, height);</span>
<span class="nc" id="L620">                    disp.isMouseOver(point, drawDimension);</span>
<span class="nc" id="L621">                }</span>
<span class="nc" id="L622">            }</span>

            @Override
            public void mouseDragged(MouseEvent e) {
<span class="nc" id="L626">                Point point = e.getPoint();</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">                if (null == point) {</span>
<span class="nc" id="L628">                    return;</span>
                }
<span class="nc bnc" id="L630" title="All 2 branches missed.">                for (int i = 0; i &lt; displayables.size(); i++) {</span>
<span class="nc" id="L631">                    IDisplayable disp = displayables.get(i);</span>
<span class="nc" id="L632">                    Point adjustPoint = new Point((int) Math.min(</span>
<span class="nc" id="L633">                            boardSize.getWidth(), -getBounds().getX()),</span>
<span class="nc" id="L634">                                                  (int) Math.min(boardSize.getHeight(), -getBounds()</span>
<span class="nc" id="L635">                                                          .getY()));</span>
<span class="nc" id="L636">                    Point dispPoint = new Point();</span>
<span class="nc" id="L637">                    dispPoint.x = point.x - adjustPoint.x;</span>
<span class="nc" id="L638">                    dispPoint.y = point.y - adjustPoint.y;</span>
<span class="nc" id="L639">                    double width = Math.min(boardSize.getWidth(), scrollpane</span>
<span class="nc" id="L640">                            .getViewport().getSize().getWidth());</span>
<span class="nc" id="L641">                    double height = Math.min(boardSize.getHeight(), scrollpane</span>
<span class="nc" id="L642">                            .getViewport().getSize().getHeight());</span>
<span class="nc" id="L643">                    Dimension drawDimension = new Dimension();</span>
<span class="nc" id="L644">                    drawDimension.setSize(width, height);</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">                    if (disp.isDragged(dispPoint, drawDimension)) {</span>
<span class="nc" id="L646">                        repaint();</span>
<span class="nc" id="L647">                        return;</span>
                    }
                }
                // only scroll when we should
<span class="nc bnc" id="L651" title="All 2 branches missed.">                if (!shouldScroll) {</span>
<span class="nc" id="L652">                    mouseAction(getCoordsAt(point), BOARD_HEX_DRAG,</span>
<span class="nc" id="L653">                                e.getModifiers());</span>
<span class="nc" id="L654">                    return;</span>
                }
                // if we have not yet been dragging, set the var so popups don't
                // appear when we stop scrolling
<span class="nc bnc" id="L658" title="All 2 branches missed.">                if (!dragging) {</span>
<span class="nc" id="L659">                    dragging = true;</span>
<span class="nc" id="L660">                    setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));</span>
                }
<span class="nc" id="L662">                Point p = scrollpane.getViewport().getViewPosition();</span>
<span class="nc" id="L663">                int newX = p.x - (e.getX() - scrollXDifference);</span>
<span class="nc" id="L664">                int newY = p.y - (e.getY() - scrollYDifference);</span>
<span class="nc" id="L665">                int maxX = getWidth() - scrollpane.getViewport().getWidth();</span>
<span class="nc" id="L666">                int maxY = getHeight() - scrollpane.getViewport().getHeight();</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                if (newX &lt; 0) {</span>
<span class="nc" id="L668">                    newX = 0;</span>
                }
<span class="nc bnc" id="L670" title="All 2 branches missed.">                if (newX &gt; maxX) {</span>
<span class="nc" id="L671">                    newX = maxX;</span>
                }
<span class="nc bnc" id="L673" title="All 2 branches missed.">                if (newY &lt; 0) {</span>
<span class="nc" id="L674">                    newY = 0;</span>
                }
<span class="nc bnc" id="L676" title="All 2 branches missed.">                if (newY &gt; maxY) {</span>
<span class="nc" id="L677">                    newY = maxY;</span>
                }
                // don't scroll horizontally if the board fits into the window
<span class="nc bnc" id="L680" title="All 2 branches missed.">                if (scrollpane.getViewport().getWidth() &gt;= getWidth()) {</span>
<span class="nc" id="L681">                    newX = scrollpane.getViewport().getViewPosition().x;</span>
                }
<span class="nc" id="L683">                scrollpane.getViewport().setViewPosition(new Point(newX, newY));</span>
<span class="nc" id="L684">            }</span>
        };
<span class="nc" id="L686">        addMouseMotionListener(mouseMotionListener);</span>

<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (controller != null) {</span>
<span class="nc" id="L689">            registerKeyboardCommands(this, controller);</span>
        }

        // setAutoscrolls(true);

<span class="nc" id="L694">        updateBoardSize();</span>

<span class="nc" id="L696">        hex_size = new Dimension((int) (HEX_W * scale), (int) (HEX_H * scale));</span>

<span class="nc" id="L698">        initPolys();</span>

<span class="nc" id="L700">        cursorSprite = new CursorSprite(this, Color.cyan);</span>
<span class="nc" id="L701">        highlightSprite = new CursorSprite(this, Color.white);</span>
<span class="nc" id="L702">        selectedSprite = new CursorSprite(this, Color.blue);</span>
<span class="nc" id="L703">        firstLOSSprite = new CursorSprite(this, Color.red);</span>
<span class="nc" id="L704">        secondLOSSprite = new CursorSprite(this, Color.red);</span>

<span class="nc" id="L706">        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);</span>
<span class="nc" id="L707">        GUIPreferences.getInstance().addPreferenceChangeListener(this);</span>

<span class="nc" id="L709">        SpecialHexDisplay.Type.ARTILLERY_HIT.init();</span>
<span class="nc" id="L710">        SpecialHexDisplay.Type.ARTILLERY_INCOMING.init();</span>
<span class="nc" id="L711">        SpecialHexDisplay.Type.ARTILLERY_TARGET.init();</span>
<span class="nc" id="L712">        SpecialHexDisplay.Type.ARTILLERY_ADJUSTED.init();</span>
<span class="nc" id="L713">        SpecialHexDisplay.Type.ARTILLERY_AUTOHIT.init();</span>
<span class="nc" id="L714">        SpecialHexDisplay.Type.PLAYER_NOTE.init();</span>

<span class="nc" id="L716">        fovHighlightingAndDarkening = new FovHighlightingAndDarkening(this);</span>

<span class="nc" id="L718">        flareImage = ImageUtil.loadImageFromFile(</span>
<span class="nc" id="L719">                new MegaMekFile(Configuration.miscImagesDir(), FILENAME_FLARE_IMAGE)</span>
<span class="nc" id="L720">                        .toString());</span>
<span class="nc" id="L721">        radarBlipImage = ImageUtil.loadImageFromFile(</span>
<span class="nc" id="L722">                new MegaMekFile(Configuration.miscImagesDir(),</span>
<span class="nc" id="L723">                        FILENAME_RADAR_BLIP_IMAGE).toString());</span>
<span class="nc" id="L724">    }</span>

    private void registerKeyboardCommands(final BoardView1 bv,
            final MegaMekController controller) {
        // Register the action for TOGGLE_ISO
<span class="nc" id="L729">        controller.registerCommandAction(KeyCommandBind.TOGGLE_ISO.cmd,</span>
<span class="nc" id="L730">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L734" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L739">                        GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc" id="L740">                        guip.setIsometricEnabled(toggleIsometric());</span>
<span class="nc" id="L741">                    }</span>

                });

        // Register the action for TOGGLE_CHAT
<span class="nc" id="L746">        controller.registerCommandAction(KeyCommandBind.TOGGLE_CHAT.cmd,</span>
<span class="nc" id="L747">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L751" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc bnc" id="L756" title="All 2 branches missed.">                        if (!getChatterBoxActive()) {</span>
<span class="nc" id="L757">                            setChatterBoxActive(true);</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">                            for (IDisplayable disp : displayables) {</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">                                if (disp instanceof ChatterBox2) {</span>
<span class="nc" id="L760">                                    ((ChatterBox2) disp).slideUp();</span>
                                }
<span class="nc" id="L762">                            }</span>
<span class="nc" id="L763">                            requestFocus();</span>
                        }
<span class="nc" id="L765">                    }</span>

                });

        // Register the action for TOGGLE_CHAT
<span class="nc" id="L770">        controller.registerCommandAction(KeyCommandBind.TOGGLE_CHAT_CMD.cmd,</span>
<span class="nc" id="L771">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L775" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc bnc" id="L780" title="All 2 branches missed.">                        if (!getChatterBoxActive()) {</span>
<span class="nc" id="L781">                            setChatterBoxActive(true);</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">                            for (IDisplayable disp : displayables) {</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">                                if (disp instanceof ChatterBox2) {</span>
<span class="nc" id="L784">                                    ((ChatterBox2) disp).slideUp();</span>
<span class="nc" id="L785">                                    ((ChatterBox2) disp).setMessage(&quot;/&quot;);</span>
                                }
<span class="nc" id="L787">                            }</span>
<span class="nc" id="L788">                            requestFocus();</span>
                        }
<span class="nc" id="L790">                    }</span>

                });

        // Register the action for CENTER_ON_SELECTED
<span class="nc" id="L795">        controller.registerCommandAction(KeyCommandBind.CENTER_ON_SELECTED.cmd,</span>
<span class="nc" id="L796">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L800" title="All 4 branches missed.">                        if (shouldIgnoreKeyCommands() || (selectedEntity == null)) {</span>
<span class="nc" id="L801">                            return false;</span>
                        } else {
<span class="nc" id="L803">                            return true;</span>
                        }
                    }

                    @Override
                    public void performAction() {
<span class="nc bnc" id="L809" title="All 2 branches missed.">                        if (selectedEntity != null) {</span>
<span class="nc" id="L810">                            centerOnHex(selectedEntity.getPosition());</span>
                        }
<span class="nc" id="L812">                    }</span>

                });

        // Register the action for SCROLL_NORTH
<span class="nc" id="L817">        controller.registerCommandAction(KeyCommandBind.SCROLL_NORTH.cmd,</span>
<span class="nc" id="L818">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L822" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L827">                        controller.stopRepeating(KeyCommandBind.SCROLL_SOUTH);</span>
<span class="nc" id="L828">                        vbar.setValue((int) (vbar.getValue() - (HEX_H * scale)));</span>
<span class="nc" id="L829">                        stopSoftCentering();</span>
<span class="nc" id="L830">                    }</span>

                    @Override
                    public void releaseAction() {
<span class="nc" id="L834">                        pingMinimap();</span>
<span class="nc" id="L835">                    }</span>

                    @Override
                    public boolean hasReleaseAction() {
<span class="nc" id="L839">                        return true;</span>
                    }

                });

        // Register the action for SCROLL_SOUTH
<span class="nc" id="L845">        controller.registerCommandAction(KeyCommandBind.SCROLL_SOUTH.cmd,</span>
<span class="nc" id="L846">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L850" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L855">                        controller.stopRepeating(KeyCommandBind.SCROLL_NORTH);</span>
<span class="nc" id="L856">                        vbar.setValue((int) (vbar.getValue() + (HEX_H * scale)));</span>
<span class="nc" id="L857">                        stopSoftCentering();</span>
<span class="nc" id="L858">                    }</span>

                    @Override
                    public void releaseAction() {
<span class="nc" id="L862">                        pingMinimap();</span>
<span class="nc" id="L863">                    }</span>

                    @Override
                    public boolean hasReleaseAction() {
<span class="nc" id="L867">                        return true;</span>
                    }

                });

        // Register the action for SCROLL_EAST
<span class="nc" id="L873">        controller.registerCommandAction(KeyCommandBind.SCROLL_EAST.cmd,</span>
<span class="nc" id="L874">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L878" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L883">                        controller.stopRepeating(KeyCommandBind.SCROLL_WEST);</span>
<span class="nc" id="L884">                        hbar.setValue((int) (hbar.getValue() + (HEX_W * scale)));</span>
<span class="nc" id="L885">                        stopSoftCentering();</span>
<span class="nc" id="L886">                    }</span>

                    @Override
                    public void releaseAction() {
<span class="nc" id="L890">                        pingMinimap();</span>
<span class="nc" id="L891">                    }</span>

                    @Override
                    public boolean hasReleaseAction() {
<span class="nc" id="L895">                        return true;</span>
                    }

                });

        // Register the action for SCROLL_WEST
<span class="nc" id="L901">        controller.registerCommandAction(KeyCommandBind.SCROLL_WEST.cmd,</span>
<span class="nc" id="L902">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L906" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L911">                        controller.stopRepeating(KeyCommandBind.SCROLL_EAST);</span>
<span class="nc" id="L912">                        hbar.setValue((int) (hbar.getValue() - (HEX_W * scale)));</span>
<span class="nc" id="L913">                        stopSoftCentering();</span>
<span class="nc" id="L914">                    }</span>

                    @Override
                    public void releaseAction() {
<span class="nc" id="L918">                        pingMinimap();</span>
<span class="nc" id="L919">                    }</span>

                    @Override
                    public boolean hasReleaseAction() {
<span class="nc" id="L923">                        return true;</span>
                    }

                });

        // Register the action for Showing the Field of Fire
<span class="nc" id="L929">        controller.registerCommandAction(KeyCommandBind.FIELD_FIRE.cmd,</span>
<span class="nc" id="L930">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L934" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L939">                        GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">                        guip.setShowFieldOfFire(!guip.getShowFieldOfFire());</span>
<span class="nc" id="L941">                        repaint();</span>
<span class="nc" id="L942">                    }</span>

                });

        // Register the action for Toggling drawing unit labels
<span class="nc" id="L947">        controller.registerCommandAction(KeyCommandBind.TOGGLE_DRAW_LABELS.cmd,</span>
<span class="nc" id="L948">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L952" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L957">                        GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc" id="L958">                        boolean drawLabels = guip.getBoolean(</span>
                                GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL);
<span class="nc bnc" id="L960" title="All 2 branches missed.">                        guip.setValue(GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL,</span>
                                !drawLabels);
<span class="nc" id="L962">                        updateEntityLabels();</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">                        for (Sprite s: wreckSprites) {</span>
<span class="nc" id="L964">                            s.prepare();</span>
<span class="nc" id="L965">                        }</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">                        for (Sprite s: isometricWreckSprites) {</span>
<span class="nc" id="L967">                            s.prepare();</span>
<span class="nc" id="L968">                        }</span>
<span class="nc" id="L969">                    }</span>

                });
        
        // Register the action for TOGGLE_KEYBIND_DISPLAY
<span class="nc" id="L974">        controller.registerCommandAction(KeyCommandBind.TOGGLE_KEYBIND_DISPLAY.cmd,</span>
<span class="nc" id="L975">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L979" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L984">                        toggleKeybindsOverlay();</span>
<span class="nc" id="L985">                    }</span>
                });
        
        // Register the action for TOGGLE_HEX_COORDS
<span class="nc" id="L989">        controller.registerCommandAction(KeyCommandBind.TOGGLE_HEX_COORDS.cmd,</span>
<span class="nc" id="L990">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L994" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L999">                        boolean coordsShown = GUIPreferences.getInstance().getBoolean(GUIPreferences.ADVANCED_SHOW_COORDS);</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">                        GUIPreferences.getInstance().setValue(GUIPreferences.ADVANCED_SHOW_COORDS, !coordsShown);</span>
<span class="nc" id="L1001">                    }</span>

                });

<span class="nc" id="L1005">    }</span>

    private boolean shouldIgnoreKeyCommands() {
<span class="nc bnc" id="L1008" title="All 4 branches missed.">        return getChatterBoxActive() || !isVisible()</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_LOUNGE)</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_END_REPORT)</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_MOVEMENT_REPORT)</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_TARGETING_REPORT)</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_FIRING_REPORT)</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_PHYSICAL_REPORT)</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_OFFBOARD_REPORT)</span>
<span class="nc bnc" id="L1016" title="All 4 branches missed.">               || (game.getPhase() == Phase.PHASE_INITIATIVE_REPORT)</span>
               || shouldIgnoreKeys;
    }

<span class="nc" id="L1020">    protected final RedrawWorker redrawWorker = new RedrawWorker();</span>

    /**
     * this should only be called once!! this will cause a timer to schedule
     * constant screen updates every 20 milliseconds!
     */
    protected TimerTask scheduleRedrawTimer() {
<span class="nc" id="L1027">        final TimerTask redraw = new TimerTask() {</span>
            @Override
            public void run() {
                try {
<span class="nc" id="L1031">                    SwingUtilities.invokeLater(redrawWorker);</span>
<span class="nc" id="L1032">                } catch (Exception ie) {</span>
<span class="nc" id="L1033">                    System.err.print(&quot;Error scheduleRedrawTimer &quot;); //$NON-NLS-1$</span>
<span class="nc" id="L1034">                    System.err.print(ie.getMessage());</span>
<span class="nc" id="L1035">                    System.err.print(&quot;: &quot;); //$NON-NLS-1$</span>
<span class="nc" id="L1036">                    System.err.println(&quot;ignoring&quot;);</span>
<span class="nc" id="L1037">                }</span>
<span class="nc" id="L1038">            }</span>
        };
<span class="nc" id="L1040">        TimerSingleton.getInstance().schedule(redraw, 20, 20);</span>
<span class="nc" id="L1041">        return redraw;</span>
    }

    protected void scheduleRedraw() {
        try {
<span class="nc" id="L1046">            SwingUtilities.invokeLater(redrawWorker);</span>
<span class="nc" id="L1047">        } catch (Exception ie) {</span>
<span class="nc" id="L1048">            System.err.print(&quot;Error scheduleRedraw &quot;); //$NON-NLS-1$</span>
<span class="nc" id="L1049">            System.err.print(ie.getMessage());</span>
<span class="nc" id="L1050">            System.err.print(&quot;: &quot;); //$NON-NLS-1$</span>
<span class="nc" id="L1051">            System.err.println(&quot;ignoring&quot;);</span>
<span class="nc" id="L1052">        }</span>
<span class="nc" id="L1053">    }</span>

    public void preferenceChange(PreferenceChangeEvent e) {
<span class="nc bnc" id="L1056" title="All 2 branches missed.">        if (e.getName().equals(IClientPreferences.MAP_TILESET)) {</span>
<span class="nc" id="L1057">            updateBoard();</span>
        }
<span class="nc bnc" id="L1059" title="All 2 branches missed.">        if (e.getName().equals(GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL)</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.UNIT_LABEL_BORDER)</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.TEAM_COLORING)</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.SHOW_DAMAGE_DECAL)</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.SHOW_DAMAGE_LEVEL)) {</span>
<span class="nc" id="L1064">            updateEntityLabels();</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            for (Sprite s: wreckSprites) {</span>
<span class="nc" id="L1066">                s.prepare();</span>
<span class="nc" id="L1067">            }</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">            for (Sprite s: isometricWreckSprites) {</span>
<span class="nc" id="L1069">                s.prepare();</span>
<span class="nc" id="L1070">            }</span>
        }
<span class="nc bnc" id="L1072" title="All 2 branches missed.">        if (e.getName().equals(GUIPreferences.AOHEXSHADOWS)</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FLOATINGISO)</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.LEVELHIGHLIGHT)</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.ADVANCED_SHOW_COORDS)</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_DARKEN)</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_DARKEN_ALPHA)</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_GRAYSCALE)</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT)</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT_ALPHA)</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_STRIPES)</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT_RINGS_COLORS_HSB)</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT_RINGS_RADII)</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.SHADOWMAP)) {</span>
<span class="nc" id="L1085">            clearHexImageCache();</span>
<span class="nc" id="L1086">            repaint();</span>
        }
<span class="nc bnc" id="L1088" title="All 2 branches missed.">        if (e.getName().equals(GUIPreferences.INCLINES)) {</span>
<span class="nc" id="L1089">            game.getBoard().initializeAllAutomaticTerrain();</span>
<span class="nc" id="L1090">            clearHexImageCache();</span>
<span class="nc" id="L1091">            repaint();</span>
        }
<span class="nc" id="L1093">    }</span>

    /**
     * Adds the specified board listener to receive board events from this
     * board.
     *
     * @param listener the board listener.
     */
    public void addBoardViewListener(BoardViewListener listener) {
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        if (!boardListeners.contains(listener)) {</span>
<span class="nc" id="L1103">            boardListeners.add(listener);</span>
        }
<span class="nc" id="L1105">    }</span>

    /**
     * Removes the specified board listener.
     *
     * @param listener the board listener.
     */
    public void removeBoardViewListener(BoardViewListener listener) {
<span class="nc" id="L1113">        boardListeners.remove(listener);</span>
<span class="nc" id="L1114">    }</span>

    /**
     * Notifies attached board listeners of the event.
     *
     * @param event the board event.
     */
    public void processBoardViewEvent(BoardViewEvent event) {
<span class="nc bnc" id="L1122" title="All 2 branches missed.">        if (boardListeners == null) {</span>
<span class="nc" id="L1123">            return;</span>
        }
<span class="nc bnc" id="L1125" title="All 2 branches missed.">        for (BoardViewListener l : boardListeners) {</span>
<span class="nc bnc" id="L1126" title="All 9 branches missed.">            switch (event.getType()) {</span>
                case BoardViewEvent.BOARD_HEX_CLICKED:
                case BoardViewEvent.BOARD_HEX_DOUBLECLICKED:
                case BoardViewEvent.BOARD_HEX_DRAGGED:
                case BoardViewEvent.BOARD_HEX_POPUP:
<span class="nc" id="L1131">                    l.hexMoused(event);</span>
<span class="nc" id="L1132">                    break;</span>
                case BoardViewEvent.BOARD_HEX_CURSOR:
<span class="nc" id="L1134">                    l.hexCursor(event);</span>
<span class="nc" id="L1135">                    break;</span>
                case BoardViewEvent.BOARD_HEX_HIGHLIGHTED:
<span class="nc" id="L1137">                    l.boardHexHighlighted(event);</span>
<span class="nc" id="L1138">                    break;</span>
                case BoardViewEvent.BOARD_HEX_SELECTED:
<span class="nc" id="L1140">                    l.hexSelected(event);</span>
<span class="nc" id="L1141">                    break;</span>
                case BoardViewEvent.BOARD_FIRST_LOS_HEX:
<span class="nc" id="L1143">                    l.firstLOSHex(event);</span>
<span class="nc" id="L1144">                    break;</span>
                case BoardViewEvent.BOARD_SECOND_LOS_HEX:
<span class="nc" id="L1146">                    l.secondLOSHex(event, getFirstLOS());</span>
<span class="nc" id="L1147">                    break;</span>
                case BoardViewEvent.FINISHED_MOVING_UNITS:
<span class="nc" id="L1149">                    l.finishedMovingUnits(event);</span>
<span class="nc" id="L1150">                    break;</span>
                case BoardViewEvent.SELECT_UNIT:
<span class="nc" id="L1152">                    l.unitSelected(event);</span>
                    break;
            }
<span class="nc" id="L1155">        }</span>
<span class="nc" id="L1156">    }</span>

    void addMovingUnit(Entity entity, Vector&lt;UnitLocation&gt; movePath) {
<span class="nc bnc" id="L1159" title="All 2 branches missed.">        if (!movePath.isEmpty()) {</span>
<span class="nc" id="L1160">            MovingUnit m = new MovingUnit(entity, movePath);</span>
<span class="nc" id="L1161">            movingUnits.add(m);</span>

<span class="nc" id="L1163">            GhostEntitySprite ghostSprite = new GhostEntitySprite(this, entity);</span>
<span class="nc" id="L1164">            ghostEntitySprites.add(ghostSprite);</span>

            // Center on the starting hex of the moving unit.
<span class="nc" id="L1167">            UnitLocation loc = movePath.get(0);</span>
<span class="nc" id="L1168">            centerOnHex(loc.getCoords());</span>
        }
<span class="nc" id="L1170">    }</span>

    public void addDisplayable(IDisplayable disp) {
<span class="nc" id="L1173">        displayables.add(disp);</span>
<span class="nc" id="L1174">    }</span>

    public void removeDisplayable(IDisplayable disp) {
<span class="nc" id="L1177">        displayables.remove(disp);</span>
<span class="nc" id="L1178">    }</span>

    /**
     * Draw the screen!
     */
    @Override
    public synchronized void paintComponent(Graphics g) {
<span class="nc" id="L1185">        GUIPreferences guip = GUIPreferences.getInstance();</span>

<span class="nc bnc" id="L1187" title="All 2 branches missed.">        if (guip.getBoolean(GUIPreferences.ADVANCED_SHOW_FPS)) {</span>
<span class="nc" id="L1188">            paintCompsStartTime = System.nanoTime();</span>
        }

<span class="nc bnc" id="L1191" title="All 2 branches missed.">        if (guip.getAntiAliasing()) {</span>
<span class="nc" id="L1192">            ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,</span>
                    RenderingHints.VALUE_ANTIALIAS_ON);
        }

<span class="nc bnc" id="L1196" title="All 2 branches missed.">        if (!isTileImagesLoaded()) {</span>
<span class="nc" id="L1197">            g.drawString(Messages.getString(&quot;BoardView1.loadingImages&quot;), 20, 50); //$NON-NLS-1$</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">            if (!tileManager.isStarted()) {</span>
<span class="nc" id="L1199">                System.out.println(&quot;boardview1: loading images for board&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L1200">                tileManager.loadNeededImages(game);</span>
            }
            // wait 1 second, then repaint
<span class="nc" id="L1203">            repaint(1000);</span>
<span class="nc" id="L1204">            return;</span>
        }

<span class="nc" id="L1207">        Rectangle viewRect = scrollpane.getVisibleRect();</span>
<span class="nc bnc" id="L1208" title="All 4 branches missed.">        if (bvBgShouldTile &amp;&amp; (bvBgImage != null)) {</span>
<span class="nc" id="L1209">            Rectangle clipping = g.getClipBounds();</span>
<span class="nc" id="L1210">            int x = 0;</span>
<span class="nc" id="L1211">            int y = 0;</span>
<span class="nc" id="L1212">            int w = bvBgImage.getWidth();</span>
<span class="nc" id="L1213">            int h = bvBgImage.getHeight();</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">            while (y &lt; clipping.getHeight()) {</span>
<span class="nc" id="L1215">                int yRem = 0;</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">                if (y == 0) {</span>
<span class="nc" id="L1217">                    yRem = clipping.y % h;</span>
                }
<span class="nc" id="L1219">                x = 0;</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">                while (x &lt; clipping.getWidth()) {</span>
<span class="nc" id="L1221">                    int xRem = 0;</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">                    if (x == 0) {</span>
<span class="nc" id="L1223">                        xRem = clipping.x % w;</span>
                    }
<span class="nc bnc" id="L1225" title="All 4 branches missed.">                    if ((xRem &gt; 0) || (yRem &gt; 0)) {</span>
                        try {
<span class="nc" id="L1227">                            g.drawImage(</span>
<span class="nc" id="L1228">                                    bvBgImage.getSubimage(xRem, yRem, w - xRem,</span>
                                            h - yRem),
                                    clipping.x + x, clipping.y + y, this);
<span class="nc" id="L1231">                        } catch (Exception e) {</span>
                            // if we somehow messed up the math, log the error and simply act as if we have no background image.
<span class="nc" id="L1233">                            Rectangle rasterBounds = bvBgImage.getRaster().getBounds();</span>
                            
<span class="nc" id="L1235">                            String errorData = String.format(&quot;Error drawing background image. Raster Bounds: %.2f, %.2f, width:%.2f, height:%.2f, Attempted Draw Coordinates: %d, %d, width:%d, height:%d&quot;,</span>
<span class="nc" id="L1236">                                    rasterBounds.getMinX(), rasterBounds.getMinY(), rasterBounds.getWidth(), rasterBounds.getHeight(),</span>
<span class="nc" id="L1237">                                    xRem, yRem, w - xRem, h - yRem);</span>
<span class="nc" id="L1238">                            MegaMek.getLogger().error(this, errorData);</span>
<span class="nc" id="L1239">                        }</span>
                    } else {
<span class="nc" id="L1241">                        g.drawImage(bvBgImage, clipping.x + x, clipping.y + y,</span>
                                this);
                    }
<span class="nc" id="L1244">                    x += w - xRem;</span>
<span class="nc" id="L1245">                }</span>
<span class="nc" id="L1246">                y += h - yRem;</span>
<span class="nc" id="L1247">            }</span>
<span class="nc bnc" id="L1248" title="All 2 branches missed.">        } else if (bvBgImage != null) {</span>
<span class="nc" id="L1249">            g.drawImage(bvBgImage, -getX(), -getY(), (int) viewRect.getWidth(),</span>
<span class="nc" id="L1250">                    (int) viewRect.getHeight(), this);</span>
        } else {
<span class="nc" id="L1252">            MetalTheme theme = new DefaultMetalTheme();</span>
<span class="nc" id="L1253">            g.setColor(theme.getControl());</span>
<span class="nc" id="L1254">            g.fillRect(-getX(), -getY(), (int) viewRect.getWidth(),</span>
<span class="nc" id="L1255">                    (int) viewRect.getHeight());</span>
        }

        // Used to pad the board edge
<span class="nc" id="L1259">        g.translate(HEX_W, HEX_H);</span>

        // Initialize the shadow map when its not yet present
<span class="nc bnc" id="L1262" title="All 2 branches missed.">        if (shadowMap == null) {</span>
<span class="nc" id="L1263">            updateShadowMap();</span>
        }

<span class="nc" id="L1266">        drawHexes(g, g.getClipBounds());</span>

        // draw wrecks
<span class="nc bnc" id="L1269" title="All 4 branches missed.">        if (guip.getShowWrecks() &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L1270">            drawSprites(g, wreckSprites);</span>
        }

        // Field of Fire
<span class="nc bnc" id="L1274" title="All 2 branches missed.">        if (!useIsometric()</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">                &amp;&amp; GUIPreferences.getInstance().getShowFieldOfFire()) {</span>
<span class="nc" id="L1276">            drawSprites(g, fieldofFireSprites);</span>
        }

<span class="nc bnc" id="L1279" title="All 4 branches missed.">        if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L1280">            drawSprites(g, moveEnvSprites);</span>
<span class="nc" id="L1281">            drawSprites(g, moveModEnvSprites);</span>
        }

        // Minefield signs all over the place!
<span class="nc" id="L1285">        drawMinefields(g);</span>

        // Artillery targets
<span class="nc" id="L1288">        drawArtilleryHexes(g);</span>

        // draw highlight border
<span class="nc" id="L1291">        drawSprite(g, highlightSprite);</span>

        // draw cursors
<span class="nc" id="L1294">        drawSprite(g, cursorSprite);</span>
<span class="nc" id="L1295">        drawSprite(g, selectedSprite);</span>
<span class="nc" id="L1296">        drawSprite(g, firstLOSSprite);</span>
<span class="nc" id="L1297">        drawSprite(g, secondLOSSprite);</span>

        // draw deployment indicators.
        // For Isometric rendering, this is done during drawHexes
<span class="nc bnc" id="L1301" title="All 4 branches missed.">        if ((en_Deployer != null) &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L1302">            drawDeployment(g);</span>
        }

<span class="nc bnc" id="L1305" title="All 4 branches missed.">        if ((game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES)</span>
                &amp;&amp; (showAllDeployment)) {
<span class="nc" id="L1307">            drawAllDeployment(g);</span>
        }

        // draw Flare Sprites
<span class="nc" id="L1311">        drawSprites(g, flareSprites);</span>

        // draw C3 links
<span class="nc" id="L1314">        drawSprites(g, c3Sprites);</span>

        // draw flyover routes
<span class="nc bnc" id="L1317" title="All 2 branches missed.">        if (game.getBoard().onGround()) {</span>
<span class="nc" id="L1318">            drawSprites(g, vtolAttackSprites);</span>
<span class="nc" id="L1319">            drawSprites(g, flyOverSprites);</span>
        }

        // draw onscreen entities
<span class="nc" id="L1323">        drawSprites(g, entitySprites);</span>

        // draw moving onscreen entities
<span class="nc" id="L1326">        drawSprites(g, movingEntitySprites);</span>

        // draw ghost onscreen entities
<span class="nc" id="L1329">        drawSprites(g, ghostEntitySprites);</span>

        // draw onscreen attacks
<span class="nc" id="L1332">        drawSprites(g, attackSprites);</span>

        // draw movement vectors.
<span class="nc bnc" id="L1335" title="All 2 branches missed.">        if (game.useVectorMove()</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">            &amp;&amp; (game.getPhase() == IGame.Phase.PHASE_MOVEMENT)) {</span>
<span class="nc" id="L1337">            drawSprites(g, movementSprites);</span>
        }

        // draw movement, if valid
<span class="nc" id="L1341">        drawSprites(g, pathSprites);</span>

        // draw firing solution sprites, but only during the firing phase
<span class="nc bnc" id="L1344" title="All 2 branches missed.">        if ((game.getPhase() == Phase.PHASE_FIRING) ||</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">            (game.getPhase() == Phase.PHASE_OFFBOARD)) {</span>
<span class="nc" id="L1346">            drawSprites(g, firingSprites);</span>
        }

<span class="nc bnc" id="L1349" title="All 2 branches missed.">        if (game.getPhase() == Phase.PHASE_FIRING) {</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">            for (Coords c : strafingCoords) {</span>
<span class="nc" id="L1351">                drawHexBorder(g, getHexLocation(c), Color.yellow, 0, 3);</span>
<span class="nc" id="L1352">            }</span>
        }


        // draw the ruler line
<span class="nc bnc" id="L1357" title="All 2 branches missed.">        if (rulerStart != null) {</span>
<span class="nc" id="L1358">            Point start = getCentreHexLocation(rulerStart);</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">            if (rulerEnd != null) {</span>
<span class="nc" id="L1360">                Point end = getCentreHexLocation(rulerEnd);</span>
<span class="nc" id="L1361">                g.setColor(Color.yellow);</span>
<span class="nc" id="L1362">                g.drawLine(start.x, start.y, end.x, end.y);</span>

<span class="nc" id="L1364">                g.setColor(rulerEndColor);</span>
<span class="nc" id="L1365">                g.fillRect(end.x - 1, end.y - 1, 2, 2);</span>
            }

<span class="nc" id="L1368">            g.setColor(rulerStartColor);</span>
<span class="nc" id="L1369">            g.fillRect(start.x - 1, start.y - 1, 2, 2);</span>
        }

        // Undo the previous translation
<span class="nc" id="L1373">        g.translate(-HEX_W, -HEX_H);</span>


        // draw all the &quot;displayables&quot;
<span class="nc bnc" id="L1377" title="All 2 branches missed.">        if (displayablesRect == null) {</span>
<span class="nc" id="L1378">            displayablesRect = new Rectangle();</span>
        }
<span class="nc" id="L1380">        displayablesRect.x = -getX();</span>
<span class="nc" id="L1381">        displayablesRect.y = -getY();</span>
<span class="nc" id="L1382">        displayablesRect.width = scrollpane.getViewport().getViewRect().width;</span>
<span class="nc" id="L1383">        displayablesRect.height = scrollpane.getViewport().getViewRect().height;</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">        for (IDisplayable disp: displayables) {</span>
<span class="nc" id="L1385">            disp.draw(g, displayablesRect);</span>
<span class="nc" id="L1386">        }</span>

<span class="nc bnc" id="L1388" title="All 2 branches missed.">        if (guip.getBoolean(GUIPreferences.ADVANCED_SHOW_FPS)) {</span>
<span class="nc bnc" id="L1389" title="All 2 branches missed.">            if (frameCount == FRAMES) {</span>
<span class="nc" id="L1390">                averageTime = totalTime / FRAMES;</span>
<span class="nc" id="L1391">                totalTime = 0;</span>
<span class="nc" id="L1392">                frameCount = 0;</span>
            } else {
<span class="nc" id="L1394">                totalTime += System.nanoTime() - paintCompsStartTime;</span>
<span class="nc" id="L1395">                frameCount++;</span>
            }
<span class="nc" id="L1397">            String s = String.format(&quot;%1$5.3f&quot;, averageTime / 1000000d);</span>
<span class="nc" id="L1398">            g.setFont(fpsFont);</span>
<span class="nc" id="L1399">            g.setColor(Color.YELLOW);</span>
<span class="nc" id="L1400">            g.drawString(s, -getX() + 5, -getY() + 20);</span>
        }

        // debugging method that renders the bounding box of a unit's movement envelope.
        //renderClusters((Graphics2D) g);
        //renderMovementBoundingBox((Graphics2D) g);
        //renderDonut(g, new Coords(10, 10), 2);
        //renderApproxHexDirection((Graphics2D) g);
<span class="nc" id="L1408">    }</span>

    /**
     * Debugging method that renders a hex in the approximate direction 
     * from the selected entity to the selected hex, of both exist.
     * @param g Graphics object on which to draw.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void renderApproxHexDirection(Graphics2D g) {
<span class="nc bnc" id="L1417" title="All 4 branches missed.">        if(selectedEntity == null || selected == null) {</span>
<span class="nc" id="L1418">            return;</span>
        }
        
<span class="nc" id="L1421">        int direction = selectedEntity.getPosition().approximateDirection(selected, 0, 0);</span>
        
<span class="nc" id="L1423">        Coords donutCoords = selectedEntity.getPosition().translated(direction);</span>
        
<span class="nc" id="L1425">        Point p = getCentreHexLocation(donutCoords.getX(), donutCoords.getY(), true);</span>
<span class="nc" id="L1426">        p.translate(HEX_W  / 2, HEX_H  / 2);</span>
<span class="nc" id="L1427">        drawHexBorder(g, p, Color.BLUE, 0, 6);</span>
<span class="nc" id="L1428">    }</span>
    
    /**
     * Debugging method that renders the bounding hex of a unit's movement envelope.
     * Warning: very slow when rendering the bounding hex for really fast units.
     * @param g Graphics object on which to draw.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void renderMovementBoundingBox(Graphics2D g) {
<span class="nc bnc" id="L1437" title="All 2 branches missed.">        if(selectedEntity != null) {</span>
<span class="nc" id="L1438">            Princess princess = new Princess(&quot;test&quot;, &quot;localhost&quot;, 2020, LogLevel.DEBUG);</span>
<span class="nc" id="L1439">            princess.getGame().setBoard(this.game.getBoard());</span>
<span class="nc" id="L1440">            PathEnumerator pathEnum = new PathEnumerator(princess, this.game);</span>
<span class="nc" id="L1441">            pathEnum.recalculateMovesFor(this.selectedEntity);</span>

<span class="nc" id="L1443">            ConvexBoardArea cba = pathEnum.getUnitMovableAreas().get(this.selectedEntity.getId());</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">            for(int x = 0; x &lt; game.getBoard().getWidth(); x++) {</span>
<span class="nc bnc" id="L1445" title="All 2 branches missed.">                for(int y = 0; y &lt; game.getBoard().getHeight(); y++) {</span>
<span class="nc" id="L1446">                    Point p = getCentreHexLocation(x, y, true);</span>
<span class="nc" id="L1447">                    p.translate(HEX_W  / 2, HEX_H  / 2);</span>
<span class="nc" id="L1448">                    Coords c = new Coords(x, y);</span>

<span class="nc bnc" id="L1450" title="All 2 branches missed.">                    if(cba.contains(c)) {</span>

<span class="nc" id="L1452">                        drawHexBorder(g, p, Color.PINK, 0, 6);</span>
                    }
                }
            }

<span class="nc bnc" id="L1457" title="All 2 branches missed.">            for(Integer x = 0; x &lt; 6; x++) {</span>
<span class="nc" id="L1458">                Coords c = cba.getVertexNum(x);</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">                if(c == null) {</span>
<span class="nc" id="L1460">                    continue;</span>
                }

<span class="nc" id="L1463">                Point p = getCentreHexLocation(c.getX(), c.getY(), true);</span>
<span class="nc" id="L1464">                p.translate(HEX_W / 2, HEX_H  / 2);</span>

<span class="nc" id="L1466">                drawHexBorder(g, p, Color.yellow, 0, 3);</span>
<span class="nc" id="L1467">                String s = x.toString();</span>
<span class="nc" id="L1468">                this.drawCenteredText((Graphics2D) g, s, p, Color.yellow, false);</span>
            }
        }
<span class="nc" id="L1471">    }</span>

    /**
     * Debugging method that renders a hex donut around the given coordinates, with the given radius.
     * @param g Graphics object on which to draw.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void renderDonut(Graphics2D g, Coords coords, int radius) {
<span class="nc" id="L1479">        List&lt;Coords&gt; donut = coords.allAtDistance(radius);</span>

<span class="nc bnc" id="L1481" title="All 2 branches missed.">        for(Coords donutCoords : donut) {</span>
<span class="nc" id="L1482">            Point p = getCentreHexLocation(donutCoords.getX(), donutCoords.getY(), true);</span>
<span class="nc" id="L1483">            p.translate(HEX_W  / 2, HEX_H  / 2);</span>
<span class="nc" id="L1484">            drawHexBorder(g, p, Color.PINK, 0, 6);</span>
<span class="nc" id="L1485">        }</span>
<span class="nc" id="L1486">    }</span>
    
    /**
     * Debugging method that renders a obnoxious pink lines around hexes in &quot;Board Clusters&quot;
     * @param g Graphics object on which to draw.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void renderClusters(Graphics2D g) {
<span class="nc" id="L1494">        BoardClusterTracker bct = new BoardClusterTracker();</span>
<span class="nc" id="L1495">        Map&lt;Coords, BoardCluster&gt; clusterMap = bct.generateClusters(selectedEntity, false, true);</span>
        
<span class="nc bnc" id="L1497" title="All 2 branches missed.">        for(BoardCluster cluster : clusterMap.values().stream().distinct().collect(Collectors.toList())) {</span>
<span class="nc bnc" id="L1498" title="All 2 branches missed.">            for (Coords coords : cluster.contents.keySet()) {</span>
<span class="nc" id="L1499">                Point p = getCentreHexLocation(coords.getX(), coords.getY(), true);</span>
<span class="nc" id="L1500">                p.translate(HEX_W  / 2, HEX_H  / 2);</span>
<span class="nc" id="L1501">                drawHexBorder(g, p, new Color(0, 0, (20 * cluster.id) % 255), 0, 6);</span>
<span class="nc" id="L1502">            }</span>
<span class="nc" id="L1503">        }</span>
<span class="nc" id="L1504">    }</span>

    /**
     *  @return a list of {@link Coords} of all hexes on the board.
     *          Returns ONLY hexes where board.getHex != null.
     */
    private List&lt;Coords&gt; allBoardHexes() {
<span class="nc" id="L1511">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L1512" title="All 2 branches missed.">        if (board == null) {</span>
<span class="nc" id="L1513">            return Collections.emptyList();</span>
        }

<span class="nc" id="L1516">        List&lt;Coords&gt; coordList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1517" title="All 2 branches missed.">        for (int i = 0; i &lt; board.getWidth(); i++) {</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">            for (int j = 0; j &lt; board.getHeight(); j++) {</span>
<span class="nc bnc" id="L1519" title="All 2 branches missed.">                if (board.getHex(i, j) != null) {</span>
<span class="nc" id="L1520">                    coordList.add(new Coords(i, j));</span>
                }
            }
        }

<span class="nc" id="L1525">        return coordList;</span>
    }

    private Image createBlurredShadow(Image orig) {
<span class="nc bnc" id="L1529" title="All 2 branches missed.">        if ((orig == null) ||</span>
<span class="nc bnc" id="L1530" title="All 2 branches missed.">                orig.getWidth(this) &lt; 0 ||</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">                orig.getHeight(this) &lt; 0) {</span>
<span class="nc" id="L1532">            return null;</span>
        }
<span class="nc" id="L1534">        BufferedImage mask = shadowImageCache.get(orig.hashCode());</span>
<span class="nc bnc" id="L1535" title="All 2 branches missed.">        if (mask == null) {</span>
            GraphicsConfiguration config = GraphicsEnvironment
<span class="nc" id="L1537">                    .getLocalGraphicsEnvironment().getDefaultScreenDevice()</span>
<span class="nc" id="L1538">                    .getDefaultConfiguration();</span>

            // a slightly bigger image to give room for blurring
<span class="nc" id="L1541">            mask = config.createCompatibleImage(orig.getWidth(this)+4, orig.getHeight(this)+4,</span>
                    Transparency.TRANSLUCENT);
<span class="nc" id="L1543">            Graphics g = mask.getGraphics();</span>
<span class="nc" id="L1544">            g.drawImage(orig,2,2,null);</span>
<span class="nc" id="L1545">            g.dispose();</span>
<span class="nc" id="L1546">            mask = createShadowMask(mask);</span>
<span class="nc" id="L1547">            mask = blurOp.filter(mask, null);</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">            if (game.getPlanetaryConditions().getLight() != PlanetaryConditions.L_DAY) {</span>
<span class="nc" id="L1549">                mask = blurOp.filter(mask, null);</span>
            }
<span class="nc" id="L1551">            shadowImageCache.put(orig.hashCode(), mask);</span>
        }
<span class="nc" id="L1553">        return mask;</span>
    }

    /**
     *  Prepares a shadow map for the board, drawing shadows for hills/trees/buildings.
     *  The shadow map is an image the size of the whole board.
     */
    private void updateShadowMap() {
        // Issues:
        // Bridge shadows show a gap towards connected hexes. I don't know why.
        // More than one super image on a hex (building+road) doesnt work. how do I get
        //   the super for a hex for a specific terrain? This would also help
        //   with building shadowing other buildings.
        // AO shadows might be handled by this too. But:
        // this seems to need a lot of additional copying (paint shadow on a clean map for this level alone; soften up; copy to real shadow
        // map with clipping area active; get new clean shadow map for next shadowed level;
        // too much hassle currently; it works so beautifully
<span class="nc bnc" id="L1570" title="All 2 branches missed.">        if (!GUIPreferences.getInstance().getShadowMap()) return;</span>

<span class="nc" id="L1572">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L1573" title="All 2 branches missed.">        if (board == null) return;</span>
<span class="nc bnc" id="L1574" title="All 2 branches missed.">        if (board.inSpace()) return;</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">        if (boardSize == null) updateBoardSize();</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">        if (!isTileImagesLoaded()) return;</span>
        // Map editor? No shadows
<span class="nc bnc" id="L1578" title="All 2 branches missed.">        if (game.getPhase() == IGame.Phase.PHASE_UNKNOWN) return;</span>

<span class="nc" id="L1580">        long stT = System.nanoTime();</span>

        // 1) create or get the hex shadow
<span class="nc" id="L1583">        Image hexShadow = createBlurredShadow(tileManager.getHexMask());</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">        if (hexShadow == null) {</span>
<span class="nc" id="L1585">            repaint(1000);</span>
<span class="nc" id="L1586">            return;</span>
        }


        // the shadowmap needs to be painted as if scale == 1
        // therefore some of the methods of boardview1 cannot be used
<span class="nc" id="L1592">        int width = game.getBoard().getWidth() * HEX_WC + (int) (HEX_W / 4);</span>
<span class="nc" id="L1593">        int height = game.getBoard().getHeight() * (int) (HEX_H) + (int) (HEX_H / 2);</span>

        GraphicsConfiguration config = GraphicsEnvironment
<span class="nc" id="L1596">                .getLocalGraphicsEnvironment().getDefaultScreenDevice()</span>
<span class="nc" id="L1597">                .getDefaultConfiguration();</span>

<span class="nc" id="L1599">        shadowMap = config.createCompatibleImage(width, height,</span>
                Transparency.TRANSLUCENT);

<span class="nc" id="L1602">        Graphics2D g = (Graphics2D)(shadowMap.createGraphics());</span>

<span class="nc bnc" id="L1604" title="All 2 branches missed.">        if ((game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_MOONLESS) ||</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">        (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_PITCH_BLACK)) {</span>
<span class="nc" id="L1606">            lightDirection = new double[] { 0, 0 };</span>
<span class="nc bnc" id="L1607" title="All 2 branches missed.">        } else if (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_DUSK) {</span>
            // TODO: replace when made user controlled
<span class="nc" id="L1609">            lightDirection = new double[] { -38, 14 };</span>
        } else {
<span class="nc" id="L1611">            lightDirection = new double[] { -19, 7 };</span>
        }

        // Shadows for elevation
        // 1a) Sort the board hexes by elevation
        // 1b) Create a reduced list of shadowcasting hexes
<span class="nc" id="L1617">        double angle = Math.atan2(-lightDirection[1], lightDirection[0]);</span>
<span class="nc" id="L1618">        int mDir = (int)(0.5+1.5-angle/Math.PI*3); // +0.5 to counter the (int)</span>
<span class="nc" id="L1619">        int[] sDirs = { mDir%6, (mDir+1)%6, (mDir+5)%6 };</span>
<span class="nc" id="L1620">        HashMap&lt;Integer,Set&lt;Coords&gt;&gt; sortedHexes = new HashMap&lt;Integer,Set&lt;Coords&gt;&gt;();</span>
<span class="nc" id="L1621">        HashMap&lt;Integer,Set&lt;Coords&gt;&gt; shadowCastingHexes = new HashMap&lt;Integer,Set&lt;Coords&gt;&gt;();</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">        for (Coords c: allBoardHexes()) {</span>
<span class="nc" id="L1623">            IHex hex = board.getHex(c);</span>
<span class="nc" id="L1624">            int level = hex.getLevel();</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">            if (!sortedHexes.containsKey(level)) { // no hexes yet for this height</span>
<span class="nc" id="L1626">                sortedHexes.put(level, new HashSet&lt;Coords&gt;());</span>
            }
<span class="nc bnc" id="L1628" title="All 2 branches missed.">            if (!shadowCastingHexes.containsKey(level)) { // no hexes yet for this height</span>
<span class="nc" id="L1629">                shadowCastingHexes.put(level, new HashSet&lt;Coords&gt;());</span>
            }
<span class="nc" id="L1631">            sortedHexes.get(level).add(c);</span>
            // add a hex to the shadowcasting hexes only
            // if it is nor surrounded by same height hexes
<span class="nc" id="L1634">            boolean surrounded = true;</span>
<span class="nc bnc" id="L1635" title="All 2 branches missed.">            for (int dir: sDirs) {</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">                if (!board.contains(c.translated(dir))) {</span>
<span class="nc" id="L1637">                    surrounded = false;</span>
                } else {
<span class="nc" id="L1639">                    IHex nhex = board.getHex(c.translated(dir));</span>
<span class="nc" id="L1640">                    int lv = nhex.getLevel();</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">                    if (lv &lt; level)</span>
<span class="nc" id="L1642">                        surrounded = false;</span>
                }
            }
<span class="nc bnc" id="L1645" title="All 2 branches missed.">            if (!surrounded) shadowCastingHexes.get(level).add(c);</span>
<span class="nc" id="L1646">        }</span>

        // 2) Create clipping areas
<span class="nc" id="L1649">        HashMap&lt;Integer,Shape&gt; levelClips = new HashMap&lt;Integer,Shape&gt;();</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">        for (Integer h: sortedHexes.keySet()) {</span>
<span class="nc" id="L1651">            Path2D path = new Path2D.Float();</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">            for (Coords c: sortedHexes.get(h)) {</span>
<span class="nc" id="L1653">                Point p = getHexLocationLargeTile(c.getX(), c.getY(), 1);</span>
<span class="nc" id="L1654">                AffineTransform t = AffineTransform.getTranslateInstance(p.x+HEX_W/2, p.y+HEX_H/2);</span>
<span class="nc" id="L1655">                t.scale(1.02, 1.02);</span>
<span class="nc" id="L1656">                t.translate(-HEX_W/2, -HEX_H/2);</span>
<span class="nc" id="L1657">                path.append(t.createTransformedShape(hexPoly), false);</span>
<span class="nc" id="L1658">            }</span>
<span class="nc" id="L1659">            levelClips.put(h, path);</span>
<span class="nc" id="L1660">        }</span>


        // 3) Find all level differences
<span class="nc" id="L1664">        final int maxDiff = 35; // limit all diffs to this value</span>
<span class="nc" id="L1665">        Set&lt;Integer&gt; lDiffs = new TreeSet&lt;Integer&gt;();</span>
<span class="nc" id="L1666">        for (int shadowed = board.getMinElevation();</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">                shadowed &lt; board.getMaxElevation();</span>
<span class="nc" id="L1668">                shadowed++) {</span>
<span class="nc bnc" id="L1669" title="All 2 branches missed.">            if (levelClips.get(shadowed) == null) continue;</span>

<span class="nc" id="L1671">            for (int shadowcaster = shadowed+1;</span>
<span class="nc bnc" id="L1672" title="All 2 branches missed.">                    shadowcaster &lt;= board.getMaxElevation();</span>
<span class="nc" id="L1673">                    shadowcaster++) {</span>
<span class="nc bnc" id="L1674" title="All 2 branches missed.">                if (levelClips.get(shadowcaster) == null) continue;</span>

<span class="nc" id="L1676">                lDiffs.add(Math.min(shadowcaster-shadowed, maxDiff));</span>
            }
        }

        // 4) Elevation Shadow images for all level differences present
<span class="nc" id="L1681">        int n = 10;</span>
<span class="nc" id="L1682">        double deltaX = lightDirection[0]/n;</span>
<span class="nc" id="L1683">        double deltaY = lightDirection[1]/n;</span>
<span class="nc" id="L1684">        Map&lt;Integer,BufferedImage&gt; hS = new HashMap&lt;Integer,BufferedImage&gt;();</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">        for (int lDiff: lDiffs) {</span>
<span class="nc" id="L1686">            Dimension eSize = new Dimension(</span>
<span class="nc" id="L1687">                    (int)(Math.abs(lightDirection[0])*lDiff+HEX_W)*2,</span>
<span class="nc" id="L1688">                    (int)(Math.abs(lightDirection[1])*lDiff+HEX_H)*2);</span>

<span class="nc" id="L1690">            BufferedImage elevShadow = config.createCompatibleImage(eSize.width, eSize.height,</span>
                    Transparency.TRANSLUCENT);
<span class="nc" id="L1692">            Graphics gS = elevShadow.getGraphics();</span>
<span class="nc" id="L1693">            Point2D p1 = new Point2D.Double(eSize.width/2, eSize.height/2);</span>
<span class="nc bnc" id="L1694" title="All 2 branches missed.">            if (GUIPreferences.getInstance().getHexInclines()) {</span>
                // With inclines, the level 1 shadows are only very slight
<span class="nc" id="L1696">                int beg = 4;</span>
<span class="nc" id="L1697">                p1.setLocation(p1.getX()+deltaX*beg, p1.getY()+deltaY*beg);</span>
<span class="nc bnc" id="L1698" title="All 2 branches missed.">                for (int i = beg; i&lt;n*(lDiff-0.4); i++) {</span>
<span class="nc" id="L1699">                    gS.drawImage(hexShadow, (int)p1.getX(), (int)p1.getY(), null);</span>
<span class="nc" id="L1700">                    p1.setLocation(p1.getX()+deltaX, p1.getY()+deltaY);</span>
                }   
<span class="nc" id="L1702">            } else {</span>
<span class="nc bnc" id="L1703" title="All 2 branches missed.">                for (int i = 0; i&lt;n*lDiff; i++) {</span>
<span class="nc" id="L1704">                    gS.drawImage(hexShadow, (int)p1.getX(), (int)p1.getY(), null);</span>
<span class="nc" id="L1705">                    p1.setLocation(p1.getX()+deltaX, p1.getY()+deltaY);</span>
                }
                
            }
<span class="nc" id="L1709">            gS.dispose();</span>
<span class="nc" id="L1710">            hS.put(lDiff, elevShadow);</span>
<span class="nc" id="L1711">        }</span>

        // 5) Actually draw the elevation shadows
<span class="nc" id="L1714">        for (int shadowed = board.getMinElevation();</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">                shadowed &lt; board.getMaxElevation();</span>
<span class="nc" id="L1716">                shadowed++) {</span>
<span class="nc bnc" id="L1717" title="All 2 branches missed.">            if (levelClips.get(shadowed) == null) continue;</span>

<span class="nc" id="L1719">            Shape saveClip = g.getClip();</span>
<span class="nc" id="L1720">            g.setClip(levelClips.get(shadowed));</span>

<span class="nc" id="L1722">            for (int shadowcaster = shadowed+1;</span>
<span class="nc bnc" id="L1723" title="All 2 branches missed.">                    shadowcaster &lt;= board.getMaxElevation();</span>
<span class="nc" id="L1724">                    shadowcaster++) {</span>
<span class="nc bnc" id="L1725" title="All 2 branches missed.">                if (levelClips.get(shadowcaster) == null) continue;</span>
<span class="nc" id="L1726">                int lDiff = shadowcaster - shadowed;</span>

<span class="nc bnc" id="L1728" title="All 2 branches missed.">                for (Coords c: shadowCastingHexes.get(shadowcaster)) {</span>
<span class="nc" id="L1729">                    Point2D p0 = getHexLocationLargeTile(c.getX(), c.getY(), 1);</span>
<span class="nc" id="L1730">                    g.drawImage(hS.get(Math.min(lDiff, maxDiff)),</span>
<span class="nc" id="L1731">                            (int)p0.getX()-(int)(Math.abs(lightDirection[0])*Math.min(lDiff, maxDiff)+HEX_W),</span>
<span class="nc" id="L1732">                            (int)p0.getY()-(int)(Math.abs(lightDirection[1])*Math.min(lDiff, maxDiff)+HEX_H), null);</span>
<span class="nc" id="L1733">                }</span>
            }
<span class="nc" id="L1735">            g.setClip(saveClip);</span>
        }

<span class="nc" id="L1738">        n = 5;</span>
<span class="nc" id="L1739">        deltaX = lightDirection[0]/n;</span>
<span class="nc" id="L1740">        deltaY = lightDirection[1]/n;</span>

        // 4) woods and bulding shadows
<span class="nc" id="L1743">        for (int shadowed = board.getMinElevation();</span>
<span class="nc bnc" id="L1744" title="All 2 branches missed.">                shadowed &lt;= board.getMaxElevation();</span>
<span class="nc" id="L1745">                shadowed++) {</span>
<span class="nc bnc" id="L1746" title="All 2 branches missed.">            if (levelClips.get(shadowed) == null) continue;</span>

<span class="nc" id="L1748">            Shape saveClip = g.getClip();</span>
<span class="nc" id="L1749">            g.setClip(levelClips.get(shadowed));</span>

<span class="nc" id="L1751">            for (int shadowcaster = board.getMinElevation();</span>
<span class="nc bnc" id="L1752" title="All 2 branches missed.">                    shadowcaster &lt;= board.getMaxElevation();</span>
<span class="nc" id="L1753">                    shadowcaster++) {</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">                if (levelClips.get(shadowcaster) == null) continue;</span>

<span class="nc bnc" id="L1756" title="All 2 branches missed.">                for (Coords c: sortedHexes.get(shadowcaster)) {</span>
<span class="nc" id="L1757">                    Point2D p0 = getHexLocationLargeTile(c.getX(), c.getY(), 1);</span>
<span class="nc" id="L1758">                    Point2D p1 = new Point2D.Double();</span>

                    // Woods Shadow
<span class="nc" id="L1761">                    IHex hex = board.getHex(c);</span>
<span class="nc" id="L1762">                    List&lt;Image&gt; supers = tileManager.supersFor(hex);</span>

<span class="nc bnc" id="L1764" title="All 2 branches missed.">                    if (!supers.isEmpty()) {</span>
<span class="nc" id="L1765">                        Image lastSuper = createBlurredShadow(supers.get(supers.size()-1));</span>
<span class="nc bnc" id="L1766" title="All 2 branches missed.">                        if (lastSuper == null) {</span>
<span class="nc" id="L1767">                            clearShadowMap();</span>
<span class="nc" id="L1768">                            return;</span>
                        }
<span class="nc bnc" id="L1770" title="All 2 branches missed.">                        if (hex.containsTerrain(Terrains.WOODS) ||</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">                                hex.containsTerrain(Terrains.JUNGLE)) {</span>
                            // Woods are 2 levels high, but then shadows
                            // appear very extreme, therefore only
                            // 1.5 levels: (shadowcaster+1.5-shadowed)
<span class="nc" id="L1775">                            double shadowHeight = .75 * hex.terrainLevel(Terrains.FOLIAGE_ELEV);</span>
<span class="nc" id="L1776">                            p1.setLocation(p0);</span>
<span class="nc bnc" id="L1777" title="All 2 branches missed.">                            if ((shadowcaster + shadowHeight - shadowed) &gt; 0) {</span>
<span class="nc bnc" id="L1778" title="All 2 branches missed.">                                for (int i = 0; i &lt; n * (shadowcaster + shadowHeight - shadowed); i++) {</span>
<span class="nc" id="L1779">                                    g.drawImage(lastSuper, (int)p1.getX(), (int)p1.getY(), null);</span>
<span class="nc" id="L1780">                                    p1.setLocation(p1.getX()+deltaX, p1.getY()+deltaY);</span>
                                }
                            }
                        }


                        // Buildings Shadow
<span class="nc bnc" id="L1787" title="All 2 branches missed.">                        if (hex.containsTerrain(Terrains.BUILDING))</span>
                        {
<span class="nc" id="L1789">                            int h = hex.terrainLevel(Terrains.BLDG_ELEV);</span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">                            if ((shadowcaster+h-shadowed) &gt; 0) {</span>
<span class="nc" id="L1791">                                p1.setLocation(p0);</span>
<span class="nc bnc" id="L1792" title="All 2 branches missed.">                                for (int i = 0; i&lt;n*(shadowcaster+h-shadowed); i++) {</span>
<span class="nc" id="L1793">                                    g.drawImage(lastSuper, (int)p1.getX(), (int)p1.getY(), null);</span>
<span class="nc" id="L1794">                                    p1.setLocation(p1.getX()+deltaX, p1.getY()+deltaY);</span>
                                }
                            }
                        }
                    }
                    // Bridge Shadow
<span class="nc bnc" id="L1800" title="All 2 branches missed.">                    if (hex.containsTerrain(Terrains.BRIDGE)) {</span>
<span class="nc" id="L1801">                        supers = tileManager.orthoFor(hex);</span>
<span class="nc bnc" id="L1802" title="All 2 branches missed.">                        if (supers.isEmpty()) break;</span>
<span class="nc" id="L1803">                        Image maskB = createBlurredShadow(supers.get(supers.size()-1));</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">                        if (maskB == null) {</span>
<span class="nc" id="L1805">                            clearShadowMap();</span>
<span class="nc" id="L1806">                            return;</span>
                        }
<span class="nc" id="L1808">                        int h = hex.terrainLevel(Terrains.BRIDGE_ELEV);</span>
<span class="nc" id="L1809">                        p1.setLocation(p0.getX()+deltaX*n*(shadowcaster+h-shadowed),</span>
<span class="nc" id="L1810">                                p0.getY()+deltaY*n*(shadowcaster+h-shadowed));</span>
                        // the shadowmask is translucent, therefore draw n times
                        // stupid hack
<span class="nc bnc" id="L1813" title="All 2 branches missed.">                        for (int i=0;i&lt;n;i++)</span>
<span class="nc" id="L1814">                            g.drawImage(maskB, (int)p1.getX(), (int)p1.getY(), null);</span>
                    }

<span class="nc" id="L1817">                }</span>
            }
<span class="nc" id="L1819">            g.setClip(saveClip);</span>
        }

<span class="nc" id="L1822">        long tT5 = System.nanoTime()-stT;</span>
<span class="nc" id="L1823">        System.out.println(&quot;Time to prepare the shadow map: &quot;+tT5/1e6+&quot; ms&quot;);</span>

<span class="nc" id="L1825">    }</span>

    public void clearShadowMap() {
<span class="nc" id="L1828">        shadowMap = null;</span>
<span class="nc" id="L1829">    }</span>

    /**
     * Updates the boardSize variable with the proper values for this board.
     */
    private void updateBoardSize() {
<span class="nc" id="L1835">        int width = (game.getBoard().getWidth() * (int) (HEX_WC * scale))</span>
                    + (int) ((HEX_W / 4) * scale);
<span class="nc" id="L1837">        int height = (game.getBoard().getHeight() * (int) (HEX_H * scale))</span>
                     + (int) ((HEX_H / 2) * scale);
<span class="nc" id="L1839">        boardSize = new Dimension(width, height);</span>
<span class="nc" id="L1840">    }</span>

    /**
     * Looks through a vector of buffered images and draws them if they're
     * onscreen.
     */
    private synchronized void drawSprites(Graphics g,
            Collection&lt;? extends Sprite&gt; spriteArrayList) {
<span class="nc bnc" id="L1848" title="All 2 branches missed.">        for (Sprite sprite : spriteArrayList) {</span>
<span class="nc" id="L1849">            drawSprite(g, sprite);</span>
<span class="nc" id="L1850">        }</span>
<span class="nc" id="L1851">    }</span>

    private synchronized void drawHexSpritesForHex(Coords c, Graphics g,
            ArrayList&lt;? extends HexSprite&gt; spriteArrayList) {
<span class="nc" id="L1855">        Rectangle view = g.getClipBounds();</span>

<span class="nc bnc" id="L1857" title="All 2 branches missed.">        for (HexSprite sprite : spriteArrayList) {</span>
<span class="nc" id="L1858">            Coords cp = sprite.getPosition();</span>
            // This can potentially be an expensive operation
<span class="nc" id="L1860">            Rectangle spriteBounds = sprite.getBounds();</span>
<span class="nc bnc" id="L1861" title="All 4 branches missed.">            if (cp.equals(c) &amp;&amp; view.intersects(spriteBounds)</span>
<span class="nc bnc" id="L1862" title="All 2 branches missed.">                    &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">                if (!sprite.isReady()) {</span>
<span class="nc" id="L1864">                    sprite.prepare();</span>
                }
<span class="nc" id="L1866">                sprite.drawOnto(g, spriteBounds.x, spriteBounds.y,</span>
                        this, false);
            }
<span class="nc" id="L1869">        }</span>
<span class="nc" id="L1870">    }</span>

    /**
     * Draws the Entity for the given hex. This function is used by the
     * isometric rendering process so that sprites are drawn in the order that
     * hills are rendered to create the appearance that the sprite is behind the
     * hill.
     *
     * @param c               The Coordinates of the hex that the sprites should be drawn
     *                        for.
     * @param g               The Graphics object for this board.
     * @param spriteArrayList The complete list of all IsometricSprite on the board.
     */
    private synchronized void drawIsometricSpritesForHex(Coords c, Graphics g,
            Collection&lt;IsometricSprite&gt; spriteArrayList) {
<span class="nc" id="L1885">        Rectangle view = g.getClipBounds();</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">        for (IsometricSprite sprite : spriteArrayList) {</span>
<span class="nc" id="L1887">            Coords cp = sprite.getPosition();</span>
            // This can potentially be an expensive operation
<span class="nc" id="L1889">            Rectangle spriteBounds = sprite.getBounds();</span>
<span class="nc bnc" id="L1890" title="All 4 branches missed.">            if (cp.equals(c) &amp;&amp; view.intersects(spriteBounds)</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">                &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">                if (!sprite.isReady()) {</span>
<span class="nc" id="L1893">                    sprite.prepare();</span>
                }
<span class="nc" id="L1895">                sprite.drawOnto(g, spriteBounds.x, spriteBounds.y, this, false);</span>
            }
<span class="nc" id="L1897">        }</span>
<span class="nc" id="L1898">    }</span>

    /**
     * Draws the wrecksprites for the given hex. This function is used by the
     * isometric rendering process so that sprites are drawn in the order that
     * hills are rendered to create the appearance that the sprite is behind the
     * hill.
     *
     * @param c               The Coordinates of the hex that the sprites should be drawn
     *                        for.
     * @param g               The Graphics object for this board.
     * @param spriteArrayList The complete list of all IsometricSprite on the board.
     */
    private synchronized void drawIsometricWreckSpritesForHex(Coords c,
            Graphics g, ArrayList&lt;IsometricWreckSprite&gt; spriteArrayList) {
<span class="nc" id="L1913">        Rectangle view = g.getClipBounds();</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">        for (IsometricWreckSprite sprite : spriteArrayList) {</span>
<span class="nc" id="L1915">            Coords cp = sprite.getPosition();</span>
<span class="nc bnc" id="L1916" title="All 4 branches missed.">            if (cp.equals(c) &amp;&amp; view.intersects(sprite.getBounds())</span>
<span class="nc bnc" id="L1917" title="All 2 branches missed.">                &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1918" title="All 2 branches missed.">                if (!sprite.isReady()) {</span>
<span class="nc" id="L1919">                    sprite.prepare();</span>
                }
<span class="nc" id="L1921">                sprite.drawOnto(g, sprite.getBounds().x, sprite.getBounds().y,</span>
                                this, false);
            }
<span class="nc" id="L1924">        }</span>
<span class="nc" id="L1925">    }</span>

    /**
     * Draws a translucent sprite without any of the companion graphics, if it
     * is in the current view. This is used only when performing isometric
     * rending. This function is used to show units (with 50% transparency) that
     * are hidden behind a hill.
     * &lt;p/&gt;
     * TODO: Optimize this function so that it is only applied to sprites that
     * are actually hidden. This implementation performs the second rendering
     * for all sprites.
     */
    private final void drawIsometricSprites(Graphics g,
            Collection&lt;IsometricSprite&gt; spriteArrayList) {
<span class="nc" id="L1939">        Rectangle view = g.getClipBounds();</span>
<span class="nc bnc" id="L1940" title="All 2 branches missed.">        for (IsometricSprite sprite : spriteArrayList) {</span>
            // This can potentially be an expensive operation
<span class="nc" id="L1942">            Rectangle spriteBounds = sprite.getBounds();</span>
<span class="nc bnc" id="L1943" title="All 4 branches missed.">            if (view.intersects(spriteBounds) &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1944" title="All 2 branches missed.">                if (!sprite.isReady()) {</span>
<span class="nc" id="L1945">                    sprite.prepare();</span>
                }
<span class="nc" id="L1947">                sprite.drawOnto(g, spriteBounds.x, spriteBounds.y,</span>
                                this, true);
            }
<span class="nc" id="L1950">        }</span>
<span class="nc" id="L1951">    }</span>

    /**
     * Draws a sprite, if it is in the current view
     */
    private final void drawSprite(Graphics g, Sprite sprite) {
<span class="nc" id="L1957">        Rectangle view = g.getClipBounds();</span>
        // This can potentially be an expensive operation
<span class="nc" id="L1959">        Rectangle spriteBounds = sprite.getBounds();</span>
<span class="nc bnc" id="L1960" title="All 4 branches missed.">        if (view.intersects(spriteBounds) &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">            if (!sprite.isReady()) {</span>
<span class="nc" id="L1962">                sprite.prepare();</span>
            }
<span class="nc" id="L1964">            sprite.drawOnto(g, spriteBounds.x, spriteBounds.y, this);</span>
        }
<span class="nc" id="L1966">    }</span>

    /**
     * Draw an outline around legal deployment hexes
     */
    private void drawDeployment(Graphics g) {
<span class="nc" id="L1972">        Rectangle view = g.getClipBounds();</span>
        // only update visible hexes
<span class="nc" id="L1974">        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</span>
<span class="nc" id="L1975">        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</span>

<span class="nc" id="L1977">        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</span>
<span class="nc" id="L1978">        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</span>

<span class="nc" id="L1980">        IBoard board = game.getBoard();</span>
        // loop through the hexes
<span class="nc bnc" id="L1982" title="All 2 branches missed.">        for (int i = 0; i &lt; drawHeight; i++) {</span>
<span class="nc bnc" id="L1983" title="All 2 branches missed.">            for (int j = 0; j &lt; drawWidth; j++) {</span>
<span class="nc" id="L1984">                Coords c = new Coords(j + drawX, i + drawY);</span>
<span class="nc bnc" id="L1985" title="All 2 branches missed.">                if (board.isLegalDeployment(c, en_Deployer.getStartingPos())) {</span>
<span class="nc" id="L1986">                    drawHexBorder(g, getHexLocation(c), Color.yellow);</span>
                }
            }
        }
<span class="nc" id="L1990">    }</span>

    /**
     * Draw indicators for the deployment zones of all players
     */
    private void drawAllDeployment(Graphics g) {
<span class="nc" id="L1996">        Rectangle view = g.getClipBounds();</span>
        // only update visible hexes
<span class="nc" id="L1998">        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</span>
<span class="nc" id="L1999">        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</span>

<span class="nc" id="L2001">        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</span>
<span class="nc" id="L2002">        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</span>

<span class="nc" id="L2004">        IBoard board = game.getBoard();</span>
        // loop through the hexes
<span class="nc bnc" id="L2006" title="All 2 branches missed.">        for (int i = 0; i &lt; drawHeight; i++) {</span>
<span class="nc bnc" id="L2007" title="All 2 branches missed.">            for (int j = 0; j &lt; drawWidth; j++) {</span>
<span class="nc" id="L2008">                Coords c = new Coords(j + drawX, i + drawY);</span>
<span class="nc" id="L2009">                Enumeration&lt;IPlayer&gt; allP = game.getPlayers();</span>
                IPlayer cp;
<span class="nc" id="L2011">                int pCount = 0;</span>
<span class="nc" id="L2012">                int bThickness = 1 + 10 / game.getNoOfPlayers();</span>
                // loop through all players
<span class="nc bnc" id="L2014" title="All 2 branches missed.">                while (allP.hasMoreElements()) {</span>
<span class="nc" id="L2015">                    cp = allP.nextElement();</span>
<span class="nc bnc" id="L2016" title="All 2 branches missed.">                    if (board.isLegalDeployment(c, cp.getStartingPos())) {</span>
<span class="nc" id="L2017">                        Color bC = cp.getColour().getColour();</span>
<span class="nc" id="L2018">                        drawHexBorder(g, getHexLocation(c), bC, (bThickness+2)</span>
                                * pCount, bThickness);
<span class="nc" id="L2020">                        pCount++;</span>
<span class="nc" id="L2021">                    }</span>
                }
            }
        }
<span class="nc" id="L2025">    }</span>

    /**
     * Darkens a hexes in the viewing area if there is no line of sight between
     * them and the supplied source hex. Used in non-isometric view.
     *
     * @param p
     *            The source hex for which line of sight originates
     * @param g
     *            The graphics object to draw on.
     * @param col
     *            The what color to use.
     * @param outOfFOV
     *            The destination hex for computing the line of sight
     */

    /**
     * Draw a layer of a solid color (alpha possible) on the hex at Point p no
     * padding by default
     */
    void drawHexLayer(Point p, Graphics g, Color col, boolean outOfFOV) {
<span class="nc" id="L2046">        drawHexLayer(p, g, col, outOfFOV, 0);</span>
<span class="nc" id="L2047">    }</span>

    /**
     * Draw a layer of a solid color (alpha possible) on the hex at Point p with
     * some padding around the border
     */
    private void drawHexLayer(Point p, Graphics g, Color col, boolean outOfFOV,
            double pad) {
<span class="nc" id="L2055">        Graphics2D g2D = (Graphics2D)g;</span>
<span class="nc" id="L2056">        g.setColor(col);</span>

        // create stripe effect for FOV darkening but not for colored weapon
        // ranges
<span class="nc" id="L2060">        int fogStripes = GUIPreferences.getInstance().getFovStripes();</span>
<span class="nc bnc" id="L2061" title="All 6 branches missed.">        if (outOfFOV &amp;&amp; (fogStripes &gt; 0) &amp;&amp; (g instanceof Graphics2D)) {</span>
<span class="nc" id="L2062">            float lineSpacing = fogStripes;</span>
            // totally transparent here hurts the eyes
<span class="nc" id="L2064">            Color c2 = new Color(col.getRed() / 2, col.getGreen() / 2,</span>
<span class="nc" id="L2065">                    col.getBlue() / 2, col.getAlpha() / 2);</span>

            // the numbers make the lines align across hexes
<span class="nc" id="L2068">            GradientPaint gp = new GradientPaint(42.0f / lineSpacing, 0.0f,</span>
                    col, 104.0f / lineSpacing, 106.0f / lineSpacing, c2, true);
<span class="nc" id="L2070">            g2D.setPaint(gp);</span>
        }
<span class="nc" id="L2072">        Composite svComposite = g2D.getComposite();</span>
<span class="nc" id="L2073">        g2D.setComposite(AlphaComposite.SrcAtop);</span>
<span class="nc" id="L2074">        g2D.fillRect(0, 0, hex_size.width, hex_size.height);</span>
<span class="nc" id="L2075">        g2D.setComposite(svComposite);</span>
<span class="nc" id="L2076">    }</span>

    private void drawHexBorder(Graphics g, Color col, double pad,
            double linewidth) {
<span class="nc" id="L2080">        drawHexBorder(g, new Point(0,0), col, pad, linewidth);</span>
<span class="nc" id="L2081">    }</span>

    public void drawHexBorder(Graphics g, Point p, Color col, double pad,
            double linewidth) {
<span class="nc" id="L2085">        g.setColor(col);</span>
<span class="nc" id="L2086">        ((Graphics2D)g).fill(</span>
<span class="nc" id="L2087">                AffineTransform.getTranslateInstance(p.x, p.y).createTransformedShape(</span>
<span class="nc" id="L2088">                AffineTransform.getScaleInstance(scale, scale).createTransformedShape(</span>
<span class="nc" id="L2089">                HexDrawUtilities.getHexFullBorderArea(linewidth, pad))));</span>
<span class="nc" id="L2090">    }</span>

    /**
     * Draw an outline around the hex at Point p no padding and a width of 1
     */
    private void drawHexBorder(Graphics g, Point p, Color col) {
<span class="nc" id="L2096">        drawHexBorder(g, p, col, 0);</span>
<span class="nc" id="L2097">    }</span>

    /**
     * Draw an outline around the hex at Point p padded around the border by pad
     * and a line-width of 1
     */
    private void drawHexBorder(Graphics g, Point p, Color col, double pad) {
<span class="nc" id="L2104">        drawHexBorder(g, p, col, pad, 1);</span>
<span class="nc" id="L2105">    }</span>

    /**
     * returns the weapon selected in the mech display, or null if none selected
     * or it is not artillery or null if the selected entity is not owned
     */
    public Mounted getSelectedArtilleryWeapon() {
        // We don't want to display artillery auto-hit/adjusted fire hexes
        // during
        // the artyautohithexes phase. These could be displayed if the player
        // uses the /reset command in some situations
<span class="nc bnc" id="L2116" title="All 2 branches missed.">        if (game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) {</span>
<span class="nc" id="L2117">            return null;</span>
        }

<span class="nc bnc" id="L2120" title="All 4 branches missed.">        if ((selectedEntity == null) || (selectedWeapon == null)) {</span>
<span class="nc" id="L2121">            return null;</span>
        }

<span class="nc bnc" id="L2124" title="All 2 branches missed.">        if (!selectedEntity.getOwner().equals(localPlayer)) {</span>
<span class="nc" id="L2125">            return null; // Not my business to see this</span>
        }

<span class="nc bnc" id="L2128" title="All 2 branches missed.">        if (selectedEntity.getEquipmentNum(selectedWeapon) == -1) {</span>
<span class="nc" id="L2129">            return null; // inconsistent state - weapon not on entity</span>
        }

<span class="nc bnc" id="L2132" title="All 2 branches missed.">        if (!((selectedWeapon.getType() instanceof WeaponType) &amp;&amp; selectedWeapon</span>
<span class="nc bnc" id="L2133" title="All 2 branches missed.">                .getType().hasFlag(WeaponType.F_ARTILLERY))) {</span>
<span class="nc" id="L2134">            return null; // not artillery</span>
        }

        // otherwise, a weapon is selected, and it is artillery
<span class="nc" id="L2138">        return selectedWeapon;</span>
    }

    /**
     * Display artillery modifier in pretargeted hexes
     */
    private void drawArtilleryHexes(Graphics g) {
<span class="nc" id="L2145">        Mounted weapon = getSelectedArtilleryWeapon();</span>
<span class="nc" id="L2146">        Rectangle view = g.getClipBounds();</span>

        // Compute the origin of the viewing area
<span class="nc" id="L2149">        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</span>
<span class="nc" id="L2150">        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</span>

        // Compute size of viewing area
<span class="nc" id="L2153">        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</span>
<span class="nc" id="L2154">        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</span>

        Image artyIconImage;

        // Draw incoming artillery sprites - requires server to update client's
        // view of game
<span class="nc" id="L2160">        for (Enumeration&lt;ArtilleryAttackAction&gt; attacks = game</span>
<span class="nc bnc" id="L2161" title="All 2 branches missed.">                .getArtilleryAttacks(); attacks.hasMoreElements(); ) {</span>
<span class="nc" id="L2162">            ArtilleryAttackAction a = attacks.nextElement();</span>
<span class="nc" id="L2163">            Coords c = a.getTarget(game).getPosition();</span>
            // Is the Coord within the viewing area?
<span class="nc bnc" id="L2165" title="All 4 branches missed.">            if ((c.getX() &gt;= drawX) &amp;&amp; (c.getX() &lt;= (drawX + drawWidth))</span>
<span class="nc bnc" id="L2166" title="All 4 branches missed.">                &amp;&amp; (c.getY() &gt;= drawY) &amp;&amp; (c.getY() &lt;= (drawY + drawHeight))) {</span>

<span class="nc" id="L2168">                Point p = getHexLocation(c);</span>
<span class="nc" id="L2169">                artyIconImage = tileManager</span>
<span class="nc" id="L2170">                        .getArtilleryTarget(TilesetManager.ARTILLERY_INCOMING);</span>
<span class="nc" id="L2171">                g.drawImage(getScaledImage(artyIconImage, true), p.x, p.y, this);</span>
            }
<span class="nc" id="L2173">        }</span>

        // Draw pre-designated auto-hit hexes
<span class="nc bnc" id="L2176" title="All 2 branches missed.">        if (localPlayer != null) // Could be null, like in map-editor</span>
        {
<span class="nc bnc" id="L2178" title="All 2 branches missed.">            for (Coords c : localPlayer.getArtyAutoHitHexes()) {</span>
                // Is the Coord within the viewing area?
<span class="nc bnc" id="L2180" title="All 4 branches missed.">                if ((c.getX() &gt;= drawX) &amp;&amp; (c.getX() &lt;= (drawX + drawWidth))</span>
<span class="nc bnc" id="L2181" title="All 4 branches missed.">                    &amp;&amp; (c.getY() &gt;= drawY) &amp;&amp; (c.getY() &lt;= (drawY + drawHeight))) {</span>

<span class="nc" id="L2183">                    Point p = getHexLocation(c);</span>
<span class="nc" id="L2184">                    artyIconImage = tileManager</span>
<span class="nc" id="L2185">                            .getArtilleryTarget(TilesetManager.ARTILLERY_AUTOHIT);</span>
<span class="nc" id="L2186">                    g.drawImage(getScaledImage(artyIconImage, true), p.x, p.y, this);</span>
                }
<span class="nc" id="L2188">            }</span>
        }

        // Draw modifiers for selected entity and weapon
<span class="nc bnc" id="L2192" title="All 2 branches missed.">        if (weapon != null) {</span>
            // Loop through all of the attack modifiers for this weapon
<span class="nc bnc" id="L2194" title="All 2 branches missed.">            for (ArtilleryTracker.ArtilleryModifier attackMod : selectedEntity.aTracker</span>
<span class="nc" id="L2195">                    .getWeaponModifiers(weapon)) {</span>
<span class="nc" id="L2196">                Coords c = attackMod.getCoords();</span>
                // Is the Coord within the viewing area?
<span class="nc bnc" id="L2198" title="All 4 branches missed.">                if ((c.getX() &gt;= drawX) &amp;&amp; (c.getX() &lt;= (drawX + drawWidth))</span>
<span class="nc bnc" id="L2199" title="All 4 branches missed.">                    &amp;&amp; (c.getY() &gt;= drawY) &amp;&amp; (c.getY() &lt;= (drawY + drawHeight))) {</span>

<span class="nc" id="L2201">                    Point p = getHexLocation(c);</span>
                    // draw the crosshairs
<span class="nc bnc" id="L2203" title="All 2 branches missed.">                    if (attackMod.getModifier() == TargetRoll.AUTOMATIC_SUCCESS) {</span>
                        // predesignated or already hit
<span class="nc" id="L2205">                        artyIconImage = tileManager</span>
<span class="nc" id="L2206">                                .getArtilleryTarget(TilesetManager.ARTILLERY_AUTOHIT);</span>
                    } else {
<span class="nc" id="L2208">                        artyIconImage = tileManager</span>
<span class="nc" id="L2209">                                .getArtilleryTarget(TilesetManager.ARTILLERY_ADJUSTED);</span>
                    }
<span class="nc" id="L2211">                    g.drawImage(getScaledImage(artyIconImage, true), p.x, p.y, this);</span>
                }
<span class="nc" id="L2213">            }</span>
        }
<span class="nc" id="L2215">    }</span>

    /*
     * NOTENOTENOTE: (itmo) wouldnt this be simpler with two arrays. One with
     * the strings {&quot;BoardView1.thunderblaablaa&quot;,&quot;BoardView1.Conventi..&quot;} one
     * with the offsets {51,51,42} etc Preferably indexed by an enum: enum{
     * Conventional, Thunder; } or something?
     */

    /**
     * Writes &quot;MINEFIELD&quot; in minefield hexes...
     */
    private void drawMinefields(Graphics g) {
<span class="nc" id="L2228">        Rectangle view = g.getClipBounds();</span>
        // only update visible hexes
<span class="nc" id="L2230">        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</span>
<span class="nc" id="L2231">        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</span>

<span class="nc" id="L2233">        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</span>
<span class="nc" id="L2234">        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</span>

<span class="nc" id="L2236">        int maxX = drawX + drawWidth;</span>
<span class="nc" id="L2237">        int maxY = drawY + drawHeight;</span>

<span class="nc" id="L2239">        IBoard board = game.getBoard();</span>
<span class="nc" id="L2240">        for (Enumeration&lt;Coords&gt; minedCoords = game.getMinedCoords();</span>
<span class="nc bnc" id="L2241" title="All 2 branches missed.">             minedCoords.hasMoreElements(); ) {</span>
<span class="nc" id="L2242">            Coords c = minedCoords.nextElement();</span>
            // If the coords aren't visible, skip
<span class="nc bnc" id="L2244" title="All 8 branches missed.">            if ((c.getX() &lt; drawX) || (c.getX() &gt; maxX) || (c.getY() &lt; drawY) || (c.getY() &gt; maxY)</span>
<span class="nc bnc" id="L2245" title="All 2 branches missed.">                || !board.contains(c)) {</span>
<span class="nc" id="L2246">                continue;</span>
            }

<span class="nc" id="L2249">            Point p = getHexLocation(c);</span>
<span class="nc" id="L2250">            Image mineImg = getScaledImage(tileManager.getMinefieldSign(), true);</span>
<span class="nc" id="L2251">            g.drawImage(mineImg, p.x + (int) (13 * scale), p.y</span>
                                                           + (int) (13 * scale), this);

<span class="nc" id="L2254">            g.setColor(Color.black);</span>
<span class="nc" id="L2255">            int nbrMfs = game.getNbrMinefields(c);</span>
<span class="nc bnc" id="L2256" title="All 2 branches missed.">            if (nbrMfs &gt; 1) {</span>
<span class="nc" id="L2257">                drawCenteredString(</span>
<span class="nc" id="L2258">                        Messages.getString(&quot;BoardView1.Multiple&quot;), //$NON-NLS-1$</span>
                        p.x, p.y + (int) (51 * scale), font_minefield, g);
<span class="nc bnc" id="L2260" title="All 2 branches missed.">            } else if (nbrMfs == 1) {</span>
<span class="nc" id="L2261">                Minefield mf = game.getMinefields(c).get(0);</span>

<span class="nc bnc" id="L2263" title="All 6 branches missed.">                switch (mf.getType()) {</span>
                    case (Minefield.TYPE_CONVENTIONAL):
<span class="nc" id="L2265">                        drawCenteredString(</span>
<span class="nc" id="L2266">                                Messages.getString(&quot;BoardView1.Conventional&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L2267">                                + mf.getDensity() + &quot;)&quot;, //$NON-NLS-1$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc" id="L2270">                        break;</span>
                    case (Minefield.TYPE_INFERNO):
<span class="nc" id="L2272">                        drawCenteredString(</span>
<span class="nc" id="L2273">                                Messages.getString(&quot;BoardView1.Inferno&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L2274">                                + mf.getDensity() + &quot;)&quot;, //$NON-NLS-1$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc" id="L2277">                        break;</span>
                    case (Minefield.TYPE_ACTIVE):
<span class="nc" id="L2279">                        drawCenteredString(</span>
<span class="nc" id="L2280">                                Messages.getString(&quot;BoardView1.Active&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L2281">                                + mf.getDensity() + &quot;)&quot;,  //$NON-NLS-2$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc" id="L2284">                        break;</span>
                    case (Minefield.TYPE_COMMAND_DETONATED):
<span class="nc" id="L2286">                        drawCenteredString(</span>
<span class="nc" id="L2287">                                Messages.getString(&quot;BoardView1.Command-&quot;), //$NON-NLS-1$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc" id="L2290">                        drawCenteredString(</span>
<span class="nc" id="L2291">                                Messages.getString(&quot;BoardView1.detonated&quot; //$NON-NLS-1$</span>
<span class="nc" id="L2292">                                                   + mf.getDensity() + &quot;)&quot;), //$NON-NLS-1$</span>
                                p.x, p.y + (int) (60 * scale),
                                font_minefield, g);
<span class="nc" id="L2295">                        break;</span>
                    case (Minefield.TYPE_VIBRABOMB):
<span class="nc" id="L2297">                        drawCenteredString(</span>
<span class="nc" id="L2298">                                Messages.getString(&quot;BoardView1.Vibrabomb&quot;), //$NON-NLS-1$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc bnc" id="L2301" title="All 2 branches missed.">                        if (mf.getPlayerId() == localPlayer.getId()) {</span>
<span class="nc" id="L2302">                            drawCenteredString(&quot;(&quot; //$NON-NLS-1$</span>
<span class="nc" id="L2303">                                               + mf.getSetting() + &quot;)&quot;, //$NON-NLS-1$</span>
                                               p.x, p.y + (int) (60 * scale),
                                               font_minefield, g);
                        }
                        break;
                }
            }
<span class="nc" id="L2310">        }</span>
<span class="nc" id="L2311">    }</span>

    private void drawCenteredString(String string, int x, int y, Font font,
                                    Graphics graph) {
<span class="nc" id="L2315">        FontMetrics currentMetrics = getFontMetrics(font);</span>
<span class="nc" id="L2316">        int stringWidth = currentMetrics.stringWidth(string);</span>

<span class="nc" id="L2318">        x += ((hex_size.width - stringWidth) / 2);</span>

<span class="nc" id="L2320">        graph.setFont(font);</span>
<span class="nc" id="L2321">        graph.drawString(string, x, y);</span>
<span class="nc" id="L2322">    }</span>

    /**
     * This method creates an image the size of the entire board (all
     * mapsheets), draws the hexes onto it, and returns that image.
     */
    public BufferedImage getEntireBoardImage(boolean ignoreUnits) {
        // Set zoom to base, so we get a consist board image

<span class="nc" id="L2331">        int oldZoom = zoomIndex;</span>
<span class="nc" id="L2332">        zoomIndex = BASE_ZOOM_INDEX;</span>
<span class="nc" id="L2333">        zoom();</span>

<span class="nc" id="L2335">        Image entireBoard = createImage(boardSize.width, boardSize.height);</span>
<span class="nc" id="L2336">        Graphics2D boardGraph = (Graphics2D) entireBoard.getGraphics();</span>
<span class="nc" id="L2337">        boardGraph.setClip(0, 0, boardSize.width, boardSize.height);</span>
<span class="nc bnc" id="L2338" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getAntiAliasing()) {</span>
<span class="nc" id="L2339">            boardGraph.setRenderingHint(RenderingHints.KEY_ANTIALIASING,</span>
                                        RenderingHints.VALUE_ANTIALIAS_ON);
        }

<span class="nc bnc" id="L2343" title="All 2 branches missed.">        if (shadowMap == null) {</span>
<span class="nc" id="L2344">            updateShadowMap();</span>
        }

        // Draw hexes
<span class="nc" id="L2348">        drawHexes(boardGraph, new Rectangle(boardSize), ignoreUnits);</span>

        // If we aren't ignoring units, draw everything else
<span class="nc bnc" id="L2351" title="All 2 branches missed.">        if (!ignoreUnits) {</span>
            // draw wrecks
<span class="nc bnc" id="L2353" title="All 2 branches missed.">            if (GUIPreferences.getInstance().getShowWrecks()</span>
<span class="nc bnc" id="L2354" title="All 2 branches missed.">                    &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L2355">                drawSprites(boardGraph, wreckSprites);</span>
            }

            // Field of Fire
<span class="nc bnc" id="L2359" title="All 2 branches missed.">            if (!useIsometric()</span>
<span class="nc bnc" id="L2360" title="All 2 branches missed.">                    &amp;&amp; GUIPreferences.getInstance().getShowFieldOfFire()) {</span>
<span class="nc" id="L2361">                drawSprites(boardGraph, fieldofFireSprites);</span>
            }

<span class="nc bnc" id="L2364" title="All 4 branches missed.">            if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L2365">                drawSprites(boardGraph, moveEnvSprites);</span>
<span class="nc" id="L2366">                drawSprites(boardGraph, moveModEnvSprites);</span>
            }

            // Minefield signs all over the place!
<span class="nc" id="L2370">            drawMinefields(boardGraph);</span>

            // Artillery targets
<span class="nc" id="L2373">            drawArtilleryHexes(boardGraph);</span>

            // draw highlight border
<span class="nc" id="L2376">            drawSprite(boardGraph, highlightSprite);</span>

            // draw cursors
<span class="nc" id="L2379">            drawSprite(boardGraph, cursorSprite);</span>
<span class="nc" id="L2380">            drawSprite(boardGraph, selectedSprite);</span>
<span class="nc" id="L2381">            drawSprite(boardGraph, firstLOSSprite);</span>
<span class="nc" id="L2382">            drawSprite(boardGraph, secondLOSSprite);</span>

            // draw deployment indicators.
            // For Isometric rendering, this is done during drawHexes
<span class="nc bnc" id="L2386" title="All 4 branches missed.">            if ((en_Deployer != null) &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L2387">                drawDeployment(boardGraph);</span>
            }

<span class="nc bnc" id="L2390" title="All 4 branches missed.">            if ((game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES)</span>
                    &amp;&amp; (showAllDeployment)) {
<span class="nc" id="L2392">                drawAllDeployment(boardGraph);</span>
            }

            // draw Flare Sprites
<span class="nc" id="L2396">            drawSprites(boardGraph, flareSprites);</span>

            // draw C3 links
<span class="nc" id="L2399">            drawSprites(boardGraph, c3Sprites);</span>

            // draw flyover routes
<span class="nc bnc" id="L2402" title="All 2 branches missed.">            if (game.getBoard().onGround()) {</span>
<span class="nc" id="L2403">                drawSprites(boardGraph, vtolAttackSprites);</span>
<span class="nc" id="L2404">                drawSprites(boardGraph, flyOverSprites);</span>
            }

            // draw onscreen entities
<span class="nc" id="L2408">            drawSprites(boardGraph, entitySprites);</span>

            // draw moving onscreen entities
<span class="nc" id="L2411">            drawSprites(boardGraph, movingEntitySprites);</span>

            // draw ghost onscreen entities
<span class="nc" id="L2414">            drawSprites(boardGraph, ghostEntitySprites);</span>

            // draw onscreen attacks
<span class="nc" id="L2417">            drawSprites(boardGraph, attackSprites);</span>

            // draw movement vectors.
<span class="nc bnc" id="L2420" title="All 2 branches missed.">            if (game.useVectorMove()</span>
<span class="nc bnc" id="L2421" title="All 2 branches missed.">                &amp;&amp; (game.getPhase() == IGame.Phase.PHASE_MOVEMENT)) {</span>
<span class="nc" id="L2422">                drawSprites(boardGraph, movementSprites);</span>
            }

            // draw movement, if valid
<span class="nc" id="L2426">            drawSprites(boardGraph, pathSprites);</span>

            // draw firing solution sprites, but only during the firing phase
<span class="nc bnc" id="L2429" title="All 2 branches missed.">            if ((game.getPhase() == Phase.PHASE_FIRING) ||</span>
<span class="nc bnc" id="L2430" title="All 2 branches missed.">                (game.getPhase() == Phase.PHASE_OFFBOARD)) {</span>
<span class="nc" id="L2431">                drawSprites(boardGraph, firingSprites);</span>
            }

<span class="nc bnc" id="L2434" title="All 2 branches missed.">            if (game.getPhase() == Phase.PHASE_FIRING) {</span>
<span class="nc bnc" id="L2435" title="All 2 branches missed.">                for (Coords c : strafingCoords) {</span>
<span class="nc" id="L2436">                    drawHexBorder(boardGraph, getHexLocation(c), Color.yellow, 0, 3);</span>
<span class="nc" id="L2437">                }</span>
            }
        }
<span class="nc" id="L2440">        boardGraph.dispose();</span>

        // Restore the zoom setting
<span class="nc" id="L2443">        zoomIndex = oldZoom;</span>
<span class="nc" id="L2444">        zoom();</span>

<span class="nc" id="L2446">        return (BufferedImage) entireBoard;</span>
    }

    private void drawHexes(Graphics g, Rectangle view) {
<span class="nc" id="L2450">        drawHexes(g, view, false);</span>
<span class="nc" id="L2451">    }</span>

    /**
     * Redraws all hexes in the specified rectangle
     */
    private void drawHexes(Graphics g, Rectangle view, boolean saveBoardImage) {
        // only update visible hexes
<span class="nc" id="L2458">        double xs = (int) (HEX_WC*scale);</span>
<span class="nc" id="L2459">        double ys = (int) (HEX_H*scale);</span>

<span class="nc" id="L2461">        int drawX = (int) (view.x / xs) - 1;</span>
<span class="nc" id="L2462">        int drawY = (int) (view.y / ys) - 1;</span>

<span class="nc" id="L2464">        int drawWidth = (int) (view.width / xs) + 3;</span>
<span class="nc" id="L2465">        int drawHeight = (int) (view.height / ys) + 3;</span>

        // draw some hexes.
<span class="nc bnc" id="L2468" title="All 2 branches missed.">        if (useIsometric()) {</span>
<span class="nc" id="L2469">            IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L2470" title="All 2 branches missed.">            for (int y = 0; y &lt; drawHeight; y++) {</span>
                // Half of each row is one-half hex
                // farther back (above) the other; draw those first
<span class="nc bnc" id="L2473" title="All 2 branches missed.">                for (int s = 0; s &lt;= 1; s++) {</span>
<span class="nc bnc" id="L2474" title="All 2 branches missed.">                    for (int x = s; x &lt; drawWidth+s+1; x=x+2) {</span>
                        // For s == 0 the x coordinate MUST be an even number
                        // to get correct occlusion; drawX may be any int though
<span class="nc" id="L2477">                        Coords c = new Coords(x + drawX/2*2, y + drawY);</span>
<span class="nc" id="L2478">                        IHex hex = board.getHex(c);</span>
<span class="nc bnc" id="L2479" title="All 2 branches missed.">                        if ((hex != null)) {</span>
<span class="nc" id="L2480">                            drawHex(c, g, saveBoardImage);</span>
<span class="nc" id="L2481">                            if (GUIPreferences.getInstance()</span>
<span class="nc bnc" id="L2482" title="All 2 branches missed.">                                    .getShowFieldOfFire()) {</span>
<span class="nc" id="L2483">                                drawHexSpritesForHex(c, g, fieldofFireSprites);</span>
                            }
<span class="nc" id="L2485">                            drawHexSpritesForHex(c, g, moveEnvSprites);</span>
<span class="nc" id="L2486">                            drawHexSpritesForHex(c, g, moveModEnvSprites);</span>
<span class="nc bnc" id="L2487" title="All 2 branches missed.">                            if ((en_Deployer != null)</span>
<span class="nc bnc" id="L2488" title="All 2 branches missed.">                                    &amp;&amp; board.isLegalDeployment(c,</span>
<span class="nc" id="L2489">                                            en_Deployer.getStartingPos())) {</span>
<span class="nc" id="L2490">                                drawHexBorder(g, getHexLocation(c),</span>
                                        Color.yellow);
                            }
<span class="nc" id="L2493">                            drawOrthograph(c, g);</span>
                        }
                    }
                }
<span class="nc bnc" id="L2497" title="All 2 branches missed.">                for (int x = 0; x &lt; drawWidth; x++) {</span>
<span class="nc" id="L2498">                    Coords c = new Coords(x + drawX, y + drawY);</span>
<span class="nc" id="L2499">                    IHex hex = board.getHex(c);</span>
<span class="nc bnc" id="L2500" title="All 2 branches missed.">                    if (hex != null) {</span>
<span class="nc bnc" id="L2501" title="All 2 branches missed.">                        if (!saveBoardImage) {</span>
<span class="nc bnc" id="L2502" title="All 2 branches missed.">                            if (GUIPreferences.getInstance().getShowWrecks()) {</span>
<span class="nc" id="L2503">                                drawIsometricWreckSpritesForHex(c, g,</span>
                                        isometricWreckSprites);
                            }
<span class="nc" id="L2506">                            drawIsometricSpritesForHex(c, g, isometricSprites);</span>
                        }
                    }
                }
            }
<span class="nc bnc" id="L2511" title="All 2 branches missed.">            if (!saveBoardImage) {</span>
                // If we are using Isometric rendering, redraw the entity
                // sprites at 50% transparent so sprites hidden behind hills can
                // still be seen by the user.
<span class="nc" id="L2515">                drawIsometricSprites(g, isometricSprites);</span>
            }
<span class="nc" id="L2517">        } else {</span>
            // Draw hexes without regard to elevation when
            // not using Isometric, since it does not matter.
<span class="nc bnc" id="L2520" title="All 2 branches missed.">            for (int i = 0; i &lt; drawHeight; i++) {</span>
<span class="nc bnc" id="L2521" title="All 2 branches missed.">                for (int j = 0; j &lt; drawWidth; j++) {</span>
<span class="nc" id="L2522">                    Coords c = new Coords(j + drawX, i + drawY);</span>
<span class="nc" id="L2523">                    drawHex(c, g, saveBoardImage);</span>
                }
            }
        }
<span class="nc" id="L2527">    }</span>

    /**
     * Draws a hex onto the board buffer. This assumes that drawRect is current,
     * and does not check if the hex is visible.
     */
    private void drawHex(Coords c, Graphics boardGraph,
                         boolean saveBoardImage) {
<span class="nc bnc" id="L2535" title="All 2 branches missed.">        if (!game.getBoard().contains(c)) {</span>
<span class="nc" id="L2536">            return;</span>
        }

<span class="nc" id="L2539">        final GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc" id="L2540">        final IHex hex = game.getBoard().getHex(c);</span>
<span class="nc" id="L2541">        final Point hexLoc = getHexLocation(c);</span>

        // Check the cache to see if we already have the image
<span class="nc" id="L2544">        HexImageCacheEntry cacheEntry = hexImageCache.get(c);</span>
<span class="nc bnc" id="L2545" title="All 4 branches missed.">        if ((cacheEntry != null) &amp;&amp; !cacheEntry.needsUpdating) {</span>
<span class="nc" id="L2546">            boardGraph.drawImage(cacheEntry.hexImage, hexLoc.x, hexLoc.y, this);</span>
<span class="nc" id="L2547">            return;</span>
        }

<span class="nc" id="L2550">        int level = hex.getLevel();</span>
<span class="nc" id="L2551">        int depth = hex.depth(false);</span>

<span class="nc" id="L2553">        ITerrain basement = hex.getTerrain(Terrains.BLDG_BASEMENT_TYPE);</span>
<span class="nc bnc" id="L2554" title="All 2 branches missed.">        if (basement != null) {</span>
<span class="nc" id="L2555">            depth = 0;</span>
        }

<span class="nc" id="L2558">        int height = Math.max(hex.terrainLevel(Terrains.BLDG_ELEV),</span>
<span class="nc" id="L2559">                              hex.terrainLevel(Terrains.BRIDGE_ELEV));</span>
<span class="nc" id="L2560">        height = Math.max(height, hex.terrainLevel(Terrains.INDUSTRIAL));</span>

<span class="nc" id="L2562">        Image boardBgHexImg = getBoardBackgroundHexImage(c, hex);</span>
        // get the base tile image
        Image baseImage, scaledImage;
<span class="nc bnc" id="L2565" title="All 2 branches missed.">        if (boardBgHexImg != null) {</span>
<span class="nc" id="L2566">            baseImage = boardBgHexImg;</span>
<span class="nc" id="L2567">            scaledImage = boardBgHexImg;</span>
        } else {
<span class="nc" id="L2569">            baseImage = tileManager.baseFor(hex);</span>
<span class="nc" id="L2570">            scaledImage = getScaledImage(baseImage, true);</span>
        }

        // Some hex images shouldn't be cached, like if they are animated
<span class="nc" id="L2574">        boolean dontCache = animatedImages.contains(baseImage.hashCode());</span>

        // check if this is a standard tile image 84x72 or something different
<span class="nc bnc" id="L2577" title="All 2 branches missed.">        boolean standardTile = (baseImage.getHeight(null) == HEX_H)</span>
<span class="nc bnc" id="L2578" title="All 2 branches missed.">                &amp;&amp; (baseImage.getWidth(null) == HEX_W);</span>

        int imgHeight, imgWidth;
<span class="nc" id="L2581">        imgWidth = scaledImage.getWidth(null);</span>
<span class="nc" id="L2582">        imgHeight = scaledImage.getHeight(null);</span>

        // do not make larger than hex images even when the input image is big
<span class="nc" id="L2585">        int origImgWidth = imgWidth; // save for later, needed for large tiles</span>
<span class="nc" id="L2586">        int origImgHeight = imgHeight;</span>

<span class="nc" id="L2588">        imgWidth = Math.min(imgWidth,(int)(HEX_W*scale));</span>
<span class="nc" id="L2589">        imgHeight = Math.min(imgHeight,(int)(HEX_H*scale));</span>

<span class="nc bnc" id="L2591" title="All 2 branches missed.">        if (useIsometric()) {</span>
<span class="nc" id="L2592">            int largestLevelDiff = 0;</span>
<span class="nc bnc" id="L2593" title="All 2 branches missed.">            for (int dir: allDirections) {</span>
<span class="nc" id="L2594">                IHex adjHex = game.getBoard().getHexInDir(c, dir);</span>
<span class="nc bnc" id="L2595" title="All 2 branches missed.">                if (adjHex == null) {</span>
<span class="nc" id="L2596">                    continue;</span>
                }
<span class="nc" id="L2598">                int levelDiff = Math.abs(level - adjHex.getLevel());</span>
<span class="nc bnc" id="L2599" title="All 2 branches missed.">                if (levelDiff &gt; largestLevelDiff) {</span>
<span class="nc" id="L2600">                    largestLevelDiff = levelDiff;</span>
                }
            }
<span class="nc" id="L2603">            imgHeight += HEX_ELEV * scale * largestLevelDiff;</span>
        }
        // If the base image isn't ready, we should signal a repaint and stop
<span class="nc bnc" id="L2606" title="All 4 branches missed.">        if ((imgWidth &lt; 0) || (imgHeight &lt; 0)) {</span>
<span class="nc" id="L2607">            repaint();</span>
<span class="nc" id="L2608">            return;</span>
        }

<span class="nc" id="L2611">        BufferedImage hexImage = new BufferedImage(imgWidth, imgHeight,</span>
                BufferedImage.TYPE_INT_ARGB);

<span class="nc" id="L2614">        Graphics2D g = (Graphics2D)(hexImage.getGraphics());</span>
<span class="nc" id="L2615">        GUIPreferences.AntiAliasifSet(g);</span>

<span class="nc bnc" id="L2617" title="All 2 branches missed.">        if (standardTile) { // is the image hex-sized, 84*72?</span>
<span class="nc" id="L2618">            g.drawImage(scaledImage, 0, 0, this);</span>
        } else { // Draw image for a texture larger than a hex
<span class="nc" id="L2620">            Point p1SRC = getHexLocationLargeTile(c.getX(), c.getY());</span>
<span class="nc" id="L2621">            p1SRC.x = p1SRC.x % origImgWidth;</span>
<span class="nc" id="L2622">            p1SRC.y = p1SRC.y % origImgHeight;</span>
<span class="nc" id="L2623">            Point p2SRC = new Point((int) (p1SRC.x + HEX_W * scale),</span>
                    (int) (p1SRC.y + HEX_H * scale));
<span class="nc" id="L2625">            Point p2DST = new Point((int) (HEX_W * scale),</span>
                    (int) (HEX_H * scale));

            // hex mask to limit drawing to the hex shape
            // TODO: this is not ideal yet but at least it draws
            // without leaving gaps at any zoom
<span class="nc" id="L2631">            Image hexMask = getScaledImage(tileManager.getHexMask(), true);</span>
<span class="nc" id="L2632">            g.drawImage(hexMask, 0, 0, this);</span>
<span class="nc" id="L2633">            Composite svComp = g.getComposite();</span>
<span class="nc" id="L2634">            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP,</span>
                    1f));

            // paint the right slice from the big pic
<span class="nc" id="L2638">            g.drawImage(scaledImage, 0, 0, p2DST.x, p2DST.y, p1SRC.x, p1SRC.y,</span>
                    p2SRC.x, p2SRC.y, null);

            // Handle wrapping of the image
<span class="nc bnc" id="L2642" title="All 4 branches missed.">            if (p2SRC.x &gt; origImgWidth &amp;&amp; p2SRC.y &lt;= origImgHeight) {</span>
<span class="nc" id="L2643">                g.drawImage(scaledImage, origImgWidth - p1SRC.x, 0, p2DST.x,</span>
                        p2DST.y, 0, p1SRC.y, p2SRC.x - origImgWidth, p2SRC.y,
                        null); // paint addtl slice on the left side
<span class="nc bnc" id="L2646" title="All 4 branches missed.">            } else if (p2SRC.x &lt;= origImgWidth &amp;&amp; p2SRC.y &gt; origImgHeight) {</span>
<span class="nc" id="L2647">                g.drawImage(scaledImage, 0, origImgHeight - p1SRC.y, p2DST.x,</span>
                        p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - origImgHeight,
                        null); // paint addtl slice on the top
<span class="nc bnc" id="L2650" title="All 4 branches missed.">            } else if (p2SRC.x &gt; origImgWidth &amp;&amp; p2SRC.y &gt; origImgHeight) {</span>
<span class="nc" id="L2651">                g.drawImage(scaledImage, origImgWidth - p1SRC.x, 0, p2DST.x,</span>
                        p2DST.y, 0, p1SRC.y, p2SRC.x - origImgWidth, p2SRC.y,
                        null); // paint addtl slice on the top
<span class="nc" id="L2654">                g.drawImage(scaledImage, 0, origImgHeight - p1SRC.y, p2DST.x,</span>
                        p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - origImgHeight,
                        null); // paint addtl slice on the left side
                // paint addtl slice on the top left side
<span class="nc" id="L2658">                g.drawImage(scaledImage, origImgWidth - p1SRC.x, origImgHeight</span>
                        - p1SRC.y, p2DST.x, p2DST.y, 0, 0, p2SRC.x
                        - origImgWidth, p2SRC.y - origImgHeight, null);
            }

<span class="nc" id="L2663">            g.setComposite(svComp);</span>
        }

        // To place roads under the shadow map, supers for hexes with roads
        // have to be drawn before the shadow map, otherwise the supers are
        // drawn after.  Unfortunately I dont think the supers images
        // themselves can be checked for roads.
<span class="nc" id="L2670">        List&lt;Image&gt; supers = tileManager.supersFor(hex);</span>
<span class="nc" id="L2671">        boolean supersUnderShadow = false;</span>
<span class="nc bnc" id="L2672" title="All 2 branches missed.">        if (hex.containsTerrain(Terrains.ROAD) ||</span>
<span class="nc bnc" id="L2673" title="All 2 branches missed.">                hex.containsTerrain(Terrains.WATER)) {</span>
<span class="nc" id="L2674">            supersUnderShadow = true;</span>
<span class="nc bnc" id="L2675" title="All 2 branches missed.">            if (supers != null) {</span>
<span class="nc bnc" id="L2676" title="All 2 branches missed.">                for (Image image : supers) {</span>
<span class="nc bnc" id="L2677" title="All 2 branches missed.">                    if (animatedImages.contains(image.hashCode())) {</span>
<span class="nc" id="L2678">                        dontCache = true;</span>
                    }
<span class="nc" id="L2680">                    scaledImage = getScaledImage(image, true);</span>
<span class="nc" id="L2681">                    g.drawImage(scaledImage, 0, 0, this);</span>
<span class="nc" id="L2682">                }</span>
            }
        }

        // Add the terrain &amp; building shadows
<span class="nc bnc" id="L2687" title="All 4 branches missed.">        if (guip.getBoolean(GUIPreferences.SHADOWMAP) &amp;&amp;</span>
            (shadowMap != null)) {
<span class="nc" id="L2689">            Point p1SRC = getHexLocationLargeTile(c.getX(), c.getY(), 1);</span>
<span class="nc" id="L2690">            Point p2SRC = new Point(p1SRC.x + HEX_W, p1SRC.y + HEX_H);</span>
<span class="nc" id="L2691">            Point p2DST = new Point(hex_size.width, hex_size.height);</span>

<span class="nc" id="L2693">            Composite svComp = g.getComposite();</span>
<span class="nc bnc" id="L2694" title="All 2 branches missed.">            if (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_DAY) {</span>
<span class="nc" id="L2695">                g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, 0.55f));</span>
            } else {
<span class="nc" id="L2697">                g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, 0.45f));</span>
            }

            // paint the right slice from the big pic
<span class="nc" id="L2701">            g.drawImage(shadowMap, 0, 0, p2DST.x, p2DST.y, p1SRC.x, p1SRC.y,</span>
                    p2SRC.x, p2SRC.y, null);
<span class="nc" id="L2703">            g.setComposite(svComp);</span>
        }

<span class="nc bnc" id="L2706" title="All 2 branches missed.">        if (!supersUnderShadow) {</span>
<span class="nc bnc" id="L2707" title="All 2 branches missed.">            if (supers != null) {</span>
<span class="nc bnc" id="L2708" title="All 2 branches missed.">                for (Image image : supers) {</span>
<span class="nc bnc" id="L2709" title="All 2 branches missed.">                    if (null != image) {</span>
<span class="nc bnc" id="L2710" title="All 2 branches missed.">                        if (animatedImages.contains(image.hashCode())) {</span>
<span class="nc" id="L2711">                            dontCache = true;</span>
                        }
<span class="nc" id="L2713">                        scaledImage = getScaledImage(image, true);</span>
<span class="nc" id="L2714">                        g.drawImage(scaledImage, 0, 0, this);</span>
                    }
<span class="nc" id="L2716">                }</span>
            }
        }

        // AO Hex Shadow in this hex when a higher one is adjacent
<span class="nc bnc" id="L2721" title="All 2 branches missed.">        if (guip.getBoolean(GUIPreferences.AOHEXSHADOWS)</span>
               ) {
<span class="nc bnc" id="L2723" title="All 2 branches missed.">            for (int dir : allDirections) {</span>
<span class="nc" id="L2724">                Shape ShadowShape = getElevationShadowArea(c, dir);</span>
<span class="nc" id="L2725">                GradientPaint gpl = getElevationShadowGP(c, dir);</span>
<span class="nc bnc" id="L2726" title="All 4 branches missed.">                if (ShadowShape != null &amp;&amp; gpl != null) {</span>
<span class="nc" id="L2727">                    g.setPaint(gpl);</span>
<span class="nc" id="L2728">                    g.fill(getElevationShadowArea(c, dir));</span>
                }
            }
        }

        // Orthos (bridges)
<span class="nc" id="L2734">        List&lt;Image&gt; orthos = tileManager.orthoFor(hex);</span>
<span class="nc bnc" id="L2735" title="All 2 branches missed.">        if (orthos != null) {</span>
<span class="nc bnc" id="L2736" title="All 2 branches missed.">            for (Image image : orthos) {</span>
<span class="nc bnc" id="L2737" title="All 2 branches missed.">                if (animatedImages.contains(image.hashCode())) {</span>
<span class="nc" id="L2738">                    dontCache = true;</span>
                }
<span class="nc" id="L2740">                scaledImage = getScaledImage(image, true);</span>
<span class="nc bnc" id="L2741" title="All 2 branches missed.">                if (!useIsometric()) {</span>
<span class="nc" id="L2742">                    g.drawImage(scaledImage, 0, 0, this);</span>
                }
                // draw a shadow for bridge hex.
<span class="nc bnc" id="L2745" title="All 2 branches missed.">                if (useIsometric()</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">                        &amp;&amp; !guip.getBoolean(GUIPreferences.SHADOWMAP)</span>
<span class="nc bnc" id="L2747" title="All 2 branches missed.">                        &amp;&amp; (hex.terrainLevel(Terrains.BRIDGE_ELEV) &gt; 0)) {</span>
<span class="nc" id="L2748">                    Image shadow = createShadowMask(scaledImage);</span>
<span class="nc" id="L2749">                    g.drawImage(shadow, 0, 0, this);</span>
                }
<span class="nc" id="L2751">            }</span>
        }

        // Shade and add static noise to hexes that are in an ECM field
<span class="nc bnc" id="L2755" title="All 2 branches missed.">        if (ecmHexes != null) {</span>
<span class="nc" id="L2756">            Color tint = ecmHexes.get(c);</span>
<span class="nc bnc" id="L2757" title="All 2 branches missed.">            if (tint != null) {</span>
<span class="nc" id="L2758">                Color origColor = g.getColor();</span>
<span class="nc" id="L2759">                g.setColor(tint);</span>
<span class="nc" id="L2760">                AffineTransform sc = new AffineTransform();</span>
<span class="nc" id="L2761">                sc.scale(scale, scale);</span>
<span class="nc" id="L2762">                g.fill(sc.createTransformedShape(hexPoly));</span>
<span class="nc" id="L2763">                g.setColor(origColor);</span>
<span class="nc" id="L2764">                Image staticImage = getScaledImage(</span>
<span class="nc" id="L2765">                        tileManager.getEcmStaticImage(tint), false);</span>
<span class="nc" id="L2766">                g.drawImage(staticImage, 0, 0, staticImage.getWidth(null),</span>
<span class="nc" id="L2767">                        staticImage.getHeight(null), this);</span>
            }
        }
        // Shade hexes that are in an ECCM field
<span class="nc bnc" id="L2771" title="All 2 branches missed.">        if (eccmHexes != null) {</span>
<span class="nc" id="L2772">            Color tint = eccmHexes.get(c);</span>
<span class="nc bnc" id="L2773" title="All 2 branches missed.">            if (tint != null) {</span>
<span class="nc" id="L2774">                Color origColor = g.getColor();</span>
<span class="nc" id="L2775">                g.setColor(tint);</span>
<span class="nc" id="L2776">                AffineTransform sc = new AffineTransform();</span>
<span class="nc" id="L2777">                sc.scale(scale, scale);</span>
<span class="nc" id="L2778">                g.fill(sc.createTransformedShape(hexPoly));</span>
<span class="nc" id="L2779">                g.setColor(origColor);</span>
            }
        }
        // Highlight hexes that contain the source of an ECM field
<span class="nc bnc" id="L2783" title="All 2 branches missed.">        if (ecmCenters != null) {</span>
<span class="nc" id="L2784">            Color tint = ecmCenters.get(c);</span>
<span class="nc bnc" id="L2785" title="All 2 branches missed.">            if (tint != null) {</span>
<span class="nc" id="L2786">                drawHexBorder(g, tint.darker(), 5, 10);</span>
            }
        }

        // Highlight hexes that contain the source of an ECCM field
<span class="nc bnc" id="L2791" title="All 2 branches missed.">        if (eccmCenters != null) {</span>
<span class="nc" id="L2792">            Color tint = eccmCenters.get(c);</span>
<span class="nc bnc" id="L2793" title="All 2 branches missed.">            if (tint != null) {</span>
<span class="nc" id="L2794">                drawHexBorder(g, tint.darker(), 5, 10);</span>
            }
        }

        // Darken the hex for night-time, if applicable
<span class="nc bnc" id="L2799" title="All 2 branches missed.">        if (guip.getBoolean(GUIPreferences.ADVANCED_DARKEN_MAP_AT_NIGHT)</span>
<span class="nc bnc" id="L2800" title="All 2 branches missed.">                &amp;&amp; (game.isPositionIlluminated(c) == IGame.ILLUMINATED_NONE)</span>
<span class="nc bnc" id="L2801" title="All 2 branches missed.">                &amp;&amp; (game.getPlanetaryConditions().getLight() &gt; PlanetaryConditions.L_DAY)) {</span>
<span class="nc bnc" id="L2802" title="All 2 branches missed.">            for (int x = 0; x &lt; hexImage.getWidth(); ++x) {</span>
<span class="nc bnc" id="L2803" title="All 2 branches missed.">                for (int y = 0; y &lt; hexImage.getHeight(); ++y) {</span>
<span class="nc" id="L2804">                    hexImage.setRGB(x, y, getNightDarkenedColor(hexImage.getRGB(x, y)));</span>
                }
            }
        }

        // Set the text color according to Preferences or Light Gray in space
<span class="nc" id="L2810">        g.setColor(guip.getMapTextColor());</span>
<span class="nc bnc" id="L2811" title="All 2 branches missed.">        if (game.getBoard().inSpace())</span>
<span class="nc" id="L2812">            g.setColor(Color.LIGHT_GRAY);</span>

        // draw special stuff for the hex
<span class="nc" id="L2815">        final Collection&lt;SpecialHexDisplay&gt; shdList = game.getBoard()</span>
<span class="nc" id="L2816">                .getSpecialHexDisplay(c);</span>
        try {
<span class="nc bnc" id="L2818" title="All 2 branches missed.">            if (shdList != null) {</span>
<span class="nc bnc" id="L2819" title="All 2 branches missed.">                for (SpecialHexDisplay shd : shdList) {</span>
<span class="nc bnc" id="L2820" title="All 2 branches missed.">                    if (shd.drawNow(game.getPhase(), game.getRoundCount(),</span>
                            localPlayer)) {
<span class="nc" id="L2822">                        scaledImage = getScaledImage(shd.getType()</span>
<span class="nc" id="L2823">                                .getDefaultImage(), true);</span>
<span class="nc" id="L2824">                        g.drawImage(scaledImage, 0, 0, this);</span>
                    }
<span class="nc" id="L2826">                }</span>
            }
<span class="nc" id="L2828">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L2829">            System.err.println(&quot;Illegal argument exception, probably &quot;</span>
                    + &quot;can't load file.&quot;);
<span class="nc" id="L2831">            e.printStackTrace();</span>
<span class="nc" id="L2832">            drawCenteredString(&quot;Loading Error&quot;, 0, 0</span>
                    + (int) (50 * scale), font_note, g);
<span class="nc" id="L2834">            return;</span>
<span class="nc" id="L2835">        }</span>

        // write hex coordinate unless deactivated or scale factor too small
<span class="nc bnc" id="L2838" title="All 4 branches missed.">        if (guip.getBoolean(GUIPreferences.ADVANCED_SHOW_COORDS)</span>
                &amp;&amp; (scale &gt;= 0.5)) {
<span class="nc" id="L2840">            drawCenteredString(c.getBoardNum(), 0, 0</span>
                    + (int) (12 * scale), font_hexnum, g);
        }

<span class="nc bnc" id="L2844" title="All 4 branches missed.">        if (getDisplayInvalidHexInfo() &amp;&amp; !hex.isValid(null)) {</span>
<span class="nc" id="L2845">            Point hexCenter = new Point((int)(HEX_W / 2 * scale), (int)(HEX_H / 2 * scale));</span>
<span class="nc" id="L2846">            drawCenteredText(g, Messages.getString(&quot;BoardEditor.INVALID&quot;), hexCenter, Color.RED, false,</span>
                    new Font(&quot;SansSerif&quot;, Font.BOLD, 14));
        }

        // write terrain level / water depth / building height
<span class="nc bnc" id="L2851" title="All 2 branches missed.">        if (scale &gt; 0.5f) {</span>
<span class="nc" id="L2852">            int ypos = HEX_H-2;</span>
<span class="nc bnc" id="L2853" title="All 2 branches missed.">            if (level != 0) {</span>
<span class="nc" id="L2854">                drawCenteredString(</span>
<span class="nc" id="L2855">                        Messages.getString(&quot;BoardView1.LEVEL&quot;) + level, //$NON-NLS-1$</span>
                        0, (int) (ypos * scale), font_elev, g);
<span class="nc" id="L2857">                ypos -= 10;</span>
            }
<span class="nc bnc" id="L2859" title="All 2 branches missed.">            if (depth != 0) {</span>
<span class="nc" id="L2860">                drawCenteredString(</span>
<span class="nc" id="L2861">                        Messages.getString(&quot;BoardView1.DEPTH&quot;) + depth, //$NON-NLS-1$</span>
                        0, (int) (ypos * scale), font_elev, g);
<span class="nc" id="L2863">                ypos -= 10;</span>
            }
<span class="nc bnc" id="L2865" title="All 2 branches missed.">            if (height &gt; 0) {</span>
<span class="nc" id="L2866">                g.setColor(GUIPreferences.getInstance().getColor(</span>
                        &quot;AdvancedBuildingTextColor&quot;));                 //$NON-NLS-1$
<span class="nc" id="L2868">                drawCenteredString(</span>
<span class="nc" id="L2869">                        Messages.getString(&quot;BoardView1.HEIGHT&quot;) + height, //$NON-NLS-1$</span>
                        0, (int) (ypos * scale), font_elev, g);
<span class="nc" id="L2871">                ypos -= 10;</span>
            }
<span class="nc bnc" id="L2873" title="All 2 branches missed.">            if (hex.terrainLevel(Terrains.FOLIAGE_ELEV) == 1) {</span>
<span class="nc" id="L2874">                g.setColor(GUIPreferences.getInstance().getColor(</span>
                        GUIPreferences.ADVANCED_LOW_FOLIAGE_COLOR));  
<span class="nc" id="L2876">                drawCenteredString(Messages.getString(&quot;BoardView1.LowFoliage&quot;), </span>
                        0, (int) (ypos * scale), font_elev, g);
<span class="nc" id="L2878">                ypos -= 10;</span>
            }
        }

        // Used to make the following draw calls shorter
<span class="nc" id="L2883">        int s21 = (int)(21*scale);</span>
<span class="nc" id="L2884">        int s71 = (int)(71*scale);</span>
<span class="nc" id="L2885">        int s35 = (int)(35*scale);</span>
<span class="nc" id="L2886">        int s36 = (int)(36*scale);</span>
<span class="nc" id="L2887">        int s62 = (int)(62*scale);</span>
<span class="nc" id="L2888">        int s83 = (int)(83*scale);</span>

<span class="nc" id="L2890">        Point p1 = new Point(s62, 0);</span>
<span class="nc" id="L2891">        Point p2 = new Point(s21, 0);</span>
<span class="nc" id="L2892">        Point p3 = new Point(s83, s35);</span>
<span class="nc" id="L2893">        Point p4 = new Point(s83, s36);</span>
<span class="nc" id="L2894">        Point p5 = new Point(s62, s71);</span>
<span class="nc" id="L2895">        Point p6 = new Point(s21, s71);</span>
<span class="nc" id="L2896">        Point p7 = new Point(0, s36);</span>
<span class="nc" id="L2897">        Point p8 = new Point(0, s35);</span>

<span class="nc" id="L2899">        g.setColor(Color.black);</span>
<span class="nc" id="L2900">        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,</span>
                1f));

        // draw elevation borders
<span class="nc bnc" id="L2904" title="All 2 branches missed.">        if (drawElevationLine(c, 0)) {</span>
<span class="nc" id="L2905">            drawIsometricElevation(c, Color.GRAY, p1, p2, 0, g);</span>
<span class="nc bnc" id="L2906" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2907">                g.drawLine(s21, 0, s62, 0);</span>
            }
        }

<span class="nc bnc" id="L2911" title="All 2 branches missed.">        if (drawElevationLine(c, 1)) {</span>
<span class="nc" id="L2912">            drawIsometricElevation(c, Color.DARK_GRAY, p3, p1, 1, g);</span>
<span class="nc bnc" id="L2913" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2914">                g.drawLine(s62, 0, s83, s35);</span>
            }
        }

<span class="nc bnc" id="L2918" title="All 2 branches missed.">        if (drawElevationLine(c, 2)) {</span>
<span class="nc" id="L2919">            drawIsometricElevation(c, Color.LIGHT_GRAY, p4, p5, 2, g);</span>
<span class="nc bnc" id="L2920" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2921">                g.drawLine(s83, s36, s62, s71);</span>
            }
        }

<span class="nc bnc" id="L2925" title="All 2 branches missed.">        if (drawElevationLine(c, 3)) {</span>
<span class="nc" id="L2926">            drawIsometricElevation(c, Color.GRAY, p6, p5, 3, g);</span>
<span class="nc bnc" id="L2927" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2928">                g.drawLine(s62, s71, s21, s71);</span>
            }
        }

<span class="nc bnc" id="L2932" title="All 2 branches missed.">        if (drawElevationLine(c, 4)) {</span>
<span class="nc" id="L2933">            drawIsometricElevation(c, Color.DARK_GRAY, p7, p6, 4, g);</span>
<span class="nc bnc" id="L2934" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2935">                g.drawLine(s21, s71, 0, s36);</span>
            }
        }

<span class="nc bnc" id="L2939" title="All 2 branches missed.">        if (drawElevationLine(c, 5)) {</span>
<span class="nc" id="L2940">            drawIsometricElevation(c, Color.LIGHT_GRAY, p8, p2, 5, g);</span>
<span class="nc bnc" id="L2941" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2942">                g.drawLine(0, s35, s21, 0);</span>
            }

        }

<span class="nc" id="L2947">        boolean hasLoS = fovHighlightingAndDarkening.draw(g, c, 0, 0,</span>
                saveBoardImage);

        // draw mapsheet borders
<span class="nc bnc" id="L2951" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getShowMapsheets()) {</span>
<span class="nc" id="L2952">            g.setColor(GUIPreferences.getInstance().getColor(</span>
                    GUIPreferences.ADVANCED_MAPSHEET_COLOR));
<span class="nc bnc" id="L2954" title="All 2 branches missed.">            if ((c.getX() % 16) == 0) {</span>
                // left edge of sheet (edge 4 &amp; 5)
<span class="nc" id="L2956">                g.drawLine(s21, s71, 0, s36);</span>
<span class="nc" id="L2957">                g.drawLine(0, s35, s21, 0);</span>
<span class="nc bnc" id="L2958" title="All 2 branches missed.">            } else if ((c.getX() % 16) == 15) {</span>
                // right edge of sheet (edge 1 &amp; 2)
<span class="nc" id="L2960">                g.drawLine(s62, 0, s83, s35);</span>
<span class="nc" id="L2961">                g.drawLine(s83, s36, s62, s71);</span>
            }
<span class="nc bnc" id="L2963" title="All 2 branches missed.">            if ((c.getY() % 17) == 0) {</span>
                // top edge of sheet (edge 0 and possible 1 &amp; 5)
<span class="nc" id="L2965">                g.drawLine(s21, 0, s62, 0);</span>
<span class="nc bnc" id="L2966" title="All 2 branches missed.">                if ((c.getX() % 2) == 0) {</span>
<span class="nc" id="L2967">                    g.drawLine(s62, 0, s83, s35);</span>
<span class="nc" id="L2968">                    g.drawLine(0, s35, s21, 0);</span>
                }
<span class="nc bnc" id="L2970" title="All 2 branches missed.">            } else if ((c.getY() % 17) == 16) {</span>
                // bottom edge of sheet (edge 3 and possible 2 &amp; 4)
<span class="nc" id="L2972">                g.drawLine(s62, s71, s21, s71);</span>
<span class="nc bnc" id="L2973" title="All 2 branches missed.">                if ((c.getX() % 2) == 1) {</span>
<span class="nc" id="L2974">                    g.drawLine(s83, s36, s62, s71);</span>
<span class="nc" id="L2975">                    g.drawLine(s21, s71, 0, s36);</span>
                }
            }
        }

<span class="nc bnc" id="L2980" title="All 4 branches missed.">        if (!hasLoS &amp;&amp; guip.getFovGrayscale()) {</span>
            // rework the pixels to grayscale
<span class="nc bnc" id="L2982" title="All 2 branches missed.">            for (int x = 0; x &lt; hexImage.getWidth(); ++x) {</span>
<span class="nc bnc" id="L2983" title="All 2 branches missed.">                for (int y = 0; y &lt; hexImage.getHeight(); ++y) {</span>
<span class="nc" id="L2984">                    int rgb = hexImage.getRGB(x, y);</span>
<span class="nc" id="L2985">                    int rd = (rgb &gt;&gt; 16) &amp; 0xFF;</span>
<span class="nc" id="L2986">                    int gr = (rgb &gt;&gt; 8) &amp; 0xFF;</span>
<span class="nc" id="L2987">                    int bl = (rgb &amp; 0xFF);</span>
<span class="nc" id="L2988">                    int al = (rgb &gt;&gt; 24);</span>

<span class="nc" id="L2990">                    int grayLevel = (rd + gr + bl) / 3;</span>
<span class="nc" id="L2991">                    int gray = (al &lt;&lt; 24) + (grayLevel &lt;&lt; 16) + (grayLevel &lt;&lt; 8) + grayLevel;</span>
<span class="nc" id="L2992">                    hexImage.setRGB(x, y, gray);</span>
                }
            }
        }

<span class="nc" id="L2997">        cacheEntry = new HexImageCacheEntry(hexImage);</span>
<span class="nc bnc" id="L2998" title="All 2 branches missed.">        if (!dontCache) {</span>
<span class="nc" id="L2999">            hexImageCache.put(c, cacheEntry);</span>
        }
<span class="nc" id="L3001">        boardGraph.drawImage(cacheEntry.hexImage, hexLoc.x, hexLoc.y, this);</span>
<span class="nc" id="L3002">    }</span>

    /**
     * Draws a orthographic hex onto the board buffer. This assumes that
     * drawRect is current, and does not check if the hex is visible.
     */
    private void drawOrthograph(Coords c, Graphics boardGraph) {
<span class="nc bnc" id="L3009" title="All 2 branches missed.">        if (!game.getBoard().contains(c)) {</span>
<span class="nc" id="L3010">            return;</span>
        }

<span class="nc" id="L3013">        final IHex oHex = game.getBoard().getHex(c);</span>
<span class="nc" id="L3014">        final Point oHexLoc = getHexLocation(c);</span>

        // We need to adjust the height based on several cases
<span class="nc" id="L3017">        int elevOffset = oHex.terrainLevel(Terrains.BRIDGE_ELEV);</span>

<span class="nc" id="L3019">        int orthX = oHexLoc.x;</span>
<span class="nc" id="L3020">        int orthY = oHexLoc.y - (int) (HEX_ELEV * scale * elevOffset);</span>
<span class="nc bnc" id="L3021" title="All 2 branches missed.">        if (!useIsometric()) {</span>
<span class="nc" id="L3022">            orthY = oHexLoc.y;</span>
        }
<span class="nc bnc" id="L3024" title="All 2 branches missed.">        if (tileManager.orthoFor(oHex) != null) {</span>
<span class="nc bnc" id="L3025" title="All 2 branches missed.">            for (Image image : tileManager.orthoFor(oHex)) {</span>
<span class="nc" id="L3026">                BufferedImage scaledImage = ImageUtil.createAcceleratedImage(getScaledImage(image, true));</span>

                // Darken the hex for night-time, if applicable
<span class="nc bnc" id="L3029" title="All 2 branches missed.">                if (GUIPreferences.getInstance().getBoolean(GUIPreferences.ADVANCED_DARKEN_MAP_AT_NIGHT)</span>
<span class="nc bnc" id="L3030" title="All 2 branches missed.">                        &amp;&amp; (game.isPositionIlluminated(c) == IGame.ILLUMINATED_NONE)</span>
<span class="nc bnc" id="L3031" title="All 2 branches missed.">                        &amp;&amp; (game.getPlanetaryConditions().getLight() &gt; PlanetaryConditions.L_DAY)) {</span>
<span class="nc bnc" id="L3032" title="All 2 branches missed.">                    for (int x = 0; x &lt; scaledImage.getWidth(null); ++x) {</span>
<span class="nc bnc" id="L3033" title="All 2 branches missed.">                        for (int y = 0; y &lt; scaledImage.getHeight(); ++y) {</span>
<span class="nc" id="L3034">                            scaledImage.setRGB(x, y, getNightDarkenedColor(scaledImage.getRGB(x, y)));</span>
                        }
                    }
                }

                // draw orthogonal
<span class="nc" id="L3040">                boardGraph.drawImage(scaledImage, orthX, orthY, this);</span>
<span class="nc" id="L3041">            }</span>
        }
<span class="nc" id="L3043">    }</span>

    final boolean useIsometric() {
<span class="nc" id="L3046">        return drawIsometric;</span>
    }

    /**
     * Draws the Isometric elevation for the hex at the given coordinates (c) on
     * the side indicated by the direction (dir). This method only draws a
     * triangle for the elevation, the companion triangle representing the
     * adjacent hex is also needed. The two triangles when drawn together make a
     * complete rectangle representing the complete elevated hex side.
     * &lt;p/&gt;
     * By drawing the elevated hex as two separate triangles we avoid clipping
     * problems with other hexes because the lower elevation is rendered before
     * the higher elevation. Thus any hexes that have a higher elevation than
     * the lower hex will overwrite the lower hex.
     * &lt;p/&gt;
     * The Triangle for each hex side is formed by points p1, p2, and p3. Where
     * p1 and p2 are the original hex edges, and p3 has the same X value as p1,
     * but the y value has been increased (or decreased) based on the difference
     * in elevation between the given hex and the adjacent hex.
     *
     * @param c          Coordinates of the source hex.
     * @param color      Color to use for the elevation polygons.
     * @param p1         The First point on the edge of the hex.
     * @param p2         The second point on the edge of the hex.
     * @param dir        The side of the hex to have the elevation drawn on.
     * @param g
     */
    private final void drawIsometricElevation(Coords c, Color color, Point p1,
            Point p2, int dir, Graphics g) {
<span class="nc" id="L3075">        final IHex dest = game.getBoard().getHexInDir(c, dir);</span>
<span class="nc" id="L3076">        final IHex src = game.getBoard().getHex(c);</span>

<span class="nc bnc" id="L3078" title="All 2 branches missed.">        if (!useIsometric() ||</span>
<span class="nc bnc" id="L3079" title="All 2 branches missed.">                GUIPreferences.getInstance().getBoolean(GUIPreferences.FLOATINGISO)) {</span>
<span class="nc" id="L3080">            return;</span>
        }

        // Pad polygon size slightly to avoid rounding errors from scale float.
<span class="nc" id="L3084">        int fudge = -1;</span>
<span class="nc bnc" id="L3085" title="All 6 branches missed.">        if ((dir == 2) || (dir == 4) || (dir == 3)) {</span>
<span class="nc" id="L3086">            fudge = 1;</span>
        }

<span class="nc" id="L3089">        final int elev = src.getLevel();</span>
        // If the Destination is null, draw the complete elevation side.
<span class="nc bnc" id="L3091" title="All 10 branches missed.">        if ((dest == null) &amp;&amp; (elev &gt; 0)</span>
            &amp;&amp; ((dir == 2) || (dir == 3) || (dir == 4))) {

            // Determine the depth of the edge that needs to be drawn.
<span class="nc" id="L3095">            int height = elev;</span>
<span class="nc" id="L3096">            IHex southHex = game.getBoard().getHexInDir(c, 3);</span>
<span class="nc bnc" id="L3097" title="All 4 branches missed.">            if ((dir != 3) &amp;&amp; (southHex != null)</span>
<span class="nc bnc" id="L3098" title="All 2 branches missed.">                &amp;&amp; (elev &gt; southHex.getLevel())) {</span>
<span class="nc" id="L3099">                height = elev - southHex.getLevel();</span>
            }
<span class="nc" id="L3101">            int scaledHeight = (int) (HEX_ELEV * scale * height);</span>

<span class="nc" id="L3103">            Polygon p = new Polygon(new int[] { p1.x, p2.x, p2.x, p1.x },</span>
                    new int[] { p1.y + fudge, p2.y + fudge,
                            p2.y + scaledHeight, p1.y + scaledHeight }, 4);
<span class="nc" id="L3106">            g.setColor(color);</span>
<span class="nc" id="L3107">            g.drawPolygon(p);</span>
<span class="nc" id="L3108">            g.fillPolygon(p);</span>

<span class="nc" id="L3110">            g.setColor(Color.BLACK);</span>
<span class="nc bnc" id="L3111" title="All 4 branches missed.">            if ((dir == 2) || (dir == 4)) {</span>
<span class="nc" id="L3112">                g.drawLine(p1.x, p1.y, p1.x, p1.y + scaledHeight);</span>
            }
<span class="nc" id="L3114">            return;</span>
<span class="nc bnc" id="L3115" title="All 2 branches missed.">        } else if (dest == null) {</span>
<span class="nc" id="L3116">            return;</span>
        }

<span class="nc" id="L3119">        int delta = elev - dest.getLevel();</span>
        // Don't draw the elevation if there is no exposed edge for the player
        // to see.
<span class="nc bnc" id="L3122" title="All 18 branches missed.">        if ((delta == 0)</span>
            || (((dir == 0) || (dir == 1) || (dir == 5)) &amp;&amp; (delta &gt; 0))
            || (((dir == 2) || (dir == 3) || (dir == 4)) &amp;&amp; (delta &lt; 0))) {
<span class="nc" id="L3125">            return;</span>
        }

<span class="nc bnc" id="L3128" title="All 2 branches missed.">        if (dir == 1) {</span>
            /*
            // Draw a little bit of shadow to improve the 3d isometric effect.
            Polygon shadow1 = new Polygon(new int[] { p1.x, p2.x,
                    p2.x - (int) (HEX_ELEV * scale) }, new int[] { p1.y, p2.y,
                    p2.y }, 3);
            if ((p2.x - (int) (HEX_ELEV * scale)) &lt; 0) {
                System.out.println(&quot;Negative X value!: &quot; + (p2.x - (int) (HEX_ELEV * scale)));
            }
            g.setColor(new Color(0, 0, 0, 0.4f));
            g.fillPolygon(shadow1);*/
            // not necessary with the shadowmap
            // people not using the shadowmap will probably not need this shadow either
        }

<span class="nc bnc" id="L3143" title="All 6 branches missed.">        if ((dir == 2) || (dir == 3) || (dir == 4)) {</span>
<span class="nc" id="L3144">            int scaledDelta = (int) (HEX_ELEV * scale * delta);</span>
<span class="nc" id="L3145">            Point p3 = new Point(p1.x, p1.y + scaledDelta + fudge);</span>

<span class="nc" id="L3147">            Polygon p = new Polygon(new int[] { p1.x, p2.x, p2.x, p1.x },</span>
                    new int[] { p1.y + fudge, p2.y + fudge,
                            p2.y + fudge + scaledDelta,
                            p1.y + fudge + scaledDelta }, 4);

<span class="nc bnc" id="L3152" title="All 2 branches missed.">            if ((p1.y + fudge) &lt; 0) {</span>
<span class="nc" id="L3153">                System.out.println(&quot;Negative Y value (Fudge)!: &quot; + (p1.y + fudge));</span>
            }
<span class="nc bnc" id="L3155" title="All 2 branches missed.">            if ((p2.y + fudge) &lt; 0) {</span>
<span class="nc" id="L3156">                System.out.println(&quot;Negative Y value (Fudge)!: &quot; + (p2.y + fudge));</span>
            }

<span class="nc bnc" id="L3159" title="All 2 branches missed.">            if ((p2.y + fudge + scaledDelta) &lt; 0) {</span>
<span class="nc" id="L3160">                System.out.println(&quot;Negative Y value!: &quot; + (p2.y + fudge + scaledDelta));</span>
            }
<span class="nc bnc" id="L3162" title="All 2 branches missed.">            if (( p1.y + fudge + scaledDelta) &lt; 0) {</span>
<span class="nc" id="L3163">                System.out.println(&quot;Negative Y value!: &quot; + ( p1.y + fudge + scaledDelta));</span>
            }
<span class="nc" id="L3165">            g.setColor(color);</span>
<span class="nc" id="L3166">            g.drawPolygon(p);</span>
<span class="nc" id="L3167">            g.fillPolygon(p);</span>

<span class="nc" id="L3169">            g.setColor(Color.BLACK);</span>
<span class="nc bnc" id="L3170" title="All 8 branches missed.">            if ((dir == 1) || (dir == 2) || (dir == 5) || (dir == 4)) {</span>
<span class="nc" id="L3171">                g.drawLine(p1.x, p1.y, p3.x, p3.y);</span>
            }
        }
<span class="nc" id="L3174">    }</span>

    /**
     * Returns true if an elevation line should be drawn between the starting
     * hex and the hex in the direction specified. Results should be transitive,
     * that is, if a line is drawn in one direction, it should be drawn in the
     * opposite direction as well.
     */
    private final boolean drawElevationLine(Coords src, int direction) {
<span class="nc" id="L3183">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L3184">        final IHex destHex = game.getBoard().getHexInDir(src, direction);</span>
<span class="nc bnc" id="L3185" title="All 4 branches missed.">        if ((destHex == null) &amp;&amp; (srcHex.getLevel() != 0)) {</span>
<span class="nc" id="L3186">            return true;</span>
<span class="nc bnc" id="L3187" title="All 2 branches missed.">        } else if (destHex == null) {</span>
<span class="nc" id="L3188">            return false;</span>
<span class="nc bnc" id="L3189" title="All 2 branches missed.">        } else if (srcHex.getLevel() != destHex.getLevel()) {</span>
<span class="nc" id="L3190">            return true;</span>
        } else {
<span class="nc bnc" id="L3192" title="All 2 branches missed.">            return (srcHex.floor() != destHex.floor());</span>
        }
    }

    /**
     * Given an int-packed RGB value, apply a modifier for the light level and return the result.
     *
     * @param rgb int-packed ARGB value.
     * @return An int-packed ARGB value, which is an adjusted value of the input, based on the light level
     */
    public int getNightDarkenedColor(int rgb) {
<span class="nc" id="L3203">        int rd = (rgb &gt;&gt; 16) &amp; 0xFF;</span>
<span class="nc" id="L3204">        int gr = (rgb &gt;&gt; 8) &amp; 0xFF;</span>
<span class="nc" id="L3205">        int bl = rgb &amp; 0xFF;</span>
<span class="nc" id="L3206">        int al = (rgb &gt;&gt; 24);</span>

<span class="nc bnc" id="L3208" title="All 5 branches missed.">        switch (game.getPlanetaryConditions().getLight()) {</span>
        case PlanetaryConditions.L_FULL_MOON:
<span class="nc" id="L3210">            rd = rd / 4; // 1/4 red</span>
<span class="nc" id="L3211">            gr = gr / 4; // 1/4 green</span>
<span class="nc" id="L3212">            bl = bl / 2; // half blue</span>
<span class="nc" id="L3213">            break;</span>
        case PlanetaryConditions.L_PITCH_BLACK:
<span class="nc" id="L3215">            int gy = (rd + gr + bl) / 16;</span>
<span class="nc bnc" id="L3216" title="All 2 branches missed.">            if (Math.random() &lt; 0.3) {</span>
<span class="nc" id="L3217">                gy = gy * 4 / 5;</span>
            }
<span class="nc bnc" id="L3219" title="All 2 branches missed.">            if (Math.random() &lt; 0.3) {</span>
<span class="nc" id="L3220">                gy = gy * 5 / 4;</span>
            }
<span class="nc" id="L3222">            rd = gy + rd / 5;</span>
<span class="nc" id="L3223">            gr = gy + gr / 5;</span>
<span class="nc" id="L3224">            bl = gy + bl / 5;</span>
<span class="nc" id="L3225">            break;</span>
        case PlanetaryConditions.L_MOONLESS:
<span class="nc" id="L3227">            rd = rd / 4;</span>
<span class="nc" id="L3228">            gr = gr / 4;</span>
<span class="nc" id="L3229">            bl = bl / 2;</span>
<span class="nc" id="L3230">            break;</span>
        case PlanetaryConditions.L_DUSK:
<span class="nc" id="L3232">            bl = bl * 3 / 4;</span>
<span class="nc" id="L3233">            break;</span>
        default:
        }

<span class="nc" id="L3237">        return (al &lt;&lt; 24) + (rd &lt;&lt; 16) + (gr &lt;&lt; 8) + bl;</span>
    }

    /**
     * Generates a Shape drawing area for the hex shadow effect in a lower hex
     * when a higher hex is found in direction.
     */
    private final Shape getElevationShadowArea(Coords src, int direction) {
<span class="nc" id="L3245">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L3246">        final IHex destHex = game.getBoard().getHexInDir(src, direction);</span>

        // When at the board edge, create a shadow in hexes of level &lt; 0
<span class="nc bnc" id="L3249" title="All 2 branches missed.">        if (destHex == null)</span>
        {
<span class="nc bnc" id="L3251" title="All 2 branches missed.">            if (srcHex.getLevel() &gt;= 0) return null;</span>
        }
        else
        {
            // no shadow area when the current hex is not lower than the next hex in direction
<span class="nc bnc" id="L3256" title="All 2 branches missed.">            if (srcHex.getLevel() &gt;= destHex.getLevel()) return null;</span>
<span class="nc bnc" id="L3257" title="All 2 branches missed.">            if (GUIPreferences.getInstance().getHexInclines()</span>
<span class="nc bnc" id="L3258" title="All 2 branches missed.">                    &amp;&amp; (destHex.getLevel() - srcHex.getLevel() &lt; 2)</span>
<span class="nc bnc" id="L3259" title="All 2 branches missed.">                    &amp;&amp; !destHex.hasCliffTopTowards(srcHex)) {</span>
<span class="nc" id="L3260">                return null;</span>
            }
        }

<span class="nc" id="L3264">        return(AffineTransform.getScaleInstance(scale, scale).createTransformedShape(</span>
<span class="nc" id="L3265">                HexDrawUtilities.getHexBorderArea(direction, HexDrawUtilities.CUT_BORDER, 36)));</span>
    }

    /**
     * Generates a fill gradient which is rotated and aligned properly for
     * the drawing area for a hex shadow effect in a lower hex.
     */
    private final GradientPaint getElevationShadowGP(Coords src, int direction) {
<span class="nc" id="L3273">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L3274">        final IHex destHex = game.getBoard().getHexInDir(src, direction);</span>

<span class="nc bnc" id="L3276" title="All 2 branches missed.">        if (destHex == null) return null;</span>

<span class="nc" id="L3278">        int ldiff = destHex.getLevel()-srcHex.getLevel();</span>
        // the shadow strength depends on the level difference,
        // but only to a maximum difference of 3 levels
<span class="nc" id="L3281">        ldiff = Math.min(ldiff*5,15);</span>

<span class="nc" id="L3283">        Color c1 = new Color(30,30,50,255); // dark end of shadow</span>
<span class="nc" id="L3284">        Color c2 = new Color(50,50,70,0);   // light end of shadow</span>

<span class="nc" id="L3286">        Point2D p1 = new Point2D.Double(41.5,-25+ldiff);</span>
<span class="nc" id="L3287">        Point2D p2 = new Point2D.Double(41.5,8.0+ldiff);</span>

<span class="nc" id="L3289">        AffineTransform t = new AffineTransform();</span>
<span class="nc" id="L3290">        t.scale(scale,scale);</span>
<span class="nc" id="L3291">        t.rotate(Math.toRadians(direction*60),41.5,35.5);</span>
<span class="nc" id="L3292">        t.transform(p1,p1);</span>
<span class="nc" id="L3293">        t.transform(p2,p2);</span>

<span class="nc" id="L3295">        return(new GradientPaint(p1,c1,p2,c2));</span>
    }

    /**
     * Returns the absolute position of the upper-left hand corner of the hex
     * graphic
     */
    private Point getHexLocation(int x, int y, boolean ignoreElevation) {
<span class="nc" id="L3303">        float elevationAdjust = 0.0f;</span>

<span class="nc" id="L3305">        IHex hex = game.getBoard().getHex(x, y);</span>
<span class="nc bnc" id="L3306" title="All 6 branches missed.">        if ((hex != null) &amp;&amp; useIsometric() &amp;&amp; !ignoreElevation) {</span>
<span class="nc" id="L3307">            elevationAdjust = hex.getLevel() * HEX_ELEV * scale * -1.0f;</span>
        }
<span class="nc" id="L3309">        int ypos = (y * (int) (HEX_H * scale))</span>
<span class="nc bnc" id="L3310" title="All 2 branches missed.">                   + ((x &amp; 1) == 1 ? (int) ((HEX_H / 2) * scale) : 0);</span>
<span class="nc" id="L3311">        return new Point(x * (int) (HEX_WC * scale), ypos + (int) elevationAdjust);</span>
    }

    /**
     * For large tile texture: Returns the absolute position of the upper-left
     * hand corner of the hex graphic When using large tiles multiplying the
     * rounding errors from the (int) cast must be avoided however this cannot
     * be used for small tiles as it will make gaps appear between hexes This
     * will not factor in Isometric as this would be incorrect for large tiles
     */
    private Point getHexLocationLargeTile(int x, int y, float tscale) {
<span class="nc" id="L3322">        int ypos = (int) (y * HEX_H * tscale)</span>
<span class="nc bnc" id="L3323" title="All 2 branches missed.">                + ((x &amp; 1) == 1 ? (int) ((HEX_H / 2) * tscale) : 0);</span>
<span class="nc" id="L3324">        return new Point((int) (x * HEX_WC * tscale), ypos);</span>
    }

    private Point getHexLocationLargeTile(int x, int y) {
<span class="nc" id="L3328">        return getHexLocationLargeTile(x, y, scale);</span>
    }

    Point getHexLocation(Coords c) {
<span class="nc" id="L3332">        return getHexLocation(c.getX(), c.getY(), false);</span>
    }

     /**
     * Returns the absolute position of the centre of the hex graphic
     */
    private Point getCentreHexLocation(int x, int y, boolean ignoreElevation) {
<span class="nc" id="L3339">        Point p = getHexLocation(x, y, ignoreElevation);</span>
<span class="nc" id="L3340">        p.x += ((HEX_W / 2) * scale);</span>
<span class="nc" id="L3341">        p.y += ((HEX_H / 2) * scale);</span>
<span class="nc" id="L3342">        return p;</span>
    }

    public Point getCentreHexLocation(Coords c) {
<span class="nc" id="L3346">        return getCentreHexLocation(c.getX(), c.getY(), false);</span>
    }

    public Point getCentreHexLocation(Coords c, boolean ignoreElevation) {
<span class="nc" id="L3350">        return getCentreHexLocation(c.getX(), c.getY(), ignoreElevation);</span>
    }

    public void drawRuler(Coords s, Coords e, Color sc, Color ec) {
<span class="nc" id="L3354">        rulerStart = s;</span>
<span class="nc" id="L3355">        rulerEnd = e;</span>
<span class="nc" id="L3356">        rulerStartColor = sc;</span>
<span class="nc" id="L3357">        rulerEndColor = ec;</span>

<span class="nc" id="L3359">        repaint();</span>
<span class="nc" id="L3360">    }</span>

    /**
     * Returns the coords at the specified point
     */
    Coords getCoordsAt(Point p) {
        // We must account for the board translation to add padding
<span class="nc" id="L3367">        p.x -= HEX_W;</span>
<span class="nc" id="L3368">        p.y -= HEX_H;</span>

        // base values
<span class="nc" id="L3371">        int x = p.x / (int) (HEX_WC * scale);</span>
<span class="nc" id="L3372">        int y = p.y / (int) (HEX_H * scale);</span>
        // correction for the displaced odd columns
<span class="nc bnc" id="L3374" title="All 2 branches missed.">        if ((float) p.y / (scale * HEX_H) - y &lt; 0.5)</span>
<span class="nc" id="L3375">            y -= x % 2;</span>

        // check the surrounding hexes if they contain p
        // checking at most 3 hexes would be sufficient
        // but which ones? This is failsafer.
<span class="nc" id="L3380">        Coords cc = new Coords(x, y);</span>
<span class="nc bnc" id="L3381" title="All 2 branches missed.">        if (!HexDrawUtilities.getHexFull(getHexLocation(cc),scale).contains(p)) {</span>
<span class="nc" id="L3382">            boolean hasMatch = false;</span>
<span class="nc bnc" id="L3383" title="All 4 branches missed.">            for (int dir = 0; dir &lt; 6 &amp;&amp; !hasMatch; dir++) {</span>
<span class="nc" id="L3384">                Coords cn = cc.translated(dir);</span>
<span class="nc bnc" id="L3385" title="All 2 branches missed.">                if (HexDrawUtilities.getHexFull(getHexLocation(cn),scale).contains(p)) {</span>
<span class="nc" id="L3386">                    cc = cn;</span>
<span class="nc" id="L3387">                    hasMatch = true;</span>
                }
            }
        }

<span class="nc bnc" id="L3392" title="All 2 branches missed.">        if (useIsometric()) {</span>
            // When using isometric rendering, a lower hex can obscure the
            // normal hex. Iterate over all hexes from highest to lowest,
            // looking for a hex that contains the selected mouse click point.
<span class="nc" id="L3396">            final int minElev = Math.min(0, game.getBoard().getMinElevation());</span>
<span class="nc" id="L3397">            final int maxElev = Math.max(0, game.getBoard().getMaxElevation());</span>
<span class="nc" id="L3398">            final int delta = (int) Math</span>
<span class="nc" id="L3399">                    .ceil(((double) maxElev - minElev) / 3.0f);</span>
<span class="nc" id="L3400">            final int minHexSpan = Math.max(y - delta, 0);</span>
<span class="nc" id="L3401">            final int maxHexSpan = Math.min(y + delta, game.getBoard()</span>
<span class="nc" id="L3402">                                                           .getHeight());</span>
<span class="nc bnc" id="L3403" title="All 2 branches missed.">            for (int elev = maxElev; elev &gt;= minElev; elev--) {</span>
<span class="nc bnc" id="L3404" title="All 2 branches missed.">                for (int i = minHexSpan; i &lt;= maxHexSpan; i++) {</span>
<span class="nc bnc" id="L3405" title="All 2 branches missed.">                    for (int dx = -1; dx &lt; 2; dx++) {</span>
<span class="nc" id="L3406">                        Coords c1 = new Coords(x + dx, i);</span>
<span class="nc" id="L3407">                        IHex hexAlt = game.getBoard().getHex(c1);</span>
<span class="nc bnc" id="L3408" title="All 4 branches missed.">                        if (HexDrawUtilities.getHexFull(getHexLocation(c1),scale).contains(p)</span>
                                &amp;&amp; (hexAlt != null)
<span class="nc bnc" id="L3410" title="All 2 branches missed.">                                &amp;&amp; (hexAlt.getLevel() == elev)) {</span>
                            // Return immediately with highest hex found.
<span class="nc" id="L3412">                            return c1;</span>
                        }
                    }
                }
            }
            // nothing found
<span class="nc" id="L3418">            return new Coords(-1,-1);</span>
        }
        else {
            // not Isometric
<span class="nc" id="L3422">            return cc;</span>
        }
    }

    public void redrawMovingEntity(Entity entity, Coords position, int facing,
            int elevation) {
<span class="nc" id="L3428">        Integer entityId = Integer.valueOf(entity.getId());</span>
<span class="nc" id="L3429">        List&lt;Integer&gt; spriteKey = getIdAndLoc(entityId, -1);</span>
<span class="nc" id="L3430">        EntitySprite sprite = entitySpriteIds.get(spriteKey);</span>
<span class="nc" id="L3431">        IsometricSprite isoSprite = isometricSpriteIds.get(spriteKey);</span>
        // We can ignore secondary locations for now, as we don't have moving
        // multi-location entitys (will need to change for mobile structures)

        PriorityQueue&lt;EntitySprite&gt; newSprites;
        PriorityQueue&lt;IsometricSprite&gt; isoSprites;
        HashMap&lt;List&lt;Integer&gt;, EntitySprite&gt; newSpriteIds;
        HashMap&lt;List&lt;Integer&gt;, IsometricSprite&gt; newIsoSpriteIds;

        // Remove sprite for Entity, so it's not displayed while moving
<span class="nc bnc" id="L3441" title="All 2 branches missed.">        if (sprite != null) {</span>
<span class="nc" id="L3442">            newSprites = new PriorityQueue&lt;EntitySprite&gt;(entitySprites);</span>
<span class="nc" id="L3443">            newSpriteIds = new HashMap&lt;&gt;(entitySpriteIds);</span>

<span class="nc" id="L3445">            newSprites.remove(sprite);</span>
<span class="nc" id="L3446">            newSpriteIds.remove(spriteKey);</span>

<span class="nc" id="L3448">            entitySprites = newSprites;</span>
<span class="nc" id="L3449">            entitySpriteIds = newSpriteIds;</span>
        }
        // Remove iso sprite for Entity, so it's not displayed while moving
<span class="nc bnc" id="L3452" title="All 2 branches missed.">        if (isoSprite != null) {</span>
<span class="nc" id="L3453">            isoSprites = new PriorityQueue&lt;IsometricSprite&gt;(isometricSprites);</span>
<span class="nc" id="L3454">            newIsoSpriteIds = new HashMap&lt;&gt;(isometricSpriteIds);</span>

<span class="nc" id="L3456">            isoSprites.remove(isoSprite);</span>
<span class="nc" id="L3457">            newIsoSpriteIds.remove(spriteKey);</span>

<span class="nc" id="L3459">            isometricSprites = isoSprites;</span>
<span class="nc" id="L3460">            isometricSpriteIds = newIsoSpriteIds;</span>
        }

<span class="nc" id="L3463">        MovingEntitySprite mSprite = movingEntitySpriteIds.get(entityId);</span>
<span class="nc" id="L3464">        List&lt;MovingEntitySprite&gt; newMovingSprites = new ArrayList&lt;&gt;(</span>
                movingEntitySprites);
<span class="nc" id="L3466">        HashMap&lt;Integer, MovingEntitySprite&gt; newMovingSpriteIds = new HashMap&lt;&gt;(</span>
                movingEntitySpriteIds);
        // Remove any old movement sprite
<span class="nc bnc" id="L3469" title="All 2 branches missed.">        if (mSprite != null) {</span>
<span class="nc" id="L3470">            newMovingSprites.remove(mSprite);</span>
        }
        // Create new movement sprite
<span class="nc bnc" id="L3473" title="All 2 branches missed.">        if (entity.getPosition() != null) {</span>
<span class="nc" id="L3474">            mSprite = new MovingEntitySprite(this, entity, position, facing,</span>
                    elevation);
<span class="nc" id="L3476">            newMovingSprites.add(mSprite);</span>
<span class="nc" id="L3477">            newMovingSpriteIds.put(entityId, mSprite);</span>
        }

<span class="nc" id="L3480">        movingEntitySprites = newMovingSprites;</span>
<span class="nc" id="L3481">        movingEntitySpriteIds = newMovingSpriteIds;</span>
<span class="nc" id="L3482">    }</span>

    public boolean isMovingUnits() {
<span class="nc bnc" id="L3485" title="All 2 branches missed.">        return movingUnits.size() &gt; 0;</span>
    }

    /**
     * Clears the sprite for an entity and prepares it to be re-drawn. Replaces
     * the old sprite with the new! Try to prevent annoying
     * ConcurrentModificationExceptions
     */
    public void redrawEntity(Entity entity) {
<span class="nc" id="L3494">        redrawEntity(entity, null);</span>
<span class="nc" id="L3495">    }</span>

    /**
     * Convenience method for returning a Key value for the entitySpriteIds and
     * isometricSprite maps. The List contains as the first element the Entity
     * ID and as the second element it's location ID: either -1 if the Entity
     * has no secondary locations, or the index of its secondary location.
     *
     * @param entityId
     *            The Entity ID
     * @param secondaryLoc
     *            the secondary loc index, or -1 for Entitys without secondary
     *            positions
     * @return
     */
    private List&lt;Integer&gt; getIdAndLoc(Integer entityId, int secondaryLoc) {
<span class="nc" id="L3511">        List&lt;Integer&gt; idLoc = new ArrayList&lt;Integer&gt;(2);</span>
<span class="nc" id="L3512">        idLoc.add(entityId);</span>
<span class="nc" id="L3513">        idLoc.add(secondaryLoc);</span>
<span class="nc" id="L3514">        return idLoc;</span>
    }

    /**
     * Clears the sprite for an entity and prepares it to be re-drawn. Replaces
     * the old sprite with the new! Takes a reference to the Entity object
     * before changes, in case it contained important state information, like
     * Dropships taking off (airborne dropships lose their secondary hexes). Try
     * to prevent annoying ConcurrentModificationExceptions
     */
    public void redrawEntity(Entity entity, Entity oldEntity) {
<span class="nc" id="L3525">        Integer entityId = Integer.valueOf(entity.getId());</span>
<span class="nc bnc" id="L3526" title="All 2 branches missed.">        if (oldEntity == null) {</span>
<span class="nc" id="L3527">            oldEntity = entity;</span>
        }

        // If the entity we are updating doesn't have a position, ensure we
        // remove all of its old sprites
<span class="nc bnc" id="L3532" title="All 2 branches missed.">        if (entity.getPosition() == null) {</span>
            Iterator&lt;EntitySprite&gt; spriteIter;

            // Remove Entity Sprites
<span class="nc" id="L3536">            spriteIter = entitySprites.iterator();</span>
<span class="nc bnc" id="L3537" title="All 2 branches missed.">            while (spriteIter.hasNext()) {</span>
<span class="nc" id="L3538">                EntitySprite sprite = spriteIter.next();</span>
<span class="nc bnc" id="L3539" title="All 2 branches missed.">                if (sprite.entity.equals(entity)) {</span>
<span class="nc" id="L3540">                    spriteIter.remove();</span>
                }
<span class="nc" id="L3542">            }</span>

            //  Update ID -&gt; Sprite map
<span class="nc" id="L3545">            spriteIter = entitySpriteIds.values().iterator();</span>
<span class="nc bnc" id="L3546" title="All 2 branches missed.">            while (spriteIter.hasNext()) {</span>
<span class="nc" id="L3547">                EntitySprite sprite = spriteIter.next();</span>
<span class="nc bnc" id="L3548" title="All 2 branches missed.">                if (sprite.entity.equals(entity)) {</span>
<span class="nc" id="L3549">                    spriteIter.remove();</span>
                }
<span class="nc" id="L3551">            }</span>

            Iterator&lt;IsometricSprite&gt; isoSpriteIter;

            // Remove IsometricSprites
<span class="nc" id="L3556">            isoSpriteIter = isometricSprites.iterator();</span>
<span class="nc bnc" id="L3557" title="All 2 branches missed.">            while (isoSpriteIter.hasNext()) {</span>
<span class="nc" id="L3558">                IsometricSprite sprite = isoSpriteIter.next();</span>
<span class="nc bnc" id="L3559" title="All 2 branches missed.">                if (sprite.entity.equals(entity)) {</span>
<span class="nc" id="L3560">                    isoSpriteIter.remove();</span>
                }
<span class="nc" id="L3562">            }</span>

            // Update ID -&gt; Iso Sprite Map
<span class="nc" id="L3565">            isoSpriteIter  = isometricSpriteIds.values().iterator();</span>
<span class="nc bnc" id="L3566" title="All 2 branches missed.">            while (isoSpriteIter.hasNext()) {</span>
<span class="nc" id="L3567">                IsometricSprite sprite = isoSpriteIter.next();</span>
<span class="nc bnc" id="L3568" title="All 2 branches missed.">                if (sprite.entity.equals(entity)) {</span>
<span class="nc" id="L3569">                    isoSpriteIter.remove();</span>
                }
<span class="nc" id="L3571">            }</span>
        }

        // Create a copy of the sprite list
<span class="nc" id="L3575">        Queue&lt;EntitySprite&gt; newSprites = new PriorityQueue&lt;&gt;(entitySprites);</span>
<span class="nc" id="L3576">        HashMap&lt;List&lt;Integer&gt;, EntitySprite&gt; newSpriteIds =</span>
                new HashMap&lt;&gt;(entitySpriteIds);
<span class="nc" id="L3578">        Queue&lt;IsometricSprite&gt; isoSprites = new PriorityQueue&lt;&gt;(</span>
                isometricSprites);
<span class="nc" id="L3580">        HashMap&lt;List&lt;Integer&gt;, IsometricSprite&gt; newIsoSpriteIds =</span>
                new HashMap&lt;&gt;(isometricSpriteIds);

        // Remove the sprites we are going to update
<span class="nc" id="L3584">        EntitySprite sprite = entitySpriteIds.get(getIdAndLoc(entityId, -1));</span>
<span class="nc" id="L3585">        IsometricSprite isoSprite = isometricSpriteIds.get(getIdAndLoc(</span>
                entityId, -1));
<span class="nc bnc" id="L3587" title="All 2 branches missed.">        if (sprite != null) {</span>
<span class="nc" id="L3588">            newSprites.remove(sprite);</span>
        }
<span class="nc bnc" id="L3590" title="All 2 branches missed.">        if (isoSprite != null) {</span>
<span class="nc" id="L3591">            isoSprites.remove(isoSprite);</span>
        }
<span class="nc bnc" id="L3593" title="All 2 branches missed.">        for (int secondaryPos : oldEntity.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3594">            sprite = entitySpriteIds.get(getIdAndLoc(entityId, secondaryPos));</span>
<span class="nc bnc" id="L3595" title="All 2 branches missed.">            if (sprite != null) {</span>
<span class="nc" id="L3596">                newSprites.remove(sprite);</span>
            }
<span class="nc" id="L3598">            isoSprite = isometricSpriteIds.get(getIdAndLoc(entityId,</span>
                    secondaryPos));
<span class="nc bnc" id="L3600" title="All 2 branches missed.">            if (isoSprite != null) {</span>
<span class="nc" id="L3601">                isoSprites.remove(isoSprite);</span>
            }
<span class="nc" id="L3603">        }</span>

        // Create the new sprites
<span class="nc" id="L3606">        Coords position = entity.getPosition();</span>
<span class="nc" id="L3607">        boolean canSee = EntityVisibilityUtils.detectedOrHasVisual(localPlayer, game, entity);</span>

<span class="nc bnc" id="L3609" title="All 4 branches missed.">        if ((position != null) &amp;&amp; canSee) {</span>
            // Add new EntitySprite
            // If no secondary positions, add a sprite for the central position
<span class="nc bnc" id="L3612" title="All 2 branches missed.">            if (entity.getSecondaryPositions().isEmpty()) {</span>
<span class="nc" id="L3613">                sprite = new EntitySprite(this, entity, -1, radarBlipImage);</span>
<span class="nc" id="L3614">                newSprites.add(sprite);</span>
<span class="nc" id="L3615">                newSpriteIds.put(getIdAndLoc(entityId, -1), sprite);</span>
            } else { // Add all secondary position sprites, which includes a
                // sprite for the central hex
<span class="nc bnc" id="L3618" title="All 2 branches missed.">                for (int secondaryPos : entity.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3619">                    sprite = new EntitySprite(this, entity, secondaryPos,</span>
                            radarBlipImage);
<span class="nc" id="L3621">                    newSprites.add(sprite);</span>
<span class="nc" id="L3622">                    newSpriteIds.put(getIdAndLoc(entityId, secondaryPos),</span>
                            sprite);
<span class="nc" id="L3624">                }</span>
            }

            // Add new IsometricSprite
            // If no secondary positions, add a sprite for the central position
<span class="nc bnc" id="L3629" title="All 2 branches missed.">            if (entity.getSecondaryPositions().isEmpty()) {</span>
<span class="nc" id="L3630">                isoSprite = new IsometricSprite(this, entity, -1,</span>
                        radarBlipImage);
<span class="nc" id="L3632">                isoSprites.add(isoSprite);</span>
<span class="nc" id="L3633">                newIsoSpriteIds.put(getIdAndLoc(entityId, -1), isoSprite);</span>
            } else { // Add all secondary position sprites, which includes a
                // sprite for the central hex
<span class="nc bnc" id="L3636" title="All 2 branches missed.">                for (int secondaryPos : entity.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3637">                    isoSprite = new IsometricSprite(this, entity, secondaryPos,</span>
                            radarBlipImage);
<span class="nc" id="L3639">                    isoSprites.add(isoSprite);</span>
<span class="nc" id="L3640">                    newIsoSpriteIds.put(getIdAndLoc(entityId, secondaryPos),</span>
                            isoSprite);
<span class="nc" id="L3642">                }</span>
            }
        }

        // Update Sprite state with new collections
<span class="nc" id="L3647">        entitySprites = newSprites;</span>
<span class="nc" id="L3648">        entitySpriteIds = newSpriteIds;</span>
<span class="nc" id="L3649">        isometricSprites = isoSprites;</span>
<span class="nc" id="L3650">        isometricSpriteIds = newIsoSpriteIds;</span>

        // Remove C3 sprites
<span class="nc bnc" id="L3653" title="All 2 branches missed.">        for (Iterator&lt;C3Sprite&gt; i = c3Sprites.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L3654">            final C3Sprite c3sprite = i.next();</span>
<span class="nc bnc" id="L3655" title="All 2 branches missed.">            if ((c3sprite.entityId == entity.getId())</span>
<span class="nc bnc" id="L3656" title="All 2 branches missed.">                || (c3sprite.masterId == entity.getId())) {</span>
<span class="nc" id="L3657">                i.remove();</span>
            }
<span class="nc" id="L3659">        }</span>

        // Update C3 link, if necessary
<span class="nc bnc" id="L3662" title="All 8 branches missed.">        if (entity.hasC3() || entity.hasC3i() || entity.hasActiveNovaCEWS() || entity.hasNavalC3()) {</span>
<span class="nc" id="L3663">            addC3Link(entity);</span>
        }

<span class="nc bnc" id="L3666" title="All 2 branches missed.">        for (Iterator&lt;VTOLAttackSprite&gt; iter = vtolAttackSprites.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L3667">            final VTOLAttackSprite s = iter.next();</span>
<span class="nc bnc" id="L3668" title="All 2 branches missed.">            if (s.getEntity().getId() == entity.getId()) {</span>
<span class="nc" id="L3669">                iter.remove();</span>
            }
<span class="nc" id="L3671">        }</span>

        // Remove Flyover Sprites
<span class="nc" id="L3674">        Iterator&lt;FlyOverSprite&gt; flyOverIt = flyOverSprites.iterator();</span>
<span class="nc bnc" id="L3675" title="All 2 branches missed.">        while (flyOverIt.hasNext()) {</span>
<span class="nc" id="L3676">            final FlyOverSprite flyOverSprite = flyOverIt.next();</span>
<span class="nc bnc" id="L3677" title="All 2 branches missed.">            if (flyOverSprite.getEntityId() == entity.getId()) {</span>
<span class="nc" id="L3678">                flyOverIt.remove();</span>
            }
<span class="nc" id="L3680">        }</span>

        // Add Flyover path, if necessary
<span class="nc bnc" id="L3683" title="All 4 branches missed.">        if ((entity.isAirborne() || entity.isMakingVTOLGroundAttack())</span>
<span class="nc bnc" id="L3684" title="All 2 branches missed.">                &amp;&amp; (entity.getPassedThrough().size() &gt; 1)) {</span>
<span class="nc" id="L3685">            addFlyOverPath(entity);</span>
        }

<span class="nc" id="L3688">        updateEcmList();</span>
<span class="nc" id="L3689">        highlightSelectedEntity();</span>
<span class="nc" id="L3690">        scheduleRedraw();</span>
<span class="nc" id="L3691">    }</span>

    /**
     * Clears all old entity sprites out of memory and sets up new ones.
     */
    void redrawAllEntities() {
<span class="nc" id="L3697">        int numEntities = game.getNoOfEntities();</span>
        // Prevent IllegalArgumentException
<span class="nc" id="L3699">        numEntities = Math.max(1, numEntities);</span>
<span class="nc" id="L3700">        Queue&lt;EntitySprite&gt; newSprites = new PriorityQueue&lt;EntitySprite&gt;(</span>
                numEntities);
<span class="nc" id="L3702">        Queue&lt;IsometricSprite&gt; newIsometricSprites = new PriorityQueue&lt;&gt;(</span>
                numEntities);
<span class="nc" id="L3704">        Map&lt;List&lt;Integer&gt;, EntitySprite&gt; newSpriteIds = new HashMap&lt;&gt;(</span>
                numEntities);
<span class="nc" id="L3706">        Map&lt;List&lt;Integer&gt;, IsometricSprite&gt; newIsoSpriteIds = new HashMap&lt;&gt;(</span>
                numEntities);

<span class="nc" id="L3709">        ArrayList&lt;WreckSprite&gt; newWrecks = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3710">        ArrayList&lt;IsometricWreckSprite&gt; newIsometricWrecks = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L3712">        Enumeration&lt;Entity&gt; e = game.getWreckedEntities();</span>
<span class="nc bnc" id="L3713" title="All 2 branches missed.">        while (e.hasMoreElements()) {</span>
<span class="nc" id="L3714">            Entity entity = e.nextElement();</span>
<span class="nc bnc" id="L3715" title="All 4 branches missed.">            if (!(entity instanceof Infantry) &amp;&amp; (entity.getPosition() != null)) {</span>
                WreckSprite ws;
                IsometricWreckSprite iws;
<span class="nc bnc" id="L3718" title="All 2 branches missed.">                if (entity.getSecondaryPositions().isEmpty()) {</span>
<span class="nc" id="L3719">                    ws = new WreckSprite(this, entity, -1);</span>
<span class="nc" id="L3720">                    newWrecks.add(ws);</span>
<span class="nc" id="L3721">                    iws = new IsometricWreckSprite(this, entity, -1);</span>
<span class="nc" id="L3722">                    newIsometricWrecks.add(iws);</span>
                } else {
<span class="nc bnc" id="L3724" title="All 2 branches missed.">                    for (int secondaryPos : entity.getSecondaryPositions()</span>
<span class="nc" id="L3725">                            .keySet()) {</span>
<span class="nc" id="L3726">                        ws = new WreckSprite(this, entity, secondaryPos);</span>
<span class="nc" id="L3727">                        newWrecks.add(ws);</span>
<span class="nc" id="L3728">                        iws = new IsometricWreckSprite(this, entity,</span>
                                secondaryPos);
<span class="nc" id="L3730">                        newIsometricWrecks.add(iws);</span>
<span class="nc" id="L3731">                    }</span>
                }
            }
<span class="nc" id="L3734">        }</span>

<span class="nc" id="L3736">        clearC3Networks();</span>
<span class="nc" id="L3737">        clearFlyOverPaths();</span>
<span class="nc bnc" id="L3738" title="All 2 branches missed.">        for (Entity entity : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L3739" title="All 2 branches missed.">            if (entity.getPosition() == null) {</span>
<span class="nc" id="L3740">                continue;</span>
            }
<span class="nc bnc" id="L3742" title="All 2 branches missed.">            if ((localPlayer != null)</span>
<span class="nc bnc" id="L3743" title="All 2 branches missed.">                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L3744" title="All 2 branches missed.">                &amp;&amp; entity.getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L3745" title="All 2 branches missed.">                &amp;&amp; !entity.hasSeenEntity(localPlayer)</span>
<span class="nc bnc" id="L3746" title="All 2 branches missed.">                &amp;&amp; !entity.hasDetectedEntity(localPlayer)) {</span>
<span class="nc" id="L3747">                continue;</span>
            }
<span class="nc bnc" id="L3749" title="All 2 branches missed.">            if ((localPlayer != null)</span>
<span class="nc bnc" id="L3750" title="All 2 branches missed.">                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)</span>
<span class="nc bnc" id="L3751" title="All 2 branches missed.">                    &amp;&amp; entity.getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L3752" title="All 2 branches missed.">                    &amp;&amp; entity.isHidden()) {</span>
<span class="nc" id="L3753">                continue;</span>
            }
<span class="nc bnc" id="L3755" title="All 2 branches missed.">            if (entity.getSecondaryPositions().isEmpty()) {</span>
<span class="nc" id="L3756">                EntitySprite sprite = new EntitySprite(this, entity, -1,</span>
                        radarBlipImage);
<span class="nc" id="L3758">                newSprites.add(sprite);</span>
<span class="nc" id="L3759">                newSpriteIds.put(getIdAndLoc(entity.getId(), -1), sprite);</span>
<span class="nc" id="L3760">                IsometricSprite isosprite = new IsometricSprite(this, entity,</span>
                        -1, radarBlipImage);
<span class="nc" id="L3762">                newIsometricSprites.add(isosprite);</span>
<span class="nc" id="L3763">                newIsoSpriteIds.put(getIdAndLoc(entity.getId(), -1), isosprite);</span>
<span class="nc" id="L3764">            } else {</span>
<span class="nc bnc" id="L3765" title="All 2 branches missed.">                for (int secondaryPos : entity.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3766">                    EntitySprite sprite = new EntitySprite(this, entity,</span>
                            secondaryPos, radarBlipImage);
<span class="nc" id="L3768">                    newSprites.add(sprite);</span>
<span class="nc" id="L3769">                    newSpriteIds.put(getIdAndLoc(entity.getId(), secondaryPos),</span>
                            sprite);

<span class="nc" id="L3772">                    IsometricSprite isosprite = new IsometricSprite(this,</span>
                            entity, secondaryPos, radarBlipImage);
<span class="nc" id="L3774">                    newIsometricSprites.add(isosprite);</span>
<span class="nc" id="L3775">                    newIsoSpriteIds.put(</span>
<span class="nc" id="L3776">                            getIdAndLoc(entity.getId(), secondaryPos),</span>
                            isosprite);
<span class="nc" id="L3778">                }</span>
            }

<span class="nc bnc" id="L3781" title="All 8 branches missed.">            if (entity.hasC3() || entity.hasC3i() || entity.hasActiveNovaCEWS() || entity.hasNavalC3()) {</span>
<span class="nc" id="L3782">                addC3Link(entity);</span>
            }

<span class="nc bnc" id="L3785" title="All 4 branches missed.">            if ((entity.isAirborne() || entity.isMakingVTOLGroundAttack())</span>
<span class="nc bnc" id="L3786" title="All 2 branches missed.">                    &amp;&amp; (entity.getPassedThrough().size() &gt; 1)) {</span>
<span class="nc" id="L3787">                addFlyOverPath(entity);</span>
            }
<span class="nc" id="L3789">        }</span>

<span class="nc" id="L3791">        entitySprites = newSprites;</span>
<span class="nc" id="L3792">        entitySpriteIds = newSpriteIds;</span>

<span class="nc" id="L3794">        isometricSprites = newIsometricSprites;</span>
<span class="nc" id="L3795">        isometricSpriteIds = newIsoSpriteIds;</span>

<span class="nc" id="L3797">        wreckSprites = newWrecks;</span>
<span class="nc" id="L3798">        isometricWreckSprites = newIsometricWrecks;</span>

        // Update ECM list, to ensure that Sprites are updated with ECM info
<span class="nc" id="L3801">        updateEcmList();</span>
        // Re-highlight a selected entity, if present
<span class="nc" id="L3803">        highlightSelectedEntity();</span>

<span class="nc" id="L3805">        scheduleRedraw();</span>
<span class="nc" id="L3806">    }</span>

    private void redrawAllFlares() {
<span class="nc" id="L3809">        flareSprites.clear();</span>
<span class="nc bnc" id="L3810" title="All 2 branches missed.">        for (Flare f : game.getFlares()) {</span>
<span class="nc" id="L3811">            flareSprites.add(new FlareSprite(this, f));</span>
<span class="nc" id="L3812">        }</span>
<span class="nc" id="L3813">    }</span>

    public Image getFlareImage() {
<span class="nc" id="L3816">        return flareImage;</span>
    }

    /**
     * Moves the cursor to the new position, or hides it, if newPos is null
     */
    private void moveCursor(CursorSprite cursor, Coords newPos) {
<span class="nc" id="L3823">        final Rectangle oldBounds = new Rectangle(cursor.getBounds());</span>
<span class="nc bnc" id="L3824" title="All 2 branches missed.">        if (newPos != null) {</span>
<span class="nc" id="L3825">            cursor.setHexLocation(newPos);</span>
        } else {
<span class="nc" id="L3827">            cursor.setOffScreen();</span>
        }
        // repaint affected area
<span class="nc" id="L3830">        repaint(oldBounds);</span>
<span class="nc" id="L3831">        repaint(cursor.getBounds());</span>
<span class="nc" id="L3832">    }</span>

    /** Centers the board on hex c. Uses smooth centering
     * if activated in the client settings. */
    public void centerOnHex(Coords c) {
<span class="nc bnc" id="L3837" title="All 2 branches missed.">        if (c == null) return;</span>

<span class="nc bnc" id="L3839" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getBoolean(&quot;SOFTCENTER&quot;)) {</span>
            // Soft Centering:
            // set the target point
<span class="nc" id="L3842">            Point p = getCentreHexLocation(c);</span>
<span class="nc" id="L3843">            softCenterTarget.setLocation(</span>
<span class="nc" id="L3844">                    (double)p.x/boardSize.getWidth(),</span>
<span class="nc" id="L3845">                    (double)p.y/boardSize.getHeight());</span>

            // adjust the target point because the board can't
            // center on points too close to an edge
<span class="nc" id="L3849">            double w = scrollpane.getViewport().getWidth();</span>
<span class="nc" id="L3850">            double h = scrollpane.getViewport().getHeight();</span>
<span class="nc" id="L3851">            double bw = boardSize.getWidth();</span>
<span class="nc" id="L3852">            double bh = boardSize.getHeight();</span>

<span class="nc" id="L3854">            double minX = (w/2-HEX_W)/bw;</span>
<span class="nc" id="L3855">            double minY = (h/2-HEX_H)/bh;</span>
<span class="nc" id="L3856">            double maxX = (bw+HEX_W-w/2)/bw;</span>
<span class="nc" id="L3857">            double maxY = (bh+HEX_H-h/2)/bh;</span>

            // here the order is important because the top/left
            // edges always stop the board, the bottom/right
            // only when the board is big enough
<span class="nc" id="L3862">            softCenterTarget.setLocation(</span>
<span class="nc" id="L3863">                    Math.min(softCenterTarget.getX(), maxX),</span>
<span class="nc" id="L3864">                    Math.min(softCenterTarget.getY(), maxY));</span>

<span class="nc" id="L3866">            softCenterTarget.setLocation(</span>
<span class="nc" id="L3867">                    Math.max(softCenterTarget.getX(), minX),</span>
<span class="nc" id="L3868">                    Math.max(softCenterTarget.getY(), minY));</span>

            // get the current board center point
<span class="nc" id="L3871">            double[] v = getVisibleArea();</span>
<span class="nc" id="L3872">            oldCenter.setLocation((v[0]+v[2])/2, (v[1]+v[3])/2);</span>

<span class="nc" id="L3874">            waitTimer = 0;</span>
<span class="nc" id="L3875">            isSoftCentering = true;</span>

<span class="nc" id="L3877">        } else {</span>
            // no soft centering:
            // center on c directly
<span class="nc" id="L3880">            Point p = getCentreHexLocation(c);</span>
<span class="nc" id="L3881">            centerOnPointRel(</span>
<span class="nc" id="L3882">                    (double)p.x/boardSize.getWidth(),</span>
<span class="nc" id="L3883">                    (double)p.y/boardSize.getHeight());</span>
        }
<span class="nc" id="L3885">    }</span>

    /** Moves the board one step towards the final
     * position in during soft centering.
     */
    private synchronized void centerOnHexSoftStep(long deltaTime) {
<span class="nc bnc" id="L3891" title="All 2 branches missed.">        if (isSoftCentering) {</span>
            // don't move the board if 20ms haven't passed since the last move
<span class="nc" id="L3893">            waitTimer += deltaTime;</span>
<span class="nc bnc" id="L3894" title="All 2 branches missed.">            if (waitTimer &lt; 20) return;</span>
<span class="nc" id="L3895">            waitTimer = 0;</span>

            // move the board by a fraction of the distance to the target
<span class="nc" id="L3898">            Point2D newCenter = new Point2D.Double(</span>
<span class="nc" id="L3899">                    oldCenter.getX() + (softCenterTarget.getX() - oldCenter.getX())/SOFT_CENTER_SPEED,</span>
<span class="nc" id="L3900">                    oldCenter.getY() + (softCenterTarget.getY() - oldCenter.getY())/SOFT_CENTER_SPEED );</span>
<span class="nc" id="L3901">            centerOnPointRel(newCenter.getX(), newCenter.getY());</span>

<span class="nc" id="L3903">            oldCenter = newCenter;</span>

            // stop the motion when close enough to the final position
<span class="nc bnc" id="L3906" title="All 2 branches missed.">            if (softCenterTarget.distance(newCenter) &lt; 0.0005) {</span>
<span class="nc" id="L3907">                stopSoftCentering();</span>
<span class="nc" id="L3908">                pingMinimap();</span>
            }
        }
<span class="nc" id="L3911">    }</span>

    public void stopSoftCentering() {
<span class="nc" id="L3914">        isSoftCentering = false;</span>
<span class="nc" id="L3915">    }</span>

    private void adjustVisiblePosition(Coords c, Point dispPoint, double ihdx, double ihdy) {
<span class="nc bnc" id="L3918" title="All 4 branches missed.">        if ((c == null) || (dispPoint == null)) return;</span>

<span class="nc" id="L3920">        Point hexPoint = getCentreHexLocation(c);</span>
        // correct for upper left board padding
<span class="nc" id="L3922">        hexPoint.translate(HEX_W, HEX_H);</span>
<span class="nc" id="L3923">        JScrollBar hscroll = scrollpane.getHorizontalScrollBar();</span>
<span class="nc" id="L3924">        hscroll.setValue(hexPoint.x-dispPoint.x+(int)(ihdx*scale*HEX_W));</span>
<span class="nc" id="L3925">        JScrollBar vscroll = scrollpane.getVerticalScrollBar();</span>
<span class="nc" id="L3926">        vscroll.setValue(hexPoint.y-dispPoint.y+(int)(ihdy*scale*HEX_H));</span>
<span class="nc" id="L3927">        pingMinimap();</span>
<span class="nc" id="L3928">        repaint();</span>
<span class="nc" id="L3929">    }</span>

    /**
     * Centers the board to a point
     * @param xrel the x position relative to board width.
     * @param yrel the y position relative to board height.
     * Both xrel and yrel should be between 0 and 1.
     * The method will clip both values to this range.
     */
    public void centerOnPointRel(double xrel, double yrel) {
        // restrict both values to between 0 and 1
<span class="nc" id="L3940">        xrel = Math.max(0,xrel);</span>
<span class="nc" id="L3941">        xrel = Math.min(1,xrel);</span>
<span class="nc" id="L3942">        yrel = Math.max(0,yrel);</span>
<span class="nc" id="L3943">        yrel = Math.min(1,yrel);</span>
<span class="nc" id="L3944">        Point p = new Point(</span>
<span class="nc" id="L3945">                (int)((double)boardSize.getWidth()*xrel)+HEX_W,</span>
<span class="nc" id="L3946">                (int)((double)boardSize.getHeight()*yrel)+HEX_H);</span>
<span class="nc" id="L3947">        JScrollBar vscroll = scrollpane.getVerticalScrollBar();</span>
<span class="nc" id="L3948">        vscroll.setValue(p.y - (vscroll.getVisibleAmount() / 2));</span>
<span class="nc" id="L3949">        JScrollBar hscroll = scrollpane.getHorizontalScrollBar();</span>
<span class="nc" id="L3950">        hscroll.setValue(p.x - (hscroll.getVisibleAmount() / 2));</span>
<span class="nc" id="L3951">        repaint();</span>
<span class="nc" id="L3952">    }</span>

    /**
     * Returns the currently visible area of the board.
     * @return an array of 4 double values indicating the relative size,
     * where the first two values indicate the x and y position of the upper left
     * corner of the visible area and the second two values the x and y position of
     * the lower right corner.
     * So when the whole board is visible, the values should be 0,0,1,1.
     * When the lower right corner of the board is visible
     * and 90% of width and height: 0.1,0.1,1,1
     * Due to board padding the values can be outside of [0;1]
     */
    public double[] getVisibleArea() {
<span class="nc" id="L3966">        double[] values = new double[4];</span>
<span class="nc" id="L3967">        double x = scrollpane.getViewport().getViewPosition().getX();</span>
<span class="nc" id="L3968">        double y = scrollpane.getViewport().getViewPosition().getY();</span>
<span class="nc" id="L3969">        double w = scrollpane.getViewport().getWidth();</span>
<span class="nc" id="L3970">        double h = scrollpane.getViewport().getHeight();</span>
<span class="nc" id="L3971">        double bw = boardSize.getWidth();</span>
<span class="nc" id="L3972">        double bh = boardSize.getHeight();</span>

<span class="nc" id="L3974">        values[0] = (x-HEX_W)/bw;</span>
<span class="nc" id="L3975">        values[1] = (y-HEX_H)/bh;</span>
<span class="nc" id="L3976">        values[2] = (x-HEX_W+w)/bw;</span>
<span class="nc" id="L3977">        values[3] = (y-HEX_H+h)/bh;</span>

<span class="nc" id="L3979">        return values;</span>
    }

    /**
     * Clears the old movement data and draws the new.
     */
    public void drawMovementData(Entity entity, MovePath md) {
<span class="nc" id="L3986">        MoveStep previousStep = null;</span>

<span class="nc" id="L3988">        clearMovementData();</span>

        // Nothing to do if we don't have a MovePath
<span class="nc bnc" id="L3991" title="All 2 branches missed.">        if (md == null) {</span>
<span class="nc" id="L3992">            movementTarget = null;</span>
<span class="nc" id="L3993">            return;</span>
        }
        // need to update the movement sprites based on the move path for this
        // entity
        // only way to do this is to clear and refresh (seems wasteful)

        // first get the color for the vector
<span class="nc" id="L4000">        Color col = Color.blue;</span>
<span class="nc bnc" id="L4001" title="All 2 branches missed.">        if (md.getLastStep() != null) {</span>
<span class="nc bnc" id="L4002" title="All 5 branches missed.">            switch (md.getLastStep().getMovementType(true)) {</span>
                case MOVE_RUN:
                case MOVE_VTOL_RUN:
                case MOVE_OVER_THRUST:
<span class="nc" id="L4006">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveRunColor&quot;);
<span class="nc" id="L4008">                    break;</span>
                case MOVE_SPRINT:
                case MOVE_VTOL_SPRINT:
<span class="nc" id="L4011">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveSprintColor&quot;);
<span class="nc" id="L4013">                    break;</span>
                case MOVE_JUMP:
<span class="nc" id="L4015">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveJumpColor&quot;);
<span class="nc" id="L4017">                    break;</span>
                case MOVE_ILLEGAL:
<span class="nc" id="L4019">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveIllegalColor&quot;);
<span class="nc" id="L4021">                    break;</span>
                default:
<span class="nc" id="L4023">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveDefaultColor&quot;);
                    break;
            }
<span class="nc" id="L4027">            movementTarget = md.getLastStep().getPosition();</span>
        } else {
<span class="nc" id="L4029">            movementTarget = null;</span>
        }

<span class="nc" id="L4032">        refreshMoveVectors(entity, md, col);</span>

<span class="nc bnc" id="L4034" title="All 2 branches missed.">        for (Enumeration&lt;MoveStep&gt; i = md.getSteps(); i.hasMoreElements(); ) {</span>
<span class="nc" id="L4035">            final MoveStep step = i.nextElement();</span>
<span class="nc bnc" id="L4036" title="All 2 branches missed.">            if ((null != previousStep)</span>
<span class="nc bnc" id="L4037" title="All 2 branches missed.">                &amp;&amp; ((step.getType() == MoveStepType.UP)</span>
<span class="nc bnc" id="L4038" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.DOWN)</span>
<span class="nc bnc" id="L4039" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.ACC)</span>
<span class="nc bnc" id="L4040" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.DEC)</span>
<span class="nc bnc" id="L4041" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.ACCN)</span>
<span class="nc bnc" id="L4042" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.DECN))) {</span>
                // Mark the previous elevation change sprite hidden
                // so that we can draw a new one in it's place without
                // having overlap.
<span class="nc" id="L4046">                pathSprites.get(pathSprites.size() - 1).setHidden(true);</span>
            }

<span class="nc bnc" id="L4049" title="All 2 branches missed.">            if (previousStep != null</span>
                    // for advanced movement, we always need to hide prior
                    // because costs will overlap and we only want the current
                    // facing
<span class="nc bnc" id="L4053" title="All 2 branches missed.">                    &amp;&amp; (game.useVectorMove()</span>
                            // A LAM converting from AirMech to Biped uses two convert steps and we
                            // only want to show the last.
<span class="nc bnc" id="L4056" title="All 2 branches missed.">                            || (step.getType() == MoveStepType.CONVERT_MODE</span>
<span class="nc bnc" id="L4057" title="All 2 branches missed.">                            &amp;&amp; previousStep.getType() == MoveStepType.CONVERT_MODE)</span>
<span class="nc bnc" id="L4058" title="All 2 branches missed.">                            || step.getType() == MoveStepType.BOOTLEGGER)) {</span>
<span class="nc" id="L4059">                pathSprites.get(pathSprites.size() - 1).setHidden(true);</span>
            }

<span class="nc" id="L4062">            pathSprites.add(new StepSprite(this, step, md.isEndStep(step)));</span>
<span class="nc" id="L4063">            previousStep = step;</span>
<span class="nc" id="L4064">        }</span>
<span class="nc" id="L4065">        repaint(100);</span>
<span class="nc" id="L4066">    }</span>

    /**
     * Clears current movement data from the screen
     */
    public void clearMovementData() {
<span class="nc" id="L4072">        pathSprites = new ArrayList&lt;StepSprite&gt;();</span>
<span class="nc" id="L4073">        movementTarget = null;</span>
<span class="nc" id="L4074">        checkFoVHexImageCacheClear();</span>
<span class="nc" id="L4075">        repaint();</span>
<span class="nc" id="L4076">        refreshMoveVectors();</span>
<span class="nc" id="L4077">    }</span>

    public void setFiringSolutions(Entity attacker,
            Map&lt;Integer, FiringSolution&gt; firingSolutions) {

<span class="nc" id="L4082">        clearFiringSolutionData();</span>
<span class="nc bnc" id="L4083" title="All 2 branches missed.">        if (firingSolutions == null) {</span>
<span class="nc" id="L4084">            return;</span>
        }
<span class="nc bnc" id="L4086" title="All 2 branches missed.">        for (FiringSolution sln : firingSolutions.values()) {</span>
<span class="nc" id="L4087">            FiringSolutionSprite sprite = new FiringSolutionSprite(this, sln);</span>
<span class="nc" id="L4088">            firingSprites.add(sprite);</span>
<span class="nc" id="L4089">        }</span>
<span class="nc" id="L4090">    }</span>

    public void clearFiringSolutionData() {
<span class="nc" id="L4093">        firingSprites.clear();</span>
<span class="nc" id="L4094">        repaint();</span>
<span class="nc" id="L4095">    }</span>

    public void addStrafingCoords(Coords c) {
<span class="nc" id="L4098">        strafingCoords.add(c);</span>
<span class="nc" id="L4099">    }</span>

    public void clearStrafingCoords() {
<span class="nc" id="L4102">        strafingCoords.clear();</span>
<span class="nc" id="L4103">    }</span>

    public void setMovementEnvelope(Map&lt;Coords, Integer&gt; mvEnvData, int walk,
            int run, int jump, int gear) {
<span class="nc" id="L4107">        clearMovementEnvelope();</span>

<span class="nc bnc" id="L4109" title="All 2 branches missed.">        if (mvEnvData == null) {</span>
<span class="nc" id="L4110">            return;</span>
        }

<span class="nc" id="L4113">        GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc bnc" id="L4114" title="All 2 branches missed.">        for (Coords loc : mvEnvData.keySet()) {</span>
<span class="nc" id="L4115">            Color spriteColor = null;</span>
<span class="nc" id="L4116">            int mvType = -1;</span>
<span class="nc bnc" id="L4117" title="All 4 branches missed.">            if (gear == MovementDisplay.GEAR_JUMP || gear == MovementDisplay.GEAR_DFA) {</span>
<span class="nc bnc" id="L4118" title="All 2 branches missed.">                if (mvEnvData.get(loc) &lt;= jump) {</span>
<span class="nc" id="L4119">                    spriteColor = guip</span>
<span class="nc" id="L4120">                            .getColor(GUIPreferences.ADVANCED_MOVE_JUMP_COLOR);</span>
<span class="nc" id="L4121">                    mvType = 1;</span>
                }
            } else {
<span class="nc bnc" id="L4124" title="All 2 branches missed.">                if (mvEnvData.get(loc) &lt;= walk) {</span>
<span class="nc" id="L4125">                    spriteColor = guip</span>
<span class="nc" id="L4126">                            .getColor(GUIPreferences.ADVANCED_MOVE_DEFAULT_COLOR);</span>
<span class="nc" id="L4127">                    mvType = 2;</span>

<span class="nc bnc" id="L4129" title="All 2 branches missed.">                } else if (mvEnvData.get(loc) &lt;= run) {</span>
<span class="nc" id="L4130">                    spriteColor = guip</span>
<span class="nc" id="L4131">                            .getColor(GUIPreferences.ADVANCED_MOVE_RUN_COLOR);</span>
<span class="nc" id="L4132">                    mvType = 3;</span>
                } else {
<span class="nc" id="L4134">                    spriteColor = guip</span>
<span class="nc" id="L4135">                            .getColor(GUIPreferences.ADVANCED_MOVE_SPRINT_COLOR);</span>
<span class="nc" id="L4136">                    mvType = 4;</span>
                }
            }

            // Next: check the adjacent hexes and find
            // those with the same movement type,
            // send this to the Sprite so it paints only
            // the borders of the movement type areas
            int mvAdjType;
<span class="nc" id="L4145">            int edgesToPaint = 0;</span>
            // cycle through hexes
<span class="nc bnc" id="L4147" title="All 2 branches missed.">            for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L4148">                mvAdjType = 0;</span>
<span class="nc" id="L4149">                Coords adjacentHex = loc.translated(dir);</span>
                // get the movement type
<span class="nc" id="L4151">                Integer Adjmv = mvEnvData.get(adjacentHex);</span>
<span class="nc bnc" id="L4152" title="All 2 branches missed.">                if (Adjmv != null) {</span>
<span class="nc bnc" id="L4153" title="All 2 branches missed.">                    if (gear == MovementDisplay.GEAR_JUMP) {</span>
<span class="nc bnc" id="L4154" title="All 2 branches missed.">                        if (Adjmv &lt;= jump) mvAdjType = 1;</span>
                    } else {
<span class="nc bnc" id="L4156" title="All 2 branches missed.">                        if (Adjmv &lt;= walk) mvAdjType = 2;</span>
<span class="nc bnc" id="L4157" title="All 2 branches missed.">                        else if (Adjmv &lt;= run) mvAdjType = 3;</span>
<span class="nc" id="L4158">                        else mvAdjType = 4;</span>
                    }
                }
                // other movement type: paint a border in this direction
<span class="nc bnc" id="L4162" title="All 2 branches missed.">                if (mvAdjType != mvType) edgesToPaint += (1 &lt;&lt; dir);</span>
            }

<span class="nc bnc" id="L4165" title="All 2 branches missed.">            if (spriteColor != null) {</span>
<span class="nc" id="L4166">                MovementEnvelopeSprite mvSprite = new MovementEnvelopeSprite(</span>
                        this, spriteColor, loc, edgesToPaint);
<span class="nc" id="L4168">                moveEnvSprites.add(mvSprite);</span>
            }
<span class="nc" id="L4170">        }</span>

<span class="nc" id="L4172">        repaint();</span>

<span class="nc" id="L4174">    }</span>

    public void setMovementModifierEnvelope(Collection&lt;MovePath&gt; movePaths) {
<span class="nc" id="L4177">        moveModEnvSprites.clear();</span>
<span class="nc bnc" id="L4178" title="All 2 branches missed.">        for (MovePath mp : movePaths) {</span>
<span class="nc" id="L4179">            moveModEnvSprites.add(new MovementModifierEnvelopeSprite(this, mp));</span>
<span class="nc" id="L4180">        }</span>
<span class="nc" id="L4181">        repaint();</span>
<span class="nc" id="L4182">    }</span>

    public void clearMovementEnvelope() {
<span class="nc" id="L4185">        moveEnvSprites.clear();</span>
<span class="nc" id="L4186">        moveModEnvSprites.clear();</span>
<span class="nc" id="L4187">        repaint();</span>
<span class="nc" id="L4188">    }</span>

    /**
     * Draws the given &lt;code&gt;text&lt;/code&gt; in the currently active font of the Graphics &lt;code&gt;g2D&lt;/code&gt;
     * at font size &lt;code&gt;fontSize&lt;/code&gt;. The text is centered in both
     * x and y directions around the position &lt;code&gt;pos&lt;/code&gt;. The text is colored with
     * the given &lt;code&gt;color&lt;/code&gt;, made translucent if the flag is set. The outline of the text
     * will be dark gray.
     * @param g2D the graphics to draw to, as &lt;code&gt;Graphics2D&lt;/code&gt;
     * @param text the string to write
     * @param pos the board pixel position
     * @param fontSize the font size. This will be scaled by the current board zoom
     * @param color the color to draw the text in
     * @param translucent (optional)  makes the text translucent if set to true. Defaults to false
     * @param cOutline (optional) the color of the outline. Defaults to Color.DARK_GRAY
     */
    public void drawOutlineText(Graphics2D g2D, String text, Point pos,
            float fontSize, Color color, boolean translucent, Color cOutline) {
<span class="nc" id="L4206">        g2D.setFont(g2D.getFont().deriveFont(fontSize));</span>
<span class="nc" id="L4207">        FontMetrics fm = g2D.getFontMetrics(g2D.getFont());</span>
        // Center the text around pos
<span class="nc" id="L4209">        int cx = pos.x - (fm.stringWidth(text) / 2);</span>
<span class="nc" id="L4210">        int cy = pos.y + (fm.getAscent() - fm.getDescent()) / 2;</span>

        // get text shape and position it
<span class="nc" id="L4213">        GlyphVector gv = g2D.getFont().createGlyphVector(g2D.getFontRenderContext(), text);</span>
<span class="nc" id="L4214">        Shape shape = gv.getOutline();</span>
<span class="nc" id="L4215">        shape = AffineTransform.getTranslateInstance(cx,cy).</span>
<span class="nc" id="L4216">                createTransformedShape(shape);</span>

        // text area fill
<span class="nc bnc" id="L4219" title="All 2 branches missed.">        if (translucent)</span>
<span class="nc" id="L4220">            color = new Color(color.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</span>
<span class="nc" id="L4221">        g2D.setColor(color);</span>
<span class="nc" id="L4222">        g2D.fill(shape);</span>

        // outline
<span class="nc" id="L4225">        g2D.setStroke(new BasicStroke(0.5f));</span>
<span class="nc" id="L4226">        Color lineColor = cOutline;</span>
<span class="nc bnc" id="L4227" title="All 2 branches missed.">        if (translucent)</span>
<span class="nc" id="L4228">            lineColor = new Color(lineColor.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</span>
<span class="nc" id="L4229">        g2D.setColor(lineColor);</span>
<span class="nc" id="L4230">        g2D.draw(shape);</span>
<span class="nc" id="L4231">    }</span>

    public void drawOutlineText(Graphics2D g2D, String text, Point pos,
            float fontSize, Color color, boolean translucent) {
<span class="nc" id="L4235">        drawOutlineText(g2D, text, pos, fontSize, color, translucent, Color.DARK_GRAY);</span>
<span class="nc" id="L4236">    }</span>

    public void drawOutlineText(Graphics2D g2D, String text, Point pos,
            float fontSize, Color color) {
<span class="nc" id="L4240">        drawOutlineText(g2D, text, pos, fontSize, color, false, Color.DARK_GRAY);</span>
<span class="nc" id="L4241">    }</span>

    public void drawTextShadow(Graphics2D g2D, String text, Point pos,
            Font font) {
<span class="nc" id="L4245">        g2D.setFont(font);</span>
        // to keep the shadow always 1 px wide,
        // counteract the current graph scaling
<span class="nc" id="L4248">        double scX = g2D.getTransform().getScaleX();</span>
<span class="nc" id="L4249">        double scY = g2D.getTransform().getScaleY();</span>

<span class="nc" id="L4251">        drawCenteredText(g2D, text, (float)pos.x+(1.0f)/(float)scX,(float)pos.y, Color.BLACK, false);</span>
<span class="nc" id="L4252">        drawCenteredText(g2D, text, (float)pos.x-(1.0f)/(float)scX,(float)pos.y, Color.BLACK, false);</span>
<span class="nc" id="L4253">        drawCenteredText(g2D, text, (float)pos.x,(float)pos.y+(1.0f)/(float)scY, Color.BLACK, false);</span>
<span class="nc" id="L4254">        drawCenteredText(g2D, text, (float)pos.x,(float)pos.y-(1.0f)/(float)scY, Color.BLACK, false);</span>
<span class="nc" id="L4255">    }</span>

    public void drawCenteredText(Graphics2D g2D, String text, Point pos,
            Color color, boolean translucent) {
<span class="nc" id="L4259">        FontMetrics fm = g2D.getFontMetrics(g2D.getFont());</span>
        // Center the text around pos
<span class="nc" id="L4261">        int cx = pos.x - (fm.stringWidth(text) / 2);</span>
<span class="nc" id="L4262">        int cy = pos.y - fm.getAscent()/2-fm.getDescent() / 2+fm.getAscent();</span>

<span class="nc bnc" id="L4264" title="All 2 branches missed.">        if (translucent)</span>
<span class="nc" id="L4265">            color = new Color(color.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</span>
<span class="nc" id="L4266">        g2D.setColor(color);</span>
<span class="nc" id="L4267">        g2D.drawString(text, cx, cy);</span>
<span class="nc" id="L4268">    }</span>

    // This method is used to draw text shadows even when the g2D is scaled
    public void drawCenteredText(Graphics2D g2D, String text, float posx, float posy,
            Color color, boolean translucent) {
<span class="nc" id="L4273">        FontMetrics fm = g2D.getFontMetrics(g2D.getFont());</span>
        // Center the text around pos
<span class="nc" id="L4275">        float cx = posx - (fm.stringWidth(text) / 2);</span>
<span class="nc" id="L4276">        float cy = posy - fm.getAscent()/2-fm.getDescent() / 2+fm.getAscent();</span>

<span class="nc bnc" id="L4278" title="All 2 branches missed.">        if (translucent)</span>
<span class="nc" id="L4279">            color = new Color(color.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</span>
<span class="nc" id="L4280">        g2D.setColor(color);</span>
<span class="nc" id="L4281">        g2D.drawString(text, cx, cy);</span>
<span class="nc" id="L4282">    }</span>

    public void drawCenteredText(Graphics2D g2D, String text, Point pos,
            Color color, boolean translucent, Font font) {
<span class="nc" id="L4286">        g2D.setFont(font);</span>
<span class="nc" id="L4287">        drawCenteredText(g2D, text, pos, color, translucent);</span>
<span class="nc" id="L4288">    }</span>

    public void drawCenteredText(Graphics2D g2D, String text, Point pos,
            Color color, boolean translucent, int fontSize) {
<span class="nc" id="L4292">        g2D.setFont(g2D.getFont().deriveFont(fontSize));</span>
<span class="nc" id="L4293">        drawCenteredText(g2D, text, pos, color, translucent);</span>
<span class="nc" id="L4294">    }</span>

    public void setLocalPlayer(IPlayer p) {
<span class="nc" id="L4297">        localPlayer = p;</span>
<span class="nc" id="L4298">    }</span>

    public IPlayer getLocalPlayer() {
<span class="nc" id="L4301">        return localPlayer;</span>
    }

    /**
     * Specifies that this should mark the deployment hexes for a player. If the
     * player is set to null, no hexes will be marked.
     */
    public void markDeploymentHexesFor(Entity ce) {
<span class="nc" id="L4309">        en_Deployer = ce;</span>
<span class="nc" id="L4310">        repaint(100);</span>
<span class="nc" id="L4311">    }</span>

    /**
     * Returns the entity that is currently being deployed
     */
    public Entity getDeployingEntity() {
<span class="nc" id="L4317">        return en_Deployer;</span>
    }

    /**
     * add a fly over path to the sprite list
     */
    public void addFlyOverPath(Entity e) {
<span class="nc bnc" id="L4324" title="All 2 branches missed.">        if (e.getPosition() == null) {</span>
<span class="nc" id="L4325">            return;</span>
        }

<span class="nc bnc" id="L4328" title="All 2 branches missed.">        if (e.isMakingVTOLGroundAttack()) {</span>
<span class="nc" id="L4329">            vtolAttackSprites.add(new VTOLAttackSprite(this, e));</span>
        }
<span class="nc" id="L4331">        flyOverSprites.add(new FlyOverSprite(this, e));</span>
<span class="nc" id="L4332">    }</span>

    public List&lt;Entity&gt; getEntitiesFlyingOver(Coords c) {
<span class="nc" id="L4335">        List&lt;Entity&gt; entities = new ArrayList&lt;Entity&gt;();</span>
<span class="nc bnc" id="L4336" title="All 2 branches missed.">        for (FlyOverSprite fsprite : flyOverSprites) {</span>
            //Spaceborne units shouldn't count here. They show up incorrectly in the firing display when sensors are in use.
<span class="nc bnc" id="L4338" title="All 4 branches missed.">            if (fsprite.getEntity().getPassedThrough().contains(c) &amp;&amp; !fsprite.getEntity().isSpaceborne()) {</span>
<span class="nc" id="L4339">                entities.add(fsprite.getEntity());</span>
            }
<span class="nc" id="L4341">        }</span>
<span class="nc" id="L4342">        return entities;</span>
    }

    /**
     * Adds a c3 line to the sprite list.
     */
    public void addC3Link(Entity e) {
<span class="nc bnc" id="L4349" title="All 2 branches missed.">        if (e.getPosition() == null) {</span>
<span class="nc" id="L4350">            return;</span>
        }

<span class="nc bnc" id="L4353" title="All 2 branches missed.">        if (e.hasC3i()) {</span>
<span class="nc bnc" id="L4354" title="All 2 branches missed.">            for (Entity fe : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4355" title="All 2 branches missed.">                if (fe.getPosition() == null) {</span>
<span class="nc" id="L4356">                    return;</span>
                }
<span class="nc bnc" id="L4358" title="All 2 branches missed.">                if (e.onSameC3NetworkAs(fe)</span>
<span class="nc bnc" id="L4359" title="All 2 branches missed.">                        &amp;&amp; !fe.equals(e)</span>
<span class="nc bnc" id="L4360" title="All 2 branches missed.">                        &amp;&amp; !ComputeECM.isAffectedByECM(e, e.getPosition(),</span>
<span class="nc" id="L4361">                                fe.getPosition())) {</span>
<span class="nc" id="L4362">                    c3Sprites.add(new C3Sprite(this, e, fe));</span>
                }
<span class="nc" id="L4364">            }</span>
<span class="nc bnc" id="L4365" title="All 2 branches missed.">        } else if (e.hasNavalC3()) {</span>
<span class="nc bnc" id="L4366" title="All 2 branches missed.">            for (Entity fe : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4367" title="All 2 branches missed.">                if (fe.getPosition() == null) {</span>
<span class="nc" id="L4368">                    return;</span>
                }
<span class="nc bnc" id="L4370" title="All 4 branches missed.">                if (e.onSameC3NetworkAs(fe) &amp;&amp; !fe.equals(e)) {</span>
<span class="nc" id="L4371">                    c3Sprites.add(new C3Sprite(this, e, fe));</span>
                }
<span class="nc" id="L4373">            }</span>
<span class="nc bnc" id="L4374" title="All 2 branches missed.">        } else if (e.hasActiveNovaCEWS()) {</span>
            // WOR Nova CEWS
<span class="nc bnc" id="L4376" title="All 2 branches missed.">            for (Entity fe : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4377" title="All 2 branches missed.">                if (fe.getPosition() == null) {</span>
<span class="nc" id="L4378">                    return;</span>
                }
<span class="nc" id="L4380">                ECMInfo ecmInfo = ComputeECM.getECMEffects(e, e.getPosition(),</span>
<span class="nc" id="L4381">                        fe.getPosition(), true, null);</span>
<span class="nc bnc" id="L4382" title="All 2 branches missed.">                if (e.onSameC3NetworkAs(fe)</span>
<span class="nc bnc" id="L4383" title="All 4 branches missed.">                    &amp;&amp; !fe.equals(e)</span>
                    &amp;&amp; (ecmInfo != null)
<span class="nc bnc" id="L4385" title="All 2 branches missed.">                    &amp;&amp; !ecmInfo.isNovaECM()) {</span>
<span class="nc" id="L4386">                    c3Sprites.add(new C3Sprite(this, e, fe));</span>
                }
<span class="nc" id="L4388">            }</span>
<span class="nc bnc" id="L4389" title="All 2 branches missed.">        } else if (e.getC3Master() != null) {</span>
<span class="nc" id="L4390">            Entity eMaster = e.getC3Master();</span>
<span class="nc bnc" id="L4391" title="All 2 branches missed.">            if (eMaster.getPosition() == null) {</span>
<span class="nc" id="L4392">                return;</span>
            }

            // ECM cuts off the network
<span class="nc" id="L4396">            boolean blocked = false;</span>
<span class="nc bnc" id="L4397" title="All 4 branches missed.">            if (e.hasBoostedC3() &amp;&amp; eMaster.hasBoostedC3()) {</span>
<span class="nc bnc" id="L4398" title="All 2 branches missed.">                blocked = ComputeECM.isAffectedByAngelECM(e, e.getPosition(),</span>
<span class="nc" id="L4399">                        eMaster.getPosition())</span>
<span class="nc bnc" id="L4400" title="All 2 branches missed.">                        || ComputeECM.isAffectedByAngelECM(eMaster,</span>
<span class="nc" id="L4401">                                eMaster.getPosition(), eMaster.getPosition());</span>
            } else {
<span class="nc bnc" id="L4403" title="All 2 branches missed.">                blocked = ComputeECM.isAffectedByECM(e, e.getPosition(),</span>
<span class="nc" id="L4404">                        eMaster.getPosition())</span>
<span class="nc bnc" id="L4405" title="All 2 branches missed.">                        || ComputeECM.isAffectedByECM(eMaster,</span>
<span class="nc" id="L4406">                                eMaster.getPosition(), eMaster.getPosition());</span>
            }

<span class="nc bnc" id="L4409" title="All 2 branches missed.">            if (!blocked) {</span>
<span class="nc" id="L4410">                c3Sprites.add(new C3Sprite(this, e, e.getC3Master()));</span>
            }
        }
<span class="nc" id="L4413">    }</span>

    /**
     * Adds an attack to the sprite list.
     */
    public synchronized void addAttack(AttackAction aa) {
        // Don't make sprites for unknown entities and sensor returns
<span class="nc" id="L4420">        Entity ae = game.getEntity(aa.getEntityId());</span>
<span class="nc" id="L4421">        Targetable t = game.getTarget(aa.getTargetType(), aa.getTargetId());</span>
<span class="nc bnc" id="L4422" title="All 4 branches missed.">        if ((ae == null) || (t == null)</span>
<span class="nc bnc" id="L4423" title="All 2 branches missed.">            || (t.getTargetType() == Targetable.TYPE_INARC_POD)</span>
<span class="nc bnc" id="L4424" title="All 4 branches missed.">            || (t.getPosition() == null) || (ae.getPosition() == null)) {</span>
<span class="nc" id="L4425">            return;</span>
        }
<span class="nc" id="L4427">        EntitySprite eSprite = entitySpriteIds.get(getIdAndLoc(ae.getId(),</span>
<span class="nc bnc" id="L4428" title="All 2 branches missed.">                ae.getSecondaryPositions().size() &gt; 0 ? 0 : -1));</span>
<span class="nc bnc" id="L4429" title="All 4 branches missed.">        if (eSprite != null &amp;&amp; eSprite.onlyDetectedBySensors()) {</span>
<span class="nc" id="L4430">            return;</span>
        }

<span class="nc" id="L4433">        repaint(100);</span>
<span class="nc bnc" id="L4434" title="All 2 branches missed.">        for (AttackSprite sprite : attackSprites) {</span>
            // can we just add this attack to an existing one?
<span class="nc bnc" id="L4436" title="All 2 branches missed.">            if ((sprite.getEntityId() == aa.getEntityId())</span>
<span class="nc bnc" id="L4437" title="All 2 branches missed.">                &amp;&amp; (sprite.getTargetId() == aa.getTargetId())) {</span>
                // use existing attack, but add this weapon
<span class="nc bnc" id="L4439" title="All 2 branches missed.">                if (aa instanceof WeaponAttackAction) {</span>
<span class="nc" id="L4440">                    WeaponAttackAction waa = (WeaponAttackAction) aa;</span>
<span class="nc bnc" id="L4441" title="All 2 branches missed.">                    if (aa.getTargetType() != Targetable.TYPE_HEX_ARTILLERY) {</span>
<span class="nc" id="L4442">                        sprite.addWeapon(waa);</span>
<span class="nc" id="L4443">                    } else if (waa.getEntity(game).getOwner().getId() == localPlayer</span>
<span class="nc bnc" id="L4444" title="All 2 branches missed.">                            .getId()) {</span>
<span class="nc" id="L4445">                        sprite.addWeapon(waa);</span>
                    }
                }
<span class="nc bnc" id="L4448" title="All 2 branches missed.">                if (aa instanceof KickAttackAction) {</span>
<span class="nc" id="L4449">                    sprite.addWeapon((KickAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4451" title="All 2 branches missed.">                if (aa instanceof PunchAttackAction) {</span>
<span class="nc" id="L4452">                    sprite.addWeapon((PunchAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4454" title="All 2 branches missed.">                if (aa instanceof PushAttackAction) {</span>
<span class="nc" id="L4455">                    sprite.addWeapon((PushAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4457" title="All 2 branches missed.">                if (aa instanceof ClubAttackAction) {</span>
<span class="nc" id="L4458">                    sprite.addWeapon((ClubAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4460" title="All 2 branches missed.">                if (aa instanceof ChargeAttackAction) {</span>
<span class="nc" id="L4461">                    sprite.addWeapon((ChargeAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4463" title="All 2 branches missed.">                if (aa instanceof DfaAttackAction) {</span>
<span class="nc" id="L4464">                    sprite.addWeapon((DfaAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4466" title="All 2 branches missed.">                if (aa instanceof ProtomechPhysicalAttackAction) {</span>
<span class="nc" id="L4467">                    sprite.addWeapon((ProtomechPhysicalAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4469" title="All 2 branches missed.">                if (aa instanceof SearchlightAttackAction) {</span>
<span class="nc" id="L4470">                    sprite.addWeapon((SearchlightAttackAction) aa);</span>
                }
<span class="nc" id="L4472">                return;</span>
            }
<span class="nc" id="L4474">        }</span>
        // no re-use possible, add a new one
        // don't add a sprite for an artillery attack made by the other player
<span class="nc bnc" id="L4477" title="All 2 branches missed.">        if (aa instanceof WeaponAttackAction) {</span>
<span class="nc" id="L4478">            WeaponAttackAction waa = (WeaponAttackAction) aa;</span>
<span class="nc bnc" id="L4479" title="All 2 branches missed.">            if (aa.getTargetType() != Targetable.TYPE_HEX_ARTILLERY) {</span>
<span class="nc" id="L4480">                attackSprites.add(new AttackSprite(this, aa));</span>
<span class="nc" id="L4481">            } else if (waa.getEntity(game).getOwner().getId() == localPlayer</span>
<span class="nc bnc" id="L4482" title="All 2 branches missed.">                    .getId()) {</span>
<span class="nc" id="L4483">                attackSprites.add(new AttackSprite(this, aa));</span>
            }
<span class="nc" id="L4485">        } else {</span>
<span class="nc" id="L4486">            attackSprites.add(new AttackSprite(this, aa));</span>
        }
<span class="nc" id="L4488">    }</span>

    /**
     * Removes all attack sprites from a certain entity
     */
    public synchronized void removeAttacksFor(Entity e) {
<span class="nc bnc" id="L4494" title="All 2 branches missed.">        if (e == null) {</span>
<span class="nc" id="L4495">            return;</span>
        }
<span class="nc" id="L4497">        int entityId = e.getId();</span>
<span class="nc bnc" id="L4498" title="All 2 branches missed.">        for (Iterator&lt;AttackSprite&gt; i = attackSprites.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L4499">            AttackSprite sprite = i.next();</span>
<span class="nc bnc" id="L4500" title="All 2 branches missed.">            if (sprite.getEntityId() == entityId) {</span>
<span class="nc" id="L4501">                i.remove();</span>
            }
<span class="nc" id="L4503">        }</span>
<span class="nc" id="L4504">        repaint(100);</span>
<span class="nc" id="L4505">    }</span>

    /**
     * Clears out all attacks and re-adds the ones in the current game.
     */
    public void refreshAttacks() {
<span class="nc" id="L4511">        clearAllAttacks();</span>
<span class="nc" id="L4512">        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</span>
<span class="nc bnc" id="L4513" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L4514">            EntityAction ea = i.nextElement();</span>
<span class="nc bnc" id="L4515" title="All 2 branches missed.">            if (ea instanceof AttackAction) {</span>
<span class="nc" id="L4516">                addAttack((AttackAction) ea);</span>
            }
<span class="nc" id="L4518">        }</span>
<span class="nc" id="L4519">        for (Enumeration&lt;AttackAction&gt; i = game.getCharges(); i</span>
<span class="nc bnc" id="L4520" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L4521">            EntityAction ea = i.nextElement();</span>
<span class="nc bnc" id="L4522" title="All 2 branches missed.">            if (ea instanceof PhysicalAttackAction) {</span>
<span class="nc" id="L4523">                addAttack((AttackAction) ea);</span>
            }
<span class="nc" id="L4525">        }</span>
<span class="nc" id="L4526">        repaint(100);</span>
<span class="nc" id="L4527">    }</span>

    public void refreshMoveVectors() {
<span class="nc" id="L4530">        clearAllMoveVectors();</span>
<span class="nc bnc" id="L4531" title="All 2 branches missed.">        for (Entity e : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4532" title="All 2 branches missed.">            if (e.getPosition() != null) {</span>
<span class="nc" id="L4533">                movementSprites.add(new MovementSprite(this, e, e.getVectors(),</span>
                                                       Color.gray, false));
            }
<span class="nc" id="L4536">        }</span>
<span class="nc" id="L4537">    }</span>

    public void refreshMoveVectors(Entity en, MovePath md, Color col) {
<span class="nc" id="L4540">        clearAllMoveVectors();</span>
        // same as normal but when I find the active entity I used the MovePath
        // to get vector
<span class="nc bnc" id="L4543" title="All 2 branches missed.">        for (Entity e : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4544" title="All 2 branches missed.">            if (e.getPosition() != null) {</span>
<span class="nc bnc" id="L4545" title="All 4 branches missed.">                if ((en != null) &amp;&amp; (e.getId() == en.getId())) {</span>
<span class="nc" id="L4546">                    movementSprites.add(new MovementSprite(this, e, md</span>
<span class="nc" id="L4547">                            .getFinalVectors(), col, true));</span>
                } else {
<span class="nc" id="L4549">                    movementSprites.add(new MovementSprite(this, e, e.getVectors(),</span>
                                                           col, false));
                }
            }
<span class="nc" id="L4553">        }</span>
<span class="nc" id="L4554">    }</span>

    public void clearC3Networks() {
<span class="nc" id="L4557">        c3Sprites.clear();</span>
<span class="nc" id="L4558">    }</span>

    public void clearFlyOverPaths() {
<span class="nc" id="L4561">        vtolAttackSprites.clear();</span>
<span class="nc" id="L4562">        flyOverSprites.clear();</span>
<span class="nc" id="L4563">    }</span>

    /**
     * Clears out all attacks that were being drawn
     */
    public void clearAllAttacks() {
<span class="nc" id="L4569">        attackSprites.clear();</span>
<span class="nc" id="L4570">    }</span>

    /**
     * Clears out all movement vectors that were being drawn
     */
    public void clearAllMoveVectors() {
<span class="nc" id="L4576">        movementSprites.clear();</span>
<span class="nc" id="L4577">    }</span>

    protected void firstLOSHex(Coords c) {
<span class="nc bnc" id="L4580" title="All 2 branches missed.">        if (useLOSTool) {</span>
<span class="nc" id="L4581">            moveCursor(secondLOSSprite, null);</span>
<span class="nc" id="L4582">            moveCursor(firstLOSSprite, c);</span>
        }
<span class="nc" id="L4584">    }</span>

    protected void secondLOSHex(Coords c2, Coords c1) {
<span class="nc bnc" id="L4587" title="All 2 branches missed.">        if (useLOSTool) {</span>

<span class="nc" id="L4589">            Entity ae = chooseEntity(c1);</span>
<span class="nc" id="L4590">            Entity te = chooseEntity(c2);</span>

<span class="nc" id="L4592">            StringBuffer message = new StringBuffer();</span>
            LosEffects le;
<span class="nc bnc" id="L4594" title="All 4 branches missed.">            if ((ae == null) || (te == null)) {</span>
<span class="nc" id="L4595">                boolean mechInFirst = GUIPreferences.getInstance()</span>
<span class="nc" id="L4596">                                                    .getMechInFirst();</span>
<span class="nc" id="L4597">                boolean mechInSecond = GUIPreferences.getInstance()</span>
<span class="nc" id="L4598">                                                     .getMechInSecond();</span>
<span class="nc" id="L4599">                LosEffects.AttackInfo ai = new LosEffects.AttackInfo();</span>
<span class="nc" id="L4600">                ai.attackPos = c1;</span>
<span class="nc" id="L4601">                ai.targetPos = c2;</span>
<span class="nc bnc" id="L4602" title="All 2 branches missed.">                ai.attackHeight = mechInFirst ? 1 : 0;</span>
<span class="nc bnc" id="L4603" title="All 2 branches missed.">                ai.targetHeight = mechInSecond ? 1 : 0;</span>
<span class="nc" id="L4604">                ai.targetIsMech = mechInSecond;</span>
<span class="nc" id="L4605">                ai.attackerIsMech = mechInFirst;</span>
<span class="nc" id="L4606">                ai.attackAbsHeight = game.getBoard().getHex(c1).floor()</span>
                                     + ai.attackHeight;
<span class="nc" id="L4608">                ai.targetAbsHeight = game.getBoard().getHex(c2).floor()</span>
                                     + ai.targetHeight;
<span class="nc" id="L4610">                le = LosEffects.calculateLos(game, ai);</span>
<span class="nc" id="L4611">                message.append(Messages</span>
<span class="nc" id="L4612">                                       .getString(</span>
                                               &quot;BoardView1.Attacker&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc bnc" id="L4614" title="All 2 branches missed.">                                                                                    mechInFirst ? Messages</span>
<span class="nc" id="L4615">                                                                                            .getString(&quot;BoardView1.Mech&quot;) : Messages.getString(&quot;BoardView1.NonMech&quot;), //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L4616">                                                                                    c1.getBoardNum()}));</span>
<span class="nc" id="L4617">                message.append(Messages</span>
<span class="nc" id="L4618">                                       .getString(</span>
                                               &quot;BoardView1.Target&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc bnc" id="L4620" title="All 2 branches missed.">                                                                                  mechInSecond ? Messages</span>
<span class="nc" id="L4621">                                                                                          .getString(&quot;BoardView1.Mech&quot;) : Messages.getString(&quot;BoardView1.NonMech&quot;), //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L4622">                                                                                  c2.getBoardNum()}));</span>
<span class="nc" id="L4623">            } else {</span>
<span class="nc" id="L4624">                le = LosEffects.calculateLos(game, ae.getId(), te);</span>
<span class="nc" id="L4625">                message.append(Messages.getString(</span>
                        &quot;BoardView1.Attacker&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4627">                                                             ae.getDisplayName(), c1.getBoardNum()}));</span>
<span class="nc" id="L4628">                message.append(Messages.getString(</span>
                        &quot;BoardView1.Target&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4630">                                                           te.getDisplayName(), c2.getBoardNum()}));</span>
            }
            // Check to see if LoS is blocked
<span class="nc bnc" id="L4633" title="All 2 branches missed.">            if (!le.canSee()) {</span>
<span class="nc" id="L4634">                message.append(Messages.getString(&quot;BoardView1.LOSBlocked&quot;,</span>
                                                  new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4636">                                                                Integer.valueOf(c1.distance(c2))}));</span>
<span class="nc" id="L4637">                ToHitData thd = le.losModifiers(game);</span>
<span class="nc" id="L4638">                message.append(&quot;\t&quot; + thd.getDesc() + &quot;\n&quot;);</span>
<span class="nc" id="L4639">            } else {</span>
<span class="nc" id="L4640">                message.append(Messages.getString(&quot;BoardView1.LOSNotBlocked&quot;,</span>
                                                  new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4642">                                                                Integer.valueOf(c1.distance(c2))}));</span>
<span class="nc bnc" id="L4643" title="All 2 branches missed.">                if (le.getHeavyWoods() &gt; 0) {</span>
<span class="nc" id="L4644">                    message.append(Messages.getString(</span>
                            &quot;BoardView1.HeavyWoods&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4646">                                                                   Integer.valueOf(le.getHeavyWoods())}));</span>
                }
<span class="nc bnc" id="L4648" title="All 2 branches missed.">                if (le.getLightWoods() &gt; 0) {</span>
<span class="nc" id="L4649">                    message.append(Messages.getString(</span>
                            &quot;BoardView1.LightWoods&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4651">                                                                   Integer.valueOf(le.getLightWoods())}));</span>
                }
<span class="nc bnc" id="L4653" title="All 2 branches missed.">                if (le.getLightSmoke() &gt; 0) {</span>
<span class="nc" id="L4654">                    message.append(Messages.getString(</span>
                            &quot;BoardView1.LightSmoke&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4656">                                                                   Integer.valueOf(le.getLightSmoke())}));</span>
                }
<span class="nc bnc" id="L4658" title="All 2 branches missed.">                if (le.getHeavySmoke() &gt; 0) {</span>
<span class="nc" id="L4659">                    message.append(Messages.getString(</span>
                            &quot;BoardView1.HeavySmoke&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4661">                                                                   Integer.valueOf(le.getHeavySmoke())}));</span>
                }
<span class="nc bnc" id="L4663" title="All 4 branches missed.">                if (le.isTargetCover() &amp;&amp; le.canSee()) {</span>
<span class="nc" id="L4664">                    message.append(Messages</span>
<span class="nc" id="L4665">                                           .getString(</span>
                                                   &quot;BoardView1.TargetPartialCover&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4667">                                                                                                  LosEffects.getCoverName(</span>
<span class="nc" id="L4668">                                                                                                          le.getTargetCover(), true)}));</span>
                }
<span class="nc bnc" id="L4670" title="All 4 branches missed.">                if (le.isAttackerCover() &amp;&amp; le.canSee()) {</span>
<span class="nc" id="L4671">                    message.append(Messages.getString(</span>
                            &quot;BoardView1.AttackerPartialCover&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4673">                                                                             LosEffects.getCoverName(le.getAttackerCover(),</span>
                                                                                                     false)}));
                }
            }
<span class="nc" id="L4677">            JOptionPane.showMessageDialog(getRootPane(), message.toString(),</span>
<span class="nc" id="L4678">                                          Messages.getString(&quot;BoardView1.LOSTitle&quot;),</span>
                                          JOptionPane.INFORMATION_MESSAGE);
        }
<span class="nc" id="L4681">    }</span>

    /**
     * Initializes the various overlay polygons with their vertices.
     */
    public void initPolys() {

<span class="nc" id="L4688">        AffineTransform facingRotate = new AffineTransform();</span>

        // facing polygons
<span class="nc" id="L4691">        Polygon facingPolyTmp = new Polygon();</span>
<span class="nc" id="L4692">        facingPolyTmp.addPoint(41, 3);</span>
<span class="nc" id="L4693">        facingPolyTmp.addPoint(35, 9);</span>
<span class="nc" id="L4694">        facingPolyTmp.addPoint(41, 7);</span>
<span class="nc" id="L4695">        facingPolyTmp.addPoint(42, 7);</span>
<span class="nc" id="L4696">        facingPolyTmp.addPoint(48, 9);</span>
<span class="nc" id="L4697">        facingPolyTmp.addPoint(42, 3);</span>

        // create the rotated shapes
<span class="nc" id="L4700">        facingPolys = new Shape[8];</span>
<span class="nc bnc" id="L4701" title="All 2 branches missed.">        for (int dir : allDirections) {</span>
<span class="nc" id="L4702">            facingPolys[dir] = facingRotate.createTransformedShape(facingPolyTmp);</span>
<span class="nc" id="L4703">            facingRotate.rotate(Math.toRadians(60), HEX_W / 2, HEX_H / 2);</span>
        }

        // final facing polygons
<span class="nc" id="L4707">        Polygon finalFacingPolyTmp = new Polygon();</span>
<span class="nc" id="L4708">        finalFacingPolyTmp.addPoint(41, 3);</span>
<span class="nc" id="L4709">        finalFacingPolyTmp.addPoint(21, 18);</span>
<span class="nc" id="L4710">        finalFacingPolyTmp.addPoint(41, 14);</span>
<span class="nc" id="L4711">        finalFacingPolyTmp.addPoint(42, 14);</span>
<span class="nc" id="L4712">        finalFacingPolyTmp.addPoint(61, 18);</span>
<span class="nc" id="L4713">        finalFacingPolyTmp.addPoint(42, 3);</span>

        // create the rotated shapes
<span class="nc" id="L4716">        facingRotate.setToIdentity();</span>
<span class="nc" id="L4717">        finalFacingPolys = new Shape[8];</span>
<span class="nc bnc" id="L4718" title="All 2 branches missed.">        for (int dir : allDirections) {</span>
<span class="nc" id="L4719">            finalFacingPolys[dir] = facingRotate.createTransformedShape(finalFacingPolyTmp);</span>
<span class="nc" id="L4720">            facingRotate.rotate(Math.toRadians(60), HEX_W / 2, HEX_H / 2);</span>
        }

        // movement polygons
<span class="nc" id="L4724">        Polygon movementPolyTmp = new Polygon();</span>
<span class="nc" id="L4725">        movementPolyTmp.addPoint(47, 67);</span>
<span class="nc" id="L4726">        movementPolyTmp.addPoint(48, 66);</span>
<span class="nc" id="L4727">        movementPolyTmp.addPoint(42, 62);</span>
<span class="nc" id="L4728">        movementPolyTmp.addPoint(41, 62);</span>
<span class="nc" id="L4729">        movementPolyTmp.addPoint(35, 66);</span>
<span class="nc" id="L4730">        movementPolyTmp.addPoint(36, 67);</span>

<span class="nc" id="L4732">        movementPolyTmp.addPoint(47, 67);</span>
<span class="nc" id="L4733">        movementPolyTmp.addPoint(45, 68);</span>
<span class="nc" id="L4734">        movementPolyTmp.addPoint(38, 68);</span>
<span class="nc" id="L4735">        movementPolyTmp.addPoint(38, 69);</span>
<span class="nc" id="L4736">        movementPolyTmp.addPoint(45, 69);</span>
<span class="nc" id="L4737">        movementPolyTmp.addPoint(45, 68);</span>

<span class="nc" id="L4739">        movementPolyTmp.addPoint(45, 70);</span>
<span class="nc" id="L4740">        movementPolyTmp.addPoint(38, 70);</span>
<span class="nc" id="L4741">        movementPolyTmp.addPoint(38, 71);</span>
<span class="nc" id="L4742">        movementPolyTmp.addPoint(45, 71);</span>
<span class="nc" id="L4743">        movementPolyTmp.addPoint(45, 68);</span>

        // create the rotated shapes
<span class="nc" id="L4746">        facingRotate.setToIdentity();</span>
<span class="nc" id="L4747">        movementPolys = new Shape[8];</span>
<span class="nc bnc" id="L4748" title="All 2 branches missed.">        for (int dir : allDirections) {</span>
<span class="nc" id="L4749">            movementPolys[dir] = facingRotate.createTransformedShape(movementPolyTmp);</span>
<span class="nc" id="L4750">            facingRotate.rotate(Math.toRadians(60), HEX_W / 2, HEX_H / 2);</span>
        }

        // Up and Down Arrows
<span class="nc" id="L4754">        facingRotate.setToIdentity();</span>
<span class="nc" id="L4755">        facingRotate.translate(0, -31);</span>
<span class="nc" id="L4756">        upArrow = facingRotate.createTransformedShape(movementPolyTmp);</span>

<span class="nc" id="L4758">        facingRotate.setToIdentity();</span>
<span class="nc" id="L4759">        facingRotate.rotate(Math.toRadians(180), HEX_W / 2, HEX_H / 2);</span>
<span class="nc" id="L4760">        facingRotate.translate(0, -31);</span>
<span class="nc" id="L4761">        downArrow = facingRotate.createTransformedShape(movementPolyTmp);</span>
<span class="nc" id="L4762">    }</span>

    synchronized boolean doMoveUnits(long idleTime) {
<span class="nc" id="L4765">        boolean movingSomething = false;</span>

<span class="nc bnc" id="L4767" title="All 2 branches missed.">        if (movingUnits.size() &gt; 0) {</span>
<span class="nc" id="L4768">            moveWait += idleTime;</span>

<span class="nc bnc" id="L4770" title="All 2 branches missed.">            if (moveWait &gt; GUIPreferences.getInstance().getInt(</span>
                    &quot;AdvancedMoveStepDelay&quot;)) {

<span class="nc" id="L4773">                ArrayList&lt;MovingUnit&gt; spent = new ArrayList&lt;MovingUnit&gt;();</span>

<span class="nc bnc" id="L4775" title="All 2 branches missed.">                for (MovingUnit move : movingUnits) {</span>
<span class="nc" id="L4776">                    movingSomething = true;</span>
<span class="nc" id="L4777">                    Entity ge = game.getEntity(move.entity.getId());</span>
<span class="nc bnc" id="L4778" title="All 2 branches missed.">                    if (move.path.size() &gt; 0) {</span>

<span class="nc" id="L4780">                        UnitLocation loc = move.path.get(0);</span>

<span class="nc bnc" id="L4782" title="All 2 branches missed.">                        if (ge != null) {</span>
<span class="nc" id="L4783">                            redrawMovingEntity(move.entity, loc.getCoords(),</span>
<span class="nc" id="L4784">                                    loc.getFacing(), loc.getElevation());</span>
                        }
<span class="nc" id="L4786">                        move.path.remove(0);</span>
<span class="nc" id="L4787">                    } else {</span>
<span class="nc bnc" id="L4788" title="All 2 branches missed.">                        if (ge != null) {</span>
<span class="nc" id="L4789">                            redrawEntity(ge);</span>
                        }
<span class="nc" id="L4791">                        spent.add(move);</span>
                    }

<span class="nc" id="L4794">                }</span>

<span class="nc bnc" id="L4796" title="All 2 branches missed.">                for (MovingUnit move : spent) {</span>
<span class="nc" id="L4797">                    movingUnits.remove(move);</span>
<span class="nc" id="L4798">                }</span>
<span class="nc" id="L4799">                moveWait = 0;</span>

<span class="nc bnc" id="L4801" title="All 2 branches missed.">                if (movingUnits.size() == 0) {</span>
<span class="nc" id="L4802">                    movingEntitySpriteIds.clear();</span>
<span class="nc" id="L4803">                    movingEntitySprites.clear();</span>
<span class="nc" id="L4804">                    ghostEntitySprites.clear();</span>
<span class="nc" id="L4805">                    processBoardViewEvent(new BoardViewEvent(this,</span>
                            BoardViewEvent.FINISHED_MOVING_UNITS));
                }
            }
        }
<span class="nc" id="L4810">        return movingSomething;</span>
    }

    //
    // MouseListener
    //
    public void mousePressed(MouseEvent me) {
<span class="nc" id="L4817">        requestFocusInWindow();</span>
<span class="nc" id="L4818">        stopSoftCentering();</span>
<span class="nc" id="L4819">        Point point = me.getPoint();</span>
<span class="nc bnc" id="L4820" title="All 2 branches missed.">        if (null == point) {</span>
<span class="nc" id="L4821">            return;</span>
        }

        // Button 4: Hide/Show the minimap and unitDisplay
<span class="nc bnc" id="L4825" title="All 2 branches missed.">        if (me.getButton() == 4) {</span>
<span class="nc bnc" id="L4826" title="All 2 branches missed.">            if (clientgui != null) clientgui.toggleMMUDDisplays();</span>
        }

        // we clicked the right mouse button,
        // remember the position if we start to scroll
        // if we drag, we should scroll
<span class="nc bnc" id="L4832" title="All 2 branches missed.">        if (SwingUtilities.isRightMouseButton(me)) {</span>
<span class="nc" id="L4833">            scrollXDifference = me.getX();</span>
<span class="nc" id="L4834">            scrollYDifference = me.getY();</span>
<span class="nc" id="L4835">            shouldScroll = true;</span>
        }

<span class="nc bnc" id="L4838" title="All 4 branches missed.">        if (me.isPopupTrigger() &amp;&amp; !dragging) {</span>
<span class="nc" id="L4839">            mouseAction(getCoordsAt(point), BOARD_HEX_POPUP, me.getModifiers());</span>
<span class="nc" id="L4840">            return;</span>
        }
<span class="nc bnc" id="L4842" title="All 2 branches missed.">        for (int i = 0; i &lt; displayables.size(); i++) {</span>
<span class="nc" id="L4843">            IDisplayable disp = displayables.get(i);</span>
<span class="nc" id="L4844">            double width = scrollpane.getViewport().getSize()</span>
<span class="nc" id="L4845">                                     .getWidth();</span>
<span class="nc" id="L4846">            double height = scrollpane.getViewport().getSize()</span>
<span class="nc" id="L4847">                                      .getHeight();</span>
<span class="nc" id="L4848">            Dimension dispDimension = new Dimension();</span>
<span class="nc" id="L4849">            dispDimension.setSize(width, height);</span>
            // we need to adjust the point, because it should be against the
            // displayable dimension
<span class="nc" id="L4852">            Point dispPoint = new Point();</span>
<span class="nc" id="L4853">            dispPoint.setLocation(point.x + getBounds().x, point.y</span>
<span class="nc" id="L4854">                                                           + getBounds().y);</span>
<span class="nc bnc" id="L4855" title="All 2 branches missed.">            if (disp.isHit(dispPoint, dispDimension)) {</span>
<span class="nc" id="L4856">                return;</span>
            }
        }
<span class="nc" id="L4859">        mouseAction(getCoordsAt(point), BOARD_HEX_DRAG, me.getModifiers());</span>
<span class="nc" id="L4860">    }</span>

    public void mouseReleased(MouseEvent me) {
        // don't show the popup if we are drag-scrolling
<span class="nc bnc" id="L4864" title="All 4 branches missed.">        if (me.isPopupTrigger() &amp;&amp; !dragging) {</span>
<span class="nc" id="L4865">            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_POPUP,</span>
<span class="nc" id="L4866">                        me.getModifiers());</span>
            // stop scrolling
<span class="nc" id="L4868">            shouldScroll = false;</span>
<span class="nc" id="L4869">            return;</span>
        }

        // if we released the right mouse button, there's no more
        // scrolling
<span class="nc bnc" id="L4874" title="All 2 branches missed.">        if (SwingUtilities.isRightMouseButton(me)) {</span>
<span class="nc" id="L4875">            scrollXDifference = 0;</span>
<span class="nc" id="L4876">            scrollYDifference = 0;</span>
<span class="nc" id="L4877">            dragging = false;</span>
<span class="nc" id="L4878">            shouldScroll = false;</span>
<span class="nc" id="L4879">            setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));</span>
        }
<span class="nc bnc" id="L4881" title="All 2 branches missed.">        for (int i = 0; i &lt; displayables.size(); i++) {</span>
<span class="nc" id="L4882">            IDisplayable disp = displayables.get(i);</span>
<span class="nc bnc" id="L4883" title="All 2 branches missed.">            if (disp.isReleased()) {</span>
<span class="nc" id="L4884">                return;</span>
            }
        }

<span class="nc bnc" id="L4888" title="All 2 branches missed.">        if (me.getClickCount() == 1) {</span>
<span class="nc" id="L4889">            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_CLICK,</span>
<span class="nc" id="L4890">                        me.getModifiers());</span>
        } else {
<span class="nc" id="L4892">            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_DOUBLECLICK,</span>
<span class="nc" id="L4893">                        me.getModifiers());</span>
        }
<span class="nc" id="L4895">    }</span>

    public void mouseEntered(MouseEvent me) {
<span class="nc" id="L4898">    }</span>

    public void mouseExited(MouseEvent me) {
        // Reset the tooltip dismissal delay to the preference
        // value so that elements outside the boardview can
        // use tooltips
<span class="nc bnc" id="L4904" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getTooltipDismissDelay() &gt;= 0) {</span>
<span class="nc" id="L4905">            ToolTipManager.sharedInstance().setDismissDelay(</span>
<span class="nc" id="L4906">                    GUIPreferences.getInstance().getTooltipDismissDelay());</span>
        } else {
<span class="nc" id="L4908">            ToolTipManager.sharedInstance().setDismissDelay(dismissDelay);</span>
        }
<span class="nc" id="L4910">    }</span>

    public void mouseClicked(MouseEvent me) {
<span class="nc" id="L4913">    }</span>

    private class MovingUnit {
        public Entity entity;

        public ArrayList&lt;UnitLocation&gt; path;

<span class="nc" id="L4920">        MovingUnit(Entity entity, Vector&lt;UnitLocation&gt; path) {</span>
<span class="nc" id="L4921">            this.entity = entity;</span>
<span class="nc" id="L4922">            this.path = new ArrayList&lt;UnitLocation&gt;(path);</span>
<span class="nc" id="L4923">        }</span>
    }

    /**
     * Determine if the tile manager's images have been loaded.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all images have been loaded.
     * &lt;code&gt;false&lt;/code&gt; if more need to be loaded.
     */
    public boolean isTileImagesLoaded() {
<span class="nc" id="L4933">        return tileManager.isLoaded();</span>
    }

    public void setUseLOSTool(boolean use) {
<span class="nc" id="L4937">        useLOSTool = use;</span>
<span class="nc" id="L4938">    }</span>

    public TilesetManager getTilesetManager() {
<span class="nc" id="L4941">        return tileManager;</span>
    }

    /**
     * @param lastCursor The lastCursor to set.
     */
    public void setLastCursor(Coords lastCursor) {
<span class="nc" id="L4948">        this.lastCursor = lastCursor;</span>
<span class="nc" id="L4949">    }</span>

    /**
     * @return Returns the lastCursor.
     */
    public Coords getLastCursor() {
<span class="nc" id="L4955">        return lastCursor;</span>
    }

    /**
     * @param highlighted The highlighted to set.
     */
    public void setHighlighted(Coords highlighted) {
<span class="nc" id="L4962">        this.highlighted = highlighted;</span>
<span class="nc" id="L4963">    }</span>

    /**
     * @return Returns the highlighted.
     */
    public Coords getHighlighted() {
<span class="nc" id="L4969">        return highlighted;</span>
    }

    /**
     * @param selected The selected to set.
     */
    public void setSelected(Coords selected) {
<span class="nc bnc" id="L4976" title="All 2 branches missed.">        if (this.selected != selected) {</span>
<span class="nc" id="L4977">            this.selected = selected;</span>
<span class="nc" id="L4978">            checkFoVHexImageCacheClear();</span>
        }
<span class="nc" id="L4980">    }</span>

    /**
     * @return Returns the selected.
     */
    public Coords getSelected() {
<span class="nc" id="L4986">        return selected;</span>
    }

    /**
     * @param firstLOS The firstLOS to set.
     */
    public void setFirstLOS(Coords firstLOS) {
<span class="nc" id="L4993">        this.firstLOS = firstLOS;</span>
<span class="nc" id="L4994">    }</span>

    /**
     * @return Returns the firstLOS.
     */
    public Coords getFirstLOS() {
<span class="nc" id="L5000">        return firstLOS;</span>
    }

    /**
     * Determines if this Board contains the Coords, and if so, &quot;selects&quot; that
     * Coords.
     *
     * @param coords the Coords.
     */
    public void select(Coords coords) {
<span class="nc bnc" id="L5010" title="All 4 branches missed.">        if ((coords == null) || game.getBoard().contains(coords)) {</span>
<span class="nc" id="L5011">            setSelected(coords);</span>
<span class="nc" id="L5012">            moveCursor(selectedSprite, coords);</span>
<span class="nc" id="L5013">            moveCursor(firstLOSSprite, null);</span>
<span class="nc" id="L5014">            moveCursor(secondLOSSprite, null);</span>
<span class="nc" id="L5015">            processBoardViewEvent(new BoardViewEvent(this, coords, null,</span>
                                                     BoardViewEvent.BOARD_HEX_SELECTED, 0));
        }
<span class="nc" id="L5018">    }</span>

    /**
     * &quot;Selects&quot; the specified Coords.
     *
     * @param x the x coordinate.
     * @param y the y coordinate.
     */
    public void select(int x, int y) {
<span class="nc" id="L5027">        select(new Coords(x, y));</span>
<span class="nc" id="L5028">    }</span>

    /**
     * Determines if this Board contains the Coords, and if so, highlights that
     * Coords.
     *
     * @param coords the Coords.
     */
    public void highlight(Coords coords) {
<span class="nc bnc" id="L5037" title="All 4 branches missed.">        if ((coords == null) || game.getBoard().contains(coords)) {</span>
<span class="nc" id="L5038">            setHighlighted(coords);</span>
<span class="nc" id="L5039">            moveCursor(highlightSprite, coords);</span>
<span class="nc" id="L5040">            moveCursor(firstLOSSprite, null);</span>
<span class="nc" id="L5041">            moveCursor(secondLOSSprite, null);</span>
<span class="nc" id="L5042">            processBoardViewEvent(new BoardViewEvent(this, coords, null,</span>
                                                     BoardViewEvent.BOARD_HEX_HIGHLIGHTED, 0));
        }
<span class="nc" id="L5045">    }</span>

    public void setHighlightColor(Color c) {
<span class="nc" id="L5048">        highlightSprite.setColor(c);</span>
<span class="nc" id="L5049">        highlightSprite.prepare();</span>
<span class="nc" id="L5050">        repaint();</span>
<span class="nc" id="L5051">    }</span>

    /**
     * Highlights the specified Coords.
     *
     * @param x the x coordinate.
     * @param y the y coordinate.
     */
    public void highlight(int x, int y) {
<span class="nc" id="L5060">        highlight(new Coords(x, y));</span>
<span class="nc" id="L5061">    }</span>

    public synchronized void highlightSelectedEntity() {
<span class="nc bnc" id="L5064" title="All 2 branches missed.">        for (EntitySprite sprite: entitySprites) {</span>
<span class="nc bnc" id="L5065" title="All 2 branches missed.">            if (sprite.entity.equals(selectedEntity)) {</span>
<span class="nc" id="L5066">                sprite.setSelected(true);</span>
            } else {
<span class="nc" id="L5068">                sprite.setSelected(false);</span>
            }
<span class="nc" id="L5070">        }</span>
<span class="nc" id="L5071">    }</span>

    /**
     * Determines if this Board contains the Coords, and if so, &quot;cursors&quot; that
     * Coords.
     *
     * @param coords the Coords.
     */
    public void cursor(Coords coords) {
<span class="nc bnc" id="L5080" title="All 4 branches missed.">        if ((coords == null) || game.getBoard().contains(coords)) {</span>
<span class="nc bnc" id="L5081" title="All 4 branches missed.">            if ((getLastCursor() == null) || (coords == null)</span>
<span class="nc bnc" id="L5082" title="All 2 branches missed.">                || !coords.equals(getLastCursor())) {</span>
<span class="nc" id="L5083">                setLastCursor(coords);</span>
<span class="nc" id="L5084">                moveCursor(cursorSprite, coords);</span>
<span class="nc" id="L5085">                moveCursor(firstLOSSprite, null);</span>
<span class="nc" id="L5086">                moveCursor(secondLOSSprite, null);</span>
<span class="nc" id="L5087">                processBoardViewEvent(new BoardViewEvent(this, coords, null,</span>
                                                         BoardViewEvent.BOARD_HEX_CURSOR, 0));
            } else {
<span class="nc" id="L5090">                setLastCursor(coords);</span>
            }
        }
<span class="nc" id="L5093">    }</span>

    /**
     * &quot;Cursors&quot; the specified Coords.
     *
     * @param x the x coordinate.
     * @param y the y coordinate.
     */
    public void cursor(int x, int y) {
<span class="nc" id="L5102">        cursor(new Coords(x, y));</span>
<span class="nc" id="L5103">    }</span>

    public void checkLOS(Coords c) {
<span class="nc bnc" id="L5106" title="All 4 branches missed.">        if ((c == null) || game.getBoard().contains(c)) {</span>
<span class="nc bnc" id="L5107" title="All 2 branches missed.">            if (getFirstLOS() == null) {</span>
<span class="nc" id="L5108">                setFirstLOS(c);</span>
<span class="nc" id="L5109">                firstLOSHex(c);</span>
<span class="nc" id="L5110">                processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                                                         BoardViewEvent.BOARD_FIRST_LOS_HEX, 0));
            } else {
<span class="nc" id="L5113">                secondLOSHex(c, getFirstLOS());</span>
<span class="nc" id="L5114">                processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                                                         BoardViewEvent.BOARD_SECOND_LOS_HEX, 0));
<span class="nc" id="L5116">                setFirstLOS(null);</span>
            }
        }
<span class="nc" id="L5119">    }</span>

    /**
     * Determines if this Board contains the (x, y) Coords, and if so, notifies
     * listeners about the specified mouse action.
     */
    public void mouseAction(int x, int y, int mtype, int modifiers) {
<span class="nc bnc" id="L5126" title="All 2 branches missed.">        if (game.getBoard().contains(x, y)) {</span>
<span class="nc" id="L5127">            Coords c = new Coords(x, y);</span>
<span class="nc bnc" id="L5128" title="All 5 branches missed.">            switch (mtype) {</span>
                case BOARD_HEX_CLICK:
<span class="nc bnc" id="L5130" title="All 2 branches missed.">                    if ((modifiers &amp; java.awt.event.InputEvent.CTRL_MASK) != 0) {</span>
<span class="nc" id="L5131">                        checkLOS(c);</span>
                    } else {
<span class="nc" id="L5133">                        processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                                BoardViewEvent.BOARD_HEX_CLICKED, modifiers));
                    }
<span class="nc" id="L5136">                    break;</span>
                case BOARD_HEX_DOUBLECLICK:
<span class="nc" id="L5138">                    processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                            BoardViewEvent.BOARD_HEX_DOUBLECLICKED, modifiers));
<span class="nc" id="L5140">                    break;</span>
                case BOARD_HEX_DRAG:
<span class="nc" id="L5142">                    processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                            BoardViewEvent.BOARD_HEX_DRAGGED, modifiers));
<span class="nc" id="L5144">                    break;</span>
                case BOARD_HEX_POPUP:
<span class="nc" id="L5146">                    processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                            BoardViewEvent.BOARD_HEX_POPUP, modifiers));
                    break;
            }
        }
<span class="nc" id="L5151">    }</span>

    /**
     * Notifies listeners about the specified mouse action.
     *
     * @param coords the Coords.
     */
    public void mouseAction(Coords coords, int mtype, int modifiers) {
<span class="nc" id="L5159">        mouseAction(coords.getX(), coords.getY(), mtype, modifiers);</span>
<span class="nc" id="L5160">    }</span>

    /*
     * (non-Javadoc)
     *
     * @see
     * megamek.common.BoardListener#boardNewBoard(megamek.common.BoardEvent)
     */
    public void boardNewBoard(BoardEvent b) {
<span class="nc" id="L5169">        updateBoard();</span>
<span class="nc" id="L5170">        clearHexImageCache();</span>
<span class="nc" id="L5171">        clearShadowMap();</span>
<span class="nc" id="L5172">        repaint();</span>
<span class="nc" id="L5173">    }</span>

    /*
     * (non-Javadoc)
     *
     * @see
     * megamek.common.BoardListener#boardChangedHex(megamek.common.BoardEvent)
     */
    public void boardChangedHex(BoardEvent b) {
<span class="nc" id="L5182">        hexImageCache.remove(b.getCoords());</span>
        // Also repaint the surrounding hexes because of shadows, border etc.
<span class="nc bnc" id="L5184" title="All 2 branches missed.">        for (int dir: allDirections) { </span>
<span class="nc" id="L5185">            hexImageCache.remove(b.getCoords().translated(dir));</span>
        }
<span class="nc" id="L5187">        clearShadowMap();</span>
<span class="nc" id="L5188">        repaint();</span>
<span class="nc" id="L5189">    }</span>

    /*
     * (non-Javadoc)
     *
     * @see
     * megamek.common.BoardListener#boardChangedHex(megamek.common.BoardEvent)
     */
    public synchronized void boardChangedAllHexes(BoardEvent b) {
<span class="nc" id="L5198">        clearHexImageCache();</span>
<span class="nc" id="L5199">        clearShadowMap();</span>
<span class="nc" id="L5200">        repaint();</span>
<span class="nc" id="L5201">    }</span>

<span class="nc" id="L5203">    private GameListener gameListener = new GameListenerAdapter() {</span>

        @Override
        public void gameEntityNew(GameEntityNewEvent e) {
<span class="nc" id="L5207">            updateEcmList();</span>
<span class="nc" id="L5208">            redrawAllEntities();</span>
<span class="nc bnc" id="L5209" title="All 2 branches missed.">            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</span>
<span class="nc" id="L5210">                refreshMoveVectors();</span>
            }
<span class="nc" id="L5212">        }</span>

        @Override
        public void gameEntityRemove(GameEntityRemoveEvent e) {
<span class="nc" id="L5216">            updateEcmList();</span>
<span class="nc" id="L5217">            redrawAllEntities();</span>
<span class="nc bnc" id="L5218" title="All 2 branches missed.">            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</span>
<span class="nc" id="L5219">                refreshMoveVectors();</span>
            }
<span class="nc" id="L5221">        }</span>

        @Override
        public void gameEntityChange(GameEntityChangeEvent e) {
<span class="nc" id="L5225">            final Vector&lt;UnitLocation&gt; mp = e.getMovePath();</span>
<span class="nc" id="L5226">            final Entity en = e.getEntity();</span>
<span class="nc" id="L5227">            final GameOptions gopts = game.getOptions();</span>
<span class="nc" id="L5228">            GUIPreferences guip = GUIPreferences.getInstance();</span>

<span class="nc" id="L5230">            updateEcmList();</span>
            
            //For Entities that have converted to another mode, check for a different sprite
<span class="nc bnc" id="L5233" title="All 2 branches missed.">            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT</span>
<span class="nc bnc" id="L5234" title="All 2 branches missed.">                    &amp;&amp; en.isConvertingNow()) {</span>
<span class="nc" id="L5235">                tileManager.reloadImage(en);</span>
            }
            
            // for units that have been blown up, damaged or ejected, force a reload
<span class="nc bnc" id="L5239" title="All 2 branches missed.">            if((e.getOldEntity() != null) &amp;&amp;</span>
<span class="nc bnc" id="L5240" title="All 2 branches missed.">                    ((en.getDamageLevel() != e.getOldEntity().getDamageLevel()) ||</span>
<span class="nc bnc" id="L5241" title="All 2 branches missed.">                    (en.isDestroyed() != e.getOldEntity().isDestroyed()) ||</span>
<span class="nc bnc" id="L5242" title="All 2 branches missed.">                    (en.getCrew().isEjected() != e.getOldEntity().getCrew().isEjected()))) {</span>
<span class="nc" id="L5243">                tileManager.reloadImage(en);</span>
            }
            
<span class="nc" id="L5246">            redrawAllEntities();</span>
<span class="nc bnc" id="L5247" title="All 2 branches missed.">            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</span>
<span class="nc" id="L5248">                refreshMoveVectors();</span>
            }
<span class="nc bnc" id="L5250" title="All 6 branches missed.">            if ((mp != null) &amp;&amp; (mp.size() &gt; 0) &amp;&amp; guip.getShowMoveStep()</span>
<span class="nc bnc" id="L5251" title="All 2 branches missed.">                    &amp;&amp; !gopts.booleanOption(OptionsConstants.INIT_SIMULTANEOUS_MOVEMENT)) {</span>
<span class="nc bnc" id="L5252" title="All 2 branches missed.">                if ((localPlayer == null)</span>
<span class="nc bnc" id="L5253" title="All 2 branches missed.">                        || !game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L5254" title="All 2 branches missed.">                        || !en.getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L5255" title="All 2 branches missed.">                        || en.hasSeenEntity(localPlayer)) {</span>
<span class="nc" id="L5256">                    addMovingUnit(en, mp);</span>
                }
            }
<span class="nc" id="L5259">        }</span>

        @Override
        public void gameNewAction(GameNewActionEvent e) {
<span class="nc" id="L5263">            EntityAction ea = e.getAction();</span>
<span class="nc bnc" id="L5264" title="All 2 branches missed.">            if (ea instanceof AttackAction) {</span>
<span class="nc" id="L5265">                addAttack((AttackAction) ea);</span>
            }
<span class="nc" id="L5267">        }</span>

        @Override
        public void gameBoardNew(GameBoardNewEvent e) {
<span class="nc" id="L5271">            IBoard b = e.getOldBoard();</span>
<span class="nc bnc" id="L5272" title="All 2 branches missed.">            if (b != null) {</span>
<span class="nc" id="L5273">                b.removeBoardListener(BoardView1.this);</span>
            }
<span class="nc" id="L5275">            b = e.getNewBoard();</span>
<span class="nc bnc" id="L5276" title="All 2 branches missed.">            if (b != null) {</span>
<span class="nc" id="L5277">                b.addBoardListener(BoardView1.this);</span>
            }
<span class="nc" id="L5279">            boardBackgrounds.clear();</span>
<span class="nc bnc" id="L5280" title="All 2 branches missed.">            if (b.hasBoardBackground()) {</span>
<span class="nc" id="L5281">                ListIterator&lt;Boolean&gt; flipItHoriz = b.getFlipBGHoriz()</span>
<span class="nc" id="L5282">                        .listIterator();</span>
<span class="nc" id="L5283">                ListIterator&lt;Boolean&gt; flipItVert = b.getFlipBGVert()</span>
<span class="nc" id="L5284">                        .listIterator();</span>
<span class="nc bnc" id="L5285" title="All 2 branches missed.">                for (String path : b.getBackgroundPaths()) {</span>
<span class="nc" id="L5286">                    boolean flipHoriz = flipItHoriz.next();</span>
<span class="nc" id="L5287">                    boolean flipVert = flipItVert.next();</span>
<span class="nc bnc" id="L5288" title="All 2 branches missed.">                    if (path == null) {</span>
<span class="nc" id="L5289">                        boardBackgrounds.add(null);</span>
                    } else {
<span class="nc" id="L5291">                        Image bgImg = ImageUtil.loadImageFromFile(path);</span>
<span class="nc" id="L5292">                        ImageProducer prod = bgImg.getSource();</span>
<span class="nc bnc" id="L5293" title="All 4 branches missed.">                        if (flipHoriz || flipVert) {</span>
<span class="nc" id="L5294">                            AffineTransform at = new AffineTransform();</span>

<span class="nc bnc" id="L5296" title="All 2 branches missed.">                            if (flipHoriz) {</span>
<span class="nc" id="L5297">                                at.concatenate(AffineTransform</span>
<span class="nc" id="L5298">                                        .getScaleInstance(1, -1));</span>
                            }
<span class="nc bnc" id="L5300" title="All 2 branches missed.">                            if (flipVert) {</span>
<span class="nc" id="L5301">                                at.concatenate(AffineTransform</span>
<span class="nc" id="L5302">                                        .getTranslateInstance(0,</span>
<span class="nc" id="L5303">                                                -bgImg.getHeight(null)));</span>
                            }
<span class="nc" id="L5305">                            ((Graphics2D) bgImg.getGraphics()).setTransform(at);</span>
                        }
<span class="nc" id="L5307">                        boardBackgrounds.add(Toolkit.getDefaultToolkit()</span>
<span class="nc" id="L5308">                                .createImage(prod));</span>
                    }
<span class="nc" id="L5310">                }</span>
            }
<span class="nc" id="L5312">            clearHexImageCache();</span>
<span class="nc" id="L5313">            updateBoard();</span>
<span class="nc" id="L5314">            clearShadowMap();</span>
<span class="nc" id="L5315">        }</span>

        @Override
        public void gameBoardChanged(GameBoardChangeEvent e) {
<span class="nc" id="L5319">            clearHexImageCache();</span>
<span class="nc" id="L5320">            boardChanged();</span>
<span class="nc" id="L5321">        }</span>

        @Override
        public void gamePhaseChange(GamePhaseChangeEvent e) {
<span class="nc bnc" id="L5325" title="All 4 branches missed.">            if (GUIPreferences.getInstance().getGameSummaryBoardView() &amp;&amp; ((e.getOldPhase() == Phase.PHASE_DEPLOYMENT)</span>
<span class="nc bnc" id="L5326" title="All 4 branches missed.">                    || (e.getOldPhase() == Phase.PHASE_MOVEMENT) || (e.getOldPhase() == Phase.PHASE_TARGETING)</span>
<span class="nc bnc" id="L5327" title="All 4 branches missed.">                    || (e.getOldPhase() == Phase.PHASE_FIRING) || (e.getOldPhase() == Phase.PHASE_PHYSICAL))) {</span>
<span class="nc" id="L5328">                File dir = new File(Configuration.gameSummaryImagesBVDir(), game.getUUIDString());</span>
<span class="nc bnc" id="L5329" title="All 2 branches missed.">                if (!dir.exists()) {</span>
<span class="nc" id="L5330">                    dir.mkdirs();</span>
                }
<span class="nc" id="L5332">                File imgFile = new File(dir, &quot;round_&quot; + game.getRoundCount() + &quot;_&quot; + e.getOldPhase().ordinal() + &quot;_&quot;</span>
<span class="nc" id="L5333">                        + IGame.Phase.getDisplayableName(e.getOldPhase()) + &quot;.png&quot;);</span>
                try {
<span class="nc" id="L5335">                    ImageIO.write(getEntireBoardImage(false), &quot;png&quot;, imgFile);</span>
<span class="nc" id="L5336">                } catch (IOException e1) {</span>
<span class="nc" id="L5337">                    e1.printStackTrace();</span>
<span class="nc" id="L5338">                }</span>
            }

<span class="nc" id="L5341">            refreshAttacks();</span>

            // Clear some information regardless of what phase it is
<span class="nc" id="L5344">            clearFiringSolutionData();</span>
<span class="nc" id="L5345">            clearMovementEnvelope();</span>

<span class="nc bnc" id="L5347" title="All 7 branches missed.">            switch (e.getNewPhase()) {</span>
                case PHASE_MOVEMENT:
<span class="nc" id="L5349">                    refreshMoveVectors();</span>
                case PHASE_FIRING:
<span class="nc" id="L5351">                    clearAllMoveVectors();</span>
                case PHASE_PHYSICAL:
<span class="nc" id="L5353">                    refreshAttacks();</span>
<span class="nc" id="L5354">                    break;</span>
                case PHASE_INITIATIVE:
<span class="nc" id="L5356">                    clearAllAttacks();</span>
<span class="nc" id="L5357">                    break;</span>
                case PHASE_END:
                case PHASE_VICTORY:
<span class="nc" id="L5360">                    clearSprites();</span>
                case PHASE_LOUNGE:
<span class="nc" id="L5362">                    clearHexImageCache();</span>
<span class="nc" id="L5363">                    clearAllMoveVectors();</span>
<span class="nc" id="L5364">                    clearAllAttacks();</span>
<span class="nc" id="L5365">                    clearSprites();</span>
<span class="nc" id="L5366">                    select(null);</span>
<span class="nc" id="L5367">                    cursor(null);</span>
<span class="nc" id="L5368">                    highlight(null);</span>
                default:
            }
<span class="nc bnc" id="L5371" title="All 2 branches missed.">            for (Entity en: game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L5372" title="All 6 branches missed.">                if ((en.getDamageLevel() != Entity.DMG_NONE) &amp;&amp; </span>
                        ((en.damageThisRound != 0) || (en instanceof GunEmplacement))) {
<span class="nc" id="L5374">                    tileManager.reloadImage(en);</span>
                }
<span class="nc" id="L5376">            }</span>

<span class="nc" id="L5378">        }</span>
    };

    synchronized void boardChanged() {
<span class="nc" id="L5382">        redrawAllEntities();</span>
<span class="nc" id="L5383">        redrawAllFlares();</span>
<span class="nc" id="L5384">    }</span>

    void clearSprites() {
<span class="nc" id="L5387">        pathSprites.clear();</span>
<span class="nc" id="L5388">        firingSprites.clear();</span>
<span class="nc" id="L5389">        attackSprites.clear();</span>
<span class="nc" id="L5390">        c3Sprites.clear();</span>
<span class="nc" id="L5391">        vtolAttackSprites.clear();</span>
<span class="nc" id="L5392">        flyOverSprites.clear();</span>
<span class="nc" id="L5393">        movementSprites.clear();</span>
<span class="nc" id="L5394">        fieldofFireSprites.clear();</span>
<span class="nc" id="L5395">    }</span>

    public synchronized void updateBoard() {
<span class="nc" id="L5398">        updateBoardSize();</span>
<span class="nc" id="L5399">        redrawAllEntities();</span>
<span class="nc" id="L5400">    }</span>

    /**
     * the old redrawworker converted to a runnable which is called now and then
     * from the event thread
     */
<span class="nc" id="L5406">    protected class RedrawWorker implements Runnable {</span>

<span class="nc" id="L5408">        protected long lastTime = System.currentTimeMillis();</span>

<span class="nc" id="L5410">        protected long currentTime = System.currentTimeMillis();</span>

        public void run() {
<span class="nc" id="L5413">            currentTime = System.currentTimeMillis();</span>
<span class="nc bnc" id="L5414" title="All 2 branches missed.">            if (isShowing()) {</span>
<span class="nc" id="L5415">                boolean redraw = false;</span>
<span class="nc bnc" id="L5416" title="All 2 branches missed.">                for (int i = 0; i &lt; displayables.size(); i++) {</span>
<span class="nc" id="L5417">                    IDisplayable disp = displayables.get(i);</span>
<span class="nc bnc" id="L5418" title="All 2 branches missed.">                    if (!disp.isSliding()) {</span>
<span class="nc" id="L5419">                        disp.setIdleTime(currentTime - lastTime, true);</span>
                    } else {
<span class="nc bnc" id="L5421" title="All 4 branches missed.">                        redraw = redraw || disp.slide();</span>
                    }
                }
<span class="nc bnc" id="L5424" title="All 4 branches missed.">                redraw = redraw || doMoveUnits(currentTime - lastTime);</span>
<span class="nc bnc" id="L5425" title="All 2 branches missed.">                if (redraw) {</span>
<span class="nc" id="L5426">                    repaint();</span>
                }
<span class="nc" id="L5428">                centerOnHexSoftStep(currentTime - lastTime);</span>
            }
<span class="nc" id="L5430">            lastTime = currentTime;</span>
<span class="nc" id="L5431">        }</span>
    }

    public synchronized void selectEntity(Entity e) {
<span class="nc" id="L5435">        selectedEntity = e;</span>
<span class="nc" id="L5436">        checkFoVHexImageCacheClear();</span>
        // If we don't do this, the selectedWeapon might not correspond to this
        // entity
<span class="nc" id="L5439">        selectedWeapon = null;</span>
<span class="nc" id="L5440">        updateEcmList();</span>
<span class="nc" id="L5441">        highlightSelectedEntity();</span>
<span class="nc" id="L5442">    }</span>

    public synchronized void weaponSelected(MechDisplayEvent b) {
<span class="nc" id="L5445">        selectedEntity = b.getEntity();</span>
<span class="nc" id="L5446">        selectedWeapon = b.getEquip();</span>
<span class="nc" id="L5447">        repaint();</span>
<span class="nc" id="L5448">    }</span>

    /**
     *  Updates maps that determine how to shade hexes affected by E(C)CM. This
     *  is expensive, so precalculate only when entity changes occur
     **/
    public void updateEcmList() {
<span class="nc" id="L5455">        Map&lt;Coords, Color&gt; newECMHexes = new HashMap&lt;Coords, Color&gt;();</span>
<span class="nc" id="L5456">        Map&lt;Coords, Color&gt; newECMCenters = new HashMap&lt;Coords, Color&gt;();</span>
<span class="nc" id="L5457">        Map&lt;Coords, Color&gt; newECCMHexes = new HashMap&lt;Coords, Color&gt;();</span>
<span class="nc" id="L5458">        Map&lt;Coords, Color&gt; newECCMCenters = new HashMap&lt;Coords, Color&gt;();</span>

        // Compute info about all E(C)CM on the board
<span class="nc" id="L5461">        final List&lt;ECMInfo&gt; allEcmInfo = ComputeECM</span>
<span class="nc" id="L5462">                .computeAllEntitiesECMInfo(game.getEntitiesVector());</span>

        // First, mark the sources of E(C)CM
        // Used for highlighting hexes and tooltips
<span class="nc bnc" id="L5466" title="All 2 branches missed.">        for (Entity e : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L5467" title="All 2 branches missed.">            if (e.getPosition() == null) {</span>
<span class="nc" id="L5468">                continue;</span>
            }
            // If this unit isn't spotted somehow, it's ECM doesn't show up
<span class="nc bnc" id="L5471" title="All 2 branches missed.">            if ((localPlayer != null)</span>
<span class="nc bnc" id="L5472" title="All 2 branches missed.">                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L5473" title="All 2 branches missed.">                    &amp;&amp; e.getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L5474" title="All 2 branches missed.">                    &amp;&amp; !e.hasSeenEntity(localPlayer)</span>
<span class="nc bnc" id="L5475" title="All 2 branches missed.">                    &amp;&amp; !e.hasDetectedEntity(localPlayer)) {</span>
<span class="nc" id="L5476">                continue;</span>
            }

<span class="nc" id="L5479">            final Color ecmColor = ECMEffects.getECMColor(e.getOwner());</span>
            // Update ECM center information
<span class="nc bnc" id="L5481" title="All 2 branches missed.">            if (e.getECMInfo() != null) {</span>
<span class="nc" id="L5482">                newECMCenters.put(e.getPosition(), ecmColor);</span>
            }
            // Update ECCM center information
<span class="nc bnc" id="L5485" title="All 2 branches missed.">            if (e.getECCMInfo() != null) {</span>
<span class="nc" id="L5486">                newECCMCenters.put(e.getPosition(), ecmColor);</span>
            }
            // Update Entity sprite's ECM status
<span class="nc" id="L5489">            int secondaryIdx = -1;</span>
<span class="nc bnc" id="L5490" title="All 2 branches missed.">            if (e.getSecondaryPositions().size() &gt; 0) {</span>
<span class="nc" id="L5491">                secondaryIdx = 0;</span>
            }
<span class="nc" id="L5493">            EntitySprite eSprite = entitySpriteIds.get(getIdAndLoc(e.getId(),</span>
                    secondaryIdx));
<span class="nc bnc" id="L5495" title="All 2 branches missed.">            if (eSprite != null) {</span>
<span class="nc" id="L5496">                Coords pos = e.getPosition();</span>
<span class="nc" id="L5497">                eSprite.setAffectedByECM(ComputeECM.isAffectedByECM(e, pos,</span>
                        pos, allEcmInfo));
            }
<span class="nc" id="L5500">        }</span>

        // Keep track of allied ECM and enemy ECCM
<span class="nc" id="L5503">        Map&lt;Coords, ECMEffects&gt; ecmAffectedCoords =</span>
                new HashMap&lt;Coords, ECMEffects&gt;();
        // Keep track of allied ECCM and enemy ECM
<span class="nc" id="L5506">        Map&lt;Coords, ECMEffects&gt; eccmAffectedCoords =</span>
                new HashMap&lt;Coords, ECMEffects&gt;();
<span class="nc bnc" id="L5508" title="All 2 branches missed.">        for (ECMInfo ecmInfo : allEcmInfo) {</span>
            // Can't see ECM field of unspotted unit
<span class="nc bnc" id="L5510" title="All 4 branches missed.">            if ((ecmInfo.getEntity() != null) &amp;&amp; (localPlayer != null)</span>
<span class="nc bnc" id="L5511" title="All 2 branches missed.">                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L5512" title="All 2 branches missed.">                    &amp;&amp; ecmInfo.getEntity().getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L5513" title="All 2 branches missed.">                    &amp;&amp; !ecmInfo.getEntity().hasSeenEntity(localPlayer)</span>
<span class="nc bnc" id="L5514" title="All 2 branches missed.">                    &amp;&amp; !ecmInfo.getEntity().hasDetectedEntity(localPlayer)) {</span>
<span class="nc" id="L5515">                continue;</span>
            }
<span class="nc" id="L5517">            final Coords ecmPos = ecmInfo.getPos();</span>
<span class="nc" id="L5518">            final int range = ecmInfo.getRange();</span>

            // Add each Coords within range to the list of ECM Coords
<span class="nc bnc" id="L5521" title="All 2 branches missed.">            for (int x = -range; x &lt;= range; x++) {</span>
<span class="nc bnc" id="L5522" title="All 2 branches missed.">                for (int y = -range; y &lt;= range; y++) {</span>
<span class="nc" id="L5523">                    Coords c = new Coords(x + ecmPos.getX(), y + ecmPos.getY());</span>
<span class="nc" id="L5524">                    int dist = ecmPos.distance(c);</span>
<span class="nc" id="L5525">                    int dir = ecmInfo.getDirection();</span>
                    // Direction is the facing of the owning Entity
<span class="nc bnc" id="L5527" title="All 2 branches missed.">                    boolean inArc = (dir == -1)</span>
                            || Compute
<span class="nc bnc" id="L5529" title="All 2 branches missed.">                                    .isInArc(ecmPos, dir, c, Compute.ARC_NOSE);</span>
<span class="nc bnc" id="L5530" title="All 4 branches missed.">                    if ((dist &gt; range) || !inArc) {</span>
<span class="nc" id="L5531">                        continue;</span>
                    }

                    // Check for allied ECCM or enemy ECM
<span class="nc bnc" id="L5535" title="All 4 branches missed.">                    if ((!ecmInfo.isOpposed(localPlayer) &amp;&amp; ecmInfo.isECCM())</span>
<span class="nc bnc" id="L5536" title="All 4 branches missed.">                            || (ecmInfo.isOpposed(localPlayer) &amp;&amp; ecmInfo.isECCM())) {</span>
<span class="nc" id="L5537">                        ECMEffects ecmEffects = eccmAffectedCoords.get(c);</span>
<span class="nc bnc" id="L5538" title="All 2 branches missed.">                        if (ecmEffects == null) {</span>
<span class="nc" id="L5539">                            ecmEffects = new ECMEffects();</span>
<span class="nc" id="L5540">                            eccmAffectedCoords.put(c, ecmEffects);</span>
                        }
<span class="nc" id="L5542">                        ecmEffects.addECM(ecmInfo);</span>
<span class="nc" id="L5543">                    } else {</span>
<span class="nc" id="L5544">                        ECMEffects ecmEffects = ecmAffectedCoords.get(c);</span>
<span class="nc bnc" id="L5545" title="All 2 branches missed.">                        if (ecmEffects == null) {</span>
<span class="nc" id="L5546">                            ecmEffects = new ECMEffects();</span>
<span class="nc" id="L5547">                            ecmAffectedCoords.put(c, ecmEffects);</span>
                        }
<span class="nc" id="L5549">                        ecmEffects.addECM(ecmInfo);</span>
                    }
                }
            }
<span class="nc" id="L5553">        }</span>

        // Finally, determine the color for each affected hex
<span class="nc bnc" id="L5556" title="All 2 branches missed.">        for (Coords c : ecmAffectedCoords.keySet()) {</span>
<span class="nc" id="L5557">            ECMEffects ecm = ecmAffectedCoords.get(c);</span>
<span class="nc" id="L5558">            ECMEffects eccm = eccmAffectedCoords.get(c);</span>
<span class="nc" id="L5559">            processAffectedCoords(c, ecm, eccm, newECMHexes, newECCMHexes);</span>
<span class="nc" id="L5560">        }</span>
<span class="nc bnc" id="L5561" title="All 2 branches missed.">        for (Coords c : eccmAffectedCoords.keySet()) {</span>
<span class="nc" id="L5562">            ECMEffects ecm = ecmAffectedCoords.get(c);</span>
<span class="nc" id="L5563">            ECMEffects eccm = eccmAffectedCoords.get(c);</span>
            // Already processed all ECM affected coords
<span class="nc bnc" id="L5565" title="All 2 branches missed.">            if (ecm != null) {</span>
<span class="nc" id="L5566">             continue;</span>
            }
<span class="nc" id="L5568">            processAffectedCoords(c, ecm, eccm, newECMHexes, newECCMHexes);</span>
<span class="nc" id="L5569">        }</span>

<span class="nc" id="L5571">        Set&lt;Coords&gt; updatedHexes = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L5572" title="All 2 branches missed.">        if (ecmHexes != null) {</span>
<span class="nc" id="L5573">            updatedHexes.addAll(ecmHexes.keySet());</span>
        }
<span class="nc bnc" id="L5575" title="All 2 branches missed.">        if (eccmHexes != null) {</span>
<span class="nc" id="L5576">            updatedHexes.addAll(eccmHexes.keySet());</span>
        }
<span class="nc" id="L5578">        updatedHexes.addAll(newECMHexes.keySet());</span>
<span class="nc" id="L5579">        updatedHexes.addAll(newECCMHexes.keySet());</span>
<span class="nc" id="L5580">        clearHexImageCache(updatedHexes);</span>

<span class="nc" id="L5582">        synchronized (this) {</span>
<span class="nc" id="L5583">            ecmHexes    = newECMHexes;</span>
<span class="nc" id="L5584">            ecmCenters  = newECMCenters;</span>
<span class="nc" id="L5585">            eccmHexes   = newECCMHexes;</span>
<span class="nc" id="L5586">            eccmCenters = newECCMCenters;</span>
<span class="nc" id="L5587">        }</span>

<span class="nc" id="L5589">        repaint();</span>
<span class="nc" id="L5590">    }</span>

    private void processAffectedCoords(Coords c, ECMEffects ecm,
            ECMEffects eccm, Map&lt;Coords, Color&gt; newECMHexes,
            Map&lt;Coords, Color&gt; newECCMHexes) {
<span class="nc" id="L5595">        Color hexColorECM = null;</span>
<span class="nc bnc" id="L5596" title="All 2 branches missed.">        if (ecm != null) {</span>
<span class="nc" id="L5597">            hexColorECM = ecm.getHexColor();</span>
        }
<span class="nc" id="L5599">        Color hexColorECCM = null;</span>
<span class="nc bnc" id="L5600" title="All 2 branches missed.">        if (eccm != null) {</span>
<span class="nc" id="L5601">            hexColorECCM = eccm.getHexColor();</span>
        }
        // Hex color is null if all effects cancel out
<span class="nc bnc" id="L5604" title="All 4 branches missed.">        if ((hexColorECM == null) &amp;&amp; (hexColorECCM == null)) {</span>
<span class="nc" id="L5605">            return;</span>
<span class="nc bnc" id="L5606" title="All 4 branches missed.">        } else if ((hexColorECM != null) &amp;&amp; (hexColorECCM == null)) {</span>
<span class="nc bnc" id="L5607" title="All 2 branches missed.">            if (ecm.isECCM()) {</span>
<span class="nc" id="L5608">                newECCMHexes.put(c, hexColorECM);</span>
            } else {
<span class="nc" id="L5610">                newECMHexes.put(c, hexColorECM);</span>
            }
<span class="nc bnc" id="L5612" title="All 4 branches missed.">        } else if ((hexColorECM == null) &amp;&amp; (hexColorECCM != null)) {</span>
<span class="nc bnc" id="L5613" title="All 2 branches missed.">            if (eccm.isECCM()) {</span>
<span class="nc" id="L5614">                newECCMHexes.put(c, hexColorECCM);</span>
            } else {
<span class="nc" id="L5616">                newECMHexes.put(c, hexColorECCM);</span>
            }
        } else { // Both are non-null
<span class="nc" id="L5619">            newECMHexes.put(c, hexColorECM);</span>
<span class="nc" id="L5620">            newECCMHexes.put(c, hexColorECCM);</span>
        }
<span class="nc" id="L5622">    }</span>

    public Dimension getPreferredScrollableViewportSize() {
<span class="nc" id="L5625">        return getPreferredSize();</span>
    }

    public int getScrollableBlockIncrement(Rectangle arg0, int arg1, int arg2) {
<span class="nc" id="L5629">        final Dimension size = scrollpane.getViewport().getSize();</span>
<span class="nc bnc" id="L5630" title="All 2 branches missed.">        if (arg1 == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L5631">            return size.height;</span>
        }
<span class="nc" id="L5633">        return size.width;</span>
    }

    public boolean getScrollableTracksViewportHeight() {
<span class="nc" id="L5637">        return false;</span>
    }

    public boolean getScrollableTracksViewportWidth() {
<span class="nc" id="L5641">        return false;</span>
    }

    public int getScrollableUnitIncrement(Rectangle arg0, int arg1, int arg2) {
<span class="nc bnc" id="L5645" title="All 2 branches missed.">        if (arg1 == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L5646">            return (int) ((scale * HEX_H) / 2.0);</span>
        }
<span class="nc" id="L5648">        return (int) ((scale * HEX_W) / 2.0);</span>
    }

    @Override
    public void setPreferredSize(Dimension d) {
<span class="nc" id="L5653">        super.setPreferredSize(d);</span>
<span class="nc" id="L5654">        preferredSize = new Dimension(d);</span>
<span class="nc" id="L5655">    }</span>

    @Override
    public Dimension getPreferredSize() {
        // If the board is small, we want the preferred size to fill the whole
        //  ScrollPane viewport, for purposes of drawing the tiled background
        //  icon.
        // However, we also need the scrollable client to be as big as the
        //  board plus the pad size.
<span class="nc" id="L5664">        return new Dimension(</span>
<span class="nc" id="L5665">                Math.max(boardSize.width + (2 * HEX_W), preferredSize.width),</span>
<span class="nc" id="L5666">                Math.max(boardSize.height + (2 * HEX_W), preferredSize.height));</span>
    }

    /**
     * Have the player select an Entity from the entities at the given coords.
     *
     * @param pos - the &lt;code&gt;Coords&lt;/code&gt; containing targets.
     */
    private Entity chooseEntity(Coords pos) {

        // Assume that we have *no* choice.
<span class="nc" id="L5677">        Entity choice = null;</span>

        // Get the available choices.
<span class="nc" id="L5680">        List&lt;Entity&gt; entities = game.getEntitiesVector(pos);</span>


        // Do we have a single choice?
<span class="nc bnc" id="L5684" title="All 2 branches missed.">        if (entities.size() == 1) {</span>
            // Return that choice.
<span class="nc" id="L5686">            choice = entities.get(0);</span>
        }

        // If we have multiple choices, display a selection dialog.
<span class="nc bnc" id="L5690" title="All 2 branches missed.">        else if (entities.size() &gt; 1) {</span>
<span class="nc" id="L5691">            String input = (String) JOptionPane</span>
<span class="nc" id="L5692">                    .showInputDialog(</span>
                            null,
<span class="nc" id="L5694">                            Messages.getString(</span>
<span class="nc" id="L5695">                                    &quot;BoardView1.ChooseEntityDialog.message&quot;, new Object[]{pos.getBoardNum()}), //$NON-NLS-1$</span>
<span class="nc" id="L5696">                            Messages.getString(&quot;BoardView1.ChooseEntityDialog.title&quot;), //$NON-NLS-1$</span>
                            JOptionPane.QUESTION_MESSAGE, null, SharedUtility
<span class="nc" id="L5698">                                    .getDisplayArray(entities), null);</span>
<span class="nc" id="L5699">            choice = (Entity) SharedUtility.getTargetPicked(entities, input);</span>
        } // End have-choices

        // Return the chosen unit.
<span class="nc" id="L5703">        return choice;</span>
    }


    /**
     * The text to be displayed when the mouse is at a certain point.
     */
    @Override
    public String getToolTipText(MouseEvent e) {
        // If new instance of mouse event, redraw obscured hexes and elevations.
<span class="nc" id="L5713">        repaint();</span>

<span class="nc" id="L5715">        StringBuffer txt = new StringBuffer();</span>
<span class="nc" id="L5716">        IHex mhex = null;</span>
<span class="nc" id="L5717">        final Point point = e.getPoint();</span>
<span class="nc bnc" id="L5718" title="All 4 branches missed.">        if (prevTipX &gt; 0 &amp;&amp; prevTipY &gt; 0) {</span>
<span class="nc" id="L5719">            int deltaX = point.x - prevTipX;</span>
<span class="nc" id="L5720">            int deltaY = point.y - prevTipY;</span>
<span class="nc" id="L5721">            double deltaMagnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);</span>
<span class="nc bnc" id="L5722" title="All 2 branches missed.">            if (deltaMagnitude &gt; GUIPreferences.getInstance().getTooltipDistSuppression()) {</span>
<span class="nc" id="L5723">                prevTipX = -1; prevTipY = -1;</span>
                // Set the dismissal delay to 0 so that the tooltip
                // goes away and does not reappear until the mouse
                // has moved more than the suppression distance
<span class="nc" id="L5727">                ToolTipManager.sharedInstance().setDismissDelay(0);</span>
<span class="nc" id="L5728">                return new String(&quot;&quot;); //$NON-NLS-1$</span>
            }
        }
<span class="nc" id="L5731">        prevTipX = point.x; prevTipY = point.y;</span>
<span class="nc" id="L5732">        final Coords mcoords = getCoordsAt(point);</span>
<span class="nc" id="L5733">        final ArrayList&lt;ArtilleryAttackAction&gt; artilleryAttacks =</span>
<span class="nc" id="L5734">                getArtilleryAttacksAtLocation(mcoords);</span>
<span class="nc" id="L5735">        final Mounted curWeapon = getSelectedArtilleryWeapon();</span>

<span class="nc bnc" id="L5737" title="All 2 branches missed.">        if (game.getBoard().contains(mcoords))</span>
<span class="nc" id="L5738">            mhex = game.getBoard().getHex(mcoords);</span>

<span class="nc" id="L5740">        txt.append(&quot;&lt;html&gt;&quot;); //$NON-NLS-1$</span>


        // Hex Terrain
<span class="nc bnc" id="L5744" title="All 4 branches missed.">        if (GUIPreferences.getInstance().getShowMapHexPopup() &amp;&amp; (mhex != null)) {</span>

<span class="nc" id="L5746">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#DDFFDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>

<span class="nc" id="L5748">            txt.append(Messages.getString(&quot;BoardView1.Tooltip.Hex&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5749">                    new Object[] { mcoords.getBoardNum(), mhex.getLevel() }));</span>
<span class="nc" id="L5750">            txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>

            // cycle through the terrains and report types found
            // this will skip buildings and other constructed units
<span class="nc" id="L5754">            int terrainTypes[] = mhex.getTerrainTypes();</span>
<span class="nc bnc" id="L5755" title="All 2 branches missed.">            for (int i = 0; i &lt; terrainTypes.length; i++) {</span>
<span class="nc" id="L5756">                int terType = terrainTypes[i];</span>
<span class="nc bnc" id="L5757" title="All 2 branches missed.">                if (mhex.containsTerrain(terType)) {</span>
<span class="nc" id="L5758">                    int tf = mhex.getTerrain(terType).getTerrainFactor();</span>
<span class="nc" id="L5759">                    int ttl = mhex.getTerrain(terType).getLevel();</span>
<span class="nc" id="L5760">                    String name = Terrains.getDisplayName(terType, ttl);</span>
<span class="nc bnc" id="L5761" title="All 2 branches missed.">                    if (tf &gt; 0) {</span>
<span class="nc" id="L5762">                        name = name + &quot; (TF: &quot; + tf + &quot;)&quot;; //$NON-NLS-1$ //$NON-NLS-2$</span>
                    }
<span class="nc bnc" id="L5764" title="All 2 branches missed.">                    if (name != null) {</span>
<span class="nc" id="L5765">                        txt.append(name);</span>
<span class="nc" id="L5766">                        txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
                    }
                }
            }
<span class="nc" id="L5770">            txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>

            // Distance from the selected unit and a planned movement end point
<span class="nc bnc" id="L5773" title="All 2 branches missed.">            if ((selectedEntity != null) &amp;&amp;</span>
<span class="nc bnc" id="L5774" title="All 2 branches missed.">                    (selectedEntity.getPosition() != null)) {</span>
<span class="nc" id="L5775">                int distance = selectedEntity</span>
<span class="nc" id="L5776">                        .getPosition()</span>
<span class="nc" id="L5777">                        .distance(mcoords);</span>
<span class="nc" id="L5778">                txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#FFDDDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L5779" title="All 2 branches missed.">                if (distance == 1) {</span>
<span class="nc" id="L5780">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Distance1&quot;)); //$NON-NLS-1$</span>
                } else {
<span class="nc" id="L5782">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.DistanceN&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5783">                            new Object[] { distance }));</span>
                }

<span class="nc bnc" id="L5786" title="All 2 branches missed.">                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {</span>
<span class="nc" id="L5787">                    LosEffects los = fovHighlightingAndDarkening.getCachedLosEffects(selectedEntity.getPosition(), mcoords);</span>
<span class="nc" id="L5788">                    int bracket = Compute.getSensorRangeBracket(selectedEntity, null,</span>
                            fovHighlightingAndDarkening.cachedAllECMInfo);
<span class="nc" id="L5790">                    int range = Compute.getSensorRangeByBracket(game, selectedEntity, null, los);</span>

<span class="nc" id="L5792">                    int maxSensorRange = bracket * range;</span>
<span class="nc" id="L5793">                    int minSensorRange = Math.max((bracket - 1) * range, 0);</span>
<span class="nc bnc" id="L5794" title="All 2 branches missed.">                    if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_INCLUSIVE_SENSOR_RANGE)) {</span>
<span class="nc" id="L5795">                        minSensorRange = 0;</span>
                    }
<span class="nc" id="L5797">                    txt.append(&quot;&lt;BR&gt;&quot;);</span>
<span class="nc bnc" id="L5798" title="All 4 branches missed.">                    if ((distance &gt; minSensorRange) &amp;&amp; (distance &lt;= maxSensorRange)) {</span>
<span class="nc" id="L5799">                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.SensorsHexInRange&quot;));</span>
                    } else {
<span class="nc" id="L5801">                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.SensorsHexNotInRange&quot;));</span>
                    }
                }

<span class="nc bnc" id="L5805" title="All 4 branches missed.">                if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp;</span>
                        (movementTarget != null)) {
<span class="nc" id="L5807">                    txt.append(&quot;&lt;BR&gt;&quot;);</span>
<span class="nc" id="L5808">                    int disPM = movementTarget.distance(mcoords);</span>
<span class="nc bnc" id="L5809" title="All 2 branches missed.">                    if (disPM == 1) {</span>
<span class="nc" id="L5810">                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.DistanceMove1&quot;)); //$NON-NLS-1$</span>
                    } else {
<span class="nc" id="L5812">                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.DistanceMoveN&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5813">                                new Object[] { disPM }));</span>
                    }
                }

<span class="nc" id="L5817">                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
            }

            // Fuel Tank
<span class="nc bnc" id="L5821" title="All 2 branches missed.">            if (mhex.containsTerrain(Terrains.FUEL_TANK)) {</span>
                // In the BoardEditor, buildings have no entry in the
                // buildings list of the board, so get the info from the hex
<span class="nc bnc" id="L5824" title="All 2 branches missed.">                if (clientgui == null) {</span>
<span class="nc" id="L5825">                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5826">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.FuelTank&quot;, new Object[] { //$NON-NLS-1$</span>
<span class="nc" id="L5827">                            mhex.terrainLevel(Terrains.FUEL_TANK_ELEV),</span>
<span class="nc" id="L5828">                            Terrains.getEditorName(Terrains.FUEL_TANK),</span>
<span class="nc" id="L5829">                            mhex.terrainLevel(Terrains.FUEL_TANK_CF),</span>
<span class="nc" id="L5830">                            mhex.terrainLevel(Terrains.FUEL_TANK_MAGN)</span>
                    }));
                } else {
<span class="nc" id="L5833">                    Building bldg = game.getBoard().getBuildingAt(mcoords);</span>
<span class="nc" id="L5834">                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5835">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.FuelTank&quot;, new Object[] { //$NON-NLS-1$</span>
<span class="nc" id="L5836">                            mhex.terrainLevel(Terrains.FUEL_TANK_ELEV),</span>
<span class="nc" id="L5837">                            bldg.toString(),</span>
<span class="nc" id="L5838">                            bldg.getCurrentCF(mcoords)</span>
                    }));
                }
<span class="nc" id="L5841">                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
            }

            // Building
<span class="nc bnc" id="L5845" title="All 2 branches missed.">            if (mhex.containsTerrain(Terrains.BUILDING)) {</span>
                // In the BoardEditor, buildings have no entry in the
                // buildings list of the board, so get the info from the hex
<span class="nc bnc" id="L5848" title="All 2 branches missed.">                if (clientgui == null) {</span>
<span class="nc" id="L5849">                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5850">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Building&quot;, new Object[] { //$NON-NLS-1$</span>
<span class="nc" id="L5851">                            mhex.terrainLevel(Terrains.BLDG_ELEV),</span>
<span class="nc" id="L5852">                            Terrains.getEditorName(Terrains.BUILDING),</span>
<span class="nc" id="L5853">                            mhex.terrainLevel(Terrains.BLDG_CF),</span>
<span class="nc" id="L5854">                            Math.max(mhex.terrainLevel(Terrains.BLDG_ARMOR),0),</span>
<span class="nc" id="L5855">                            BasementType.getType(mhex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE)).toString()</span>
                    }));
                } else {
<span class="nc" id="L5858">                    Building bldg = game.getBoard().getBuildingAt(mcoords);</span>
<span class="nc" id="L5859">                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#CCCC99 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5860">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Building&quot;, new Object[] { //$NON-NLS-1$</span>
<span class="nc" id="L5861">                            mhex.terrainLevel(Terrains.BLDG_ELEV),</span>
<span class="nc" id="L5862">                            bldg.toString(),</span>
<span class="nc" id="L5863">                            bldg.getCurrentCF(mcoords),</span>
<span class="nc" id="L5864">                            bldg.getArmor(mcoords),</span>
<span class="nc" id="L5865">                            bldg.getBasement(mcoords).getDesc()</span>
                    }));

<span class="nc bnc" id="L5868" title="All 2 branches missed.">                    if (bldg.getBasementCollapsed(mcoords)) {</span>
<span class="nc" id="L5869">                        txt.append(Messages</span>
<span class="nc" id="L5870">                                .getString(&quot;BoardView1.Tooltip.BldgBasementCollapsed&quot;)); //$NON-NLS-1$</span>
                    }
                }
<span class="nc" id="L5873">                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
            }

            // Bridge
<span class="nc bnc" id="L5877" title="All 2 branches missed.">            if (mhex.containsTerrain(Terrains.BRIDGE)) {</span>
                // In the BoardEditor, buildings have no entry in the
                // buildings list of the board, so get the info from the hex
<span class="nc bnc" id="L5880" title="All 2 branches missed.">                if (clientgui == null) {</span>
<span class="nc" id="L5881">                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5882">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Bridge&quot;, new Object[] { //$NON-NLS-1$</span>
<span class="nc" id="L5883">                            mhex.terrainLevel(Terrains.BRIDGE_ELEV),</span>
<span class="nc" id="L5884">                            Terrains.getEditorName(Terrains.BRIDGE),</span>
<span class="nc" id="L5885">                            mhex.terrainLevel(Terrains.BRIDGE_CF),</span>
                    }));
                } else {
<span class="nc" id="L5888">                    Building bldg = game.getBoard().getBuildingAt(mcoords);</span>
<span class="nc" id="L5889">                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5890">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Bridge&quot;, new Object[] { //$NON-NLS-1$</span>
<span class="nc" id="L5891">                            mhex.terrainLevel(Terrains.BRIDGE_ELEV),</span>
<span class="nc" id="L5892">                            bldg.toString(),</span>
<span class="nc" id="L5893">                            bldg.getCurrentCF(mcoords),</span>
                    }));
                }
<span class="nc" id="L5896">                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
            }

<span class="nc bnc" id="L5899" title="All 2 branches missed.">            if (game.containsMinefield(mcoords)) {</span>
<span class="nc" id="L5900">                Vector&lt;Minefield&gt; minefields = game.getMinefields(mcoords);</span>
<span class="nc bnc" id="L5901" title="All 2 branches missed.">                for (int i = 0; i &lt; minefields.size(); i++) {</span>
<span class="nc" id="L5902">                    Minefield mf = minefields.elementAt(i);</span>
<span class="nc" id="L5903">                    String owner = &quot; (&quot; //$NON-NLS-1$</span>
<span class="nc" id="L5904">                                   + game.getPlayer(mf.getPlayerId()).getName()</span>
                                   + &quot;)&quot;; //$NON-NLS-1$

<span class="nc bnc" id="L5907" title="All 6 branches missed.">                    switch (mf.getType()) {</span>
                        case (Minefield.TYPE_CONVENTIONAL):
<span class="nc" id="L5909">                            txt.append(mf.getName()</span>
<span class="nc" id="L5910">                                       + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5911">                                       + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot; &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L5912">                            break;</span>
                        case (Minefield.TYPE_COMMAND_DETONATED):
<span class="nc" id="L5914">                            txt.append(mf.getName()</span>
<span class="nc" id="L5915">                                       + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5916">                                       + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot; &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L5917">                            break;</span>
                        case (Minefield.TYPE_VIBRABOMB):
<span class="nc bnc" id="L5919" title="All 2 branches missed.">                            if (mf.getPlayerId() == localPlayer.getId()) {</span>
<span class="nc" id="L5920">                                txt.append(mf.getName()</span>
                                           + Messages
<span class="nc" id="L5922">                                        .getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5923">                                           + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot;(&quot; //$NON-NLS-1$</span>
<span class="nc" id="L5924">                                           + mf.getSetting() + &quot;) &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
                            } else {
<span class="nc" id="L5926">                                txt.append(mf.getName()</span>
                                           + Messages
<span class="nc" id="L5928">                                        .getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5929">                                           + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot; &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
                            }
<span class="nc" id="L5931">                            break;</span>
                        case (Minefield.TYPE_ACTIVE):
<span class="nc" id="L5933">                            txt.append(mf.getName()</span>
<span class="nc" id="L5934">                                       + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5935">                                       + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L5936">                            break;</span>
                        case (Minefield.TYPE_INFERNO):
<span class="nc" id="L5938">                            txt.append(mf.getName()</span>
<span class="nc" id="L5939">                                       + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5940">                                       + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
                            break;
                    }
<span class="nc" id="L5943">                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
                }
            }

<span class="nc bnc" id="L5947" title="All 2 branches missed.">            if (displayInvalidHexInfo) {</span>
<span class="nc" id="L5948">                StringBuffer errBuff = new StringBuffer();</span>
<span class="nc bnc" id="L5949" title="All 2 branches missed.">                if (!mhex.isValid(errBuff)) {</span>
<span class="nc" id="L5950">                    txt.append(Messages.getString(&quot;BoardView1.invalidHex&quot;));</span>
<span class="nc" id="L5951">                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5952">                    String errors = errBuff.toString();</span>
<span class="nc" id="L5953">                    errors = errors.replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;);</span>
<span class="nc" id="L5954">                    txt.append(errors);</span>
<span class="nc" id="L5955">                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
                }
            }
        }

        // Show the player(s) that may deploy here
        // in the artillery autohit designation phase
<span class="nc bnc" id="L5962" title="All 4 branches missed.">        if ((game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) &amp;&amp; (mhex != null)) {</span>
<span class="nc" id="L5963">            txt.append(&quot;&lt;TABLE BORDER=0 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5964">            Enumeration&lt;IPlayer&gt; allP = game.getPlayers();</span>
<span class="nc" id="L5965">            boolean foundPlayer = false;</span>
            // loop through all players
<span class="nc bnc" id="L5967" title="All 2 branches missed.">            while (allP.hasMoreElements())</span>
            {
<span class="nc" id="L5969">                IPlayer cp = allP.nextElement();</span>
<span class="nc bnc" id="L5970" title="All 2 branches missed.">                if (game.getBoard().isLegalDeployment(mcoords, cp.getStartingPos())) {</span>
<span class="nc bnc" id="L5971" title="All 2 branches missed.">                    if (!foundPlayer) {</span>
<span class="nc" id="L5972">                        foundPlayer = true;</span>
<span class="nc" id="L5973">                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtyAutoHeader&quot;)); //$NON-NLS-1$</span>
                    }
<span class="nc" id="L5975">                    txt.append(&quot;&lt;B&gt;&lt;FONT COLOR=#&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5976">                    txt.append(cp.getColour().getHexString());</span>
<span class="nc" id="L5977">                    txt.append(&quot;&gt;&amp;nbsp;&amp;nbsp;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5978">                    txt.append(cp.getName());</span>
<span class="nc" id="L5979">                    txt.append(&quot;&lt;/FONT&gt;&lt;/B&gt;&lt;BR&gt;&quot;); //$NON-NLS-1$</span>
                }
<span class="nc" id="L5981">            }</span>
<span class="nc bnc" id="L5982" title="All 2 branches missed.">            if (foundPlayer) txt.append(&quot;&lt;BR&gt;&quot;); //$NON-NLS-1$</span>

            // Add a hint with keybind that the zones can be shown graphically
<span class="nc" id="L5985">            String keybindText = KeyEvent.getKeyModifiersText(KeyCommandBind.getBindByCmd(&quot;autoArtyDeployZone&quot;).modifiers);</span>
<span class="nc bnc" id="L5986" title="All 2 branches missed.">            if (!keybindText.isEmpty()) keybindText += &quot;+&quot;;</span>
<span class="nc" id="L5987">            keybindText += KeyEvent.getKeyText(KeyCommandBind.getBindByCmd(&quot;autoArtyDeployZone&quot;).key);</span>
<span class="nc" id="L5988">            txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtyAutoHint&quot;, keybindText));</span>

<span class="nc" id="L5990">            txt.append(&quot;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
        }


        // check if it's on any flares
<span class="nc bnc" id="L5995" title="All 2 branches missed.">        for (FlareSprite fSprite : flareSprites) {</span>
<span class="nc bnc" id="L5996" title="All 2 branches missed.">            if (fSprite.isInside(point)) {</span>
<span class="nc" id="L5997">                txt.append(fSprite.getTooltip().toString());</span>
            }
<span class="nc" id="L5999">        }</span>

        // check if it's on any attacks
<span class="nc bnc" id="L6002" title="All 2 branches missed.">        for (AttackSprite aSprite : attackSprites) {</span>
<span class="nc bnc" id="L6003" title="All 2 branches missed.">            if (aSprite.isInside(point)) {</span>
<span class="nc" id="L6004">                txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#FFDDDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L6005">                txt.append(aSprite.getTooltip().toString());</span>
<span class="nc" id="L6006">                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
            }
<span class="nc" id="L6008">        }</span>

        // Entity tooltips
<span class="nc" id="L6011">        int entityCount = 0;</span>
        // Maximum number of entities to show in the tooltip
<span class="nc" id="L6013">        int maxShown = 4;</span>

<span class="nc" id="L6015">        Set&lt;Entity&gt; coordEnts = new HashSet&lt;&gt;(game.getEntitiesVector(mcoords));</span>
<span class="nc" id="L6016">        Set&lt;Entity&gt; usedSet = new HashSet&lt;Entity&gt;(entitySprites.size());</span>
<span class="nc bnc" id="L6017" title="All 2 branches missed.">        for (EntitySprite eSprite : entitySprites) {</span>
<span class="nc bnc" id="L6018" title="All 4 branches missed.">            if ((eSprite.isInside(point) || coordEnts.contains(eSprite.entity))</span>
<span class="nc bnc" id="L6019" title="All 2 branches missed.">                    &amp;&amp; !usedSet.contains(eSprite.entity)) {</span>
<span class="nc" id="L6020">                usedSet.add(eSprite.entity);</span>
<span class="nc" id="L6021">                entityCount++;</span>

                // List only the first four units
<span class="nc bnc" id="L6024" title="All 2 branches missed.">                if (entityCount &lt;= maxShown) {</span>
                    // Table to add a bar to the left of an entity in
                    // the player's color
<span class="nc" id="L6027">                    txt.append(&quot;&lt;hr style=width:90%&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L6028">                    txt.append(&quot;&lt;TABLE&gt;&lt;TR&gt;&lt;TD bgcolor=#&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L6029">                    txt.append(eSprite.getPlayerColor());</span>
<span class="nc" id="L6030">                    txt.append(&quot; width=6&gt;&lt;/TD&gt;&lt;TD&gt;&quot;); //$NON-NLS-1$</span>

                    // TT generated by Sprite
<span class="nc" id="L6033">                    txt.append(eSprite.getTooltip());</span>

                    // ECM and ECCM source
<span class="nc bnc" id="L6036" title="All 2 branches missed.">                    if (eSprite.entity.hasActiveECM()) {</span>
<span class="nc" id="L6037">                        txt.append(&quot;&lt;br&gt;&lt;FONT SIZE=-2&gt;&lt;img src=file:&quot; //$NON-NLS-1$</span>
<span class="nc" id="L6038">                                + Configuration.widgetsDir()</span>
                                + &quot;/Tooltip/ECM_BW.png&gt;&amp;nbsp;&quot;); //$NON-NLS-1$
<span class="nc" id="L6040">                        txt.append(Messages.getString(&quot;BoardView1.ecmSource&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L6041">                        txt.append(&quot;&lt;/FONT&gt;&quot;); //$NON-NLS-1$</span>
                    }
<span class="nc bnc" id="L6043" title="All 2 branches missed.">                    if (eSprite.entity.hasActiveECCM()) {</span>
<span class="nc" id="L6044">                        txt.append(&quot;&lt;br&gt;&lt;FONT SIZE=-2&gt;&lt;img src=file:&quot; //$NON-NLS-1$</span>
<span class="nc" id="L6045">                                + Configuration.widgetsDir()</span>
                                + &quot;/Tooltip/ECM_BW.png&gt;&amp;nbsp;&quot;); //$NON-NLS-1$
<span class="nc" id="L6047">                        txt.append(Messages.getString(&quot;BoardView1.eccmSource&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L6048">                        txt.append(&quot;&lt;/FONT&gt;&quot;);</span>
                    }

<span class="nc" id="L6051">                    txt.append(&quot;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
                }
            }
<span class="nc" id="L6054">        }</span>
        // Info block if there are more than 4 units in that hex
<span class="nc bnc" id="L6056" title="All 2 branches missed.">        if (entityCount &gt; maxShown)</span>
        {
<span class="nc" id="L6058">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#000060 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT COLOR=WHITE&gt;There &quot;);</span>
<span class="nc bnc" id="L6059" title="All 2 branches missed.">            if (entityCount-maxShown == 1)</span>
<span class="nc" id="L6060">                txt.append(&quot;is 1 more&lt;BR&gt;unit&quot;);</span>
            else
<span class="nc" id="L6062">                txt.append(&quot;are &quot;+(entityCount-maxShown)+&quot; more&lt;BR&gt;units&quot;);</span>
<span class="nc" id="L6063">            txt.append(&quot; in this hex...&lt;/FONT&gt;&quot;);</span>
<span class="nc" id="L6064">            txt.append(&quot;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;);</span>
        }

        // Artillery attacks
<span class="nc bnc" id="L6068" title="All 2 branches missed.">        for (ArtilleryAttackAction aaa : artilleryAttacks) {</span>
            // Default texts if no real names can be found
<span class="nc" id="L6070">            String wpName = Messages.getString(&quot;BoardView1.Artillery&quot;);</span>
<span class="nc" id="L6071">            String ammoName = &quot;Unknown&quot;;</span>

            // Get real weapon and ammo name
<span class="nc" id="L6074">            final Entity artyEnt = game.getEntity(aaa.getEntityId());</span>
<span class="nc bnc" id="L6075" title="All 2 branches missed.">            if (artyEnt != null) {</span>
<span class="nc bnc" id="L6076" title="All 2 branches missed.">                if (aaa.getWeaponId() &gt; -1) {</span>
<span class="nc" id="L6077">                    wpName = artyEnt.getEquipment(aaa.getWeaponId()).getName();</span>
<span class="nc bnc" id="L6078" title="All 2 branches missed.">                    if (aaa.getAmmoId() &gt; -1) {</span>
<span class="nc" id="L6079">                        ammoName =  artyEnt.getEquipment(aaa.getAmmoId()).getName();</span>
                    }
                }
            }

<span class="nc" id="L6084">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#FFDDDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;);</span>
<span class="nc bnc" id="L6085" title="All 2 branches missed.">            if (aaa.getTurnsTilHit() == 1)</span>
<span class="nc" id="L6086">                txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtilleryAttack1&quot;,</span>
                        new Object[] { wpName, ammoName }));
            else
<span class="nc" id="L6089">                txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtilleryAttackN&quot;,</span>
<span class="nc" id="L6090">                        new Object[] { wpName, ammoName, aaa.getTurnsTilHit() }));</span>
<span class="nc" id="L6091">            txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;);</span>
<span class="nc" id="L6092">        }</span>

        // Artillery fire adjustment
<span class="nc bnc" id="L6095" title="All 4 branches missed.">        if ((curWeapon != null) &amp;&amp; (selectedEntity != null)) {</span>
            // process targetted hexes
<span class="nc" id="L6097">            int amod = 0;</span>
            // Check the predesignated hexes
<span class="nc" id="L6099">            if (selectedEntity.getOwner().getArtyAutoHitHexes()</span>
<span class="nc bnc" id="L6100" title="All 2 branches missed.">                              .contains(mcoords)) {</span>
<span class="nc" id="L6101">                amod = TargetRoll.AUTOMATIC_SUCCESS;</span>
            } else {
<span class="nc" id="L6103">                amod = selectedEntity.aTracker.getModifier(curWeapon, mcoords);</span>
            }

<span class="nc bnc" id="L6106" title="All 2 branches missed.">            if (amod == TargetRoll.AUTOMATIC_SUCCESS) {</span>
<span class="nc" id="L6107">                txt.append(Messages</span>
<span class="nc" id="L6108">                                   .getString(&quot;BoardView1.ArtilleryAutohit&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L6109">                txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
            } else {
<span class="nc" id="L6111">                txt.append(Messages.getString(</span>
                        &quot;BoardView1.ArtilleryAdjustment&quot;, //$NON-NLS-1$
<span class="nc" id="L6113">                        new Object[]{Integer.valueOf(amod)}));</span>
<span class="nc" id="L6114">                txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
            }
        }

<span class="nc" id="L6118">        final Collection&lt;SpecialHexDisplay&gt; shdList = game.getBoard()</span>
<span class="nc" id="L6119">                .getSpecialHexDisplay(mcoords);</span>
<span class="nc" id="L6120">        final Phase currPhase = game.getPhase();</span>
<span class="nc" id="L6121">        int round = game.getRoundCount();</span>
<span class="nc bnc" id="L6122" title="All 2 branches missed.">        if (shdList != null) {</span>
<span class="nc" id="L6123">            boolean isHexAutoHit = localPlayer.getArtyAutoHitHexes().contains(</span>
                    mcoords);
<span class="nc bnc" id="L6125" title="All 2 branches missed.">            for (SpecialHexDisplay shd : shdList) {</span>
<span class="nc bnc" id="L6126" title="All 2 branches missed.">                boolean isTypeAutoHit = shd.getType()</span>
                        == SpecialHexDisplay.Type.ARTILLERY_AUTOHIT;
                // Don't draw if this SHD is obscured from this player
                // The SHD list may also contain stale SHDs, so don't show
                // tooltips for SHDs that aren't drawn.
                // The exception is auto hits.  There will be an icon for auto
                // hits, so we need to draw a tooltip
<span class="nc bnc" id="L6133" title="All 2 branches missed.">                if (!shd.isObscured(localPlayer)</span>
<span class="nc bnc" id="L6134" title="All 6 branches missed.">                        &amp;&amp; (shd.drawNow(currPhase, round, localPlayer)</span>
                                || (isHexAutoHit &amp;&amp; isTypeAutoHit))) {
<span class="nc bnc" id="L6136" title="All 2 branches missed.">                    if (shd.getType() == SpecialHexDisplay.Type.PLAYER_NOTE) {</span>
<span class="nc bnc" id="L6137" title="All 2 branches missed.">                        if (localPlayer.equals(shd.getOwner())) {</span>
<span class="nc" id="L6138">                            txt.append(&quot;Note: &quot;);</span>
                        } else {
<span class="nc" id="L6140">                            txt.append(&quot;Note (&quot; + shd.getOwner().getName()</span>
                                       + &quot;): &quot;);
                        }
                    }
<span class="nc" id="L6144">                    String buf = shd.getInfo();</span>
<span class="nc" id="L6145">                    buf = buf.replaceAll(&quot;\\n&quot;, &quot;&lt;br&gt;&quot;);</span>
<span class="nc" id="L6146">                    txt.append(buf);</span>
<span class="nc" id="L6147">                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
                }
<span class="nc" id="L6149">            }</span>
        }

<span class="nc" id="L6152">        txt.append(&quot;&lt;/html&gt;&quot;); //$NON-NLS-1$</span>

        // Check to see if the tool tip is completely empty
<span class="nc bnc" id="L6155" title="All 2 branches missed.">        if (txt.toString().equals(&quot;&lt;html&gt;&lt;/html&gt;&quot;)) { //$NON-NLS-1$</span>
<span class="nc" id="L6156">            return new String(&quot;&quot;); //$NON-NLS-1$</span>
        }

        // Now that a valid tooltip text seems to be present,
        // (re)set the tooltip dismissal delay time to the preference
        // value so that the tooltip actually appears
<span class="nc bnc" id="L6162" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getTooltipDismissDelay() &gt;= 0) {</span>
<span class="nc" id="L6163">            ToolTipManager.sharedInstance().setDismissDelay(</span>
<span class="nc" id="L6164">                    GUIPreferences.getInstance().getTooltipDismissDelay());</span>
        } else {
<span class="nc" id="L6166">            ToolTipManager.sharedInstance().setDismissDelay(dismissDelay);</span>
        }

<span class="nc" id="L6169">        return txt.toString();</span>
    }

    private ArrayList&lt;ArtilleryAttackAction&gt; getArtilleryAttacksAtLocation(
            Coords c) {
<span class="nc" id="L6174">        ArrayList&lt;ArtilleryAttackAction&gt; v = new ArrayList&lt;ArtilleryAttackAction&gt;();</span>
<span class="nc" id="L6175">        for (Enumeration&lt;ArtilleryAttackAction&gt; attacks = game</span>
<span class="nc bnc" id="L6176" title="All 2 branches missed.">                .getArtilleryAttacks(); attacks.hasMoreElements(); ) {</span>
<span class="nc" id="L6177">            ArtilleryAttackAction a = attacks.nextElement();</span>
<span class="nc bnc" id="L6178" title="All 2 branches missed.">            if (a.getTarget(game).getPosition().equals(c)) {</span>
<span class="nc" id="L6179">                v.add(a);</span>
            }
<span class="nc" id="L6181">        }</span>
<span class="nc" id="L6182">        return v;</span>
    }

    public Component getComponent() {
<span class="nc" id="L6186">        return getComponent(false);</span>
    }

    public Component getComponent(boolean scrollBars) {
        // If we're already configured, return the scrollpane
<span class="nc bnc" id="L6191" title="All 2 branches missed.">        if (scrollpane != null) {</span>
<span class="nc" id="L6192">            return scrollpane;</span>
        }

<span class="nc" id="L6195">        SkinSpecification bvSkinSpec = SkinXMLHandler</span>
<span class="nc" id="L6196">                .getSkin(SkinSpecification.UIComponents.BoardView.getComp());</span>

        // Setup background icons
        try {
            File file;
<span class="nc bnc" id="L6201" title="All 2 branches missed.">            if (bvSkinSpec.backgrounds.size() &gt; 0) {</span>
<span class="nc" id="L6202">                file = new MegaMekFile(Configuration.widgetsDir(),</span>
<span class="nc" id="L6203">                                bvSkinSpec.backgrounds.get(0)).getFile();</span>
<span class="nc bnc" id="L6204" title="All 2 branches missed.">                if (!file.exists()) {</span>
<span class="nc" id="L6205">                    System.err.println(&quot;BoardView1 Error: icon doesn't exist: &quot;</span>
<span class="nc" id="L6206">                                       + file.getAbsolutePath());</span>
                } else {
<span class="nc" id="L6208">                    bvBgImage = (BufferedImage) ImageUtil.loadImageFromFile(</span>
<span class="nc" id="L6209">                            file.getAbsolutePath());</span>
<span class="nc" id="L6210">                    bvBgShouldTile = bvSkinSpec.tileBackground;</span>
                }
            }
<span class="nc bnc" id="L6213" title="All 2 branches missed.">            if (bvSkinSpec.backgrounds.size() &gt; 1) {</span>
<span class="nc" id="L6214">                file = new MegaMekFile(Configuration.widgetsDir(),</span>
<span class="nc" id="L6215">                                bvSkinSpec.backgrounds.get(1)).getFile();</span>
<span class="nc bnc" id="L6216" title="All 2 branches missed.">                if (!file.exists()) {</span>
<span class="nc" id="L6217">                    System.err.println(&quot;BoardView1 Error: icon doesn't exist: &quot;</span>
<span class="nc" id="L6218">                                       + file.getAbsolutePath());</span>
                } else {
<span class="nc" id="L6220">                    scrollPaneBgImg = ImageUtil.loadImageFromFile(</span>
<span class="nc" id="L6221">                            file.getAbsolutePath());</span>
                }
            }
<span class="nc" id="L6224">        } catch (Exception e) {</span>
<span class="nc" id="L6225">            System.out.println(&quot;Error loading BoardView background images!&quot;);</span>
<span class="nc" id="L6226">            System.out.println(e.getMessage());</span>
<span class="nc" id="L6227">        }</span>

        // Place the board viewer in a set of scrollbars.
<span class="nc" id="L6230">        scrollpane = new JScrollPane(this) {</span>

            /**
             *
             */
            private static final long serialVersionUID = 5973610449428194319L;

            @Override
            protected void paintComponent(Graphics g) {
<span class="nc bnc" id="L6239" title="All 2 branches missed.">                if (scrollPaneBgImg == null) {</span>
<span class="nc" id="L6240">                    super.paintComponent(g);</span>
<span class="nc" id="L6241">                    return;</span>
                }
<span class="nc" id="L6243">                int w = getWidth();</span>
<span class="nc" id="L6244">                int h = getHeight();</span>
<span class="nc" id="L6245">                int iW = scrollPaneBgImg.getWidth(null);</span>
<span class="nc" id="L6246">                int iH = scrollPaneBgImg.getHeight(null);</span>
<span class="nc bnc" id="L6247" title="All 2 branches missed.">                if ((scrollPaneBgBuffer == null)</span>
<span class="nc bnc" id="L6248" title="All 2 branches missed.">                    || (scrollPaneBgBuffer.getWidth() != w)</span>
<span class="nc bnc" id="L6249" title="All 2 branches missed.">                    || (scrollPaneBgBuffer.getHeight() != h)) {</span>
<span class="nc" id="L6250">                    scrollPaneBgBuffer = new BufferedImage(w, h,</span>
                            BufferedImage.TYPE_INT_RGB);
<span class="nc" id="L6252">                    Graphics bgGraph = scrollPaneBgBuffer.getGraphics();</span>
                    // If the unit icon not loaded, prevent infinite loop
<span class="nc bnc" id="L6254" title="All 4 branches missed.">                    if ((iW &lt; 1) || (iH &lt; 1)) {</span>
<span class="nc" id="L6255">                        return;</span>
                    }
<span class="nc bnc" id="L6257" title="All 2 branches missed.">                    for (int x = 0; x &lt; w; x += iW) {</span>
<span class="nc bnc" id="L6258" title="All 2 branches missed.">                        for (int y = 0; y &lt; h; y += iH) {</span>
<span class="nc" id="L6259">                            bgGraph.drawImage(scrollPaneBgImg, x, y, null);</span>
                        }
                    }
<span class="nc" id="L6262">                    bgGraph.dispose();</span>
                }
<span class="nc" id="L6264">                g.drawImage(scrollPaneBgBuffer, 0, 0, null);</span>
<span class="nc" id="L6265">            }</span>
        };
<span class="nc" id="L6267">        scrollpane.setBorder(new MegamekBorder(bvSkinSpec));</span>
<span class="nc" id="L6268">        scrollpane.setLayout(new ScrollPaneLayout());</span>
        // we need to use the simple scroll mode because otherwise the
        // IDisplayables that are drawn in fixed positions in the viewport
        // leave artifacts when scrolling
<span class="nc" id="L6272">        scrollpane.getViewport().setScrollMode(JViewport.SIMPLE_SCROLL_MODE);</span>

        // Prevent the default arrow key scrolling
<span class="nc" id="L6275">        scrollpane.getActionMap().put(&quot;unitScrollRight&quot;, DoNothing);</span>
<span class="nc" id="L6276">        scrollpane.getActionMap().put(&quot;unitScrollDown&quot;, DoNothing);</span>
<span class="nc" id="L6277">        scrollpane.getActionMap().put(&quot;unitScrollLeft&quot;, DoNothing);</span>
<span class="nc" id="L6278">        scrollpane.getActionMap().put(&quot;unitScrollUp&quot;, DoNothing);</span>

<span class="nc" id="L6280">        vbar = scrollpane.getVerticalScrollBar();</span>
<span class="nc" id="L6281">        hbar = scrollpane.getHorizontalScrollBar();</span>

<span class="nc bnc" id="L6283" title="All 4 branches missed.">        if (!scrollBars &amp;&amp; !bvSkinSpec.showScrollBars) {</span>
<span class="nc" id="L6284">            vbar.setPreferredSize(new Dimension(0, vbar.getHeight()));</span>
<span class="nc" id="L6285">            hbar.setPreferredSize(new Dimension(hbar.getWidth(), 0));</span>
        }

<span class="nc" id="L6288">        return scrollpane;</span>
    }

<span class="nc" id="L6291">    AbstractAction DoNothing = new AbstractAction() {</span>
        private static final long serialVersionUID = 5944877465265121983L;

        @Override
        public void actionPerformed(ActionEvent e) {
<span class="nc" id="L6296">        }</span>
    };

    /**
     * refresh the IDisplayables
     */
    public void refreshDisplayables() {
<span class="nc" id="L6303">        repaint();</span>
<span class="nc" id="L6304">    }</span>

    private void pingMinimap() {
        // send the minimap a hex moused event to make it
        // update the visible area rectangle
<span class="nc" id="L6309">        BoardViewEvent bve = new BoardViewEvent(this,BoardViewEvent.BOARD_HEX_DRAGGED);</span>
<span class="nc bnc" id="L6310" title="All 2 branches missed.">        if (boardListeners != null) {</span>
<span class="nc bnc" id="L6311" title="All 2 branches missed.">            for (BoardViewListener l : boardListeners) l.hexMoused(bve);</span>
        }
<span class="nc" id="L6313">    }</span>

    public void showPopup(Object popup, Coords c) {
<span class="nc" id="L6316">        Point p = getHexLocation(c);</span>
<span class="nc" id="L6317">        p.x += ((int) (HEX_WC * scale) - scrollpane.getX()) + HEX_W;</span>
<span class="nc" id="L6318">        p.y += ((int) ((HEX_H * scale) / 2) - scrollpane.getY()) + HEX_H;</span>
<span class="nc bnc" id="L6319" title="All 2 branches missed.">        if (((JPopupMenu) popup).getParent() == null) {</span>
<span class="nc" id="L6320">            add((JPopupMenu) popup);</span>
        }
<span class="nc" id="L6322">        ((JPopupMenu) popup).show(this, p.x, p.y);</span>
<span class="nc" id="L6323">    }</span>

    public void refreshMinefields() {
<span class="nc" id="L6326">        repaint();</span>
<span class="nc" id="L6327">    }</span>

    /**
     * Increases zoomIndex and refreshes the map.
     */
    public void zoomIn() {
<span class="nc bnc" id="L6333" title="All 2 branches missed.">        if (zoomIndex == (ZOOM_FACTORS.length - 1)) {</span>
<span class="nc" id="L6334">            return;</span>
        }
<span class="nc" id="L6336">        zoomIndex++;</span>
<span class="nc" id="L6337">        zoom();</span>
<span class="nc" id="L6338">    }</span>

    /**
     * Decreases zoomIndex and refreshes the map.
     */
    public void zoomOut() {
<span class="nc bnc" id="L6344" title="All 2 branches missed.">        if (zoomIndex == 0) {</span>
<span class="nc" id="L6345">            return;</span>
        }
<span class="nc" id="L6347">        zoomIndex--;</span>
<span class="nc" id="L6348">        zoom();</span>
<span class="nc" id="L6349">    }</span>

    public void hideTooltip() {
<span class="nc" id="L6352">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    private void checkZoomIndex() {
<span class="nc bnc" id="L6356" title="All 2 branches missed.">        if (zoomIndex &gt; (ZOOM_FACTORS.length - 1)) {</span>
<span class="nc" id="L6357">            zoomIndex = ZOOM_FACTORS.length - 1;</span>
        }
<span class="nc bnc" id="L6359" title="All 2 branches missed.">        if (zoomIndex &lt; 0) {</span>
<span class="nc" id="L6360">            zoomIndex = 0;</span>
        }
<span class="nc" id="L6362">    }</span>

    /**
     * Changes hex dimensions and refreshes the map with the new scale
     */
    private void zoom() {

<span class="nc" id="L6369">        checkZoomIndex();</span>
<span class="nc" id="L6370">        stopSoftCentering();</span>
<span class="nc" id="L6371">        scale = ZOOM_FACTORS[zoomIndex];</span>
<span class="nc" id="L6372">        GUIPreferences.getInstance().setMapZoomIndex(zoomIndex);</span>

<span class="nc" id="L6374">        hex_size = new Dimension((int) (HEX_W * scale), (int) (HEX_H * scale));</span>

<span class="nc" id="L6376">        scaledImageCache = new ImageCache&lt;Integer, Image&gt;();</span>

<span class="nc" id="L6378">        cursorSprite.prepare();</span>
<span class="nc" id="L6379">        highlightSprite.prepare();</span>
<span class="nc" id="L6380">        selectedSprite.prepare();</span>
<span class="nc" id="L6381">        firstLOSSprite.prepare();</span>
<span class="nc" id="L6382">        secondLOSSprite.prepare();</span>
<span class="nc bnc" id="L6383" title="All 2 branches missed.">        for (Sprite spr : moveEnvSprites) {</span>
<span class="nc" id="L6384">            spr.prepare();</span>
<span class="nc" id="L6385">        }</span>
<span class="nc bnc" id="L6386" title="All 2 branches missed.">        for (Sprite spr : moveModEnvSprites) {</span>
<span class="nc" id="L6387">            spr.prepare();</span>
<span class="nc" id="L6388">        }</span>
<span class="nc bnc" id="L6389" title="All 2 branches missed.">        for (Sprite spr : fieldofFireSprites) {</span>
<span class="nc" id="L6390">            spr.prepare();</span>
<span class="nc" id="L6391">        }</span>

<span class="nc" id="L6393">        updateFontSizes();</span>
<span class="nc" id="L6394">        updateBoard();</span>
<span class="nc bnc" id="L6395" title="All 2 branches missed.">        for (StepSprite sprite : pathSprites) {</span>
<span class="nc" id="L6396">            sprite.refreshZoomLevel();</span>
<span class="nc" id="L6397">        }</span>
<span class="nc bnc" id="L6398" title="All 2 branches missed.">        for (FiringSolutionSprite sprite : firingSprites) {</span>
<span class="nc" id="L6399">            sprite.prepare();</span>
<span class="nc" id="L6400">        }</span>
<span class="nc" id="L6401">        this.setSize(boardSize);</span>

<span class="nc" id="L6403">        clearHexImageCache();</span>
<span class="nc" id="L6404">        repaint();</span>
<span class="nc" id="L6405">    }</span>

    private void updateFontSizes() {
<span class="nc bnc" id="L6408" title="All 2 branches missed.">        if (zoomIndex &lt;= 4) {</span>
<span class="nc" id="L6409">            font_elev = FONT_7;</span>
<span class="nc" id="L6410">            font_hexnum = FONT_7;</span>
<span class="nc" id="L6411">            font_minefield = FONT_7;</span>
        }
<span class="nc bnc" id="L6413" title="All 6 branches missed.">        if ((zoomIndex &lt;= 5) &amp; (zoomIndex &gt; 4)) {</span>
<span class="nc" id="L6414">            font_elev = FONT_8;</span>
<span class="nc" id="L6415">            font_hexnum = FONT_8;</span>
<span class="nc" id="L6416">            font_minefield = FONT_8;</span>
        }
<span class="nc bnc" id="L6418" title="All 2 branches missed.">        if (zoomIndex &gt; 5) {</span>
<span class="nc" id="L6419">            font_elev = FONT_9;</span>
<span class="nc" id="L6420">            font_hexnum = FONT_9;</span>
<span class="nc" id="L6421">            font_minefield = FONT_9;</span>
        }
<span class="nc" id="L6423">    }</span>

    /**
     * Return a scaled version of the input.  If the useCache flag is set, the
     * scaled image will be stored in an image cache for later retrieval.
     *
     * @param base     The image to get a scaled copy of.  The current zoom level
     *                 is used to determine the scale.
     * @param useCache This flag determines whether the scaled image should
     *                 be stored in a cache for later retrieval.
     */
    Image getScaledImage(Image base, boolean useCache) {
<span class="nc bnc" id="L6435" title="All 2 branches missed.">        if (base == null) {</span>
<span class="nc" id="L6436">            return null;</span>
        }
<span class="nc bnc" id="L6438" title="All 2 branches missed.">        if (zoomIndex == BASE_ZOOM_INDEX) {</span>
<span class="nc" id="L6439">            return base;</span>
        }


        Image scaled;
<span class="nc bnc" id="L6444" title="All 2 branches missed.">        if (useCache) {</span>
            // Check the cache
<span class="nc" id="L6446">            scaled = scaledImageCache.get(base.hashCode());</span>
        } else {
<span class="nc" id="L6448">            scaled = null;</span>
        }
        // Compute the scaled image
<span class="nc bnc" id="L6451" title="All 2 branches missed.">        if (scaled == null) {</span>
<span class="nc" id="L6452">            MediaTracker tracker = new MediaTracker(this);</span>
<span class="nc bnc" id="L6453" title="All 4 branches missed.">            if ((base.getWidth(null) == -1) || (base.getHeight(null) == -1)) {</span>
<span class="nc" id="L6454">                tracker.addImage(base, 0);</span>
                try {
<span class="nc" id="L6456">                    tracker.waitForID(0);</span>
<span class="nc" id="L6457">                } catch (InterruptedException e) {</span>
<span class="nc" id="L6458">                    e.printStackTrace();</span>
<span class="nc" id="L6459">                }</span>
<span class="nc bnc" id="L6460" title="All 2 branches missed.">                if (tracker.isErrorAny()) {</span>
<span class="nc" id="L6461">                    return null;</span>
                }
<span class="nc" id="L6463">                tracker.removeImage(base);</span>
            }
<span class="nc" id="L6465">            int width = (int) (base.getWidth(null) * scale);</span>
<span class="nc" id="L6466">            int height = (int) (base.getHeight(null) * scale);</span>

<span class="nc bnc" id="L6468" title="All 4 branches missed.">            if ((width &lt; 1) || (height &lt; 1)) {</span>
<span class="nc" id="L6469">                return null;</span>
            }

<span class="nc" id="L6472">            scaled = scale(base, width, height);</span>
<span class="nc" id="L6473">            tracker.addImage(scaled, 1);</span>
            // Wait for image to load
            try {
<span class="nc" id="L6476">                tracker.waitForID(1);</span>
<span class="nc" id="L6477">            } catch (InterruptedException e) {</span>
<span class="nc" id="L6478">                e.printStackTrace();</span>
<span class="nc" id="L6479">            }</span>
<span class="nc" id="L6480">            tracker.removeImage(scaled);</span>
            // Cache the image if the flag is set
<span class="nc bnc" id="L6482" title="All 2 branches missed.">            if (useCache) {</span>
<span class="nc" id="L6483">                scaledImageCache.put(base.hashCode(), scaled);</span>
            }
        }
<span class="nc" id="L6486">        return scaled;</span>
    }

    /**
     * The actual scaling code.
     */
    private Image scale(Image img, int width, int height) {
<span class="nc" id="L6493">        return ImageUtil.getScaledImage(img, width, height,</span>
                ZOOM_SCALE_TYPES[zoomIndex]);
    }

    public boolean toggleIsometric() {
<span class="nc bnc" id="L6498" title="All 2 branches missed.">        drawIsometric = !drawIsometric;</span>
<span class="nc bnc" id="L6499" title="All 2 branches missed.">        for (Sprite spr : moveEnvSprites) spr.prepare();</span>
<span class="nc bnc" id="L6500" title="All 2 branches missed.">        for (Sprite spr : moveModEnvSprites) spr.prepare();</span>
<span class="nc bnc" id="L6501" title="All 2 branches missed.">        for (Sprite spr : fieldofFireSprites) spr.prepare();</span>
<span class="nc" id="L6502">        clearHexImageCache();</span>
<span class="nc" id="L6503">        updateBoard();</span>
<span class="nc bnc" id="L6504" title="All 2 branches missed.">        for (MovementEnvelopeSprite sprite: moveEnvSprites)</span>
<span class="nc" id="L6505">            sprite.updateBounds();</span>
<span class="nc bnc" id="L6506" title="All 2 branches missed.">        for (MovementModifierEnvelopeSprite sprite: moveModEnvSprites)</span>
<span class="nc" id="L6507">            sprite.updateBounds();</span>
<span class="nc" id="L6508">        repaint();</span>
<span class="nc" id="L6509">        return drawIsometric;</span>
    }

    public void updateEntityLabels() {
<span class="nc bnc" id="L6513" title="All 2 branches missed.">        for (Entity e: game.getEntitiesVector()) {</span>
<span class="nc" id="L6514">            e.generateShortName();</span>
<span class="nc" id="L6515">        }</span>
<span class="nc bnc" id="L6516" title="All 2 branches missed.">        for (EntitySprite eS: entitySprites) {</span>
<span class="nc" id="L6517">            eS.prepare();</span>
<span class="nc" id="L6518">        }</span>
<span class="nc" id="L6519">        repaint();</span>
<span class="nc" id="L6520">    }</span>

    BufferedImage createShadowMask(Image image) {
<span class="nc" id="L6523">        int hashCode = image.hashCode();</span>
<span class="nc" id="L6524">        BufferedImage mask = shadowImageCache.get(hashCode);</span>
<span class="nc bnc" id="L6525" title="All 2 branches missed.">        if (mask != null) {</span>
<span class="nc" id="L6526">            return mask;</span>
        }
<span class="nc" id="L6528">        mask = new BufferedImage(image.getWidth(null),</span>
<span class="nc" id="L6529">                image.getHeight(null), BufferedImage.TYPE_INT_ARGB);</span>
<span class="nc" id="L6530">        float opacity = 0.4f;</span>
<span class="nc" id="L6531">        Graphics2D g2d = mask.createGraphics();</span>
<span class="nc" id="L6532">        g2d.drawImage(image, 0, 0, null);</span>
<span class="nc" id="L6533">        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_IN,</span>
                                                    opacity));
<span class="nc" id="L6535">        g2d.setColor(Color.BLACK);</span>
<span class="nc" id="L6536">        g2d.fillRect(0, 0, image.getWidth(null), image.getHeight(null));</span>
<span class="nc" id="L6537">        g2d.dispose();</span>
<span class="nc" id="L6538">        shadowImageCache.put(hashCode, mask);</span>
<span class="nc" id="L6539">        return mask;</span>
    }

    public void die() {
<span class="nc" id="L6543">        ourTask.cancel();</span>
<span class="nc" id="L6544">        fovHighlightingAndDarkening.die();</span>
<span class="nc" id="L6545">    }</span>

    /**
     * Returns true if the BoardView has an active chatter box else false.
     *
     * @return
     */
    public boolean getChatterBoxActive() {
<span class="nc" id="L6553">        return chatterBoxActive;</span>
    }

    /**
     * Sets whether the BoardView has an active chatter box or not.
     *
     * @param cba
     */
    public void setChatterBoxActive(boolean cba) {
<span class="nc" id="L6562">        chatterBoxActive = cba;</span>
<span class="nc" id="L6563">    }</span>

    public void setShouldIgnoreKeys(boolean shouldIgnoreKeys) {
<span class="nc" id="L6566">        this.shouldIgnoreKeys = shouldIgnoreKeys;</span>
<span class="nc" id="L6567">    }</span>

    @Override
    public boolean imageUpdate(Image img, int flags, int x, int y, int w, int h) {
        // If FRAMEBITS is set, then new frame from a multi-frame image is ready
        // This indicates an animated image, which shouldn't be cached
<span class="nc bnc" id="L6573" title="All 2 branches missed.">        if ((flags &amp; ImageObserver.FRAMEBITS) != 0) {</span>
<span class="nc" id="L6574">            animatedImages.add(img.hashCode());</span>
        }
<span class="nc" id="L6576">        return super.imageUpdate(img, flags, x, y, w, h);</span>
    }

    public void clearHexImageCache() {
<span class="nc" id="L6580">        hexImageCache.clear();</span>
<span class="nc" id="L6581">    }</span>

    /**
     * Clear a specific list of Coords from the hex image cache.
     * @param coords
     */
    public void clearHexImageCache(Set&lt;Coords&gt; coords) {
<span class="nc bnc" id="L6588" title="All 2 branches missed.">        for (Coords c : coords) {</span>
<span class="nc" id="L6589">            hexImageCache.remove(c);</span>
<span class="nc" id="L6590">        }</span>
<span class="nc" id="L6591">    }</span>

    /**
     * Check to see if the HexImageCache should be cleared because of
     * field-of-view changes.
     */
    public void checkFoVHexImageCacheClear() {
<span class="nc" id="L6598">        boolean darken = GUIPreferences.getInstance().getBoolean(</span>
                GUIPreferences.FOV_DARKEN);
<span class="nc" id="L6600">        boolean highlight = GUIPreferences.getInstance().getBoolean(</span>
                GUIPreferences.FOV_HIGHLIGHT);
<span class="nc bnc" id="L6602" title="All 6 branches missed.">        if ((game.getPhase() == Phase.PHASE_MOVEMENT)</span>
                &amp;&amp; (darken || highlight)) {
<span class="nc" id="L6604">            clearHexImageCache();</span>
        }
<span class="nc" id="L6606">    }</span>

    public Polygon getHexPoly() {
<span class="nc" id="L6609">        return hexPoly;</span>
    }

    public void clearFieldofF() {
<span class="nc" id="L6613">        fieldofFireWpArc = -1;</span>
<span class="nc" id="L6614">        fieldofFireUnit = null;</span>
<span class="nc" id="L6615">        fieldofFireSprites.clear();</span>
<span class="nc" id="L6616">        repaint();</span>
<span class="nc" id="L6617">    }</span>

    // this is called from MovementDisplay and checks if
    // the unit ends up underwater
    public void setWeaponFieldofFire(Entity ce, MovePath cmd) {
        // if lack of data: clear and return
<span class="nc bnc" id="L6623" title="All 6 branches missed.">        if ((fieldofFireUnit == null)</span>
            || (ce == null)
            || (cmd == null)) {
<span class="nc" id="L6626">            clearFieldofF();</span>
<span class="nc" id="L6627">            return;</span>
        }

        // If the field of fire is not dispalyed
        // for the active unit, then don't change anything
<span class="nc bnc" id="L6632" title="All 2 branches missed.">        if (fieldofFireUnit.equals(ce)) {</span>

<span class="nc" id="L6634">            fieldofFireWpUnderwater = 0;</span>
            // check if the weapon ends up underwater
<span class="nc" id="L6636">            IHex hex = game.getBoard().getHex(cmd.getFinalCoords());</span>

<span class="nc bnc" id="L6638" title="All 4 branches missed.">            if ((hex.terrainLevel(Terrains.WATER) &gt; 0) &amp;&amp; !cmd.isJumping()</span>
<span class="nc bnc" id="L6639" title="All 2 branches missed.">                    &amp;&amp; (cmd.getFinalElevation() &lt; 0)) {</span>
<span class="nc bnc" id="L6640" title="All 4 branches missed.">                if ((fieldofFireUnit instanceof Mech) &amp;&amp; !fieldofFireUnit.isProne()</span>
<span class="nc bnc" id="L6641" title="All 2 branches missed.">                        &amp;&amp; (hex.terrainLevel(Terrains.WATER) == 1)) {</span>
<span class="nc bnc" id="L6642" title="All 4 branches missed.">                    if ((fieldofFireWpLoc == Mech.LOC_RLEG)</span>
                        || (fieldofFireWpLoc == Mech.LOC_LLEG))
<span class="nc" id="L6644">                        fieldofFireWpUnderwater = 1;</span>

<span class="nc bnc" id="L6646" title="All 2 branches missed.">                    if (fieldofFireUnit instanceof QuadMech) {</span>
<span class="nc bnc" id="L6647" title="All 4 branches missed.">                        if ((fieldofFireWpLoc == Mech.LOC_RARM)</span>
                            || (fieldofFireWpLoc == Mech.LOC_LARM))
<span class="nc" id="L6649">                            fieldofFireWpUnderwater = 1;</span>
                    }
<span class="nc bnc" id="L6651" title="All 2 branches missed.">                    if (fieldofFireUnit instanceof TripodMech) {</span>
<span class="nc bnc" id="L6652" title="All 2 branches missed.">                        if (fieldofFireWpLoc == Mech.LOC_CLEG)</span>
<span class="nc" id="L6653">                            fieldofFireWpUnderwater = 1;</span>
                    }
                } else {
<span class="nc" id="L6656">                    fieldofFireWpUnderwater = 1;</span>
                }
            }
<span class="nc" id="L6659">            setWeaponFieldofFire(cmd.getFinalFacing(), cmd.getFinalCoords());</span>
        }
<span class="nc" id="L6661">    }</span>

    // prepares the sprites for a field of fire
    public void setWeaponFieldofFire(int fac, Coords c) {
<span class="nc bnc" id="L6665" title="All 2 branches missed.">        if (fieldofFireUnit == null) {</span>
<span class="nc" id="L6666">            clearFieldofF();</span>
<span class="nc" id="L6667">            return;</span>
        }

        // Do not display anything for offboard units
<span class="nc bnc" id="L6671" title="All 2 branches missed.">        if (fieldofFireUnit.isOffBoard()) {</span>
<span class="nc" id="L6672">            clearFieldofF();</span>
<span class="nc" id="L6673">            return;</span>
        }

        // check if extreme range is used
<span class="nc" id="L6677">        int maxrange = 4;</span>
<span class="nc" id="L6678">        if (game.getOptions().</span>
<span class="nc bnc" id="L6679" title="All 2 branches missed.">                booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RANGE)) maxrange = 5;</span>

        // create the lists of hexes
<span class="nc" id="L6682">        List&lt;Set&lt;Coords&gt;&gt; fieldFire = new ArrayList&lt;Set&lt;Coords&gt;&gt;(5);</span>
<span class="nc" id="L6683">        int range = 1;</span>
        // for all available range brackets Min/S/M/L/E ...
<span class="nc bnc" id="L6685" title="All 2 branches missed.">        for (int bracket = 0; bracket &lt; maxrange; bracket++) {</span>
<span class="nc" id="L6686">            fieldFire.add(new HashSet&lt;Coords&gt;());</span>
            // Add all hexes up to the weapon range to separate lists
<span class="nc bnc" id="L6688" title="All 2 branches missed.">            while (range&lt;=fieldofFireRanges[fieldofFireWpUnderwater][bracket]) {</span>
<span class="nc" id="L6689">                fieldFire.get(bracket).addAll(c.allAtDistance(range));</span>
<span class="nc" id="L6690">                range++;</span>
<span class="nc bnc" id="L6691" title="All 2 branches missed.">                if (range&gt;100) break; // only to avoid hangs</span>
            }

            // Remove hexes that are not on the board or not in the arc
<span class="nc bnc" id="L6695" title="All 2 branches missed.">            for (Iterator&lt;Coords&gt; iterator = fieldFire.get(bracket).iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L6696">                Coords h = iterator.next();</span>
<span class="nc bnc" id="L6697" title="All 2 branches missed.">                if (!game.getBoard().contains(h)</span>
<span class="nc bnc" id="L6698" title="All 2 branches missed.">                        || !Compute.isInArc(c, fac, h, fieldofFireWpArc)) {</span>
<span class="nc" id="L6699">                    iterator.remove();</span>
                }
<span class="nc" id="L6701">            }</span>
        }

        // create the sprites
        //
<span class="nc" id="L6706">        fieldofFireSprites.clear();</span>

        // for all available range brackets Min/S/M/L/E ...
<span class="nc bnc" id="L6709" title="All 2 branches missed.">        for (int bracket = 0; bracket &lt; fieldFire.size(); bracket++) {</span>
<span class="nc bnc" id="L6710" title="All 2 branches missed.">            if (fieldFire.get(bracket) == null) continue;</span>
<span class="nc bnc" id="L6711" title="All 2 branches missed.">            for (Coords loc : fieldFire.get(bracket)) {</span>
                // check surrounding hexes
<span class="nc" id="L6713">                int edgesToPaint = 0;</span>
<span class="nc bnc" id="L6714" title="All 2 branches missed.">                for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L6715">                    Coords adjacentHex = loc.translated(dir);</span>
<span class="nc bnc" id="L6716" title="All 2 branches missed.">                    if (!fieldFire.get(bracket).contains(adjacentHex)) edgesToPaint += (1 &lt;&lt; dir);</span>
                }
                // create sprite if there's a border to paint
<span class="nc bnc" id="L6719" title="All 2 branches missed.">                if (edgesToPaint &gt; 0) {</span>
<span class="nc" id="L6720">                    FieldofFireSprite ffSprite = new FieldofFireSprite(</span>
                            this, bracket, loc, edgesToPaint);
<span class="nc" id="L6722">                    fieldofFireSprites.add(ffSprite);</span>
                }
<span class="nc" id="L6724">            }</span>
            // Add range markers (m, S, M, L, E)
            // this looks for a hex in the middle of the range bracket;
            // if outside the board, nearer hexes will be tried until
            // the inner edge of the range bracket is reached
            // the directions tested are those that fall between the
            // hex facings because this makes for a better placement
            // ... most of the time...

            // The directions[][] is used to make the marker placement
            // fairly symmetrical to the unit facing which a simple for
            // loop over the hex facings doesn't do
<span class="nc" id="L6736">            int[][] directions = { {0,1},{0,5},{3,2},{3,4},{1,2},{5,4} };</span>
            // don't paint too many &quot;min&quot; markers
<span class="nc" id="L6738">            int numMinMarkers = 0;</span>
<span class="nc bnc" id="L6739" title="All 2 branches missed.">            for (int[] dir: directions) {</span>
                // find the middle of the range bracket
<span class="nc" id="L6741">                int rangeend = Math.max(fieldofFireRanges[fieldofFireWpUnderwater][bracket],0);</span>
<span class="nc" id="L6742">                int rangebegin = 1;</span>
<span class="nc bnc" id="L6743" title="All 2 branches missed.">                if (bracket&gt;0)</span>
<span class="nc" id="L6744">                    rangebegin = Math.max(fieldofFireRanges[fieldofFireWpUnderwater][bracket-1]+1,1);</span>
<span class="nc" id="L6745">                int dist = (rangeend + rangebegin)/2;</span>
                // translate to the middle of the range bracket
<span class="nc" id="L6747">                Coords mark = c.translated((dir[0]+fac)%6,(dist+1)/2)</span>
<span class="nc" id="L6748">                        .translated((dir[1]+fac)%6,dist/2);</span>
                // traverse back to the unit until a hex is onboard
<span class="nc bnc" id="L6750" title="All 2 branches missed.">                while (!game.getBoard().contains(mark))</span>
<span class="nc" id="L6751">                    mark = Coords.nextHex(mark, c);</span>

                // add a text range marker if the found position is good
<span class="nc bnc" id="L6754" title="All 8 branches missed.">                if (game.getBoard().contains(mark) &amp;&amp; fieldFire.get(bracket).contains(mark)</span>
                        &amp;&amp; ((bracket &gt; 0) || (numMinMarkers &lt; 2))) {
<span class="nc" id="L6756">                    TextMarkerSprite tS = new TextMarkerSprite(this, mark,</span>
                            rangeTexts[bracket], FieldofFireSprite.fieldofFireColors[bracket]);
<span class="nc" id="L6758">                    fieldofFireSprites.add(tS);</span>
<span class="nc bnc" id="L6759" title="All 2 branches missed.">                    if (bracket == 0) numMinMarkers++;</span>
                }
            }
        }

<span class="nc" id="L6764">        repaint();</span>
<span class="nc" id="L6765">    }</span>

    /** Displays a dialog and changes the theme of all
     *  board hexes to the user-chosen theme.
     */
    public void changeTheme() {
<span class="nc bnc" id="L6771" title="All 2 branches missed.">        if (game == null) return;</span>
<span class="nc" id="L6772">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L6773" title="All 2 branches missed.">        if (board.inSpace()) return;</span>

<span class="nc" id="L6775">        Set&lt;String&gt; themes = tileManager.getThemes();</span>
<span class="nc bnc" id="L6776" title="All 2 branches missed.">        if (themes.remove(&quot;&quot;)) themes.add(&quot;(No Theme)&quot;);</span>
<span class="nc" id="L6777">        themes.add(&quot;(Original Theme)&quot;);</span>

<span class="nc" id="L6779">        setShouldIgnoreKeys(true);</span>
<span class="nc" id="L6780">        selectedTheme = (String)JOptionPane.showInputDialog(</span>
                null,
                &quot;Choose the desired theme:&quot;,
                &quot;Theme Selection&quot;,
                JOptionPane.PLAIN_MESSAGE,
                null,
<span class="nc" id="L6786">                themes.toArray(),</span>
                selectedTheme);
<span class="nc" id="L6788">        setShouldIgnoreKeys(false);</span>

<span class="nc bnc" id="L6790" title="All 2 branches missed.">        if (selectedTheme == null) {</span>
<span class="nc" id="L6791">            return;</span>
<span class="nc bnc" id="L6792" title="All 2 branches missed.">        } else if (selectedTheme.equals(&quot;(Original Theme)&quot;)) {</span>
<span class="nc" id="L6793">            selectedTheme = null;</span>
<span class="nc bnc" id="L6794" title="All 2 branches missed.">        } else if (selectedTheme.equals(&quot;(No Theme)&quot;)) {</span>
<span class="nc" id="L6795">            selectedTheme = &quot;&quot;;</span>
        }
        
<span class="nc" id="L6798">        board.setTheme(selectedTheme);</span>
<span class="nc" id="L6799">    }</span>

    private Image getBoardBackgroundHexImage(Coords c, IHex hex) {
<span class="nc" id="L6802">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L6803" title="All 6 branches missed.">        if ((hex == null) || (board == null) || (hex.getTheme() == null)</span>
<span class="nc bnc" id="L6804" title="All 2 branches missed.">                || !hex.getTheme().equals(HexTileset.TRANSPARENT_THEME)</span>
<span class="nc bnc" id="L6805" title="All 2 branches missed.">                || !board.hasBoardBackground()) {</span>
<span class="nc" id="L6806">            return null;</span>
        }
        // Determine what sub-board the hex came from
<span class="nc" id="L6809">        int boardX = (int)((c.getX() + 0.0) / board.getSubBoardWidth());</span>
<span class="nc" id="L6810">        int boardY = (int)((c.getY() + 0.0) / board.getSubBoardHeight());</span>
<span class="nc" id="L6811">        int linIdx = boardY * board.getNumBoardsWidth() + boardX;</span>
<span class="nc bnc" id="L6812" title="All 4 branches missed.">        if (linIdx &lt; 0 || linIdx &gt; boardBackgrounds.size() - 1) {</span>
<span class="nc" id="L6813">            System.out.println(&quot;Error computing linear index or &quot;</span>
                    + &quot;missing background images &quot;
                    + &quot;in BoardView1.getBoardBackgroundHexImage!&quot;);
<span class="nc" id="L6816">            return null;</span>
        }
<span class="nc" id="L6818">        Image bgImg = getScaledImage(boardBackgrounds.get(linIdx), true);</span>
<span class="nc" id="L6819">        int bgImgWidth = bgImg.getWidth(null);</span>
<span class="nc" id="L6820">        int bgImgHeight = bgImg.getHeight(null);</span>

<span class="nc" id="L6822">        Point p1SRC = getHexLocationLargeTile(</span>
<span class="nc" id="L6823">                c.getX() - (boardX * board.getSubBoardWidth()),</span>
<span class="nc" id="L6824">                c.getY() - (boardY * board.getSubBoardHeight()));</span>
<span class="nc" id="L6825">        p1SRC.x = p1SRC.x % bgImgWidth;</span>
<span class="nc" id="L6826">        p1SRC.y = p1SRC.y % bgImgHeight;</span>
<span class="nc" id="L6827">        Point p2SRC = new Point((int) (p1SRC.x + HEX_W * scale),</span>
                (int) (p1SRC.y + HEX_H * scale));
<span class="nc" id="L6829">        Point p2DST = new Point((int) (HEX_W * scale),</span>
                (int) (HEX_H * scale));

<span class="nc" id="L6832">        Image hexImage = new BufferedImage(HEX_W,  HEX_H,</span>
                BufferedImage.TYPE_INT_ARGB);
<span class="nc" id="L6834">        Graphics2D g = (Graphics2D)hexImage.getGraphics();</span>

        // hex mask to limit drawing to the hex shape
        // TODO: this is not ideal yet but at least it draws
        // without leaving gaps at any zoom
<span class="nc" id="L6839">        Image hexMask = getScaledImage(tileManager.getHexMask(), true);</span>
<span class="nc" id="L6840">        g.drawImage(hexMask, 0, 0, this);</span>
<span class="nc" id="L6841">        Composite svComp = g.getComposite();</span>
<span class="nc" id="L6842">        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP,</span>
              1f));

        // paint the right slice from the big pic
<span class="nc" id="L6846">        g.drawImage(bgImg, 0, 0, p2DST.x, p2DST.y, p1SRC.x, p1SRC.y,</span>
                p2SRC.x, p2SRC.y, null);

        // Handle wrapping of the image
<span class="nc bnc" id="L6850" title="All 4 branches missed.">        if (p2SRC.x &gt; bgImgWidth &amp;&amp; p2SRC.y &lt;= bgImgHeight) {</span>
<span class="nc" id="L6851">            g.drawImage(bgImg, bgImgWidth - p1SRC.x, 0, p2DST.x,</span>
                    p2DST.y, 0, p1SRC.y, p2SRC.x - bgImgWidth, p2SRC.y,
                    null); // paint addtl slice on the left side
<span class="nc bnc" id="L6854" title="All 4 branches missed.">        } else if (p2SRC.x &lt;= bgImgWidth &amp;&amp; p2SRC.y &gt; bgImgHeight) {</span>
<span class="nc" id="L6855">            g.drawImage(bgImg, 0, bgImgHeight - p1SRC.y, p2DST.x,</span>
                    p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - bgImgHeight,
                    null); // paint addtl slice on the top
<span class="nc bnc" id="L6858" title="All 4 branches missed.">        } else if (p2SRC.x &gt; bgImgWidth &amp;&amp; p2SRC.y &gt; bgImgHeight) {</span>
<span class="nc" id="L6859">            g.drawImage(bgImg, bgImgWidth - p1SRC.x, 0, p2DST.x,</span>
                    p2DST.y, 0, p1SRC.y, p2SRC.x - bgImgWidth, p2SRC.y,
                    null); // paint addtl slice on the top
<span class="nc" id="L6862">            g.drawImage(bgImg, 0, bgImgHeight - p1SRC.y, p2DST.x,</span>
                    p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - bgImgHeight,
                    null); // paint addtl slice on the left side
            // paint addtl slice on the top left side
<span class="nc" id="L6866">            g.drawImage(bgImg, bgImgWidth - p1SRC.x,</span>
                    bgImgHeight - p1SRC.y, p2DST.x, p2DST.y, 0, 0,
                    p2SRC.x - bgImgWidth, p2SRC.y - bgImgHeight, null);
        }
<span class="nc" id="L6870">        g.setComposite(svComp);</span>
<span class="nc" id="L6871">        return hexImage;</span>
    }

    public void setDisplayInvalidHexInfo(boolean v) {
<span class="nc" id="L6875">        displayInvalidHexInfo = v;</span>
<span class="nc" id="L6876">    }</span>

    public boolean getDisplayInvalidHexInfo() {
<span class="nc" id="L6879">        return displayInvalidHexInfo;</span>
    }
    
    public Rectangle getDisplayablesRect() {
<span class="nc" id="L6883">        return displayablesRect;</span>
    }
    
    public void toggleKeybindsOverlay() {
<span class="nc bnc" id="L6887" title="All 2 branches missed.">        keybindOverlay.setVisible(!keybindOverlay.isVisible());</span>
<span class="nc" id="L6888">        repaint();</span>
<span class="nc" id="L6889">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>