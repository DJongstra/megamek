<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="nl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Compute.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PlayerTest Coverage Results</a> &gt; <a href="index.source.html" class="el_package">megamek.common</a> &gt; <span class="el_source">Compute.java</span></div><h1>Compute.java</h1><pre class="source lang-java linenums">/*
* MegaMek -
* Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Ben Mazur (bmazur@sev.org)
* Copyright (C) 2018 The MegaMek Team
*
* This program is free software; you can redistribute it and/or modify it under
* the terms of the GNU General Public License as published by the Free Software
* Foundation; either version 2 of the License, or (at your option) any later
* version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
* details.
*/

package megamek.common;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.Vector;

import megamek.common.Building.BasementType;
import megamek.common.MovePath.MoveStepType;
import megamek.common.actions.BAVibroClawAttackAction;
import megamek.common.actions.BreakGrappleAttackAction;
import megamek.common.actions.BrushOffAttackAction;
import megamek.common.actions.ClubAttackAction;
import megamek.common.actions.EntityAction;
import megamek.common.actions.GrappleAttackAction;
import megamek.common.actions.JumpJetAttackAction;
import megamek.common.actions.KickAttackAction;
import megamek.common.actions.LayExplosivesAttackAction;
import megamek.common.actions.ProtomechPhysicalAttackAction;
import megamek.common.actions.PunchAttackAction;
import megamek.common.actions.PushAttackAction;
import megamek.common.actions.ThrashAttackAction;
import megamek.common.actions.TripAttackAction;
import megamek.common.actions.WeaponAttackAction;
import megamek.common.annotations.Nullable;
import megamek.common.options.OptionsConstants;
import megamek.common.weapons.InfantryAttack;
import megamek.common.weapons.Weapon;
import megamek.common.weapons.artillery.ArtilleryCannonWeapon;
import megamek.common.weapons.bayweapons.BayWeapon;
import megamek.common.weapons.gaussrifles.HAGWeapon;
import megamek.common.weapons.infantry.InfantryWeapon;
import megamek.common.weapons.mgs.MGWeapon;
import megamek.common.weapons.mortars.MekMortarWeapon;
import megamek.server.Server;
import megamek.server.SmokeCloud;

/**
 * The compute class is designed to provide static methods for mechs and other
 * entities moving, firing, etc.
 */
<span class="nc" id="L63">public class Compute {</span>

    public static final int ARC_360 = 0;
    public static final int ARC_FORWARD = 1;
    public static final int ARC_LEFTARM = 2;
    public static final int ARC_RIGHTARM = 3;
    public static final int ARC_REAR = 4;
    public static final int ARC_LEFTSIDE = 5;
    public static final int ARC_RIGHTSIDE = 6;
    public static final int ARC_MAINGUN = 7;
    public static final int ARC_NORTH = 8;
    public static final int ARC_EAST = 9;
    public static final int ARC_WEST = 10;
    public static final int ARC_NOSE = 11;
    public static final int ARC_LWING = 12;
    public static final int ARC_RWING = 13;
    public static final int ARC_LWINGA = 14;
    public static final int ARC_RWINGA = 15;
    public static final int ARC_LEFTSIDE_SPHERE = 16;
    public static final int ARC_RIGHTSIDE_SPHERE = 17;
    public static final int ARC_LEFTSIDEA_SPHERE = 18;
    public static final int ARC_RIGHTSIDEA_SPHERE = 19;
    public static final int ARC_LEFT_BROADSIDE = 20;
    public static final int ARC_RIGHT_BROADSIDE = 21;
    public static final int ARC_AFT = 22;
    public static final int ARC_LEFT_SPHERE_GROUND = 23;
    public static final int ARC_RIGHT_SPHERE_GROUND = 24;
    public static final int ARC_TURRET = 25;
    public static final int ARC_SPONSON_TURRET_LEFT = 26;
    public static final int ARC_SPONSON_TURRET_RIGHT = 27;
    public static final int ARC_PINTLE_TURRET_LEFT = 28;
    public static final int ARC_PINTLE_TURRET_RIGHT = 29;
    public static final int ARC_PINTLE_TURRET_FRONT = 30;
    public static final int ARC_PINTLE_TURRET_REAR = 31;
    public static final int ARC_VGL_FRONT = 32;
    public static final int ARC_VGL_RF = 33;
    public static final int ARC_VGL_RR = 34;
    public static final int ARC_VGL_REAR = 35;
    public static final int ARC_VGL_LR = 36;
    public static final int ARC_VGL_LF = 37;
    //Expanded arcs for Waypoint Launched Capital Missiles
    public static final int ARC_NOSE_WPL = 38;
    public static final int ARC_LWING_WPL = 39;
    public static final int ARC_RWING_WPL = 40;
    public static final int ARC_LWINGA_WPL = 41;
    public static final int ARC_RWINGA_WPL = 42;
    public static final int ARC_LEFTSIDE_SPHERE_WPL = 43;
    public static final int ARC_RIGHTSIDE_SPHERE_WPL = 44;
    public static final int ARC_LEFTSIDEA_SPHERE_WPL = 45;
    public static final int ARC_RIGHTSIDEA_SPHERE_WPL = 46;
    public static final int ARC_AFT_WPL = 47;
    public static final int ARC_LEFT_BROADSIDE_WPL = 48;
    public static final int ARC_RIGHT_BROADSIDE_WPL = 49;
    
    /** Lookup table for vehicular grenade launcher firing arc from facing */
<span class="nc" id="L118">    private static final int[] VGL_FIRING_ARCS = { ARC_VGL_FRONT, ARC_VGL_RF, ARC_VGL_RR,</span>
            ARC_VGL_REAR, ARC_VGL_LR, ARC_VGL_LF
    };

<span class="nc" id="L122">    private static MMRandom random = MMRandom.generate(MMRandom.R_DEFAULT);</span>

<span class="nc" id="L124">    private static final int[][] clusterHitsTable = new int[][]{</span>
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2},
            {3, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3},
            {4, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4},
            {5, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5},
            {6, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6},
            {7, 2, 2, 3, 4, 4, 4, 4, 6, 6, 7, 7},
            {8, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8},
            {9, 3, 3, 4, 5, 5, 5, 5, 7, 7, 9, 9},
            {10, 3, 3, 4, 6, 6, 6, 6, 8, 8, 10, 10},
            {11, 4, 4, 5, 7, 7, 7, 7, 9, 9, 11, 11},
            {12, 4, 4, 5, 8, 8, 8, 8, 10, 10, 12, 12},
            {13, 4, 4, 5, 8, 8, 8, 8, 11, 11, 13, 13},
            {14, 5, 5, 6, 9, 9, 9, 9, 11, 11, 14, 14},
            {15, 5, 5, 6, 9, 9, 9, 9, 12, 12, 15, 15},
            {16, 5, 5, 7, 10, 10, 10, 10, 13, 13, 16, 16},
            {17, 5, 5, 7, 10, 10, 10, 10, 14, 14, 17, 17},
            {18, 6, 6, 8, 11, 11, 11, 11, 14, 14, 18, 18},
            {19, 6, 6, 8, 11, 11, 11, 11, 15, 15, 19, 19},
            {20, 6, 6, 9, 12, 12, 12, 12, 16, 16, 20, 20},
            {21, 7, 7, 9, 13, 13, 13, 13, 17, 17, 21, 21},
            {22, 7, 7, 9, 14, 14, 14, 14, 18, 18, 22, 22},
            {23, 7, 7, 10, 15, 15, 15, 15, 19, 19, 23, 23},
            {24, 8, 8, 10, 16, 16, 16, 16, 20, 20, 24, 24},
            {25, 8, 8, 10, 16, 16, 16, 16, 21, 21, 25, 25},
            {26, 9, 9, 11, 17, 17, 17, 17, 21, 21, 26, 26},
            {27, 9, 9, 11, 17, 17, 17, 17, 22, 22, 27, 27},
            {28, 9, 9, 11, 17, 17, 17, 17, 23, 23, 28, 28},
            {29, 10, 10, 12, 18, 18, 18, 18, 23, 23, 29, 29},
            {30, 10, 10, 12, 18, 18, 18, 18, 24, 24, 30, 30},
            {40, 12, 12, 18, 24, 24, 24, 24, 32, 32, 40, 40}};

    /**
     * Wrapper to random#d6(n)
     */
    public static int d6(int dice) {
<span class="nc" id="L161">        Roll roll = random.d6(dice);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (Server.getServerInstance() != null) {</span>
<span class="nc" id="L163">            if (Server.getServerInstance().getGame().getOptions()</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">                      .booleanOption(OptionsConstants.BASE_RNG_LOG)) {</span>
<span class="nc" id="L165">                Server.getServerInstance().reportRoll(roll);</span>
            }
        }
<span class="nc" id="L168">        return roll.getIntValue();</span>
    }

    /**
     * Wrapper to random#d6(n)
     */
    public static int d6(int dice, int keep) {
<span class="nc" id="L175">        Roll roll = random.d6(dice, keep);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (Server.getServerInstance() != null) {</span>
<span class="nc" id="L177">            if (Server.getServerInstance().getGame().getOptions()</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">                      .booleanOption(OptionsConstants.BASE_RNG_LOG)) {</span>
<span class="nc" id="L179">                Server.getServerInstance().reportRoll(roll);</span>
            }
        }
<span class="nc" id="L182">        return roll.getIntValue();</span>
    }

    /**
     * Wrapper to random#d6()
     */
    public static int d6() {
<span class="nc" id="L189">        Roll roll = random.d6();</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (Server.getServerInstance() != null) {</span>
<span class="nc" id="L191">            if (Server.getServerInstance().getGame().getOptions()</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                      .booleanOption(OptionsConstants.BASE_RNG_LOG)) {</span>
<span class="nc" id="L193">                Server.getServerInstance().reportRoll(roll);</span>
            }
        }
<span class="nc" id="L196">        return roll.getIntValue();</span>
    }

    /**
     * Wrapper to random#randomInt(n)
     */
    public static int randomInt(int maxValue) {
<span class="nc" id="L203">        Roll roll = new MMRoll(random, maxValue);</span>
<span class="nc" id="L204">        return roll.getIntValue();</span>
    }

    /**
     * Wrapper to random#randomFloat()
     */
    public static float randomFloat() {
<span class="nc" id="L211">        return random.randomFloat();</span>
    }

    /**
     * Sets the RNG to the desired type
     */
    public static void setRNG(int type) {
<span class="nc" id="L218">        random = MMRandom.generate(type);</span>
<span class="nc" id="L219">    }</span>

    /**
     * Sets the RNG to the specific instance.
     * @param random A non-null instance of {@see MMRandom} to use
     *               for all random number generation.
     */
    public static void setRNG(MMRandom random) {
<span class="nc" id="L227">        Compute.random = Objects.requireNonNull(random);</span>
<span class="nc" id="L228">    }</span>

    /**
     * Returns the odds that a certain number or above will be rolled on 2d6.
     */
    public static double oddsAbove(int n) {
<span class="nc" id="L234">        return oddsAbove(n, false);</span>
    }


    /**
     * Returns the odds that a certain number or above will be rolled on 2d6,
     * or on 3d6 drop the lowest if the flag is set.
     *
     * @param n
     * @param dropLowest Flag that determines whether 2d6 or 3d6 drop the
     *                   lowest is used
     * @return
     */
    public static double oddsAbove(int n, boolean dropLowest) {
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (n &lt;= 2) {</span>
<span class="nc" id="L249">            return 100.0;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">        } else if (n &gt; 12) {</span>
<span class="nc" id="L251">            return 0;</span>
        }

<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (dropLowest) {</span>
<span class="nc" id="L255">            final double[] odds = {100.0, 100.0, 100.0, 99.54, 98.15, 94.91,</span>
                                   89.35, 80.56, 68.06, 52.32, 35.65, 19.91, 7.41, 0};
<span class="nc" id="L257">            return odds[n];</span>
        } else {
<span class="nc" id="L259">            final double[] odds = {100.0, 100.0, 100.0, 97.2, 91.6, 83.3, 72.2,</span>
                                   58.3, 41.6, 27.7, 16.6, 8.3, 2.78, 0};
<span class="nc" id="L261">            return odds[n];</span>
        }
    }

    /**
     * Returns an entity if the specified entity would cause a stacking
     * violation entering a hex, or returns null if it would not. The returned
     * entity is the entity causing the violation.
     *
     * The position, and elevation for the stacking violation are derived from
     * the Entity represented by the passed Entity ID.
     */
    public static Entity stackingViolation(IGame game, int enteringId,
            Coords coords) {
<span class="nc" id="L275">        Entity entering = game.getEntity(enteringId);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (entering == null) {</span>
<span class="nc" id="L277">            return null;</span>
        }
<span class="nc" id="L279">        return Compute.stackingViolation(game, entering, coords, null);</span>
    }

    /**
     * When compiling an unloading step, both the transporter and the unloaded
     * unit probably occupy some other position on the board.
     *
     * The position, and elevation for the stacking violation are derived from
     * the passed Entity.
     *
     * @param transport
     *            Represents the unit transporing entering, which may affect
     *            stacking, can be null
     */
    public static Entity stackingViolation(IGame game, Entity entering,
            Coords dest, Entity transport) {
<span class="nc" id="L295">        return stackingViolation(game, entering, entering.getElevation(), dest,</span>
                transport);
    }

    /**
     * Returns an entity if the specified entity would cause a stacking
     * violation entering a hex, or returns null if it would not. The returned
     * entity is the entity causing the violation.
     *
     * The position is derived from the passed Entity, while the elevation is
     * derived from the passed Entity parameter.
     *
     * @param transport
     *            Represents the unit transporing entering, which may affect
     *            stacking, can be null
     */
    public static Entity stackingViolation(IGame game, Entity entering,
            int elevation, Coords dest, Entity transport) {
<span class="nc" id="L313">        return stackingViolation(game, entering, entering.getPosition(),</span>
                elevation, dest, transport);
    }

    /**
     * Returns an entity if the specified entity would cause a stacking
     * violation entering a hex, or returns null if it would not. The returned
     * entity is the entity causing the violation.
     *
     * The position and elevation is derived from the passed Entity parameter.
     *
     * @param transport
     *            Represents the unit transporing entering, which may affect
     *            stacking, can be null
     */
    public static Entity stackingViolation(IGame game, Entity entering,
            Coords origPosition, int elevation, Coords dest, Entity transport) {
        // no stacking violations on the low-atmosphere and space maps
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (!game.getBoard().onGround()) {</span>
<span class="nc" id="L332">            return null;</span>
        }

        // no stacking violations for flying aeros
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (entering.isAirborne()) {</span>
<span class="nc" id="L337">            return null;</span>
        }

<span class="nc bnc" id="L340" title="All 4 branches missed.">        boolean isMech = (entering instanceof Mech)</span>
                || (entering instanceof SmallCraft);
<span class="nc bnc" id="L342" title="All 6 branches missed.">        boolean isLargeSupport = (entering instanceof LargeSupportTank)</span>
                || (entering instanceof Dropship)
                || ((entering instanceof Mech) &amp;&amp; ((Mech) entering)
<span class="nc bnc" id="L345" title="All 2 branches missed.">                        .isSuperHeavy());</span>

<span class="nc bnc" id="L347" title="All 2 branches missed.">        boolean isTrain = !entering.getAllTowedUnits().isEmpty();</span>
<span class="nc" id="L348">        boolean isDropship = entering instanceof Dropship;</span>
<span class="nc" id="L349">        boolean isInfantry = entering instanceof Infantry;</span>
<span class="nc" id="L350">        Entity firstEntity = transport;</span>
<span class="nc" id="L351">        int totalUnits = 1;</span>
<span class="nc" id="L352">        Vector&lt;Coords&gt; positions = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L353">        positions.add(dest);</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (isDropship) {</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">            for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L356">                positions.add(dest.translated(dir));</span>
            }
        }
<span class="nc bnc" id="L359" title="All 2 branches missed.">        for (Coords coords : positions) {</span>
<span class="nc" id="L360">            int thisLowStackingLevel = elevation;</span>
<span class="nc bnc" id="L361" title="All 4 branches missed.">            if ((coords != null) &amp;&amp; (origPosition != null)) {</span>
<span class="nc" id="L362">                thisLowStackingLevel = entering.calcElevation(game.getBoard()</span>
<span class="nc" id="L363">                        .getHex(origPosition), game.getBoard()</span>
<span class="nc" id="L364">                        .getHex(coords), elevation, entering</span>
<span class="nc" id="L365">                        .climbMode(), false);</span>
            }
<span class="nc" id="L367">            int thisHighStackingLevel = thisLowStackingLevel;</span>
            // mechs only occupy one level of a building
<span class="nc bnc" id="L369" title="All 2 branches missed.">            if (!Compute.isInBuilding(game, entering, coords)) {</span>
<span class="nc" id="L370">                thisHighStackingLevel += entering.height();</span>
            }

            // Walk through the entities in the given hex.
<span class="nc bnc" id="L374" title="All 2 branches missed.">            for (Entity inHex : game.getEntitiesVector(coords)) {</span>

<span class="nc bnc" id="L376" title="All 2 branches missed.">                if (inHex.isAirborne()) {</span>
<span class="nc" id="L377">                    continue;</span>
                }

<span class="nc" id="L380">                int lowStackingLevel = inHex.getElevation();</span>
<span class="nc" id="L381">                int highStackingLevel = lowStackingLevel;</span>
                // units only occupy one level of a building
<span class="nc bnc" id="L383" title="All 2 branches missed.">                if (!Compute.isInBuilding(game, inHex)) {</span>
<span class="nc" id="L384">                    highStackingLevel += inHex.height();</span>
                }

                // Only do all this jazz if they're close enough together on lvl
                // to interfere.
<span class="nc bnc" id="L389" title="All 4 branches missed.">                if ((thisLowStackingLevel &lt;= highStackingLevel)</span>
                        &amp;&amp; (thisHighStackingLevel &gt;= lowStackingLevel)) {
                    // Don't compare the entering entity to itself.
<span class="nc bnc" id="L392" title="All 2 branches missed.">                    if (inHex.equals(entering)) {</span>
<span class="nc" id="L393">                        continue;</span>
                    }

                    // Ignore the transport of the entering entity.
<span class="nc bnc" id="L397" title="All 2 branches missed.">                    if (inHex.equals(transport)) {</span>
<span class="nc" id="L398">                        continue;</span>
                    }

                    //ignore the first trailer behind a non-superheavy tractor
                    //which can be in the same hex
<span class="nc bnc" id="L403" title="All 4 branches missed.">                    if (isTrain &amp;&amp; !entering.isSuperHeavy()) {</span>
<span class="nc" id="L404">                        Entity firstTrailer = game.getEntity(entering.getAllTowedUnits().get(0));</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                        if (inHex.equals(firstTrailer)) {</span>
<span class="nc" id="L406">                            continue;</span>
                        }
                    }

                    // DFAing units don't count towards stacking
<span class="nc bnc" id="L411" title="All 2 branches missed.">                    if (inHex.isMakingDfa()) {</span>
<span class="nc" id="L412">                        continue;</span>
                    }

                    // If the entering entity is a mech,
                    // then any other mech in the hex is a violation.
                    // Unless grappled (but chain whip grapples don't count)
                    // grounded small craft are treated as mechs for purposes
                    // of stacking
<span class="nc bnc" id="L420" title="All 4 branches missed.">                    if (isMech</span>
                            &amp;&amp; (((inHex instanceof Mech) &amp;&amp; (inHex
<span class="nc bnc" id="L422" title="All 2 branches missed.">                                    .getGrappled() != entering.getId() || inHex</span>
<span class="nc bnc" id="L423" title="All 4 branches missed.">                                    .isChainWhipGrappled())) || (inHex instanceof SmallCraft))) {</span>
<span class="nc" id="L424">                        return inHex;</span>
                    }

                    // only inf can be in the same hex as a large support vee
                    // grounded dropships are treated as large support vees,
                    // ditto for superheavy mechs
<span class="nc bnc" id="L430" title="All 4 branches missed.">                    if (isLargeSupport &amp;&amp; !(inHex instanceof Infantry)) {</span>
<span class="nc" id="L431">                        return inHex;</span>
                    }
<span class="nc bnc" id="L433" title="All 6 branches missed.">                    if (((inHex instanceof LargeSupportTank)</span>
                            || (inHex instanceof Dropship) || ((inHex instanceof Mech) &amp;&amp; ((Mech) inHex)
<span class="nc bnc" id="L435" title="All 4 branches missed.">                            .isSuperHeavy())) &amp;&amp; !isInfantry) {</span>
<span class="nc" id="L436">                        return inHex;</span>
                    }

<span class="nc" id="L439">                    totalUnits++;</span>
                    // If the new one is the most
<span class="nc bnc" id="L441" title="All 2 branches missed.">                    if (totalUnits &gt; 4) {</span>
                        // Arbitrarily return this one, because we can, and it's
                        // simpler.
<span class="nc" id="L444">                        return inHex;</span>
                    }

                    // Otherwise, if there are two present entities controlled
                    // by this player, returns a random one of the two.
                    // Somewhat arbitrary, but how else should we resolve it?
<span class="nc bnc" id="L450" title="All 2 branches missed.">                    if (!inHex.getOwner().isEnemyOf(entering.getOwner())) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                        if (firstEntity == null) {</span>
<span class="nc" id="L452">                            firstEntity = inHex;</span>
                        } else {
<span class="nc bnc" id="L454" title="All 2 branches missed.">                            return Compute.d6() &gt; 3 ? firstEntity : inHex;</span>
                        }
                    }
                }
<span class="nc" id="L458">            }</span>
<span class="nc" id="L459">        }</span>
        // okay, all clear
<span class="nc" id="L461">        return null;</span>
    }

    /**
     * Returns true if there is any unit that is an enemy of the specified unit
     * in the specified hex. This is only called for stacking purposes, and so
     * does not return true if the enemy unit is currenly making a DFA.
     */
    public static boolean isEnemyIn(IGame game, Entity entity, Coords coords,
                                    boolean onlyMechs, boolean ignoreInfantry, int enLowEl) {
<span class="nc" id="L471">        int enHighEl = enLowEl + entity.getHeight();</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">        for (Entity inHex : game.getEntitiesVector(coords)) {</span>
<span class="nc" id="L473">            int inHexEnLowEl = inHex.getElevation();</span>
<span class="nc" id="L474">            int inHexEnHighEl = inHexEnLowEl + inHex.getHeight();</span>
<span class="nc bnc" id="L475" title="All 8 branches missed.">            if ((!onlyMechs || (inHex instanceof Mech))</span>
                &amp;&amp; !(ignoreInfantry &amp;&amp; (inHex instanceof Infantry))
<span class="nc bnc" id="L477" title="All 8 branches missed.">                &amp;&amp; inHex.isEnemyOf(entity) &amp;&amp; !inHex.isMakingDfa()</span>
                &amp;&amp; (enLowEl &lt;= inHexEnHighEl) &amp;&amp; (enHighEl &gt;= inHexEnLowEl)) {
<span class="nc" id="L479">                return true;</span>
            }
<span class="nc" id="L481">        }</span>
<span class="nc" id="L482">        return false;</span>
    }

    /**
     * @return true if a piloting skill roll is needed to traverse the terrain
     */
    public static boolean isPilotingSkillNeeded(IGame game, int entityId,
            Coords src, Coords dest, EntityMovementType movementType,
            boolean isTurning, boolean prevStepIsOnPavement, int srcElevation,
            int destElevation, MoveStep moveStep) {
<span class="nc" id="L492">        final Entity entity = game.getEntity(entityId);</span>
<span class="nc" id="L493">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L494">        final IHex destHex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L495">        final boolean isInfantry = (entity instanceof Infantry);</span>
<span class="nc" id="L496">        int delta_alt = (destElevation + destHex.getLevel())</span>
<span class="nc" id="L497">                        - (srcElevation + srcHex.getLevel());</span>

        // arguments valid?
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (entity == null) {</span>
<span class="nc" id="L501">            throw new IllegalArgumentException(&quot;Entity invalid. ID &quot; + entityId);</span>
        }
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (src.distance(dest) &gt; 1) {</span>
<span class="nc" id="L504">            throw new IllegalArgumentException(&quot;Coordinates must be adjacent.&quot;);</span>
        }

        // let's only worry about actual movement, please
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (src.equals(dest)) {</span>
<span class="nc" id="L509">            return false;</span>
        }

        // airborne aircraft do not require pavement-related checks
<span class="nc bnc" id="L513" title="All 2 branches missed.">        final boolean isPavementStep = entity.isAirborne() ? false : Compute.canMoveOnPavement(game, src, dest, moveStep);</span>

        // check for rubble
<span class="nc bnc" id="L516" title="All 2 branches missed.">        if ((movementType != EntityMovementType.MOVE_JUMP)</span>
<span class="nc bnc" id="L517" title="All 6 branches missed.">            &amp;&amp; (destHex.terrainLevel(Terrains.RUBBLE) &gt; 0)</span>
            &amp;&amp; (destElevation == 0)
            &amp;&amp; !isPavementStep
<span class="nc bnc" id="L520" title="All 2 branches missed.">            &amp;&amp; entity.canFall()) {</span>
<span class="nc" id="L521">            return true;</span>
        }

        // check for swamp
<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (destHex.containsTerrain(Terrains.SWAMP)</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">            &amp;&amp; !(entity.getElevation() &gt; destHex.getLevel())</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</span>
<span class="nc bnc" id="L528" title="All 4 branches missed.">            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.VTOL)</span>
            &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)
<span class="nc bnc" id="L530" title="All 4 branches missed.">            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)</span>
            &amp;&amp; !isPavementStep) {
<span class="nc" id="L532">            return true;</span>
        }

        // check for thin ice
<span class="nc bnc" id="L536" title="All 2 branches missed.">        if (destHex.containsTerrain(Terrains.ICE)</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">            &amp;&amp; destHex.containsTerrain(Terrains.WATER)</span>
<span class="nc bnc" id="L538" title="All 6 branches missed.">            &amp;&amp; !(entity.getElevation() &gt; destHex.getLevel())</span>
            &amp;&amp; !isPavementStep
            &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)) {
<span class="nc" id="L541">            return true;</span>
        }

        // Check for water unless we're a hovercraft or naval or using a bridge
        // or flying or QuadVee in vehicle mode.
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if ((movementType != EntityMovementType.MOVE_JUMP)</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">                &amp;&amp; !(entity.getElevation() &gt; destHex.surface())</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                &amp;&amp; !((entity.getMovementMode() == EntityMovementMode.HOVER)</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.NAVAL)</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.HYDROFOIL)</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.SUBMARINE)</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.INF_UMU)</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.BIPED_SWIM)</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.QUAD_SWIM)</span>
<span class="nc bnc" id="L555" title="All 4 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.WIGE)</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                        || (entity instanceof QuadVee &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE))</span>
<span class="nc bnc" id="L557" title="All 4 branches missed.">                &amp;&amp; (destHex.terrainLevel(Terrains.WATER) &gt; 0)</span>
                &amp;&amp; !isPavementStep) {
<span class="nc" id="L559">            return true;</span>
        }
        
        // Sheer Cliffs, TO p.39
        // Roads over cliffs cancel the cliff effects for units that move on roads
<span class="nc bnc" id="L564" title="All 2 branches missed.">        boolean quadveeVehMode = entity instanceof QuadVee </span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">                &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE;</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">        boolean vehicleAffectedByCliff = entity instanceof Tank </span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                &amp;&amp; !entity.isAirborneVTOLorWIGE();</span>
<span class="nc bnc" id="L568" title="All 6 branches missed.">        boolean mechAffectedByCliff = (entity instanceof Mech || entity instanceof Protomech) </span>
                &amp;&amp; movementType != EntityMovementType.MOVE_JUMP
<span class="nc bnc" id="L570" title="All 2 branches missed.">                &amp;&amp; !entity.isAero(); // LAM</span>
<span class="nc" id="L571">        int stepHeight = destElevation + destHex.getLevel() - (srcElevation + srcHex.getLevel());</span>
        // Cliffs should only exist towards 1 or 2 level drops, check just to make sure
        // Everything that does not have a 1 or 2 level drop shouldn't be handled as a cliff
<span class="nc bnc" id="L574" title="All 2 branches missed.">        boolean isUpCliff = !src.equals(dest)</span>
<span class="nc bnc" id="L575" title="All 6 branches missed.">                &amp;&amp; destHex.hasCliffTopTowards(srcHex)</span>
                &amp;&amp; (stepHeight == 1 || stepHeight == 2);
<span class="nc bnc" id="L577" title="All 2 branches missed.">        boolean isDownCliff = !src.equals(dest) </span>
<span class="nc bnc" id="L578" title="All 6 branches missed.">                &amp;&amp; srcHex.hasCliffTopTowards(destHex)</span>
                &amp;&amp; (stepHeight == -1 || stepHeight == -2);

        // Mechs and Vehicles moving down a cliff
        // Quadvees in vee mode ignore PSRs to avoid falls, IO p.133 
<span class="nc bnc" id="L583" title="All 10 branches missed.">        if ((mechAffectedByCliff || vehicleAffectedByCliff) </span>
                &amp;&amp; !quadveeVehMode
                &amp;&amp; isDownCliff
                &amp;&amp; !isPavementStep) {
<span class="nc" id="L587">            return true;</span>
        }

        // Mechs moving up a cliff
<span class="nc bnc" id="L591" title="All 8 branches missed.">        if (mechAffectedByCliff </span>
                &amp;&amp; !quadveeVehMode 
                &amp;&amp; isUpCliff
                &amp;&amp; !isPavementStep) {
<span class="nc" id="L595">            return true;</span>
        }

        // Check for skid. Please note, the skid will be rolled on the
        // current step, but starts from the previous step's location.
        // TODO: add check for elevation of pavement, road,
        // or bridge matches entity elevation.
        /*
         * Bug 754610: Revert fix for bug 702735. if ( (
         * srcHex.contains(Terrain.PAVEMENT) || srcHex.contains(Terrain.ROAD) ||
         * srcHex.contains(Terrain.BRIDGE) )
         */
<span class="nc bnc" id="L607" title="All 6 branches missed.">        if (((prevStepIsOnPavement</span>
                &amp;&amp; ((movementType == EntityMovementType.MOVE_RUN)
                        || (movementType == EntityMovementType.MOVE_SPRINT)))
<span class="nc bnc" id="L610" title="All 4 branches missed.">                        || ((srcHex.containsTerrain(Terrains.ICE))</span>
                                &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)))
<span class="nc bnc" id="L612" title="All 2 branches missed.">                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</span>
<span class="nc bnc" id="L613" title="All 6 branches missed.">                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)</span>
                &amp;&amp; isTurning &amp;&amp; !isInfantry) {
<span class="nc" id="L615">            return true;</span>
        }

        // If we entering a building, all non-infantry
        // need to make a piloting check to avoid damage.
<span class="nc bnc" id="L620" title="All 4 branches missed.">        if ((destElevation &lt; destHex.terrainLevel(Terrains.BLDG_ELEV))</span>
            &amp;&amp; !(entity instanceof Infantry)) {
<span class="nc" id="L622">            Building bldg = game.getBoard().getBuildingAt(dest);</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">            boolean insideHangar = (null != bldg)</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                                   &amp;&amp; bldg.isIn(src)</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">                                   &amp;&amp; (bldg.getBldgClass() == Building.HANGAR)</span>
<span class="nc" id="L626">                                   &amp;&amp; (destHex.terrainLevel(Terrains.BLDG_ELEV) &gt; entity</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">                    .height());</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">            if (!insideHangar) {</span>
<span class="nc" id="L629">                return true;</span>
            }
        }

        // check sideslips
<span class="nc bnc" id="L634" title="All 2 branches missed.">        if ((entity instanceof VTOL)</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.HOVER)</span>
<span class="nc bnc" id="L636" title="All 6 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.WIGE</span>
                        &amp;&amp; destElevation &gt; 0 &amp;&amp; !(entity instanceof Protomech))) {
<span class="nc bnc" id="L638" title="All 10 branches missed.">            if (isTurning</span>
                    &amp;&amp; ((movementType == EntityMovementType.MOVE_RUN)
                            || (movementType == EntityMovementType.MOVE_SPRINT)
                            || (movementType == EntityMovementType.MOVE_VTOL_RUN)
                            || (movementType == EntityMovementType.MOVE_VTOL_SPRINT))) {
<span class="nc" id="L643">                return true;</span>
            }
            // Controlled sideslip requires check to avoid extra hex of sideslip movement.
<span class="nc bnc" id="L646" title="All 2 branches missed.">            if ((moveStep.getType() == MoveStepType.LATERAL_LEFT</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">                    || moveStep.getType() == MoveStepType.LATERAL_RIGHT</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">                    || moveStep.getType() == MoveStepType.LATERAL_LEFT_BACKWARDS</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">                    || moveStep.getType() == MoveStepType.LATERAL_RIGHT_BACKWARDS)</span>
<span class="nc bnc" id="L650" title="All 6 branches missed.">                    &amp;&amp; (!entity.isUsingManAce()</span>
                            || movementType != EntityMovementType.MOVE_WALK
                            || movementType != EntityMovementType.MOVE_VTOL_WALK)) {
<span class="nc" id="L653">                return true;</span>
            }
        }

        // check leaps
<span class="nc bnc" id="L658" title="All 10 branches missed.">        if ((entity instanceof Mech) &amp;&amp; (delta_alt &lt; -2)</span>
            &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP
            &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_WALK
            &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_RUN)))) {
<span class="nc" id="L662">            return true;</span>
        }

<span class="nc" id="L665">        return false;</span>
    }

    /**
     * Can the defending unit be displaced from the source to the destination?
     */
    public static boolean isValidDisplacement(IGame game, int entityId,
            Coords src, int direction) {
<span class="nc" id="L673">        return Compute.isValidDisplacement(game, entityId, src,</span>
<span class="nc" id="L674">                src.translated(direction));</span>
    }

    /**
     * Can the defending unit be displaced from the source to the destination?
     */
    public static boolean isValidDisplacement(IGame game, int entityId,
            Coords src, Coords dest) {
<span class="nc" id="L682">        final Entity entity = game.getEntity(entityId);</span>
<span class="nc" id="L683">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L684">        final IHex destHex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L685">        final ArrayList&lt;Coords&gt; intervening = Coords.intervening(src, dest);</span>
<span class="nc" id="L686">        final int direction = src.direction(dest);</span>

        // arguments valid?
<span class="nc bnc" id="L689" title="All 2 branches missed.">        if (entity == null) {</span>
<span class="nc" id="L690">            throw new IllegalArgumentException(&quot;Entity invalid.&quot;);</span>
        }

        // dropships should never be displaceable
        // this should also take care of the situation of displacing another
        // entity
        // into a grounded droppers hex, because of the stacking violation check
        // below
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (entity instanceof Dropship) {</span>
<span class="nc" id="L699">            return false;</span>
        }

        // an easy check
<span class="nc bnc" id="L703" title="All 2 branches missed.">        if (!game.getBoard().contains(dest)) {</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">            if (game.getOptions().booleanOption(OptionsConstants.BASE_PUSH_OFF_BOARD)) {</span>
<span class="nc" id="L705">                return true;</span>
            }
<span class="nc" id="L707">            return false;</span>
        }

        // can't be displaced into prohibited terrain
        // unless we're displacing a tracked or wheeled vee into water
<span class="nc bnc" id="L712" title="All 4 branches missed.">        if (entity.isLocationProhibited(dest)</span>
                &amp;&amp; !((entity instanceof Tank)
<span class="nc bnc" id="L714" title="All 6 branches missed.">                        &amp;&amp; destHex.containsTerrain(Terrains.WATER)</span>
                        &amp;&amp; ((entity.movementMode == EntityMovementMode.TRACKED)
                                || (entity.movementMode == EntityMovementMode.WHEELED)))) {
<span class="nc" id="L717">            return false;</span>
        }

        // can't go up more levels than normally possible
<span class="nc bnc" id="L721" title="All 2 branches missed.">        for (Coords c : intervening) {</span>
            // ignore off-board hexes
<span class="nc bnc" id="L723" title="All 2 branches missed.">            if (!game.getBoard().contains(c)) {</span>
<span class="nc" id="L724">                continue;</span>
            }
<span class="nc" id="L726">            final IHex hex = game.getBoard().getHex(c);</span>
<span class="nc" id="L727">            int change = entity.elevationOccupied(hex)</span>
<span class="nc" id="L728">                         - entity.elevationOccupied(srcHex);</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">            if (change &gt; entity.getMaxElevationChange()) {</span>
<span class="nc" id="L730">                return false;</span>
            }
<span class="nc" id="L732">        }</span>

        // if there's an entity in the way, can they be displaced in that
        // direction?
<span class="nc" id="L736">        Entity inTheWay = Compute.stackingViolation(game, entityId, dest);</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (inTheWay != null) {</span>
<span class="nc" id="L738">            return Compute.isValidDisplacement(game, inTheWay.getId(),</span>
<span class="nc" id="L739">                    inTheWay.getPosition(), direction);</span>
        }

        // okay, that's about all the checks
<span class="nc" id="L743">        return true;</span>
    }

    /**
     * Gets a valid displacement, from the hexes around src, as close to the
     * original direction as is possible.
     *
     * @return valid displacement coords, or null if none
     */
    public static Coords getValidDisplacement(IGame game, int entityId,
            Coords src, int direction) {
        // check the surrounding hexes, nearest to the original direction first
<span class="nc" id="L755">        int[] offsets = {0, 1, 5, 2, 4, 3};</span>
<span class="nc" id="L756">        int range = 1;</span>
        // check for a central dropship hex and if so, then displace to a two
        // hex radius
<span class="nc bnc" id="L759" title="All 2 branches missed.">        for (Entity en : game.getEntitiesVector(src)) {</span>
<span class="nc bnc" id="L760" title="All 4 branches missed.">            if ((en instanceof Dropship) &amp;&amp; !en.isAirborne()</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">                &amp;&amp; en.getPosition().equals(src)) {</span>
<span class="nc" id="L762">                range = 2;</span>
            }
<span class="nc" id="L764">        }</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">        for (int offset : offsets) {</span>
<span class="nc" id="L766">            Coords dest = src.translated((direction + offset) % 6, range);</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">            if (Compute.isValidDisplacement(game, entityId, src, dest)) {</span>
<span class="nc" id="L768">                return dest;</span>
            }
            // code here borrowed from Compute.coordsAtRange
<span class="nc bnc" id="L771" title="All 2 branches missed.">            for (int count = 1; count &lt; range; count++) {</span>
<span class="nc" id="L772">                dest = dest.translated((direction + offset + 2) % 6);</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">                if (Compute.isValidDisplacement(game, entityId, src, dest)) {</span>
<span class="nc" id="L774">                    return dest;</span>
                }
            }
        }
        // have fun being insta-killed!
<span class="nc" id="L779">        return null;</span>
    }

    /**
     * Gets a preferred displacement. Right now this picks the surrounding hex
     * with the same elevation as original hex, if not available it picks the
     * highest elevation that is a valid displacement. This will preferably not
     * displace into friendly units
     *
     * @return valid displacement coords, or null if none
     */
    public static Coords getPreferredDisplacement(IGame game, int entityId,
            Coords src, int direction) {
<span class="nc" id="L792">        final Entity entity = game.getEntity(entityId);</span>
<span class="nc" id="L793">        int highestElev = Integer.MIN_VALUE;</span>
<span class="nc" id="L794">        Coords highest = null;</span>
<span class="nc" id="L795">        int srcElevation =</span>
<span class="nc" id="L796">                entity.elevationOccupied(game.getBoard().getHex(src));</span>

        // check the surrounding hexes, nearest to the original direction first
<span class="nc" id="L799">        int[] offsets = {0, 1, 5, 2, 4, 3};</span>
        // first, try not to displace into friendly units
<span class="nc bnc" id="L801" title="All 2 branches missed.">        for (int offset : offsets) {</span>
<span class="nc" id="L802">            Coords dest = src.translated((direction + offset) % 6);</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">            if (Compute.isValidDisplacement(game, entityId, src, dest)</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">                &amp;&amp; game.getBoard().contains(dest)) {</span>
<span class="nc" id="L805">                Iterator&lt;Entity&gt; entities = game.getFriendlyEntities(dest,</span>
<span class="nc" id="L806">                        game.getEntity(entityId));</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">                if (entities.hasNext()) {</span>
                    // friendly unit here, try next hex
<span class="nc" id="L809">                    continue;</span>
                }
<span class="nc" id="L811">                IHex hex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L812">                int elevation = entity.elevationOccupied(hex);</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">                if (elevation &gt; highestElev) {</span>
<span class="nc" id="L814">                    highestElev = elevation;</span>
<span class="nc" id="L815">                    highest = dest;</span>
                }
                // preferably, go to same elevation
<span class="nc bnc" id="L818" title="All 2 branches missed.">                if (elevation == srcElevation) {</span>
<span class="nc" id="L819">                    return dest;</span>
                }
            }
        }
<span class="nc bnc" id="L823" title="All 2 branches missed.">        if (highest != null) {</span>
<span class="nc" id="L824">            return highest;</span>
        }
        // ok, all hexes occupied, now displace preferably to same elevation,
        // else highest
<span class="nc bnc" id="L828" title="All 2 branches missed.">        for (int offset : offsets) {</span>
<span class="nc" id="L829">            Coords dest = src.translated((direction + offset) % 6);</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">            if (Compute.isValidDisplacement(game, entityId, src, dest)</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">                &amp;&amp; game.getBoard().contains(dest)) {</span>
<span class="nc" id="L832">                IHex hex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L833">                int elevation = entity.elevationOccupied(hex);</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">                if (elevation &gt; highestElev) {</span>
<span class="nc" id="L835">                    highestElev = elevation;</span>
<span class="nc" id="L836">                    highest = dest;</span>
                }
                // preferably, go to same elevation
<span class="nc bnc" id="L839" title="All 2 branches missed.">                if (elevation == entity.getElevation()) {</span>
<span class="nc" id="L840">                    return dest;</span>
                }
            }
        }
<span class="nc" id="L844">        return highest;</span>
    }

    /**
     * Gets a hex to displace a missed charge to. Picks left or right, first
     * preferring higher hexes, then randomly, or returns the base hex if
     * they're impassible.
     */
    public static Coords getMissedChargeDisplacement(IGame game, int entityId,
                                                     Coords src, int direction) {
<span class="nc" id="L854">        Coords first = src.translated((direction + 1) % 6);</span>
<span class="nc" id="L855">        Coords second = src.translated((direction + 5) % 6);</span>
<span class="nc" id="L856">        IHex firstHex = game.getBoard().getHex(first);</span>
<span class="nc" id="L857">        IHex secondHex = game.getBoard().getHex(second);</span>
<span class="nc" id="L858">        Entity entity = game.getEntity(entityId);</span>

<span class="nc bnc" id="L860" title="All 4 branches missed.">        if ((firstHex == null) || (secondHex == null)) {</span>
            // leave it, will be handled
<span class="nc" id="L862">        } else if (entity.elevationOccupied(firstHex) &gt; entity</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">                .elevationOccupied(secondHex)) {</span>
            // leave it
<span class="nc" id="L865">        } else if (entity.elevationOccupied(firstHex) &lt; entity</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">                .elevationOccupied(secondHex)) {</span>
            // switch
<span class="nc" id="L868">            Coords temp = first;</span>
<span class="nc" id="L869">            first = second;</span>
<span class="nc" id="L870">            second = temp;</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">        } else if (Compute.d6() &gt; 3) {</span>
            // switch randomly
<span class="nc" id="L873">            Coords temp = first;</span>
<span class="nc" id="L874">            first = second;</span>
<span class="nc" id="L875">            second = temp;</span>
        }

<span class="nc bnc" id="L878" title="All 2 branches missed.">        if (Compute.isValidDisplacement(game, entityId, src,</span>
<span class="nc" id="L879">                                        src.direction(first))</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">            &amp;&amp; game.getBoard().contains(first)) {</span>
<span class="nc" id="L881">            return first;</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">        } else if (Compute.isValidDisplacement(game, entityId, src,</span>
<span class="nc" id="L883">                                               src.direction(second))</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">                   &amp;&amp; game.getBoard().contains(second)) {</span>
<span class="nc" id="L885">            return second;</span>
        } else {
<span class="nc" id="L887">            return src;</span>
        }
    }

    /**
     * Finds the best spotter for the attacker. The best spotter is the one with
     * the lowest attack modifiers, of course. LOS modifiers and movement are
     * considered.
     */
    public static Entity findSpotter(IGame game, Entity attacker,
                                     Targetable target) {
<span class="nc" id="L898">        Entity spotter = null;</span>
<span class="nc" id="L899">        int taggedBy = -1;</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L901">            taggedBy = ((Entity) target).getTaggedBy();</span>
        }
<span class="nc" id="L903">        ToHitData bestMods = new ToHitData(TargetRoll.IMPOSSIBLE, &quot;&quot;);</span>

<span class="nc bnc" id="L905" title="All 2 branches missed.">        for (Entity other : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">            if (((other.isSpotting() &amp;&amp; (other.getSpotTargetId() == target</span>
<span class="nc bnc" id="L907" title="All 4 branches missed.">                    .getTargetId())) || (taggedBy == other.getId()))</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">                &amp;&amp; !attacker.isEnemyOf(other)) {</span>
                // what are this guy's mods to the attack?
<span class="nc" id="L910">                LosEffects los = LosEffects.calculateLos(game, other.getId(),</span>
                        target, true);
<span class="nc" id="L912">                ToHitData mods = los.losModifiers(game);</span>
                // If the target isn't spotted, can't target
<span class="nc bnc" id="L914" title="All 2 branches missed.">                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">                    &amp;&amp; !Compute.inVisualRange(game, los, other, target)</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">                    &amp;&amp; !Compute.inSensorRange(game, los, other, target, null)) {</span>
<span class="nc" id="L917">                    mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;outside of visual and sensor range&quot;);
                }
<span class="nc" id="L920">                los.setTargetCover(LosEffects.COVER_NONE);</span>
<span class="nc" id="L921">                mods.append(Compute.getAttackerMovementModifier(game,</span>
<span class="nc" id="L922">                                                                other.getId()));</span>
                
                // a spotter suffers a penalty if it's also making an attack this round
                // unless it has a command console or has TAGged the target
<span class="nc bnc" id="L926" title="All 4 branches missed.">                if (other.isAttackingThisTurn() &amp;&amp; !other.getCrew().hasActiveCommandConsole() &amp;&amp; </span>
<span class="nc bnc" id="L927" title="All 4 branches missed.">                        (!isTargetTagged(attacker, target, game) || (taggedBy != -1))) {</span>
<span class="nc" id="L928">                    mods.addModifier(1, &quot;spotter is making an attack this turn&quot;);</span>
                }
                
                // is this guy a better spotter?
<span class="nc bnc" id="L932" title="All 2 branches missed.">                if ((spotter == null)</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">                    || (mods.getValue() &lt; bestMods.getValue())) {</span>
<span class="nc" id="L934">                    spotter = other;</span>
<span class="nc" id="L935">                    bestMods = mods;</span>
                }
            }
<span class="nc" id="L938">        }</span>

<span class="nc" id="L940">        return spotter;</span>
    }

    /**
     * Worker function to determine if the target has been tagged.
     * @param target The non-entity target to check
     * @param game Game object
     * @return Whether or not the given entity or other targetable is tagged.
     */
    public static boolean isTargetTagged(Targetable target, IGame game) {
<span class="nc" id="L950">        boolean targetTagged = false;</span>
        
<span class="nc" id="L952">        Entity te = null;</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">        if(target instanceof Entity) {</span>
<span class="nc" id="L954">            te = (Entity) target;</span>
        }
        
        // If this is an entity, we can see if it's tagged
<span class="nc bnc" id="L958" title="All 2 branches missed.">        if (te != null) {</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">            targetTagged = te.getTaggedBy() != -1;</span>
        } else { // Non entities will require us to look harder
<span class="nc bnc" id="L961" title="All 2 branches missed.">            for (TagInfo ti : game.getTagInfo()) {</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">                if (target.getTargetId() == ti.target.getTargetId()) {</span>
<span class="nc" id="L963">                    return true;</span>
                }
<span class="nc" id="L965">            }</span>
        }
        
<span class="nc" id="L968">        return targetTagged;</span>
    }
    
    /**
     * Worker function to determine if the target has been tagged by the specific attacker.
     * @param attacker The attacker.
     * @param target The non-entity target to check
     * @param game Game object
     * @return Whether or not the given entity or other targetable is tagged by the specific attacker.
     */
    public static boolean isTargetTagged(Entity attacker, Targetable target, IGame game) {
<span class="nc" id="L979">        boolean targetTagged = false;</span>
        
<span class="nc" id="L981">        Entity te = null;</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">        if(target instanceof Entity) {</span>
<span class="nc" id="L983">            te = (Entity) target;</span>
        }
        
        // If this is an entity, we can see if it's tagged
<span class="nc bnc" id="L987" title="All 2 branches missed.">        if (te != null) {</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">            targetTagged = te.getTaggedBy() == attacker.getId();</span>
        } else { // Non entities will require us to look harder
<span class="nc bnc" id="L990" title="All 2 branches missed.">            for (TagInfo ti : game.getTagInfo()) {</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">                if ((target.getTargetId() == ti.target.getTargetId()) &amp;&amp;</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">                        (ti.attackerId == attacker.getId())) {</span>
<span class="nc" id="L993">                    return true;</span>
                }
<span class="nc" id="L995">            }</span>
        }
        
<span class="nc" id="L998">        return targetTagged;</span>
    }
    
    
    public static ToHitData getImmobileMod(Targetable target) {
<span class="nc" id="L1003">        return Compute.getImmobileMod(target, Entity.LOC_NONE,</span>
                                      IAimingModes.AIM_MODE_NONE);
    }

    /**
     * Gets the ToHitData associated with firing at an immobile target. Returns null if target isn't.
     * @param target The target being considered for firing
     * @param aimingAt The location of the unit being aimed at
     * @param aimingMode The aiming mode
     * @return The relevant ToHitData
     */
    @Nullable
    public static ToHitData getImmobileMod(Targetable target, int aimingAt,
                                           int aimingMode) {
        // if we are bombing hexes, they are not considered immobile.
<span class="nc bnc" id="L1018" title="All 2 branches missed.">        if(target.getTargetType() == Targetable.TYPE_HEX_BOMB ||</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">           target.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB) {</span>
<span class="nc" id="L1020">            return null;</span>
        }

<span class="nc bnc" id="L1023" title="All 2 branches missed.">        if (target.isImmobile()) {</span>
<span class="nc bnc" id="L1024" title="All 6 branches missed.">            if ((target instanceof Mech) &amp;&amp; (aimingAt == Mech.LOC_HEAD)</span>
                &amp;&amp; (aimingMode == IAimingModes.AIM_MODE_IMMOBILE)) {
<span class="nc" id="L1026">                return new ToHitData(3, &quot;aiming at head&quot;);</span>
            }
<span class="nc" id="L1028">            return new ToHitData(-4, &quot;target immobile&quot;);</span>
        }
<span class="nc" id="L1030">        return null;</span>
    }

    /**
     * Determines the to-hit modifier due to range for an attack with the
     * specified parameters. Includes minimum range, infantry 0-range mods, and
     * target stealth mods. Accounts for friendly C3 units.
     *
     * @return the modifiers
     */
    public static ToHitData getRangeMods(IGame game, Entity ae, int weaponId,
                                         Targetable target) {
<span class="nc" id="L1042">        Mounted weapon = ae.getEquipment(weaponId);</span>
<span class="nc" id="L1043">        WeaponType wtype = (WeaponType) weapon.getType();</span>
<span class="nc" id="L1044">        int[] weaponRanges = wtype.getRanges(weapon);</span>
<span class="nc" id="L1045">        boolean isAttackerInfantry = (ae instanceof Infantry);</span>
<span class="nc" id="L1046">        boolean isAttackerBA = (ae instanceof BattleArmor);</span>
<span class="nc bnc" id="L1047" title="All 4 branches missed.">        boolean isWeaponInfantry = (wtype instanceof InfantryWeapon) &amp;&amp; !wtype.hasFlag(WeaponType.F_TAG);</span>
<span class="nc" id="L1048">        boolean isSwarmOrLegAttack = (wtype instanceof InfantryAttack);</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">        boolean isIndirect = ((wtype.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_EXLRM)</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_TBOLT_5)</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_TBOLT_10)</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_TBOLT_15)</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_TBOLT_20)</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_IATM)</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO)</span>
<span class="nc bnc" id="L1059" title="All 4 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_MEK_MORTAR)</span>
                || (wtype instanceof ArtilleryCannonWeapon))
<span class="nc bnc" id="L1061" title="All 2 branches missed.">                &amp;&amp; weapon.curMode().equals(&quot;Indirect&quot;);</span>
<span class="nc" id="L1062">        boolean useExtremeRange = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RANGE);</span>
<span class="nc" id="L1063">        boolean useLOSRange = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_LOS_RANGE);</span>
        //Naval C3 only provides full C3 range benefits to energy weapons and guided missiles
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        boolean nc3EnergyGuided = ((wtype.hasFlag(WeaponType.F_ENERGY))</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_CAPITAL_MISSILE)</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_TELE_MISSILE)</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_AR10)</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_ATM)</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_LRM)</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_SRM)</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_MML)</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_THUNDERBOLT));</span>

<span class="nc bnc" id="L1075" title="All 2 branches missed.">        if (ae.isAirborne()) {</span>
<span class="nc" id="L1076">            useExtremeRange = true;</span>
            // This is a separate SO rule, and isn't implemented yet
<span class="nc" id="L1078">            useLOSRange = false;</span>
        }

<span class="nc" id="L1081">        ToHitData mods = new ToHitData();</span>

<span class="nc" id="L1083">        Entity te = null;</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L1085">            te = (Entity) target;</span>
        }

        // We need to adjust the ranges for Centurion Weapon Systems: it's
        //  default range is 6/12/18 but that's only for units that are
        //  susceptible to CWS, for those that aren't the ranges are 1/2/3
<span class="nc bnc" id="L1091" title="All 4 branches missed.">        if (wtype.hasFlag(WeaponType.F_CWS)</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">            &amp;&amp; ((te == null) || !te.hasQuirk(&quot;susceptible_cws&quot;))) {</span>
<span class="nc" id="L1093">            weaponRanges[RangeType.RANGE_MINIMUM] = 0;</span>
<span class="nc" id="L1094">            weaponRanges[RangeType.RANGE_SHORT] = 1;</span>
<span class="nc" id="L1095">            weaponRanges[RangeType.RANGE_MEDIUM] = 2;</span>
<span class="nc" id="L1096">            weaponRanges[RangeType.RANGE_LONG] = 3;</span>
<span class="nc" id="L1097">            weaponRanges[RangeType.RANGE_EXTREME] = 4;</span>
        }

        //
        // modifiy the ranges for PPCs when field inhibitors are turned off
        // TODO: See above, it should be coded elsewhere...
        //
<span class="nc bnc" id="L1104" title="All 2 branches missed.">        if (wtype.hasFlag(WeaponType.F_PPC)) {</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">            if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_PPC_INHIBITORS)) {</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">                if ((weapon.curMode() != null)</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">                    &amp;&amp; weapon.curMode().equals(&quot;Field Inhibitor OFF&quot;)) {</span>
<span class="nc" id="L1108">                    weaponRanges[RangeType.RANGE_MINIMUM] = 0;</span>
                }
            }
        }

        // Hotloaded weapons
<span class="nc bnc" id="L1114" title="All 2 branches missed.">        if (weapon.isHotLoaded()</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">            &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_HOTLOAD)) {</span>
<span class="nc" id="L1116">            weaponRanges[RangeType.RANGE_MINIMUM] = 0;</span>
        }

        // is water involved?
<span class="nc" id="L1120">        IHex targHex = game.getBoard().getHex(target.getPosition());</span>
<span class="nc" id="L1121">        int targTop = target.relHeight();</span>
<span class="nc" id="L1122">        int targBottom = target.getElevation();</span>

<span class="nc" id="L1124">        boolean targetInPartialWater = false;</span>
<span class="nc" id="L1125">        boolean targetUnderwater = false;</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        boolean weaponUnderwater = (ae.getLocationStatus(weapon.getLocation()) == ILocationExposureStatus.WET);</span>
<span class="nc bnc" id="L1127" title="All 4 branches missed.">        if ((target.getTargetType() == Targetable.TYPE_ENTITY)</span>
<span class="nc bnc" id="L1128" title="All 4 branches missed.">            &amp;&amp; (targHex != null) &amp;&amp; targHex.containsTerrain(Terrains.WATER) </span>
            &amp;&amp; (targBottom &lt; 0)) {
            
<span class="nc bnc" id="L1131" title="All 2 branches missed.">                if (targTop &gt;= 0) {</span>
<span class="nc" id="L1132">                    targetInPartialWater = true;</span>
                } else {
<span class="nc" id="L1134">                    targetUnderwater = true;</span>
                }
        }

        // allow naval units on surface to be attacked from above or below
<span class="nc bnc" id="L1139" title="All 4 branches missed.">        if ((null != te) &amp;&amp; (targBottom == 0)</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">            &amp;&amp; (te.getUnitType() == UnitType.NAVAL)) {</span>
<span class="nc" id="L1141">            targetInPartialWater = true;</span>
        }

        // allow naval units to target underwater units,
        // torpedo tubes are mounted underwater
<span class="nc bnc" id="L1146" title="All 2 branches missed.">        if ((targetUnderwater</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO) || (wtype</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">                .getAmmoType() == AmmoType.T_SRM_TORPEDO))</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">            &amp;&amp; (ae.getUnitType() == UnitType.NAVAL)) {</span>
<span class="nc" id="L1150">            weaponUnderwater = true;</span>
<span class="nc" id="L1151">            weaponRanges = wtype.getWRanges();</span>
        }
        
        // allow ice to be cleared from below
<span class="nc bnc" id="L1155" title="All 4 branches missed.">        if ((targHex != null) &amp;&amp; targHex.containsTerrain(Terrains.WATER)</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">            &amp;&amp; (target.getTargetType() == Targetable.TYPE_HEX_CLEAR)) {</span>
<span class="nc" id="L1157">            targetInPartialWater = true;</span>
        }

<span class="nc bnc" id="L1160" title="All 2 branches missed.">        if (weaponUnderwater) {</span>
<span class="nc" id="L1161">            weaponRanges = wtype.getWRanges();</span>
<span class="nc" id="L1162">            boolean MPM = false;</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">            if ((wtype.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_SRM_IMP)</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_MRM)</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_MML)) {</span>
<span class="nc" id="L1169">                AmmoType atype = (AmmoType) weapon.getLinked().getType();</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">                if (atype.getMunitionType() == AmmoType.M_TORPEDO) {</span>
<span class="nc" id="L1171">                    weaponRanges = wtype.getRanges(weapon);</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">                } else if (atype.getMunitionType() == AmmoType.M_MULTI_PURPOSE) {</span>
<span class="nc" id="L1173">                    weaponRanges = wtype.getRanges(weapon);</span>
<span class="nc" id="L1174">                    MPM = true;</span>
                }
            }

            // HACK on ranges: for those without underwater range,
            // long == medium; iteration in rangeBracket() allows this
<span class="nc bnc" id="L1180" title="All 2 branches missed.">            if (weaponRanges[RangeType.RANGE_SHORT] == 0) {</span>
<span class="nc" id="L1181">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Weapon cannot fire underwater.&quot;);
            }
<span class="nc bnc" id="L1184" title="All 6 branches missed.">            if (!targetUnderwater &amp;&amp; !targetInPartialWater &amp;&amp; !MPM) {</span>
                // target on land or over water
<span class="nc" id="L1186">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Weapon underwater, but not target.&quot;);
            }
            // special case: mechs can only fire upper body weapons at surface
            // naval
<span class="nc bnc" id="L1191" title="All 2 branches missed.">            if ((te != null)</span>
<span class="nc bnc" id="L1192" title="All 4 branches missed.">                &amp;&amp; (te.getUnitType() == UnitType.NAVAL)</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">                &amp;&amp; (ae instanceof Mech) &amp;&amp; (ae.height() &gt; 0)</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">                &amp;&amp; (ae.getElevation() == -1)) {</span>
<span class="nc" id="L1195">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Partially submerged mech cannot fire leg weapons at surface naval vessels.&quot;);
            }
<span class="nc bnc" id="L1198" title="All 2 branches missed.">        } else if (targetUnderwater) {</span>
<span class="nc" id="L1199">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                 &quot;Target underwater, but not weapon.&quot;);
<span class="nc bnc" id="L1201" title="All 2 branches missed.">        } else if ((wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO)</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">                   || (wtype.getAmmoType() == AmmoType.T_SRM_TORPEDO)) {</span>
            // Torpedos only fire underwater.
<span class="nc" id="L1204">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                 &quot;Weapon can only fire underwater.&quot;);
        }

        // if Aero then adjust to standard ranges
<span class="nc bnc" id="L1209" title="All 4 branches missed.">        if (ae.isAero() &amp;&amp; (ae.isAirborne()</span>
<span class="nc bnc" id="L1210" title="All 4 branches missed.">            || (ae.usesWeaponBays() &amp;&amp; game.getBoard().onGround()))) {</span>
<span class="nc" id="L1211">            weaponRanges = wtype.getATRanges();</span>
        }
        // And if you're using bearings-only capital missiles, update the extreme range
<span class="nc bnc" id="L1214" title="All 2 branches missed.">        if (weapon.isInBearingsOnlyMode()) {</span>
<span class="nc" id="L1215">            weaponRanges = new int[] { Integer.MIN_VALUE, 12, 24, 40, RangeType.RANGE_BEARINGS_ONLY_OUT };</span>
        }

        // determine base distance &amp; range bracket
<span class="nc" id="L1219">        int distance = Compute.effectiveDistance(game, ae, target, false);</span>
<span class="nc" id="L1220">        int range = RangeType.rangeBracket(distance, weaponRanges,</span>
                                           useExtremeRange, useLOSRange);

        // Additional checks for LOS range and some weapon types, TO 85
<span class="nc bnc" id="L1224" title="All 2 branches missed.">        if (range == RangeType.RANGE_LOS) {</span>
            // Swarm or leg attacks can't use LoS range
<span class="nc bnc" id="L1226" title="All 2 branches missed.">            if (isSwarmOrLegAttack) {</span>
<span class="nc" id="L1227">                range = RangeType.RANGE_OUT;</span>
            }

            // MGs lack range for LOS Range, but don't have F_DIRECT_FIRE flag
<span class="nc bnc" id="L1231" title="All 2 branches missed.">            if (wtype instanceof MGWeapon) {</span>
<span class="nc" id="L1232">                range = RangeType.RANGE_OUT;</span>
            }

            // AMS lack range for LOS Range, but don't have F_DIRECT_FIRE flag
<span class="nc bnc" id="L1236" title="All 2 branches missed.">            if (wtype.hasFlag(WeaponType.F_AMS)) {</span>
<span class="nc" id="L1237">                range = RangeType.RANGE_OUT;</span>
            }

            // Flamers lack range for LOS Range, but don't have F_DIRECT_FIRE
<span class="nc bnc" id="L1241" title="All 2 branches missed.">            if (wtype.hasFlag(WeaponType.F_FLAMER)) {</span>
<span class="nc" id="L1242">                range = RangeType.RANGE_OUT;</span>
            }

<span class="nc" id="L1245">            int longRange = wtype.getRanges(weapon)[RangeType.RANGE_LONG];</span>
            // No Missiles or Direct Fire Ballistics with range &lt; 13
<span class="nc bnc" id="L1247" title="All 2 branches missed.">            if (wtype.hasFlag(WeaponType.F_MISSILE)</span>
<span class="nc bnc" id="L1248" title="All 2 branches missed.">                || (wtype.hasFlag(WeaponType.F_DIRECT_FIRE)</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">                    &amp;&amp; wtype.hasFlag(WeaponType.F_BALLISTIC))) {</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">                if (longRange &lt; 13) {</span>
<span class="nc" id="L1251">                    range = RangeType.RANGE_OUT;</span>
                }
            }
            // No Direct Fire Energy or Pulse with range &lt; 7
<span class="nc bnc" id="L1255" title="All 2 branches missed.">            if (wtype.hasFlag(WeaponType.F_PULSE)</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">                || (wtype.hasFlag(WeaponType.F_ENERGY)</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">                    &amp;&amp; wtype.hasFlag(WeaponType.F_DIRECT_FIRE))) {</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">                if (longRange &lt; 7) {</span>
<span class="nc" id="L1259">                    range = RangeType.RANGE_OUT;</span>
                }
            }
        }
<span class="nc" id="L1263">        int maxRange = wtype.getMaxRange(weapon);</span>

        // if aero and greater than max range then swith to range_out
<span class="nc bnc" id="L1266" title="All 4 branches missed.">        if ((ae.isAirborne() || (ae.usesWeaponBays() &amp;&amp; game.getBoard()</span>
<span class="nc bnc" id="L1267" title="All 4 branches missed.">                .onGround())) &amp;&amp; (range &gt; maxRange)) {</span>
<span class="nc" id="L1268">            range = RangeType.RANGE_OUT;</span>
        }

        // Swarm/Leg attacks need to  be impossible, not auto-fail, so that the
        // attack can't even be attempted
<span class="nc bnc" id="L1273" title="All 4 branches missed.">        if (isSwarmOrLegAttack &amp;&amp; (distance &gt; 0)) {</span>
<span class="nc" id="L1274">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                    &quot;Swarm/Leg attacks can &quot;
                            + &quot;only target units in the same hex!&quot;);
        }
        // short circuit if at zero range or out of range
<span class="nc bnc" id="L1279" title="All 4 branches missed.">        if ((range == RangeType.RANGE_OUT) &amp;&amp; !isWeaponInfantry) {</span>
<span class="nc" id="L1280">            return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                 &quot;Target out of range&quot;);
        }

        // Infantry with infantry weapons (rifles, etc, i.e. not field pieces)
        //  and BattleArmor can fire at zero range, among other things
<span class="nc bnc" id="L1286" title="All 10 branches missed.">        if ((distance == 0)</span>
            &amp;&amp; (!isAttackerInfantry ||
                !(isWeaponInfantry || isSwarmOrLegAttack
                  || isAttackerBA))
<span class="nc bnc" id="L1290" title="All 2 branches missed.">            &amp;&amp; !(ae.isAirborne())</span>
<span class="nc bnc" id="L1291" title="All 6 branches missed.">            &amp;&amp; !(ae.isBomber() &amp;&amp; ((IBomber)ae).isVTOLBombing())</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">            &amp;&amp; !((ae instanceof Dropship) &amp;&amp; ((Dropship) ae).isSpheroid()</span>
<span class="nc bnc" id="L1293" title="All 6 branches missed.">                 &amp;&amp; !ae.isAirborne() &amp;&amp; !ae.isSpaceborne())</span>
<span class="nc" id="L1294">            &amp;&amp; !((ae instanceof Mech) &amp;&amp; (((Mech) ae).getGrappled() == target</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">                .getTargetId()))) {</span>
<span class="nc" id="L1296">            return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                 &quot;Only infantry weapons shoot at zero range&quot;);
        }

        // Account for &quot;dead zones&quot; between Aeros at different altitudes
<span class="nc bnc" id="L1301" title="All 4 branches missed.">        if (!Compute.useSpheroidAtmosphere(game, ae) &amp;&amp; Compute.inDeadZone(game, ae, target)) {</span>
<span class="nc" id="L1302">            return new ToHitData(TargetRoll.IMPOSSIBLE, &quot;Target in dead zone&quot;);</span>
        }

        // find any c3 spotters that could help
<span class="nc" id="L1306">        Entity c3spotter = Compute.findC3Spotter(game, ae, target);</span>
<span class="nc bnc" id="L1307" title="All 2 branches missed.">        if (isIndirect) {</span>
<span class="nc" id="L1308">            c3spotter = ae; // no c3 when using indirect fire</span>
        }
<span class="nc bnc" id="L1310" title="All 2 branches missed.">        if (isIndirect</span>
<span class="nc bnc" id="L1311" title="All 2 branches missed.">            &amp;&amp; game.getOptions().booleanOption(OptionsConstants.BASE_INDIRECT_FIRE)</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_INDIRECT_ALWAYS_POSSIBLE)</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">            &amp;&amp; LosEffects.calculateLos(game, ae.getId(), target).canSee()</span>
<span class="nc bnc" id="L1314" title="All 2 branches missed.">            &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND) || Compute</span>
<span class="nc bnc" id="L1315" title="All 4 branches missed.">                .canSee(game, ae, target))</span>
            &amp;&amp; !(wtype instanceof MekMortarWeapon)) {
<span class="nc" id="L1317">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                    &quot;Indirect fire impossible with direct LOS&quot;);
        }

<span class="nc" id="L1321">        int c3dist = Compute.effectiveDistance(game, c3spotter, target, false);</span>
        // C3 can't benefit from LOS range
<span class="nc" id="L1323">        int c3range = RangeType.rangeBracket(c3dist, weaponRanges,</span>
                useExtremeRange, false);

        /*
         * Tac Ops Extreme Range Rule p. 85 if the weapons normal range is
         * Extreme then C3 uses the next highest range bracket, i.e. medium
         * instead of short.
         */
<span class="nc bnc" id="L1331" title="All 4 branches missed.">        if ((range == RangeType.RANGE_EXTREME) &amp;&amp; (c3range &lt; range)) {</span>
<span class="nc" id="L1332">            c3range++;</span>
        }

        // determine which range we're using
<span class="nc" id="L1336">        int usingRange = Math.min(range, c3range);</span>

        // add range modifier, C3 can't be used with LOS Range
<span class="nc bnc" id="L1339" title="All 8 branches missed.">        if ((usingRange == range) || (range == RangeType.RANGE_LOS) || (ae.hasNavalC3() &amp;&amp; !nc3EnergyGuided)) {</span>
            // Ensure usingRange is set to range, ie with C3
<span class="nc" id="L1341">            usingRange = range;</span>
            // Naval C3 adjustment for ballistic and unguided weapons
<span class="nc bnc" id="L1343" title="All 6 branches missed.">            if ((ae.hasNavalC3() &amp;&amp; !nc3EnergyGuided) &amp;&amp; (c3range &lt; range)) {</span>
<span class="nc bnc" id="L1344" title="All 4 branches missed.">                if (((range == RangeType.RANGE_SHORT) || (range == RangeType.RANGE_MINIMUM))</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">                        &amp;&amp; (ae.getShortRangeModifier() != 0)) {</span>
<span class="nc" id="L1346">                    mods.addModifier((ae.getShortRangeModifier() / 2), &quot;NC3 modified short range&quot;);</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_MEDIUM) {</span>
<span class="nc" id="L1348">                    mods.addModifier((ae.getMediumRangeModifier() / 2), &quot;NC3 modified medium range&quot;);</span>
<span class="nc bnc" id="L1349" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_LONG) {</span>
<span class="nc" id="L1350">                    mods.addModifier((ae.getLongRangeModifier() / 2), &quot;NC3 modified long range&quot;);</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_EXTREME) {</span>
<span class="nc" id="L1352">                    mods.addModifier((ae.getExtremeRangeModifier() / 2), &quot;NC3 modified Extreme range&quot;);</span>
                }
            } else {
                // no c3 adjustment
<span class="nc bnc" id="L1356" title="All 4 branches missed.">                if (((range == RangeType.RANGE_SHORT) || (range == RangeType.RANGE_MINIMUM))</span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">                        &amp;&amp; (ae.getShortRangeModifier() != 0)) {</span>
<span class="nc" id="L1358">                    mods.addModifier(ae.getShortRangeModifier(), &quot;short range&quot;);</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_MEDIUM) {</span>
                    // Right now, the range-mod affecting targeting systems DON'T
                    // affect medium range, so we won't add that here ever.
<span class="nc" id="L1362">                    mods.addModifier(ae.getMediumRangeModifier(), &quot;medium range&quot;);</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_LONG) {</span>
                    // Protos that loose head sensors can't shoot long range.
<span class="nc bnc" id="L1365" title="All 2 branches missed.">                    if ((ae instanceof Protomech)</span>
                            &amp;&amp; (2 == ((Protomech) ae)
<span class="nc bnc" id="L1367" title="All 2 branches missed.">                            .getCritsHit(Protomech.LOC_HEAD))) {</span>
<span class="nc" id="L1368">                        mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;No long range attacks with destroyed head sensors.&quot;);
                    } else {
<span class="nc" id="L1371">                        mods.addModifier(ae.getLongRangeModifier(), &quot;long range&quot;);</span>
                    }
<span class="nc bnc" id="L1373" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_EXTREME) {</span>
                    // Protos that loose head sensors can't shoot extreme range.
<span class="nc bnc" id="L1375" title="All 2 branches missed.">                    if ((ae instanceof Protomech)</span>
                            &amp;&amp; (2 == ((Protomech) ae)
<span class="nc bnc" id="L1377" title="All 2 branches missed.">                            .getCritsHit(Protomech.LOC_HEAD))) {</span>
<span class="nc" id="L1378">                        mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;No extreme range attacks with destroyed head sensors.&quot;);
                    } else {
<span class="nc" id="L1381">                        mods.addModifier(ae.getExtremeRangeModifier(),</span>
                                         &quot;extreme range&quot;);
                    }
<span class="nc bnc" id="L1384" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_LOS) {</span>
                    // Protos that loose head sensors can't shoot LOS range.
<span class="nc bnc" id="L1386" title="All 2 branches missed.">                    if ((ae instanceof Protomech)</span>
                            &amp;&amp; (2 == ((Protomech) ae)
<span class="nc bnc" id="L1388" title="All 2 branches missed.">                            .getCritsHit(Protomech.LOC_HEAD))) {</span>
<span class="nc" id="L1389">                        mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;No LOS range attacks with destroyed head sensors.&quot;);
                    } else {
<span class="nc" id="L1392">                        mods.addModifier(ae.getLOSRangeModifier(),</span>
                                         &quot;LOS range&quot;);
                    }
                }
            }
        } else {
            // report c3 adjustment
<span class="nc bnc" id="L1399" title="All 4 branches missed.">            if ((c3range == RangeType.RANGE_SHORT)</span>
                || (c3range == RangeType.RANGE_MINIMUM)) {
<span class="nc" id="L1401">                mods.addModifier(ae.getShortRangeModifier(),</span>
                                 &quot;short range due to C3 spotter&quot;);
<span class="nc bnc" id="L1403" title="All 2 branches missed.">            } else if (c3range == RangeType.RANGE_MEDIUM) {</span>
<span class="nc" id="L1404">                mods.addModifier(ae.getMediumRangeModifier(),</span>
                                 &quot;medium range due to C3 spotter&quot;);
<span class="nc bnc" id="L1406" title="All 2 branches missed.">            } else if (c3range == RangeType.RANGE_LONG) {</span>
<span class="nc" id="L1407">                mods.addModifier(ae.getLongRangeModifier(),</span>
                                 &quot;long range due to C3 spotter&quot;);
            }
        }

        // add minimum range modifier (only for ground-to-ground attacks)
<span class="nc" id="L1413">        int minRange = weaponRanges[RangeType.RANGE_MINIMUM];</span>
<span class="nc bnc" id="L1414" title="All 4 branches missed.">        if ((minRange &gt; 0) &amp;&amp; (distance &lt;= minRange)</span>
<span class="nc bnc" id="L1415" title="All 2 branches missed.">            &amp;&amp; Compute.isGroundToGround(ae, target)) {</span>
<span class="nc" id="L1416">            int minPenalty = (minRange - distance) + 1;</span>
<span class="nc" id="L1417">            mods.addModifier(minPenalty, &quot;minimum range&quot;);</span>
        }

        // if this is an infantry weapon then we use a whole different
        // calculation
        // to figure out range, so overwrite whatever we have at this point
<span class="nc bnc" id="L1423" title="All 2 branches missed.">        if (isWeaponInfantry) {</span>
<span class="nc" id="L1424">            mods = Compute.getInfantryRangeMods(Math.min(distance, c3dist),</span>
                    (InfantryWeapon) wtype,
<span class="nc bnc" id="L1426" title="All 2 branches missed.">                    (ae instanceof Infantry)? ((Infantry)ae).getSecondaryWeapon() : null,</span>
                            weaponUnderwater);

<span class="nc" id="L1429">            int rangeModifier = mods.getValue();</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">            if (rangeModifier == TargetRoll.AUTOMATIC_FAIL) {</span>
<span class="nc" id="L1431">                usingRange = RangeType.RANGE_OUT;</span>
<span class="nc bnc" id="L1432" title="All 2 branches missed.">            } else if (rangeModifier == 0) {</span>
<span class="nc" id="L1433">                usingRange = RangeType.RANGE_SHORT;</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">            } else if (rangeModifier &lt;= 2) {</span>
<span class="nc" id="L1435">                usingRange = RangeType.RANGE_MEDIUM;</span>
<span class="nc bnc" id="L1436" title="All 2 branches missed.">            } else if (rangeModifier &lt;= 4) {</span>
<span class="nc" id="L1437">                usingRange = RangeType.RANGE_LONG;</span>
            } else {
<span class="nc" id="L1439">                usingRange = RangeType.RANGE_EXTREME;</span>
            }
        }

        // add any target stealth modifier
<span class="nc bnc" id="L1444" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L1445">            TargetRoll tmpTR = ((Entity) target).getStealthModifier(usingRange,</span>
                                                                    ae);
<span class="nc bnc" id="L1447" title="All 4 branches missed.">            if ((tmpTR != null) &amp;&amp; (tmpTR.getValue() != 0)) {</span>
<span class="nc" id="L1448">                mods.append(((Entity) target)</span>
<span class="nc" id="L1449">                                    .getStealthModifier(usingRange, ae));</span>
            }
        }

<span class="nc" id="L1453">        return mods;</span>
    }

    /**
     * Calculate the range modifiers for a conventional infantry attack.
     *
     * @param distance - range to target
     * @param wpn - the weapon used to calculate range -- secondary if 2/squad, otherwise primary
     * @param secondary - the secondary weapon, if any. Range zero penalties apply even if primary is used for range
     * @param underwater - underwater range is half, rounded down
     * @return - all modifiers for range
     */
    public static ToHitData getInfantryRangeMods(int distance, InfantryWeapon wpn,
            InfantryWeapon secondary, boolean underwater) {
<span class="nc" id="L1467">        ToHitData mods = new ToHitData();</span>
<span class="nc" id="L1468">        int range = wpn.getInfantryRange();</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">        if (underwater) {</span>
<span class="nc" id="L1470">            range /= 2;</span>
        }
<span class="nc" id="L1472">        int mod = 0;</span>

<span class="nc bnc" id="L1474" title="All 9 branches missed.">        switch (range) {</span>
            case 0:
<span class="nc bnc" id="L1476" title="All 2 branches missed.">                if (distance &gt; 0) {</span>
<span class="nc" id="L1477">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1479" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1480">                    mod = 0;</span>
                }
                break;
            case 1:
<span class="nc bnc" id="L1484" title="All 2 branches missed.">                if (distance &gt; 3) {</span>
<span class="nc" id="L1485">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1487" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1488">                    mod = -2;</span>
<span class="nc bnc" id="L1489" title="All 2 branches missed.">                } else if (distance == 2) {</span>
<span class="nc" id="L1490">                    mod = 2;</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">                } else if (distance == 3) {</span>
<span class="nc" id="L1492">                    mod = 4;</span>
                }
                break;
            case 2:
<span class="nc bnc" id="L1496" title="All 2 branches missed.">                if (distance &gt; 6) {</span>
<span class="nc" id="L1497">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1499" title="All 2 branches missed.">                } else if (distance &gt; 4) {</span>
<span class="nc" id="L1500">                    mod = 4;</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">                } else if (distance &gt; 2) {</span>
<span class="nc" id="L1502">                    mod = 2;</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1504">                    mod = -2;</span>
                }
                break;
            case 3:
<span class="nc bnc" id="L1508" title="All 2 branches missed.">                if (distance &gt; 9) {</span>
<span class="nc" id="L1509">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1511" title="All 2 branches missed.">                } else if (distance &gt; 6) {</span>
<span class="nc" id="L1512">                    mod = 4;</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">                } else if (distance &gt; 3) {</span>
<span class="nc" id="L1514">                    mod = 2;</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1516">                    mod = -2;</span>
                }
                break;
            case 4:
<span class="nc bnc" id="L1520" title="All 2 branches missed.">                if (distance &gt; 12) {</span>
<span class="nc" id="L1521">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1523" title="All 2 branches missed.">                } else if (distance &gt; 10) {</span>
<span class="nc" id="L1524">                    mod = 4;</span>
<span class="nc bnc" id="L1525" title="All 2 branches missed.">                } else if (distance &gt; 8) {</span>
<span class="nc" id="L1526">                    mod = 3;</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">                } else if (distance &gt; 6) {</span>
<span class="nc" id="L1528">                    mod = 2;</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">                } else if (distance &gt; 4) {</span>
<span class="nc" id="L1530">                    mod = 1;</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1532">                    mod = -2;</span>
                }
                break;
            case 5:
<span class="nc bnc" id="L1536" title="All 2 branches missed.">                if (distance &gt; 15) {</span>
<span class="nc" id="L1537">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1539" title="All 2 branches missed.">                } else if (distance &gt; 12) {</span>
<span class="nc" id="L1540">                    mod = 4;</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">                } else if (distance &gt; 10) {</span>
<span class="nc" id="L1542">                    mod = 3;</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">                } else if (distance &gt; 7) {</span>
<span class="nc" id="L1544">                    mod = 2;</span>
<span class="nc bnc" id="L1545" title="All 2 branches missed.">                } else if (distance &gt; 5) {</span>
<span class="nc" id="L1546">                    mod = 1;</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1548">                    mod = -1;</span>
                }
                break;
            case 6:
<span class="nc bnc" id="L1552" title="All 2 branches missed.">                if (distance &gt; 18) {</span>
<span class="nc" id="L1553">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1555" title="All 2 branches missed.">                } else if (distance &gt; 15) {</span>
<span class="nc" id="L1556">                    mod = 5;</span>
<span class="nc bnc" id="L1557" title="All 2 branches missed.">                } else if (distance &gt; 12) {</span>
<span class="nc" id="L1558">                    mod = 4;</span>
<span class="nc bnc" id="L1559" title="All 2 branches missed.">                } else if (distance &gt; 9) {</span>
<span class="nc" id="L1560">                    mod = 2;</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">                } else if (distance &gt; 6) {</span>
<span class="nc" id="L1562">                    mod = 1;</span>
<span class="nc bnc" id="L1563" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1564">                    mod = -1;</span>
                }
                break;
            case 7:
<span class="nc bnc" id="L1568" title="All 2 branches missed.">                if (distance &gt; 21) {</span>
<span class="nc" id="L1569">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1571" title="All 2 branches missed.">                } else if (distance &gt; 17) {</span>
<span class="nc" id="L1572">                    mod = 6;</span>
<span class="nc bnc" id="L1573" title="All 2 branches missed.">                } else if (distance &gt; 14) {</span>
<span class="nc" id="L1574">                    mod = 4;</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">                } else if (distance &gt; 10) {</span>
<span class="nc" id="L1576">                    mod = 2;</span>
<span class="nc bnc" id="L1577" title="All 2 branches missed.">                } else if (distance &gt; 7) {</span>
<span class="nc" id="L1578">                    mod = 1;</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1580">                    mod = -1;</span>
                }
                break;
            default:
<span class="nc" id="L1584">                return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                     &quot;Target out of range&quot;);
        }

        // a bunch of special conditions at range 0
        // penalties due to point blank or encumbering apply for secondary weapon even if
        // primary is used to determine range
<span class="nc bnc" id="L1591" title="All 2 branches missed.">        if (distance == 0) {</span>

<span class="nc bnc" id="L1593" title="All 4 branches missed.">            if (wpn.hasFlag(WeaponType.F_INF_POINT_BLANK)</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">                    || (secondary != null &amp;&amp; secondary.hasFlag(WeaponType.F_INF_POINT_BLANK))) {</span>
<span class="nc" id="L1595">                mods.addModifier(1, &quot;point blank weapon&quot;);</span>
            }
<span class="nc bnc" id="L1597" title="All 6 branches missed.">            if (wpn.hasFlag(WeaponType.F_INF_ENCUMBER) || (wpn.getCrew() &gt; 1)</span>
                    || (secondary != null
<span class="nc bnc" id="L1599" title="All 2 branches missed.">                        &amp;&amp; (secondary.hasFlag(WeaponType.F_INF_ENCUMBER)</span>
<span class="nc bnc" id="L1600" title="All 2 branches missed.">                                || secondary.getCrew() &gt; 1))) {</span>
<span class="nc" id="L1601">                mods.addModifier(1, &quot;point blank support weapon&quot;);</span>
            }

<span class="nc bnc" id="L1604" title="All 2 branches missed.">            if (wpn.hasFlag(WeaponType.F_INF_BURST)) {</span>
<span class="nc" id="L1605">                mods.addModifier(-1, &quot;point blank burst fire weapon&quot;);</span>
            }
        }

        // TODO: we need to adjust for stealth modifiers for Chameleon LPS but
        // we don't have range brackets
        // http://bg.battletech.com/forums/index.php/topic,27433.new.html#new

<span class="nc bnc" id="L1613" title="All 2 branches missed.">        if (mod != 0) {</span>
<span class="nc" id="L1614">            mods.addModifier(mod, &quot;infantry range&quot;);</span>
        }

<span class="nc" id="L1617">        return mods;</span>
    }

    /**
     * Finds the effective distance between an attacker and a target. Includes
     * the distance bonus if the attacker and target are in the same building
     * and on different levels. Also takes account of altitude differences
     *
     * @return the effective distance
     */
    public static int effectiveDistance(IGame game, Entity attacker, Targetable target) {
<span class="nc" id="L1628">        return Compute.effectiveDistance(game, attacker, target, false);</span>
    }

    /**
     * Finds the effective distance between an attacker and a target. Includes
     * the distance bonus if the attacker and target are in the same building
     * and on different levels. Also takes account of altitude differences
     *
     * @return the effective distance
     */
    public static int effectiveDistance(IGame game, Entity attacker, Targetable target,
                                        boolean useGroundDistance) {
<span class="nc bnc" id="L1640" title="All 2 branches missed.">        if (Compute.isAirToGround(attacker, target)</span>
<span class="nc bnc" id="L1641" title="All 4 branches missed.">                || (attacker.isBomber() &amp;&amp; target.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB)) {</span>
            // always a distance of zero
<span class="nc" id="L1643">            return 0;</span>
        }

<span class="nc" id="L1646">        Vector&lt;Coords&gt; attackPos = new Vector&lt;&gt;();</span>
<span class="nc" id="L1647">        attackPos.add(attacker.getPosition());</span>
<span class="nc" id="L1648">        Vector&lt;Coords&gt; targetPos = new Vector&lt;&gt;();</span>
<span class="nc" id="L1649">        targetPos.add(target.getPosition());</span>
        // if a grounded dropship is the attacker, then it gets to choose the
        // best secondary position for LoS
<span class="nc bnc" id="L1652" title="All 6 branches missed.">        if ((attacker instanceof Dropship) &amp;&amp; !attacker.isAirborne() &amp;&amp; !attacker.isSpaceborne()) {</span>
<span class="nc" id="L1653">            attackPos = new Vector&lt;&gt;();</span>
<span class="nc bnc" id="L1654" title="All 2 branches missed.">            for (int key : attacker.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L1655">                attackPos.add(attacker.getSecondaryPositions().get(key));</span>
<span class="nc" id="L1656">            }</span>
        }
<span class="nc bnc" id="L1658" title="All 6 branches missed.">        if ((target instanceof Dropship) &amp;&amp; !target.isAirborne() &amp;&amp; !((Entity) target).isSpaceborne()) {</span>
<span class="nc" id="L1659">            targetPos = new Vector&lt;&gt;();</span>
<span class="nc bnc" id="L1660" title="All 2 branches missed.">            for (final int key : target.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L1661">                targetPos.add(target.getSecondaryPositions().get(key));</span>
<span class="nc" id="L1662">            }</span>
        }
<span class="nc" id="L1664">        int distance = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">        for (Coords apos : attackPos) {</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">            for (Coords tpos : targetPos) {</span>
<span class="nc bnc" id="L1667" title="All 4 branches missed.">                if ((tpos != null) &amp;&amp; (apos != null)</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">                    &amp;&amp; (apos.distance(tpos) &lt; distance)) {</span>
<span class="nc" id="L1669">                    distance = apos.distance(tpos);</span>
                }
<span class="nc" id="L1671">            }</span>
<span class="nc" id="L1672">        }</span>

<span class="nc bnc" id="L1674" title="All 4 branches missed.">        if (Compute.isGroundToAir(attacker, target) &amp;&amp; (target instanceof Entity)) {</span>
            // distance is determined by closest point on flight path
<span class="nc" id="L1676">            distance = attacker.getPosition().distance(getClosestFlightPath(attacker.getId(),</span>
<span class="nc" id="L1677">                    attacker.getPosition(), (Entity) target));</span>

            // if the ground attacker uses weapon bays and we are on a
            // ground map, then we will divide this distance by 16
            // This is totally crazy, but I don't see how else to do it. Use
            // the unofficial
            // &quot;grounded dropships use individual weapons&quot; for sanity.
<span class="nc bnc" id="L1684" title="All 4 branches missed.">            if (attacker.usesWeaponBays() &amp;&amp; game.getBoard().onGround()) {</span>
<span class="nc" id="L1685">                distance = (int) Math.ceil(distance / 16.0);</span>
            }
        }

        // if this is an air-to-air attack on the ground map, then divide
        // distance by 16
<span class="nc bnc" id="L1691" title="All 6 branches missed.">        if (Compute.isAirToAir(attacker, target) &amp;&amp; game.getBoard().onGround() &amp;&amp; !useGroundDistance) {</span>
<span class="nc" id="L1692">            distance = (int) Math.ceil(distance / 16.0);</span>
        }

        // If the attack is completely inside a building, add the difference
        // in elevations between the attacker and target to the range.
        // TODO: should the player be explicitly notified?
<span class="nc bnc" id="L1698" title="All 2 branches missed.">        if (Compute.isInSameBuilding(game, attacker, target)) {</span>
<span class="nc" id="L1699">            int aElev = attacker.getElevation();</span>
<span class="nc" id="L1700">            int tElev = target.getElevation();</span>
<span class="nc" id="L1701">            distance += Math.abs(aElev - tElev);</span>
        }

        // air-to-air attacks add one for altitude differences
<span class="nc bnc" id="L1705" title="All 2 branches missed.">        if (Compute.isAirToAir(attacker, target)) {</span>
<span class="nc" id="L1706">            int aAlt = attacker.getAltitude();</span>
<span class="nc" id="L1707">            int tAlt = target.getAltitude();</span>
<span class="nc bnc" id="L1708" title="All 2 branches missed.">            if (target.isAirborneVTOLorWIGE()) {</span>
<span class="nc" id="L1709">                tAlt++;</span>
            }
<span class="nc" id="L1711">            distance += Math.abs(aAlt - tAlt);</span>
        }

<span class="nc bnc" id="L1714" title="All 2 branches missed.">        if (Compute.isGroundToAir(attacker, target)) {</span>
<span class="nc bnc" id="L1715" title="All 4 branches missed.">            if (attacker.usesWeaponBays() &amp;&amp; game.getBoard().onGround()) {</span>
<span class="nc" id="L1716">                distance += (target.getAltitude());</span>
            } else {
<span class="nc" id="L1718">                distance += (2 * target.getAltitude());</span>
            }
        }

        // Attacking a ground unit while dropping
<span class="nc bnc" id="L1723" title="All 4 branches missed.">        if (attacker.isDropping() &amp;&amp; target.getAltitude() == 0) {</span>
<span class="nc" id="L1724">            distance += (2 * attacker.getAltitude());</span>
        }

<span class="nc" id="L1727">        return distance;</span>
    }

    /**
     * @param aPos the attacker's position
     * @param te the target entity
     * @return the closest position along &lt;code&gt;te&lt;/codeE&gt;'s flight path to &lt;code&gt;aPos&lt;/code&gt;. In
     * the case of multiple equi-distance positions, the first one is picked unless
     * &lt;code&gt;te&lt;/code&gt;'s playerPickedPassThrough position is non-null.
     */
    public static @Nullable Coords getClosestFlightPath(int attackerId, Coords aPos, Entity te) {
<span class="nc" id="L1738">        Coords finalPos = te.getPosition();</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">        if (te.getPlayerPickedPassThrough(attackerId) != null) {</span>
<span class="nc" id="L1740">            finalPos = te.getPlayerPickedPassThrough(attackerId);</span>
        }
<span class="nc" id="L1742">        int distance = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1743" title="All 2 branches missed.">        if (finalPos != null) {</span>
<span class="nc" id="L1744">            distance = aPos.distance(finalPos);</span>
        }
        // don't return zero distance Coords, but rather the Coords immediately
        // before this
        // This is necessary to determine angle of attack and arc information
        // for direct fly-overs
<span class="nc bnc" id="L1750" title="All 2 branches missed.">        for (Coords c : te.getPassedThrough()) {</span>
<span class="nc bnc" id="L1751" title="All 4 branches missed.">            if (!aPos.equals(c) &amp;&amp; (c != null)</span>
<span class="nc bnc" id="L1752" title="All 4 branches missed.">                &amp;&amp; ((aPos.distance(c) &lt; distance) || (distance == 0))) {</span>
<span class="nc" id="L1753">                finalPos = c;</span>
<span class="nc" id="L1754">                distance = aPos.distance(c);</span>
            }
<span class="nc" id="L1756">        }</span>
<span class="nc" id="L1757">        return finalPos;</span>
    }

    public static int getClosestFlightPathFacing(int attackerId,
            Coords aPos, Entity te) {

<span class="nc" id="L1763">        Coords finalPos = te.getPosition();</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">        if (te.getPlayerPickedPassThrough(attackerId) != null) {</span>
<span class="nc" id="L1765">            finalPos = te.getPlayerPickedPassThrough(attackerId);</span>
        }
<span class="nc" id="L1767">        int distance = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1768" title="All 2 branches missed.">        if (finalPos != null) {</span>
<span class="nc" id="L1769">            distance = aPos.distance(finalPos);</span>
        }
<span class="nc" id="L1771">        int finalFacing = te.getFacing();</span>
        // don't return zero distance Coords, but rather the Coords immediately
        // before this
        // This is necessary to determine angle of attack and arc information
        // for direct fly-overs
<span class="nc bnc" id="L1776" title="All 2 branches missed.">        for (int i = 0; i &lt; te.getPassedThrough().size(); i++) {</span>
<span class="nc" id="L1777">            Coords c = te.getPassedThrough().get(i);</span>
<span class="nc bnc" id="L1778" title="All 4 branches missed.">            if (!aPos.equals(c) &amp;&amp; (c != null)</span>
<span class="nc bnc" id="L1779" title="All 4 branches missed.">                &amp;&amp; ((aPos.distance(c) &lt; distance) || (distance == 0))) {</span>
<span class="nc" id="L1780">                finalFacing = te.getPassedThroughFacing().get(i);</span>
<span class="nc" id="L1781">                finalPos = c;</span>
<span class="nc" id="L1782">                distance = aPos.distance(c);</span>
<span class="nc bnc" id="L1783" title="All 2 branches missed.">            } else if (c.equals(finalPos)) {</span>
<span class="nc" id="L1784">                finalFacing = te.getPassedThroughFacing().get(i);</span>
            }
        }
<span class="nc" id="L1787">        return finalFacing;</span>
    }

    /**
     * WOR: Need this function to find out where my nova stuff doesn't work.
     * Delete it if nova works but remember to alter the /nova debug server
     * command.
     */
    public static Entity exposed_findC3Spotter(IGame game, Entity attacker,
                                               Targetable target) {
<span class="nc" id="L1797">        return findC3Spotter(game, attacker, target);</span>
    }

    /**
     * find a c3, c3i, NC3, or nova spotter that is closer to the target than the
     * attacker.
     *
     * @param game
     * @param attacker
     * @param target
     * @return A closer C3/C3i/Nova spotter, or the attacker if no spotters are
     *         found
     */
    private static Entity findC3Spotter(IGame game, Entity attacker,
            Targetable target) {
        // no available C3-like system
<span class="nc bnc" id="L1813" title="All 4 branches missed.">        if (!attacker.hasC3() &amp;&amp; !attacker.hasC3i()</span>
<span class="nc bnc" id="L1814" title="All 4 branches missed.">                &amp;&amp; !attacker.hasActiveNovaCEWS() &amp;&amp; !attacker.hasNavalC3()) {</span>
<span class="nc" id="L1815">            return attacker;</span>
        }

<span class="nc" id="L1818">        ArrayList&lt;Entity&gt; network = new ArrayList&lt;Entity&gt;();</span>

        // Compute friends in network
<span class="nc bnc" id="L1821" title="All 2 branches missed.">        for (Entity friend : game.getEntitiesVector()) {</span>

<span class="nc bnc" id="L1823" title="All 2 branches missed.">            if (attacker.equals(friend)</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">                    || !attacker.onSameC3NetworkAs(friend, true)</span>
<span class="nc bnc" id="L1825" title="All 2 branches missed.">                    || !friend.isDeployed()</span>
<span class="nc bnc" id="L1826" title="All 2 branches missed.">                    || (friend.getTransportId() != Entity.NONE)) {</span>
<span class="nc" id="L1827">                continue; // useless to us...</span>
            }

            // Must have LoS, Compute.canSee considers sensors and visual range
<span class="nc bnc" id="L1831" title="All 2 branches missed.">            if (!LosEffects.calculateLos(game, friend.getId(), target).canSee()) {</span>
<span class="nc" id="L1832">                continue;</span>
            }

<span class="nc" id="L1835">            int buddyRange = Compute.effectiveDistance(game, friend, target,</span>
                    false);

<span class="nc" id="L1838">            boolean added = false;</span>
            // put everyone in the C3 network into a list and sort it by range.
<span class="nc bnc" id="L1840" title="All 2 branches missed.">            for (int pos = 0; pos &lt; network.size(); pos++) {</span>
<span class="nc bnc" id="L1841" title="All 2 branches missed.">                if (Compute.effectiveDistance(game, network.get(pos), target,</span>
                        false) &gt;= buddyRange) {
<span class="nc" id="L1843">                    network.add(pos, friend);</span>
<span class="nc" id="L1844">                    added = true;</span>
<span class="nc" id="L1845">                    break;</span>
                }
            }

<span class="nc bnc" id="L1849" title="All 2 branches missed.">            if (!added) {</span>
<span class="nc" id="L1850">                network.add(friend);</span>
            }
<span class="nc" id="L1852">        }</span>

        // ensure network connectivity
<span class="nc" id="L1855">        List&lt;ECMInfo&gt; allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game</span>
<span class="nc" id="L1856">                .getEntitiesVector());</span>
<span class="nc" id="L1857">        int position = 0;</span>
<span class="nc bnc" id="L1858" title="All 2 branches missed.">        for (Entity spotter : network) {</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">            for (int count = position++; count &lt; network.size(); count++) {</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">                if (Compute.canCompleteNodePath(spotter, attacker, network,</span>
                        count, allECMInfo)) {
<span class="nc" id="L1862">                    return spotter;</span>
                }
            }
<span class="nc" id="L1865">        }</span>

<span class="nc" id="L1867">        return attacker;</span>
    }

    /**
     * Looks through the network list to ensure that the given Entity is
     * connected to the network.
     *
     * @param start
     * @param end
     * @param network
     * @param startPosition
     * @return
     */
    private static boolean canCompleteNodePath(Entity start, Entity end,
            ArrayList&lt;Entity&gt; network, int startPosition,
            List&lt;ECMInfo&gt; allECMInfo) {

<span class="nc" id="L1884">        Entity spotter = network.get(startPosition);</span>

        // ECMInfo for line between spotter's position and start's position
<span class="nc" id="L1887">        ECMInfo spotterStartECM = ComputeECM.getECMEffects(spotter,</span>
<span class="nc" id="L1888">                start.getPosition(), spotter.getPosition(), true, allECMInfo);</span>

        // Check for ECM between spotter and start
<span class="nc bnc" id="L1891" title="All 4 branches missed.">        boolean isC3BDefeated = start.hasBoostedC3()</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">                &amp;&amp; (spotterStartECM != null) &amp;&amp; spotterStartECM.isAngelECM();</span>
<span class="nc bnc" id="L1893" title="All 4 branches missed.">        boolean isNovaDefeated = start.hasNovaCEWS()</span>
<span class="nc bnc" id="L1894" title="All 2 branches missed.">                &amp;&amp; (spotterStartECM != null) &amp;&amp; spotterStartECM.isNovaECM();</span>
<span class="nc bnc" id="L1895" title="All 6 branches missed.">        boolean isC3Defeated = !(start.hasBoostedC3() || start.hasNovaCEWS())</span>
<span class="nc bnc" id="L1896" title="All 2 branches missed.">                &amp;&amp; (spotterStartECM != null) &amp;&amp; spotterStartECM.isECM();</span>
<span class="nc bnc" id="L1897" title="All 6 branches missed.">        if (isC3BDefeated || isNovaDefeated || isC3Defeated) {</span>
<span class="nc" id="L1898">            return false;</span>
        }

        // ECMInfo for line between spotter's position and end's position
<span class="nc" id="L1902">        ECMInfo spotterEndECM = ComputeECM.getECMEffects(spotter,</span>
<span class="nc" id="L1903">                spotter.getPosition(), end.getPosition(), true, allECMInfo);</span>
<span class="nc bnc" id="L1904" title="All 4 branches missed.">        isC3BDefeated = start.hasBoostedC3() &amp;&amp; (spotterEndECM != null)</span>
<span class="nc bnc" id="L1905" title="All 2 branches missed.">                &amp;&amp; spotterEndECM.isAngelECM();</span>
<span class="nc bnc" id="L1906" title="All 4 branches missed.">        isNovaDefeated = start.hasNovaCEWS() &amp;&amp; (spotterEndECM != null)</span>
<span class="nc bnc" id="L1907" title="All 2 branches missed.">                &amp;&amp; spotterEndECM.isNovaECM();</span>
<span class="nc bnc" id="L1908" title="All 6 branches missed.">        isC3Defeated = !(start.hasBoostedC3() || start.hasNovaCEWS())</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">                &amp;&amp; (spotterEndECM != null) &amp;&amp; spotterEndECM.isECM();</span>
        // If there's no ECM between spotter and end, we're done
<span class="nc bnc" id="L1911" title="All 6 branches missed.">        if (!(isC3BDefeated || isNovaDefeated || isC3Defeated)) {</span>
<span class="nc" id="L1912">            return true;</span>
        }

<span class="nc bnc" id="L1915" title="All 2 branches missed.">        for (++startPosition; startPosition &lt; network.size(); startPosition++) {</span>
<span class="nc bnc" id="L1916" title="All 2 branches missed.">            if (Compute.canCompleteNodePath(spotter, end, network,</span>
                    startPosition, allECMInfo)) {
<span class="nc" id="L1918">                return true;</span>
            }
        }

<span class="nc" id="L1922">        return false;</span>
    }

    /**
     * Gets the modifiers, if any, that the mech receives from being prone.
     *
     * @return any applicable modifiers due to being prone
     */
    public static ToHitData getProneMods(IGame game, Entity attacker,
                                         int weaponId) {
<span class="nc bnc" id="L1932" title="All 2 branches missed.">        if (!attacker.isProne()) {</span>
<span class="nc" id="L1933">            return null; // no modifier</span>
        }
<span class="nc" id="L1935">        ToHitData mods = new ToHitData();</span>
<span class="nc" id="L1936">        Mounted weapon = attacker.getEquipment(weaponId);</span>
<span class="nc bnc" id="L1937" title="All 2 branches missed.">        if (attacker.entityIsQuad()) {</span>
<span class="nc" id="L1938">            int legsDead = ((Mech) attacker).countBadLegs();</span>
<span class="nc bnc" id="L1939" title="All 4 branches missed.">            if (legsDead == 0 &amp;&amp; !((Mech)attacker).hasHipCrit()) {</span>
                // No legs destroyed and no hip crits: no penalty and can fire all weapons
<span class="nc" id="L1941">                return null; // no modifier</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">            } else if (legsDead &gt;= 3) {</span>
<span class="nc" id="L1943">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Prone with three or more legs destroyed.&quot;);
            }
            // we have one or two dead legs...

            // Need an intact front leg
<span class="nc bnc" id="L1949" title="All 2 branches missed.">            if (attacker.isLocationBad(Mech.LOC_RARM)</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">                &amp;&amp; attacker.isLocationBad(Mech.LOC_LARM)) {</span>
<span class="nc" id="L1951">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Prone with both front legs destroyed.&quot;);
            }

            // front leg-mounted weapons have addidional trouble
<span class="nc bnc" id="L1956" title="All 4 branches missed.">            if ((weapon.getLocation() == Mech.LOC_RARM) || (weapon.getSecondLocation() == Mech.LOC_RARM)</span>
<span class="nc bnc" id="L1957" title="All 4 branches missed.">                || (weapon.getLocation() == Mech.LOC_LARM || (weapon.getSecondLocation() == Mech.LOC_LARM))) {</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">                int otherArm = (weapon.getLocation() == Mech.LOC_RARM</span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">                        || weapon.getSecondLocation() == Mech.LOC_RARM)? Mech.LOC_LARM</span>
<span class="nc" id="L1960">                                                                     : Mech.LOC_RARM;</span>
                // check previous attacks for weapons fire from the other arm
<span class="nc bnc" id="L1962" title="All 2 branches missed.">                if (Compute.isFiringFromArmAlready(game, weaponId, attacker,</span>
                                                   otherArm)) {
<span class="nc" id="L1964">                    return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;Prone and firing from other front leg already.&quot;);
                }
            }
            // can't fire rear leg weapons
<span class="nc bnc" id="L1969" title="All 2 branches missed.">            if ((weapon.getLocation() == Mech.LOC_LLEG)</span>
<span class="nc bnc" id="L1970" title="All 2 branches missed.">                || (weapon.getLocation() == Mech.LOC_RLEG)) {</span>
<span class="nc" id="L1971">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Can't fire rear leg-mounted weapons while prone with destroyed legs.&quot;);
            }
<span class="nc bnc" id="L1974" title="All 2 branches missed.">            if (((Mech)attacker).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L1975" title="All 2 branches missed.">                    &amp;&amp; attacker.getCrew().hasDedicatedGunner()) {</span>
<span class="nc" id="L1976">                mods.addModifier(1, &quot;attacker prone&quot;);</span>
            } else {
<span class="nc" id="L1978">                mods.addModifier(2, &quot;attacker prone&quot;);</span>
            }
<span class="nc" id="L1980">        } else {</span>
<span class="nc" id="L1981">            int l3ProneFiringArm = Entity.LOC_NONE;</span>

<span class="nc bnc" id="L1983" title="All 2 branches missed.">            if (attacker.isLocationBad(Mech.LOC_RARM)</span>
<span class="nc bnc" id="L1984" title="All 2 branches missed.">                || attacker.isLocationBad(Mech.LOC_LARM)) {</span>
<span class="nc bnc" id="L1985" title="All 2 branches missed.">                if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_PRONE_FIRE)) {</span>
                    // Can fire with only one arm
<span class="nc bnc" id="L1987" title="All 2 branches missed.">                    if (attacker.isLocationBad(Mech.LOC_RARM)</span>
<span class="nc bnc" id="L1988" title="All 2 branches missed.">                        &amp;&amp; attacker.isLocationBad(Mech.LOC_LARM)) {</span>
<span class="nc" id="L1989">                        return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                             &quot;Prone with both arms destroyed.&quot;);
                    }

<span class="nc bnc" id="L1993" title="All 2 branches missed.">                    l3ProneFiringArm = attacker.isLocationBad(Mech.LOC_RARM) ? Mech.LOC_LARM</span>
<span class="nc" id="L1994">                                                                             : Mech.LOC_RARM;</span>
                } else {
                    // must have an arm intact
<span class="nc" id="L1997">                    return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;Prone with one or both arms destroyed.&quot;);
                }
            }

            // arm-mounted weapons have addidional trouble
<span class="nc bnc" id="L2003" title="All 4 branches missed.">            if ((weapon.getLocation() == Mech.LOC_RARM) || (weapon.getSecondLocation() == Mech.LOC_RARM)</span>
<span class="nc bnc" id="L2004" title="All 4 branches missed.">                || (weapon.getLocation() == Mech.LOC_LARM) || (weapon.getSecondLocation() == Mech.LOC_LARM)) {</span>
<span class="nc bnc" id="L2005" title="All 2 branches missed.">                if (l3ProneFiringArm == weapon.getLocation()</span>
<span class="nc bnc" id="L2006" title="All 4 branches missed.">                        || (weapon.getSecondLocation() != Entity.NONE &amp;&amp; l3ProneFiringArm == weapon.getSecondLocation())) {</span>
<span class="nc" id="L2007">                    return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;Prone and propping up with this arm.&quot;);
                }

<span class="nc bnc" id="L2011" title="All 2 branches missed.">                int otherArm = (weapon.getLocation() == Mech.LOC_RARM</span>
<span class="nc bnc" id="L2012" title="All 2 branches missed.">                        || weapon.getSecondLocation() == Mech.LOC_RARM)? Mech.LOC_LARM</span>
<span class="nc" id="L2013">                                                                        : Mech.LOC_RARM;</span>
                // check previous attacks for weapons fire from the other arm
<span class="nc bnc" id="L2015" title="All 2 branches missed.">                if (Compute.isFiringFromArmAlready(game, weaponId, attacker,</span>
                                                   otherArm)) {
<span class="nc" id="L2017">                    return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;Prone and firing from other arm already.&quot;);
                }
            }
            // can't fire leg weapons
<span class="nc bnc" id="L2022" title="All 2 branches missed.">            if ((weapon.getLocation() == Mech.LOC_LLEG)</span>
<span class="nc bnc" id="L2023" title="All 2 branches missed.">                || (weapon.getLocation() == Mech.LOC_RLEG)) {</span>
<span class="nc" id="L2024">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Can't fire leg-mounted weapons while prone.&quot;);
            }
<span class="nc bnc" id="L2027" title="All 2 branches missed.">            if (((Mech)attacker).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">                    &amp;&amp; attacker.getCrew().hasDedicatedGunner()) {</span>
<span class="nc" id="L2029">                mods.addModifier(1, &quot;attacker prone&quot;);</span>
            } else {
<span class="nc" id="L2031">                mods.addModifier(2, &quot;attacker prone&quot;);</span>
            }

<span class="nc bnc" id="L2034" title="All 2 branches missed.">            if (l3ProneFiringArm != Entity.LOC_NONE) {</span>
<span class="nc" id="L2035">                mods.addModifier(1, &quot;attacker propping on single arm&quot;);</span>
            }
        }
<span class="nc" id="L2038">        return mods;</span>
    }

    /**
     * Checks to see if there is an attack previous to the one with this weapon
     * from the specified arm.
     *
     * @return true if there is a previous attack from this arm
     */
    private static boolean isFiringFromArmAlready(IGame game, int weaponId,
                                                  final Entity attacker, int armLoc) {
<span class="nc" id="L2049">        int torsoLoc = Mech.getInnerLocation(armLoc);</span>
<span class="nc" id="L2050">        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</span>
<span class="nc bnc" id="L2051" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L2052">            EntityAction ea = i.nextElement();</span>
<span class="nc bnc" id="L2053" title="All 2 branches missed.">            if (!(ea instanceof WeaponAttackAction)) {</span>
<span class="nc" id="L2054">                continue;</span>
            }
<span class="nc" id="L2056">            WeaponAttackAction prevAttack = (WeaponAttackAction) ea;</span>
            // stop when we get to this weaponattack (does this always work?)
<span class="nc bnc" id="L2058" title="All 2 branches missed.">            if ((prevAttack.getEntityId() == attacker.getId())</span>
<span class="nc bnc" id="L2059" title="All 2 branches missed.">                &amp;&amp; (prevAttack.getWeaponId() == weaponId)) {</span>
<span class="nc" id="L2060">                break;</span>
            }
<span class="nc bnc" id="L2062" title="All 2 branches missed.">            if (((prevAttack.getEntityId() == attacker.getId()) &amp;&amp; (attacker</span>
<span class="nc" id="L2063">                                                                            .getEquipment(prevAttack.getWeaponId())</span>
<span class="nc bnc" id="L2064" title="All 2 branches missed.">                                                                            .getLocation() == armLoc))</span>
<span class="nc bnc" id="L2065" title="All 2 branches missed.">                || ((prevAttack.getEntityId() == attacker.getId())</span>
<span class="nc" id="L2066">                    &amp;&amp; (attacker.getEquipment(prevAttack.getWeaponId())</span>
<span class="nc bnc" id="L2067" title="All 2 branches missed.">                                .getLocation() == torsoLoc) &amp;&amp; attacker</span>
<span class="nc bnc" id="L2068" title="All 2 branches missed.">                            .getEquipment(prevAttack.getWeaponId()).isSplit())) {</span>
<span class="nc" id="L2069">                return true;</span>
            }
<span class="nc" id="L2071">        }</span>
<span class="nc" id="L2072">        return false;</span>
    }

    /**
     * Adds any damage modifiers from arm critical hits or sensor damage.
     *
     * @return Any applicable damage modifiers
     */
    public static ToHitData getDamageWeaponMods(Entity attacker, Mounted weapon) {
<span class="nc" id="L2081">        ToHitData mods = new ToHitData();</span>
<span class="nc bnc" id="L2082" title="All 2 branches missed.">        if (attacker instanceof Protomech) {</span>
            // Head criticals add to target number of all weapons.
<span class="nc" id="L2084">            int hits = ((Protomech) attacker).getCritsHit(Protomech.LOC_HEAD);</span>
<span class="nc bnc" id="L2085" title="All 2 branches missed.">            if (hits &gt; 0) {</span>
<span class="nc" id="L2086">                mods.addModifier(hits, hits + &quot; head critical(s)&quot;);</span>
            }

            // Arm mounted (and main gun) weapons get DRMs from arm crits.
<span class="nc bnc" id="L2090" title="All 3 branches missed.">            switch (weapon.getLocation()) {</span>
                case Protomech.LOC_LARM:
                case Protomech.LOC_RARM:
<span class="nc" id="L2093">                    hits = ((Protomech) attacker).getCritsHit(weapon</span>
<span class="nc" id="L2094">                                                                      .getLocation());</span>
<span class="nc bnc" id="L2095" title="All 2 branches missed.">                    if (hits &gt; 0) {</span>
<span class="nc" id="L2096">                        mods.addModifier(hits, hits + &quot; arm critical(s)&quot;);</span>
                    }
                    break;
                case Protomech.LOC_MAINGUN:
                    // Main gun is affected by crits in *both* arms.
<span class="nc" id="L2101">                    hits = ((Protomech) attacker)</span>
<span class="nc" id="L2102">                            .getCritsHit(Protomech.LOC_LARM);</span>
<span class="nc" id="L2103">                    hits += ((Protomech) attacker)</span>
<span class="nc" id="L2104">                            .getCritsHit(Protomech.LOC_RARM);</span>
<span class="nc bnc" id="L2105" title="All 2 branches missed.">                    if (4 == hits) {</span>
<span class="nc" id="L2106">                        mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;Cannot fire main gun with no arms.&quot;);
<span class="nc bnc" id="L2108" title="All 2 branches missed.">                    } else if (hits &gt; 0) {</span>
<span class="nc" id="L2109">                        mods.addModifier(hits, hits + &quot; arm critical(s)&quot;);</span>
                    }
                    break;
            }

<span class="nc" id="L2114">        } // End attacker-is-Protomech</span>

        // only mechs have arm actuators - for those, we check whether
        // there is arm actuator damage
<span class="nc bnc" id="L2118" title="All 2 branches missed.">        else if(attacker instanceof Mech) {</span>
            // split weapons need to account for arm actuator hits, too
            // see bug 1363690
            // we don't need to specifically check for weapons split between
            // torso and leg, because for those, the location stored in the
            // Mounted is the leg.
<span class="nc" id="L2124">            int location = weapon.getLocation();</span>
<span class="nc bnc" id="L2125" title="All 2 branches missed.">            if (weapon.isSplit()) {</span>
<span class="nc bnc" id="L2126" title="All 3 branches missed.">                switch (location) {</span>
                    case Mech.LOC_LT:
<span class="nc" id="L2128">                        location = Mech.LOC_LARM;</span>
<span class="nc" id="L2129">                        break;</span>
                    case Mech.LOC_RT:
<span class="nc" id="L2131">                        location = Mech.LOC_RARM;</span>
<span class="nc" id="L2132">                        break;</span>
                    default:
                }
            }
            
            // only arms can have damaged arm actuators
<span class="nc bnc" id="L2138" title="All 4 branches missed.">            if(location == Mech.LOC_LARM || location == Mech.LOC_RARM) {</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">                if (attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                                             Mech.ACTUATOR_SHOULDER, location) &gt; 0) {
<span class="nc" id="L2141">                    mods.addModifier(4, &quot;shoulder actuator destroyed&quot;);</span>
                } else {
                    // no shoulder hits, add other arm hits
<span class="nc" id="L2144">                    int actuatorHits = 0;</span>
<span class="nc bnc" id="L2145" title="All 2 branches missed.">                    if (attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                                                 Mech.ACTUATOR_UPPER_ARM, location) &gt; 0) {
<span class="nc" id="L2147">                        actuatorHits++;</span>
                    }
<span class="nc bnc" id="L2149" title="All 2 branches missed.">                    if (attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                                                 Mech.ACTUATOR_LOWER_ARM, location) &gt; 0) {
<span class="nc" id="L2151">                        actuatorHits++;</span>
                    }
<span class="nc bnc" id="L2153" title="All 2 branches missed.">                    if (actuatorHits &gt; 0) {</span>
<span class="nc" id="L2154">                        mods.addModifier(actuatorHits, actuatorHits</span>
                                                       + &quot; destroyed arm actuators&quot;);
                    }
                }
            }
        }

        // sensors critical hit to attacker
<span class="nc" id="L2162">        int sensorHits = attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                                                  Mech.SYSTEM_SENSORS, Mech.LOC_HEAD);
<span class="nc bnc" id="L2164" title="All 2 branches missed.">        if ((attacker instanceof Mech)</span>
<span class="nc bnc" id="L2165" title="All 2 branches missed.">            &amp;&amp; (((Mech) attacker).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED)) {</span>
<span class="nc" id="L2166">            sensorHits += attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                                                   Mech.SYSTEM_SENSORS, Mech.LOC_CT);
<span class="nc bnc" id="L2168" title="All 2 branches missed.">            if (sensorHits &gt; 1) {</span>
<span class="nc" id="L2169">                mods.addModifier(4, &quot;attacker sensors badly damaged&quot;);</span>
<span class="nc bnc" id="L2170" title="All 2 branches missed.">            } else if (sensorHits &gt; 0) {</span>
<span class="nc" id="L2171">                mods.addModifier(2, &quot;attacker sensors damaged&quot;);</span>
            }
<span class="nc bnc" id="L2173" title="All 2 branches missed.">        } else if (sensorHits &gt; 0) {</span>
<span class="nc bnc" id="L2174" title="All 4 branches missed.">            if (attacker instanceof Mech &amp;&amp; ((Mech)attacker).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2175" title="All 2 branches missed.">                    &amp;&amp; attacker.getCrew().hasDedicatedGunner()) {</span>
<span class="nc" id="L2176">                mods.addModifier(1, &quot;attacker sensors damaged&quot;);</span>
            } else {
<span class="nc" id="L2178">                mods.addModifier(2, &quot;attacker sensors damaged&quot;);</span>
            }
        }

        // if partial sensor/stabilizer/fcs/cic repairs are present the shot will be more difficult
<span class="nc bnc" id="L2183" title="All 2 branches missed.">        if (attacker.getPartialRepairs() != null) {</span>
<span class="nc bnc" id="L2184" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;sensors_1_crit&quot;)) {</span>
<span class="nc" id="L2185">                mods.addModifier(1, &quot;sensor damage&quot;);</span>
            }
<span class="nc bnc" id="L2187" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;mech_sensors_2_crit&quot;)) {</span>
<span class="nc" id="L2188">                mods.addModifier(2, &quot;sensor damage&quot;);</span>
            }
<span class="nc bnc" id="L2190" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;veh_stabilizer_crit&quot;)) {</span>
<span class="nc" id="L2191">                mods.addModifier(1, &quot;stabilizer damage&quot;);</span>
            }
<span class="nc bnc" id="L2193" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;aero_cic_fcs_replace&quot;)) {</span>
<span class="nc" id="L2194">                mods.addModifier(1, &quot;misreplaced cic/fcs equipment&quot;);</span>
            }
<span class="nc bnc" id="L2196" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;aero_cic_fcs_crit&quot;)) {</span>
<span class="nc" id="L2197">                 mods.addModifier(1, &quot;faulty cic/fcs repairs&quot;);</span>
            }
        }

<span class="nc" id="L2201">        return mods;</span>
    }

    /**
     * Determines if the current target is a secondary target, and if so,
     * returns the appropriate modifier.
     *
     * @return The secondary target modifier.
     * @author Ben
     */
    public static ToHitData getSecondaryTargetMod(IGame game, Entity attacker,
            Targetable target) {

        // large craft do not get secondary target mod
        // http://www.classicbattletech.com/forums/index.php/topic,37661.0.html
<span class="nc bnc" id="L2216" title="All 2 branches missed.">        if (attacker.getCrew().getCrewType().getMaxPrimaryTargets() &lt; 0) {</span>
<span class="nc" id="L2217">            return null;</span>
        }

<span class="nc" id="L2220">        boolean curInFrontArc = Compute</span>
<span class="nc" id="L2221">                .isInArc(attacker.getPosition(), attacker.getSecondaryFacing(),</span>
<span class="nc" id="L2222">                         target, attacker.getForwardArc());</span>
<span class="nc" id="L2223">        boolean curInRearArc = Compute.isInArc(attacker.getPosition(),</span>
<span class="nc" id="L2224">                                               attacker.getSecondaryFacing(), target, attacker.getRearArc());</span>
<span class="nc bnc" id="L2225" title="All 4 branches missed.">        if (!curInRearArc &amp;&amp; attacker.hasQuirk(OptionsConstants.QUIRK_POS_MULTI_TRAC)) {</span>
<span class="nc" id="L2226">            return null;</span>
        }

<span class="nc" id="L2229">        int primaryTarget = Entity.NONE;</span>
<span class="nc" id="L2230">        boolean primaryInFrontArc = false;</span>
        // Track # of targets, for secondary modifiers w/ multi-crew vehicles
<span class="nc" id="L2232">        Set&lt;Integer&gt; targIds = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2233">        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</span>
<span class="nc bnc" id="L2234" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L2235">            Object o = i.nextElement();</span>
<span class="nc bnc" id="L2236" title="All 2 branches missed.">            if (!(o instanceof WeaponAttackAction)) {</span>
<span class="nc" id="L2237">                continue;</span>
            }
<span class="nc" id="L2239">            WeaponAttackAction prevAttack = (WeaponAttackAction) o;</span>
<span class="nc bnc" id="L2240" title="All 2 branches missed.">            if (prevAttack.getEntityId() == attacker.getId()) {</span>
                // Don't add id of current target, as it gets counted elsewhere
<span class="nc bnc" id="L2242" title="All 2 branches missed.">                if (prevAttack.getTargetId() != target.getTargetId()) {</span>
<span class="nc" id="L2243">                    targIds.add(prevAttack.getTargetId());</span>
                }
                // first front arc target is our primary.
                // if first target is non-front, and either a later target or
                // the current one is in front, use that instead.
<span class="nc bnc" id="L2248" title="All 2 branches missed.">                if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_NO_FORCED_PRIMARY_TARGETS)) {</span>
<span class="nc" id="L2249">                    Targetable pte = game.getTarget(prevAttack.getTargetType(),</span>
<span class="nc" id="L2250">                                                    prevAttack.getTargetId());</span>
                    // in double blind play, we might not have the target in our
                    // local copy of the game. In that case, the sprite won't
                    // have the correct to-hit number, but at least we don't crash
<span class="nc bnc" id="L2254" title="All 2 branches missed.">                    if (pte == null) {</span>
<span class="nc" id="L2255">                        continue;</span>
                    }

                    // Determine primary target
<span class="nc bnc" id="L2259" title="All 4 branches missed.">                    if ((primaryTarget == Entity.NONE || !primaryInFrontArc)</span>
<span class="nc bnc" id="L2260" title="All 2 branches missed.">                        &amp;&amp; Compute.isInArc(attacker.getPosition(),</span>
<span class="nc" id="L2261">                                           attacker.getSecondaryFacing(), pte,</span>
<span class="nc" id="L2262">                                           attacker.getForwardArc())) {</span>
<span class="nc" id="L2263">                        primaryTarget = prevAttack.getTargetId();</span>
<span class="nc" id="L2264">                        primaryInFrontArc = true;</span>
<span class="nc bnc" id="L2265" title="All 4 branches missed.">                    } else if ((primaryTarget == Entity.NONE) &amp;&amp; !curInFrontArc) {</span>
<span class="nc" id="L2266">                        primaryTarget = prevAttack.getTargetId();</span>
                    }
<span class="nc bnc" id="L2268" title="All 2 branches missed.">                } else if (primaryTarget == Entity.NONE){</span>
<span class="nc" id="L2269">                    primaryTarget = prevAttack.getTargetId();</span>
                }
            }
<span class="nc" id="L2272">        }</span>

        // # of targets, +1 for the passed target
<span class="nc" id="L2275">        int countTargets = 1 + targIds.size();</span>

<span class="nc" id="L2277">        int maxPrimary = 1;</span>
        //Tripods and QuadVees with dedicated gunnery can target up to three units before incurring a penalty, and two for dual cockpit
<span class="nc bnc" id="L2279" title="All 2 branches missed.">        if (attacker.getCrew().hasDedicatedGunner()) {</span>
<span class="nc" id="L2280">            maxPrimary = attacker.getCrew().getCrewType().getMaxPrimaryTargets();</span>
        }
<span class="nc bnc" id="L2282" title="All 4 branches missed.">        if (game.getOptions().booleanOption(&quot;tacops_tank_crews&quot;)</span>
            &amp;&amp; (attacker instanceof Tank)) {

            // If we are a tank, and only have 1 crew then we have some special
            //  restrictions
<span class="nc bnc" id="L2287" title="All 4 branches missed.">            if (countTargets &gt; 1 &amp;&amp; attacker.getCrew().getSize() == 1) {</span>
<span class="nc" id="L2288">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                        &quot;Vehicles with only 1 crewman may not attack &quot;
                                + &quot;secondary targets&quot;);
            }
            // If we are a tank, we can have Crew Size - 1 targets before
            //  incurring a secondary target penalty (or crew size - 2 secondary
            //  targets without penalty)
<span class="nc" id="L2295">            maxPrimary =  attacker.getCrew().getSize() - 1;</span>
        }
<span class="nc bnc" id="L2297" title="All 2 branches missed.">        if (countTargets &lt;= maxPrimary) {</span>
<span class="nc" id="L2298">            return null; // no modifier</span>
        }

<span class="nc bnc" id="L2301" title="All 2 branches missed.">        if ((primaryTarget == Entity.NONE)</span>
<span class="nc bnc" id="L2302" title="All 2 branches missed.">            || (primaryTarget == target.getTargetId())) {</span>
            // current target is primary target
<span class="nc" id="L2304">            return null; // no modifier</span>
        }

        // current target is secondary

        // Stealthed Mechs can't be secondary targets (TW, pg. 142)
<span class="nc bnc" id="L2310" title="All 6 branches missed.">        if (((target instanceof Tank) || (target instanceof Mech) || (target instanceof Aero))</span>
<span class="nc bnc" id="L2311" title="All 2 branches missed.">            &amp;&amp; ((Entity) target).isStealthActive()) {</span>
<span class="nc" id="L2312">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                 &quot;Can't target unit with active stealth armor as &quot; +
                                 &quot;secondary target&quot;);
        }

<span class="nc" id="L2317">        int mod = 2;</span>
<span class="nc bnc" id="L2318" title="All 4 branches missed.">        if (curInFrontArc || (attacker instanceof BattleArmor)) {</span>
<span class="nc" id="L2319">            mod--;</span>
        }
<span class="nc bnc" id="L2321" title="All 2 branches missed.">        if (attacker.hasAbility(OptionsConstants.GUNNERY_MULTI_TASKER)) {</span>
<span class="nc" id="L2322">            mod--;</span>
        }
<span class="nc" id="L2324">        return new ToHitData(mod, &quot;secondary target modifier&quot;);</span>
    }

    /**
     * Damage that a mech does with a accidental fall from above.
     */

    public static int getAffaDamageFor(Entity entity) {
<span class="nc" id="L2332">        return (int) entity.getWeight() / 10;</span>
    }

    /**
     * Modifier to attacks due to attacker movement
     */
    public static ToHitData getAttackerMovementModifier(IGame game, int entityId) {
<span class="nc" id="L2339">        return Compute.getAttackerMovementModifier(game, entityId,</span>
<span class="nc" id="L2340">                                                   game.getEntity(entityId).moved);</span>
    }

    /**
     * Modifier to attacks due to attacker movement
     */
    public static ToHitData getAttackerMovementModifier(IGame game,
            int entityId, EntityMovementType movement) {
<span class="nc" id="L2348">        final Entity entity = game.getEntity(entityId);</span>
<span class="nc" id="L2349">        ToHitData toHit = new ToHitData();</span>

        // infantry aren't affected by their own movement.
<span class="nc bnc" id="L2352" title="All 2 branches missed.">        if (entity instanceof Infantry) {</span>
<span class="nc" id="L2353">            return toHit;</span>
        }

<span class="nc bnc" id="L2356" title="All 2 branches missed.">        if ((entity.getMovementMode() == EntityMovementMode.BIPED_SWIM)</span>
<span class="nc bnc" id="L2357" title="All 2 branches missed.">            || (entity.getMovementMode() == EntityMovementMode.QUAD_SWIM)) {</span>
<span class="nc" id="L2358">            toHit.addModifier(3, &quot;attacker used UMUs&quot;);</span>
<span class="nc bnc" id="L2359" title="All 4 branches missed.">        } else if (entity instanceof LandAirMech &amp;&amp; movement == EntityMovementType.MOVE_VTOL_WALK) {</span>
<span class="nc" id="L2360">            toHit.addModifier(3, &quot;attacker cruised&quot;);</span>
<span class="nc bnc" id="L2361" title="All 4 branches missed.">        } else if (entity instanceof LandAirMech &amp;&amp; movement == EntityMovementType.MOVE_VTOL_RUN) {</span>
<span class="nc" id="L2362">            toHit.addModifier(4, &quot;attacker flanked&quot;);</span>
<span class="nc bnc" id="L2363" title="All 6 branches missed.">        } else if ((movement == EntityMovementType.MOVE_WALK) || (movement == EntityMovementType.MOVE_VTOL_WALK)</span>
                || (movement == EntityMovementType.MOVE_CAREFUL_STAND)) {
<span class="nc" id="L2365">            toHit.addModifier(1, &quot;attacker walked&quot;);</span>
<span class="nc bnc" id="L2366" title="All 4 branches missed.">        } else if ((movement == EntityMovementType.MOVE_RUN) || (movement == EntityMovementType.MOVE_VTOL_RUN)) {</span>
<span class="nc" id="L2367">            toHit.addModifier(2, &quot;attacker ran&quot;);</span>
<span class="nc bnc" id="L2368" title="All 2 branches missed.">        } else if (movement == EntityMovementType.MOVE_SKID) {</span>
<span class="nc" id="L2369">            toHit.addModifier(3, &quot;attacker ran and skidded&quot;);</span>
<span class="nc bnc" id="L2370" title="All 2 branches missed.">        } else if (movement == EntityMovementType.MOVE_JUMP) {</span>
<span class="nc bnc" id="L2371" title="All 2 branches missed.">            if (entity.hasAbility(OptionsConstants.PILOT_JUMPING_JACK)) {</span>
<span class="nc" id="L2372">                toHit.addModifier(1, &quot;attacker jumped&quot;);</span>
<span class="nc bnc" id="L2373" title="All 2 branches missed.">            } else if (entity.hasAbility(OptionsConstants.PILOT_HOPPING_JACK)) {</span>
<span class="nc" id="L2374">                toHit.addModifier(2, &quot;attacker jumped&quot;);</span>
            } else {
<span class="nc" id="L2376">                toHit.addModifier(3, &quot;attacker jumped&quot;);</span>
            }
<span class="nc bnc" id="L2378" title="All 4 branches missed.">        } else if (movement == EntityMovementType.MOVE_SPRINT</span>
                || movement == EntityMovementType.MOVE_VTOL_SPRINT) {
<span class="nc" id="L2380">            return new ToHitData(TargetRoll.AUTOMATIC_FAIL, &quot;attacker sprinted&quot;);</span>
        }

        //Dual cockpit with both pilot and gunner has lower modifier for attacker movement.
<span class="nc bnc" id="L2384" title="All 4 branches missed.">        if (toHit.getValue() != TargetRoll.AUTOMATIC_FAIL</span>
<span class="nc bnc" id="L2385" title="All 2 branches missed.">                &amp;&amp; entity instanceof Mech &amp;&amp; ((Mech)entity).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2386" title="All 2 branches missed.">                &amp;&amp; entity.getCrew().hasDedicatedGunner()) {</span>
<span class="nc bnc" id="L2387" title="All 2 branches missed.">            for (TargetRollModifier mod : toHit.getModifiers()) {</span>
<span class="nc" id="L2388">                mod.setValue(mod.getValue() / 2);</span>
<span class="nc" id="L2389">            }</span>
        }
<span class="nc" id="L2391">        return toHit;</span>
    }

    /**
     * Modifier to attacks due to spotter movement
     */
    public static ToHitData getSpotterMovementModifier(IGame game, int entityId) {
<span class="nc" id="L2398">        return Compute.getSpotterMovementModifier(game, entityId,</span>
<span class="nc" id="L2399">                                                  game.getEntity(entityId).moved);</span>
    }

    /**
     * Modifier to attacks due to spotter movement
     */
    public static ToHitData getSpotterMovementModifier(IGame game,
                                                       int entityId, EntityMovementType movement) {
<span class="nc" id="L2407">        ToHitData toHit = new ToHitData();</span>

<span class="nc" id="L2409">        Entity e = game.getEntity(entityId);</span>
<span class="nc bnc" id="L2410" title="All 4 branches missed.">        if ((e != null) &amp;&amp; (e instanceof Infantry)) {</span>
<span class="nc" id="L2411">            return toHit;</span>
        }

<span class="nc bnc" id="L2414" title="All 4 branches missed.">        if ((movement == EntityMovementType.MOVE_WALK)</span>
            || (movement == EntityMovementType.MOVE_VTOL_WALK)) {
<span class="nc" id="L2416">            toHit.addModifier(1, &quot;spotter walked&quot;);</span>
<span class="nc bnc" id="L2417" title="All 6 branches missed.">        } else if ((movement == EntityMovementType.MOVE_RUN)</span>
                   || (movement == EntityMovementType.MOVE_VTOL_RUN)
                   || (movement == EntityMovementType.MOVE_SKID)) {
<span class="nc" id="L2420">            toHit.addModifier(2, &quot;spotter ran&quot;);</span>
<span class="nc bnc" id="L2421" title="All 2 branches missed.">        } else if (movement == EntityMovementType.MOVE_JUMP) {</span>
<span class="nc" id="L2422">            toHit.addModifier(3, &quot;spotter jumped&quot;);</span>
<span class="nc bnc" id="L2423" title="All 4 branches missed.">        } else if (movement == EntityMovementType.MOVE_SPRINT</span>
                || movement == EntityMovementType.MOVE_VTOL_SPRINT) {
<span class="nc" id="L2425">            return new ToHitData(TargetRoll.IMPOSSIBLE, &quot;spotter sprinted&quot;);</span>
        }

<span class="nc" id="L2428">        return toHit;</span>
    }

    /**
     * Modifier to physical attack BTH due to pilot advantages
     */
    public static void modifyPhysicalBTHForAdvantages(final Entity attacker, final Entity target,
                                                      final ToHitData toHit, final IGame game) {
<span class="nc" id="L2436">        Objects.requireNonNull(attacker);</span>

<span class="nc bnc" id="L2438" title="All 4 branches missed.">        if (attacker.hasAbility(OptionsConstants.PILOT_MELEE_SPECIALIST)</span>
                &amp;&amp; (attacker instanceof Mech)) {
<span class="nc" id="L2440">            toHit.addModifier(-1, &quot;melee specialist&quot;);</span>
        }

<span class="nc bnc" id="L2443" title="All 6 branches missed.">        if (attacker.hasAbility(OptionsConstants.PILOT_TM_FROGMAN)</span>
                &amp;&amp; ((attacker instanceof Mech) || (attacker instanceof Protomech))
<span class="nc bnc" id="L2445" title="All 2 branches missed.">                &amp;&amp; (game.getBoard().getHex(attacker.getPosition()).terrainLevel(Terrains.WATER) &gt; 1)) {</span>
<span class="nc" id="L2446">            toHit.addModifier(-1, &quot;Frogman&quot;);</span>
        }

<span class="nc bnc" id="L2449" title="All 2 branches missed.">        if (attacker.hasAbility(OptionsConstants.UNOFF_CLAN_PILOT_TRAINING)) {</span>
<span class="nc" id="L2450">            toHit.addModifier(1, &quot;clan pilot training&quot;);</span>
        }

        // Mek targets that are dodging are harder to hit.
<span class="nc bnc" id="L2454" title="All 2 branches missed.">        if ((target instanceof Mech)</span>
<span class="nc bnc" id="L2455" title="All 4 branches missed.">                &amp;&amp; target.hasAbility(OptionsConstants.PILOT_DODGE_MANEUVER) &amp;&amp; target.dodging) {</span>
<span class="nc" id="L2456">            toHit.addModifier(2, &quot;target is dodging&quot;);</span>
        }
<span class="nc" id="L2458">    }</span>

    /**
     * Modifier to attacks due to target movement
     */
    public static ToHitData getTargetMovementModifier(IGame game, int entityId) {
<span class="nc" id="L2464">        Entity entity = game.getEntity(entityId);</span>

<span class="nc bnc" id="L2466" title="All 2 branches missed.">        if (entity.isAero()) {</span>
<span class="nc" id="L2467">            return new ToHitData();</span>
        }

        //If we're a trailer and being towed, return data for the tractor
<span class="nc bnc" id="L2471" title="All 4 branches missed.">        if (entity.isTrailer() &amp;&amp; entity.getTractor() != Entity.NONE) {</span>
<span class="nc" id="L2472">            return getTargetMovementModifier(game, entity.getTractor());</span>
        }

<span class="nc bnc" id="L2475" title="All 4 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_STANDING_STILL)</span>
            &amp;&amp; (entity.mpUsed == 0)
<span class="nc bnc" id="L2477" title="All 8 branches missed.">            &amp;&amp; !entity.isImmobile()</span>
            &amp;&amp; !((entity instanceof Infantry) || (entity instanceof VTOL) || (entity instanceof GunEmplacement))) {
<span class="nc" id="L2479">            ToHitData toHit = new ToHitData();</span>
<span class="nc" id="L2480">            toHit.addModifier(-1, &quot;target didn't move&quot;);</span>
<span class="nc" id="L2481">            return toHit;</span>
        }

<span class="nc bnc" id="L2484" title="All 2 branches missed.">        if (entity.isAssaultDropInProgress()) {</span>
<span class="nc" id="L2485">            ToHitData toHit = new ToHitData();</span>
<span class="nc" id="L2486">            toHit.addModifier(3, &quot;target is assault dropping&quot;);</span>
<span class="nc" id="L2487">            return toHit;</span>
        }

<span class="nc" id="L2490">        ToHitData toHit = Compute</span>
<span class="nc" id="L2491">                .getTargetMovementModifier(</span>
                        entity.delta_distance,
<span class="nc bnc" id="L2493" title="All 14 branches missed.">                        (entity.getMovementMode() != EntityMovementMode.WIGE)</span>
                        &amp;&amp; ((entity.moved == EntityMovementType.MOVE_JUMP)
                                || (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
                                || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
                                || (entity.moved == EntityMovementType.MOVE_VTOL_SPRINT)),

                        (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
                        || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
<span class="nc bnc" id="L2501" title="All 4 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.VTOL)</span>
                        || (entity.moved == EntityMovementType.MOVE_VTOL_SPRINT),
                        game);
<span class="nc bnc" id="L2504" title="All 6 branches missed.">        if (entity.moved != EntityMovementType.MOVE_JUMP</span>
                &amp;&amp; entity.delta_distance &gt; 0
<span class="nc bnc" id="L2506" title="All 2 branches missed.">                &amp;&amp; entity instanceof Mech &amp;&amp; ((Mech)entity).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2507" title="All 2 branches missed.">                &amp;&amp; entity.getCrew().hasDedicatedPilot()) {</span>
<span class="nc bnc" id="L2508" title="All 2 branches missed.">            if (toHit.getModifiers().isEmpty()) {</span>
<span class="nc" id="L2509">                toHit.addModifier(1, &quot;target moved 1-2 hexes&quot;);</span>
            } else {
<span class="nc" id="L2511">                toHit.getModifiers().get(0).setValue(toHit.getModifiers().get(0).getValue() + 1);</span>
            }
        }

        // Did the target skid this turn?
<span class="nc bnc" id="L2516" title="All 2 branches missed.">        if (entity.moved == EntityMovementType.MOVE_SKID) {</span>
<span class="nc" id="L2517">            toHit.addModifier(2, &quot;target skidded&quot;);</span>
        }
<span class="nc bnc" id="L2519" title="All 2 branches missed.">        if ((entity.getElevation() &gt; 0)</span>
<span class="nc bnc" id="L2520" title="All 2 branches missed.">            &amp;&amp; (entity.getMovementMode() == EntityMovementMode.WIGE)) {</span>
<span class="nc" id="L2521">                toHit.addModifier(1, &quot;target is airborne&quot;);</span>
        }

        // did the target sprint?
<span class="nc bnc" id="L2525" title="All 4 branches missed.">        if (entity.moved == EntityMovementType.MOVE_SPRINT</span>
                || entity.moved == EntityMovementType.MOVE_VTOL_SPRINT) {
<span class="nc" id="L2527">            toHit.addModifier(-1, &quot;target sprinted&quot;);</span>
        }

<span class="nc" id="L2530">        return toHit;</span>
    }

    /**
     * Target movement modifer for the specified delta_distance
     */
    public static ToHitData getTargetMovementModifier(int distance,
            boolean jumped, boolean isVTOL, IGame game) {
<span class="nc" id="L2538">        ToHitData toHit = new ToHitData();</span>
<span class="nc bnc" id="L2539" title="All 4 branches missed.">        if (distance == 0 &amp;&amp; !jumped) {</span>
<span class="nc" id="L2540">            return toHit;</span>
        }

<span class="nc bnc" id="L2543" title="All 2 branches missed.">        if ((game != null)</span>
<span class="nc bnc" id="L2544" title="All 2 branches missed.">            &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_MAXTECH_MOVEMENT_MODS)) {</span>
<span class="nc bnc" id="L2545" title="All 4 branches missed.">            if ((distance &gt;= 3) &amp;&amp; (distance &lt;= 4)) {</span>
<span class="nc" id="L2546">                toHit.addModifier(1, &quot;target moved 3-4 hexes&quot;);</span>
<span class="nc bnc" id="L2547" title="All 4 branches missed.">            } else if ((distance &gt;= 5) &amp;&amp; (distance &lt;= 6)) {</span>
<span class="nc" id="L2548">                toHit.addModifier(2, &quot;target moved 5-6 hexes&quot;);</span>
<span class="nc bnc" id="L2549" title="All 4 branches missed.">            } else if ((distance &gt;= 7) &amp;&amp; (distance &lt;= 9)) {</span>
<span class="nc" id="L2550">                toHit.addModifier(3, &quot;target moved 7-9 hexes&quot;);</span>
<span class="nc bnc" id="L2551" title="All 4 branches missed.">            } else if ((distance &gt;= 10) &amp;&amp; (distance &lt;= 13)) {</span>
<span class="nc" id="L2552">                toHit.addModifier(4, &quot;target moved 10-13 hexes&quot;);</span>
<span class="nc bnc" id="L2553" title="All 4 branches missed.">            } else if ((distance &gt;= 14) &amp;&amp; (distance &lt;= 18)) {</span>
<span class="nc" id="L2554">                toHit.addModifier(5, &quot;target moved 18-24 hexes&quot;);</span>
<span class="nc bnc" id="L2555" title="All 4 branches missed.">            } else if ((distance &gt;= 19) &amp;&amp; (distance &lt;= 24)) {</span>
<span class="nc" id="L2556">                toHit.addModifier(6, &quot;target moved 18-24 hexes&quot;);</span>
<span class="nc bnc" id="L2557" title="All 2 branches missed.">            } else if (distance &gt;= 25) {</span>
<span class="nc" id="L2558">                toHit.addModifier(7, &quot;target moved 25+ hexes&quot;);</span>
            }
        } else {
<span class="nc bnc" id="L2561" title="All 4 branches missed.">            if ((distance &gt;= 3) &amp;&amp; (distance &lt;= 4)) {</span>
<span class="nc" id="L2562">                toHit.addModifier(1, &quot;target moved 3-4 hexes&quot;);</span>
<span class="nc bnc" id="L2563" title="All 4 branches missed.">            } else if ((distance &gt;= 5) &amp;&amp; (distance &lt;= 6)) {</span>
<span class="nc" id="L2564">                toHit.addModifier(2, &quot;target moved 5-6 hexes&quot;);</span>
<span class="nc bnc" id="L2565" title="All 4 branches missed.">            } else if ((distance &gt;= 7) &amp;&amp; (distance &lt;= 9)) {</span>
<span class="nc" id="L2566">                toHit.addModifier(3, &quot;target moved 7-9 hexes&quot;);</span>
<span class="nc bnc" id="L2567" title="All 4 branches missed.">            } else if ((distance &gt;= 10) &amp;&amp; (distance &lt;= 17)) {</span>
<span class="nc" id="L2568">                toHit.addModifier(4, &quot;target moved 10-17 hexes&quot;);</span>
<span class="nc bnc" id="L2569" title="All 4 branches missed.">            } else if ((distance &gt;= 18) &amp;&amp; (distance &lt;= 24)) {</span>
<span class="nc" id="L2570">                toHit.addModifier(5, &quot;target moved 18-24 hexes&quot;);</span>
<span class="nc bnc" id="L2571" title="All 2 branches missed.">            } else if (distance &gt;= 25) {</span>
<span class="nc" id="L2572">                toHit.addModifier(6, &quot;target moved 25+ hexes&quot;);</span>
            }
        }

<span class="nc bnc" id="L2576" title="All 2 branches missed.">        if (jumped) {</span>
<span class="nc bnc" id="L2577" title="All 4 branches missed.">            if (isVTOL &amp;&amp; (distance &gt; 0)) {</span>
<span class="nc" id="L2578">                toHit.addModifier(1, &quot;target VTOL used MPs&quot;);</span>
            } else {
<span class="nc" id="L2580">                toHit.addModifier(1, &quot;target jumped&quot;);</span>
            }
        }

<span class="nc" id="L2584">        return toHit;</span>
    }

    /**
     * Modifier to attacks due to attacker terrain
     */
    public static ToHitData getAttackerTerrainModifier(IGame game, int entityId) {
<span class="nc" id="L2591">        final Entity attacker = game.getEntity(entityId);</span>
<span class="nc" id="L2592">        final IHex hex = game.getBoard().getHex(attacker.getPosition());</span>

<span class="nc" id="L2594">        ToHitData toHit = new ToHitData();</span>

        // space screens; bonus depends on number (level)
<span class="nc bnc" id="L2597" title="All 4 branches missed.">        if ((hex != null) &amp;&amp; (hex.terrainLevel(Terrains.SCREEN) &gt; 0)) {</span>
<span class="nc" id="L2598">            toHit.addModifier(hex.terrainLevel(Terrains.SCREEN) + 1,</span>
                              &quot;attacker in screen(s)&quot;);
        }

<span class="nc" id="L2602">        return toHit;</span>
    }

    /**
     * Modifier to attacks due to target terrain TODO:um....should VTOLs get
     * modifiers for smoke, etc.
     */
    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t) {
<span class="nc" id="L2610">        return Compute.getTargetTerrainModifier(game, t, 0);</span>
    }

    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t,
                                                     int eistatus) {
<span class="nc" id="L2615">        return Compute.getTargetTerrainModifier(game, t, eistatus, false);</span>
    }

    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t,
                                                     int eistatus, boolean attackerInSameBuilding) {
<span class="nc" id="L2620">        return Compute.getTargetTerrainModifier(game, t, eistatus,</span>
                                                attackerInSameBuilding, false);
    }

    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t,
                                                     int eistatus, boolean attackerInSameBuilding,
                                                     boolean underwaterWeapon) {
<span class="nc" id="L2627">        ToHitData toHit = new ToHitData();</span>

        // no terrain mods for bombs, artillery strikes
<span class="nc bnc" id="L2630" title="All 2 branches missed.">        if (t.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB ||</span>
<span class="nc bnc" id="L2631" title="All 2 branches missed.">                t.getTargetType() == Targetable.TYPE_HEX_ARTILLERY) {</span>
<span class="nc" id="L2632">            return toHit;</span>
        }
        
<span class="nc" id="L2635">        Entity entityTarget = null;</span>
<span class="nc" id="L2636">        IHex hex = game.getBoard().getHex(t.getPosition());</span>
<span class="nc bnc" id="L2637" title="All 2 branches missed.">        if (t.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L2638">            entityTarget = (Entity) t;</span>
<span class="nc bnc" id="L2639" title="All 2 branches missed.">            if (hex == null) {</span>
<span class="nc" id="L2640">                entityTarget.setPosition(game.getEntity(entityTarget.getId())</span>
<span class="nc" id="L2641">                                             .getPosition());</span>
<span class="nc" id="L2642">                hex = game.getBoard().getHex(</span>
<span class="nc" id="L2643">                        game.getEntity(entityTarget.getId()).getPosition());</span>
            }
        }
        
        // if the hex doesn't exist, it's unlikely to have terrain modifiers
<span class="nc bnc" id="L2648" title="All 2 branches missed.">        if (hex == null) {</span>
<span class="nc" id="L2649">            return toHit;</span>
        }


<span class="nc bnc" id="L2653" title="All 4 branches missed.">        boolean hasWoods = hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE);</span>
        // Standard mechs (standing) report their height as 1, tanks as 0
        // Standard mechs should not benefit from 1 level high woods
        
<span class="nc bnc" id="L2657" title="All 2 branches missed.">        boolean isAboveWoods = (entityTarget == null) </span>
<span class="nc bnc" id="L2658" title="All 2 branches missed.">                || (entityTarget.relHeight() + 1 &gt; hex.terrainLevel(Terrains.FOLIAGE_ELEV)) </span>
<span class="nc bnc" id="L2659" title="All 4 branches missed.">                || entityTarget.isAirborne() </span>
                || !hasWoods;
<span class="nc bnc" id="L2661" title="All 2 branches missed.">        boolean isAboveSmoke = (entityTarget == null)</span>
<span class="nc bnc" id="L2662" title="All 2 branches missed.">                || (entityTarget.relHeight() + 1 &gt; 2) </span>
<span class="nc bnc" id="L2663" title="All 2 branches missed.">                || !hex.containsTerrain(Terrains.SMOKE);</span>
<span class="nc bnc" id="L2664" title="All 2 branches missed.">        boolean isUnderwater = (entityTarget != null)</span>
<span class="nc bnc" id="L2665" title="All 4 branches missed.">                               &amp;&amp; hex.containsTerrain(Terrains.WATER) &amp;&amp; (hex.depth() &gt; 0)</span>
<span class="nc bnc" id="L2666" title="All 2 branches missed.">                               &amp;&amp; (entityTarget.getElevation() &lt; hex.surface());</span>

        // if we have in-building combat, it's a +1
<span class="nc bnc" id="L2669" title="All 2 branches missed.">        if (attackerInSameBuilding) {</span>
<span class="nc" id="L2670">            toHit.addModifier(1, &quot;target in a building hex&quot;);</span>
        }

        // Smoke and woods. With L3, the effects STACK.
<span class="nc" id="L2674">        int woodsLevel = hex.terrainLevel(Terrains.WOODS);</span>
<span class="nc" id="L2675">        int jungleLevel = hex.terrainLevel(Terrains.JUNGLE);</span>
<span class="nc" id="L2676">        String woodsText = &quot;woods&quot;;</span>
<span class="nc bnc" id="L2677" title="All 2 branches missed.">        if (woodsLevel &lt; jungleLevel) {</span>
<span class="nc" id="L2678">            woodsLevel = jungleLevel;</span>
<span class="nc" id="L2679">            woodsText = &quot;jungle&quot;;</span>
        }
<span class="nc bnc" id="L2681" title="All 2 branches missed.">        if (woodsLevel == 1) {</span>
<span class="nc" id="L2682">            woodsText = &quot;target in light &quot; + woodsText;</span>
<span class="nc bnc" id="L2683" title="All 2 branches missed.">        } else if (woodsLevel == 2) {</span>
<span class="nc" id="L2684">            woodsText = &quot;target in heavy &quot; + woodsText;</span>
<span class="nc bnc" id="L2685" title="All 2 branches missed.">        } else if (woodsLevel == 3) {</span>
<span class="nc" id="L2686">            woodsText = &quot;target in ultra heavy &quot; + woodsText;</span>
        }

<span class="nc bnc" id="L2689" title="All 4 branches missed.">        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_WOODS_COVER)</span>
            &amp;&amp; !isAboveWoods
<span class="nc bnc" id="L2691" title="All 2 branches missed.">            &amp;&amp; !((t.getTargetType() == Targetable.TYPE_HEX_CLEAR)</span>
<span class="nc bnc" id="L2692" title="All 2 branches missed.">                 || (t.getTargetType() == Targetable.TYPE_HEX_IGNITE)</span>
<span class="nc bnc" id="L2693" title="All 2 branches missed.">                 || (t.getTargetType() == Targetable.TYPE_HEX_BOMB)</span>
<span class="nc bnc" id="L2694" title="All 2 branches missed.">                 || (t.getTargetType() == Targetable.TYPE_HEX_ARTILLERY)</span>
<span class="nc bnc" id="L2695" title="All 2 branches missed.">                 || (t.getTargetType() == Targetable.TYPE_MINEFIELD_DELIVER))) {</span>
<span class="nc bnc" id="L2696" title="All 4 branches missed.">            if ((woodsLevel == 1) &amp;&amp; (eistatus != 2)) {</span>
<span class="nc" id="L2697">                toHit.addModifier(1, woodsText);</span>
<span class="nc bnc" id="L2698" title="All 2 branches missed.">            } else if (woodsLevel &gt; 1) {</span>
<span class="nc bnc" id="L2699" title="All 2 branches missed.">                if (eistatus &gt; 0) {</span>
<span class="nc" id="L2700">                    toHit.addModifier(woodsLevel - 1, woodsText);</span>
                } else {
<span class="nc" id="L2702">                    toHit.addModifier(woodsLevel, woodsText);</span>
                }
            }
        }
<span class="nc bnc" id="L2706" title="All 6 branches missed.">        if (!isAboveSmoke &amp;&amp; !isUnderwater &amp;&amp; !underwaterWeapon) {</span>
<span class="nc bnc" id="L2707" title="All 2 branches missed.">            if ((hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LIGHT)</span>
<span class="nc bnc" id="L2708" title="All 2 branches missed.">                || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_LIGHT)</span>
<span class="nc bnc" id="L2709" title="All 2 branches missed.">                || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_HEAVY)</span>
<span class="nc bnc" id="L2710" title="All 2 branches missed.">                || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_CHAFF_LIGHT)) {</span>
<span class="nc" id="L2711">                toHit.addModifier(1, &quot;target in light smoke&quot;);</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">            } else if (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_HEAVY) {</span>
<span class="nc bnc" id="L2713" title="All 2 branches missed.">                if (eistatus &gt; 0) {</span>
<span class="nc" id="L2714">                    toHit.addModifier(1, &quot;target in heavy smoke&quot;);</span>
                } else {
<span class="nc" id="L2716">                    toHit.addModifier(2, &quot;target in heavy smoke&quot;);</span>
                }
            }
        }
<span class="nc bnc" id="L2720" title="All 2 branches missed.">        if (hex.terrainLevel(Terrains.GEYSER) == 2) {</span>
<span class="nc bnc" id="L2721" title="All 2 branches missed.">            if (eistatus &gt; 0) {</span>
<span class="nc" id="L2722">                toHit.addModifier(1, &quot;target in erupting geyser&quot;);</span>
            } else {
<span class="nc" id="L2724">                toHit.addModifier(2, &quot;target in erupting geyser&quot;);</span>
            }
        }

<span class="nc bnc" id="L2728" title="All 2 branches missed.">        if (hex.containsTerrain(Terrains.INDUSTRIAL)) {</span>
<span class="nc" id="L2729">            toHit.addModifier(+1, &quot;target in heavy industrial zone&quot;);</span>
        }
        // space screens; bonus depends on number (level)
<span class="nc bnc" id="L2732" title="All 2 branches missed.">        if (hex.terrainLevel(Terrains.SCREEN) &gt; 0) {</span>
<span class="nc" id="L2733">            toHit.addModifier(hex.terrainLevel(Terrains.SCREEN) + 1,</span>
                              &quot;target in screen(s)&quot;);
        }

        // only entities get remaining terrain bonuses
        // TODO: should this be changed for buildings???
<span class="nc bnc" id="L2739" title="All 2 branches missed.">        if (entityTarget == null) {</span>
<span class="nc" id="L2740">            return toHit;</span>
<span class="nc bnc" id="L2741" title="All 2 branches missed.">        } else if (entityTarget.isMakingDfa()) {</span>
            // you don't get terrain modifiers in midair
            // should be abstracted more into a 'not on the ground'
            // flag for vtols and such
<span class="nc" id="L2745">            return toHit;</span>
        }

<span class="nc bnc" id="L2748" title="All 2 branches missed.">        if (entityTarget.isStuck()) {</span>
<span class="nc" id="L2749">            toHit.addModifier(-2, &quot;target stuck in swamp&quot;);</span>
        }
<span class="nc bnc" id="L2751" title="All 2 branches missed.">        if ((entityTarget instanceof Infantry)</span>
<span class="nc bnc" id="L2752" title="All 2 branches missed.">            &amp;&amp; hex.containsTerrain(Terrains.FIELDS)) {</span>
<span class="nc" id="L2753">            toHit.addModifier(+1, &quot;target in planted fields&quot;);</span>
        }
<span class="nc" id="L2755">        return toHit;</span>
    }

    public static ToHitData getStrafingTerrainModifier(IGame game,
                                                       int eistatus, IHex hex) {
<span class="nc" id="L2760">        ToHitData toHit = new ToHitData();</span>
        // Smoke and woods. With L3, the effects STACK.
<span class="nc" id="L2762">        int woodsLevel = hex.terrainLevel(Terrains.WOODS);</span>
<span class="nc" id="L2763">        int jungleLevel = hex.terrainLevel(Terrains.JUNGLE);</span>
<span class="nc" id="L2764">        String woodsText = &quot;woods&quot;;</span>
<span class="nc bnc" id="L2765" title="All 2 branches missed.">        if (woodsLevel &lt; jungleLevel) {</span>
<span class="nc" id="L2766">            woodsLevel = jungleLevel;</span>
<span class="nc" id="L2767">            woodsText = &quot;jungle&quot;;</span>
        }
<span class="nc bnc" id="L2769" title="All 2 branches missed.">        if (woodsLevel == 1) {</span>
<span class="nc" id="L2770">            woodsText = &quot;light &quot; + woodsText;</span>
<span class="nc bnc" id="L2771" title="All 2 branches missed.">        } else if (woodsLevel == 2) {</span>
<span class="nc" id="L2772">            woodsText = &quot;heavy &quot; + woodsText;</span>
<span class="nc bnc" id="L2773" title="All 2 branches missed.">        } else if (woodsLevel == 3) {</span>
<span class="nc" id="L2774">            woodsText = &quot;heavy &quot; + woodsText;</span>
        }

<span class="nc bnc" id="L2777" title="All 2 branches missed.">        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_WOODS_COVER)) {</span>
<span class="nc bnc" id="L2778" title="All 4 branches missed.">            if ((woodsLevel == 1) &amp;&amp; (eistatus != 2)) {</span>
<span class="nc" id="L2779">                toHit.addModifier(1, woodsText);</span>
<span class="nc bnc" id="L2780" title="All 2 branches missed.">            } else if (woodsLevel &gt; 1) {</span>
<span class="nc bnc" id="L2781" title="All 2 branches missed.">                if (eistatus &gt; 0) {</span>
<span class="nc" id="L2782">                    toHit.addModifier(woodsLevel - 1, woodsText);</span>
                } else {
<span class="nc" id="L2784">                    toHit.addModifier(woodsLevel, woodsText);</span>
                }
            }
        }

<span class="nc bnc" id="L2789" title="All 2 branches missed.">        if ((hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LIGHT)</span>
<span class="nc bnc" id="L2790" title="All 2 branches missed.">            || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_LIGHT)</span>
<span class="nc bnc" id="L2791" title="All 2 branches missed.">            || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_HEAVY)</span>
<span class="nc bnc" id="L2792" title="All 2 branches missed.">            || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_CHAFF_LIGHT)) {</span>
<span class="nc" id="L2793">            toHit.addModifier(1, &quot;light smoke&quot;);</span>
<span class="nc bnc" id="L2794" title="All 2 branches missed.">        } else if (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_HEAVY) {</span>
<span class="nc bnc" id="L2795" title="All 2 branches missed.">            if (eistatus &gt; 0) {</span>
<span class="nc" id="L2796">                toHit.addModifier(1, &quot;heavy smoke&quot;);</span>
            } else {
<span class="nc" id="L2798">                toHit.addModifier(2, &quot;heavy smoke&quot;);</span>
            }
        }

<span class="nc bnc" id="L2802" title="All 2 branches missed.">        if (hex.terrainLevel(Terrains.GEYSER) == 2) {</span>
<span class="nc bnc" id="L2803" title="All 2 branches missed.">            if (eistatus &gt; 0) {</span>
<span class="nc" id="L2804">                toHit.addModifier(1, &quot;erupting geyser&quot;);</span>
            } else {
<span class="nc" id="L2806">                toHit.addModifier(2, &quot;erupting geyser&quot;);</span>
            }
        }
<span class="nc" id="L2809">        return toHit;</span>
    }

    /**
     * Calculates the current theoretical damage absorbable(armor+structure, etc) by the given target.
     * Used as a measure of the potential durability of the target under fire.
     */
    public static int getTargetTotalHP(IGame game, Targetable target) {
<span class="nc" id="L2817">        int targetType = target.getTargetType();</span>
<span class="nc" id="L2818">        int targetId = target.getTargetId();</span>
<span class="nc" id="L2819">        Coords position = target.getPosition();</span>

        //First, handle buildings versus entities, since they are handled differently.
<span class="nc bnc" id="L2822" title="All 2 branches missed.">        if(targetType == Targetable.TYPE_BUILDING) {</span>
            //Buildings are a simple sum of their current CF and armor values.
<span class="nc" id="L2824">            Building parentBuilding = game.getBoard().getBuildingAt(position); //the building the targeted hex belongs to. We have to get this and then get values for the specific hex internally to it.</span>
<span class="nc" id="L2825">            int targetCF = parentBuilding.getCurrentCF(position);</span>
<span class="nc" id="L2826">            int targetArmor = parentBuilding.getArmor(position);</span>
<span class="nc" id="L2827">            return targetCF + targetArmor;</span>
<span class="nc bnc" id="L2828" title="All 2 branches missed.">        } else if (targetType == Targetable.TYPE_ENTITY) {</span>
            //I don't *think* we have to handle infantry differently here- I think these methods should return the total number of men remaining as internal structure.
<span class="nc" id="L2830">            Entity targetEntity = game.getEntity(targetId);</span>

<span class="nc bnc" id="L2832" title="All 2 branches missed.">            if (targetEntity instanceof GunEmplacement) { //If this is a gun emplacement, handle it as the building hex it is in.</span>
<span class="nc" id="L2833">                Building parentBuilding = game.getBoard().getBuildingAt(position);</span>
<span class="nc" id="L2834">                int targetCF = parentBuilding.getCurrentCF(position);</span>
<span class="nc" id="L2835">                int targetArmor = parentBuilding.getArmor(position);</span>
<span class="nc" id="L2836">                return targetCF + targetArmor;</span>
            }
<span class="nc" id="L2838">            int targetArmor = targetEntity.getTotalArmor();</span>
<span class="nc" id="L2839">            int targetStructure = targetEntity.getTotalInternal();</span>
<span class="nc" id="L2840">            return targetArmor + targetStructure;</span>
<span class="nc bnc" id="L2841" title="All 2 branches missed.">        } else if (targetType == Targetable.TYPE_HEX_CLEAR) {</span>
            // clearing a hex - the &quot;HP&quot; is the terrain factor of destroyable terrain on this hex
<span class="nc" id="L2843">            IHex mhex = game.getBoard().getHex(position);</span>
<span class="nc" id="L2844">            int terrainTypes[] = mhex.getTerrainTypes();</span>
<span class="nc" id="L2845">            int totalTF = 0;</span>
            
<span class="nc bnc" id="L2847" title="All 2 branches missed.">            for (int i = 0; i &lt; terrainTypes.length; i++) {</span>
<span class="nc" id="L2848">                int tf = 0;</span>
<span class="nc" id="L2849">                int terType = terrainTypes[i];</span>
<span class="nc bnc" id="L2850" title="All 2 branches missed.">                if (mhex.containsTerrain(terType)) {</span>
<span class="nc" id="L2851">                    tf = mhex.getTerrain(terType).getTerrainFactor();</span>
                }
                
<span class="nc" id="L2854">                totalTF += tf;</span>
            }
            
<span class="nc" id="L2857">            return totalTF;</span>
        } else { //something else, e.g. terrain. We probably don't need to handle it for now.
<span class="nc" id="L2859">            return 0;</span>
        }
    }

    /**
     * Returns the weapon attack out of a list that has the highest expected
     * damage
     */
    public static WeaponAttackAction getHighestExpectedDamage(IGame g,
            List&lt;WeaponAttackAction&gt; vAttacks, boolean assumeHit) {
<span class="nc" id="L2869">        float fHighest = -1.0f;</span>
<span class="nc" id="L2870">        WeaponAttackAction waaHighest = null;</span>
<span class="nc bnc" id="L2871" title="All 2 branches missed.">        for (int x = 0, n = vAttacks.size(); x &lt; n; x++) {</span>
<span class="nc" id="L2872">            WeaponAttackAction waa = vAttacks.get(x);</span>
<span class="nc" id="L2873">            float fDanger = Compute.getExpectedDamage(g, waa, assumeHit);</span>
<span class="nc bnc" id="L2874" title="All 2 branches missed.">            if (fDanger &gt; fHighest) {</span>
<span class="nc" id="L2875">                fHighest = fDanger;</span>
<span class="nc" id="L2876">                waaHighest = waa;</span>
            }
        }
<span class="nc" id="L2879">        return waaHighest;</span>
    }

    // store these as constants since the tables will never change
<span class="nc" id="L2883">    private static float[] expectedHitsByRackSize = { 0.0f, 1.0f, 1.58f, 2.0f,</span>
            2.63f, 3.17f, 4.0f, 4.49f, 4.98f, 5.47f, 6.31f, 7.23f, 8.14f,
            8.59f, 9.04f, 9.5f, 10.1f, 10.8f, 11.42f, 12.1f, 12.7f };

    /*
     * | No Modifier | +2 (Artemis, Narc) | -2 (HAG, AMS v Art)| -4 (AMS) | |
     * Avg | Avg | Avg | Avg | | Hits Pct | Hits Pct | Hits Pct | Hits Pct | |
     * Avg Per vs | Avg Per vs | Avg Per vs | Avg Per vs | Size| Hits Size Avg |
     * Hits Size Avg | Hits Size Avg | Hits Size Avg |
     * ----+--------------------+
     * --------------------+--------------------+--------------------+ 2 | 1.42
     * 0.708 9.1 | 1.72 0.861 10.3 | 1.17 0.583 10.7 | 1.03 0.514 21.9 | 3 |
     * 2.00 0.667 2.7 | 2.39 0.796 2.0 | 1.61 0.537 2.0 | 1.28 0.426 1.0 | 4 |
     * 2.64 0.660 1.6 | 3.11 0.778 -0.4 | 2.11 0.528 0.2 | 1.67 0.417 -1.2 | 5 |
     * 3.17 0.633 -2.5 | 3.83 0.767 -1.8 | 2.50 0.500 -5.1 | 1.86 0.372 -11.7 |
     * 6 | 4.00 0.667 2.7 | 4.78 0.796 2.0 | 3.22 0.537 2.0 | 2.58 0.431 2.1 | 7
     * | 4.39 0.627 -3.4 | 5.42 0.774 -0.9 | 3.47 0.496 -5.8 | 2.69 0.385 -8.7 |
     * 8 | 5.08 0.635 -2.1 | 6.06 0.757 -3.0 | 4.22 0.528 0.2 | 3.58 0.448 6.2 |
     * 9 | 5.47 0.608 -6.4 | 6.69 0.744 -4.7 | 4.47 0.497 -5.7 | 3.69 0.410 -2.7
     * | 10 | 6.31 0.631 -2.9 | 7.67 0.767 -1.8 | 5.06 0.506 -4.0 | 3.97 0.397
     * -5.8 | 11 | 7.31 0.664 2.3 | 8.67 0.788 0.9 | 6.06 0.551 4.5 | 4.97 0.452
     * 7.2 | 12 | 8.14 0.678 4.5 | 9.64 0.803 2.9 | 6.64 0.553 5.0 | 5.25 0.438
     * 3.7 | 13 | 8.42 0.647 -0.3 | 10.22 0.786 0.7 | 6.72 0.517 -1.8 | 5.25
     * 0.404 -4.2 | 14 | 9.22 0.659 1.5 | 10.92 0.780 -0.1 | 7.64 0.546 3.6 |
     * 6.25 0.446 5.9 | 15 | 9.50 0.633 -2.5 | 11.50 0.767 -1.8 | 7.72 0.515
     * -2.3 | 6.25 0.417 -1.2 | 16 | 10.42 0.651 0.3 | 12.50 0.781 0.1 | 8.44
     * 0.528 0.2 | 6.67 0.417 -1.2 | 17 | 10.69 0.629 -3.1 | 13.08 0.770 -1.4 |
     * 8.53 0.502 -4.8 | 6.67 0.392 -7.0 | 18 | 11.50 0.639 -1.6 | 13.78 0.765
     * -1.9 | 9.44 0.525 -0.4 | 7.67 0.426 1.0 | 19 | 11.78 0.620 -4.5 | 14.36
     * 0.756 -3.2 | 9.53 0.501 -4.8 | 7.67 0.404 -4.3 | 20 | 12.69 0.635 -2.2 |
     * 15.36 0.768 -1.6 | 10.25 0.512 -2.7 | 8.08 0.404 -4.2 | 21 | 13.61 0.648
     * -0.2 | 16.33 0.778 -0.4 | 11.11 0.529 0.4 | 8.94 0.426 1.0 | 22 | 14.44
     * 0.657 1.1 | 17.31 0.787 0.8 | 11.69 0.532 0.9 | 9.22 0.419 -0.6 | 23 |
     * 15.36 0.668 2.9 | 18.31 0.796 2.0 | 12.42 0.540 2.5 | 9.64 0.419 -0.6 |
     * 24 | 16.28 0.678 4.5 | 19.28 0.803 2.9 | 13.28 0.553 5.0 | 10.50 0.438
     * 3.7 | 25 | 16.56 0.662 2.0 | 19.86 0.794 1.8 | 13.36 0.534 1.5 | 10.50
     * 0.420 -0.4 | 26 | 17.36 0.668 2.8 | 20.56 0.791 1.3 | 14.28 0.549 4.2 |
     * 11.50 0.442 4.9 | 27 | 17.64 0.653 0.6 | 21.14 0.783 0.3 | 14.36 0.532
     * 1.0 | 11.50 0.426 1.0 | 28 | 17.92 0.640 -1.4 | 21.72 0.776 -0.6 | 14.44
     * 0.516 -2.1 | 11.50 0.411 -2.6 | 29 | 18.72 0.646 -0.6 | 22.42 0.773 -1.0
     * | 15.36 0.530 0.6 | 12.50 0.431 2.2 | 30 | 19.00 0.633 -2.5 | 23.00 0.767
     * -1.8 | 15.44 0.515 -2.3 | 12.50 0.417 -1.2 | 40 | 25.39 0.635 -2.2 |
     * 30.72 0.768 -1.6 | 20.50 0.512 -2.7 | 16.17 0.404 -4.2 | ----- -----
     * ----- ----- Average: 0.649 0.781 0.527 0.422 1.202 0.811 0.649
     */

    /**
     * Determines the expected damage of a weapon attack, based on to-hit, salvo
     * sizes, etc.
     */
    public static float getExpectedDamage(IGame g, WeaponAttackAction waa,
            boolean assumeHit) {
<span class="nc" id="L2935">        return Compute.getExpectedDamage(g, waa, assumeHit, null);</span>
    }

    /**
     * Determines the expected damage of a weapon attack, based on to-hit, salvo
     * sizes, etc.
     */
    public static float getExpectedDamage(IGame g, WeaponAttackAction waa,
            boolean assumeHit, List&lt;ECMInfo&gt; allECMInfo) {
<span class="nc" id="L2944">        boolean use_table = false;</span>

<span class="nc" id="L2946">        AmmoType loaded_ammo = new AmmoType();</span>

<span class="nc" id="L2948">        Entity attacker = g.getEntity(waa.getEntityId());</span>
<span class="nc" id="L2949">        Entity target = g.getEntity(waa.getTargetId());</span>
        
<span class="nc bnc" id="L2951" title="All 2 branches missed.">        int baShootingStrength = attacker instanceof BattleArmor ? </span>
<span class="nc" id="L2952">                ((BattleArmor) attacker).getShootingStrength() : 0;</span>
        
<span class="nc" id="L2954">        int infShootingStrength = 0;</span>
<span class="nc" id="L2955">        double infDamagePerTrooper = 0;</span>
                
<span class="nc" id="L2957">        Mounted weapon = attacker.getEquipment(waa.getWeaponId());</span>
        Mounted lnk_guide;

<span class="nc" id="L2960">        ToHitData hitData = waa.toHit(g, allECMInfo);</span>

<span class="nc bnc" id="L2962" title="All 2 branches missed.">        if (attacker.isConventionalInfantry()) {</span>
<span class="nc" id="L2963">            infShootingStrength = ((Infantry) attacker).getShootingStrength();</span>
<span class="nc" id="L2964">            infDamagePerTrooper = ((Infantry) attacker).getDamagePerTrooper();</span>
        }

<span class="nc" id="L2967">        WeaponType wt = (WeaponType) weapon.getType();</span>

<span class="nc" id="L2969">        float fDamage = 0.0f;</span>
<span class="nc" id="L2970">        float fChance = 0.0f;</span>
<span class="nc bnc" id="L2971" title="All 2 branches missed.">        if (assumeHit) {</span>
<span class="nc" id="L2972">            fChance = 1.0f;</span>
        } else {
<span class="nc bnc" id="L2974" title="All 2 branches missed.">            if ((hitData.getValue() == TargetRoll.IMPOSSIBLE)</span>
<span class="nc bnc" id="L2975" title="All 2 branches missed.">                || (hitData.getValue() == TargetRoll.AUTOMATIC_FAIL)) {</span>
<span class="nc" id="L2976">                return 0.0f;</span>
            }

<span class="nc bnc" id="L2979" title="All 2 branches missed.">            if (hitData.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</span>
<span class="nc" id="L2980">                fChance = 1.0f;</span>
            } else {
<span class="nc" id="L2982">                fChance = (float) Compute.oddsAbove(hitData.getValue(),</span>
<span class="nc" id="L2983">                                                    attacker.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY))</span>
                          / 100.0f;
            }
        }

        // Missiles, HAGs, LBX cluster rounds, and ultra/rotary cannons (when
        // spun up)
        // use the missile hits table
<span class="nc bnc" id="L2991" title="All 2 branches missed.">        if (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</span>
<span class="nc" id="L2992">            use_table = true;</span>
        }

        //Unless it's a fighter squadron, which uses a weird group of single weapons and should return mass AV
<span class="nc bnc" id="L2996" title="All 2 branches missed.">        if (attacker.isCapitalFighter()) {</span>
<span class="nc" id="L2997">            use_table = false;</span>
        }

<span class="nc bnc" id="L3000" title="All 2 branches missed.">        if ((wt.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L3001" title="All 2 branches missed.">            || (wt.getAmmoType() == AmmoType.T_AC_LBX_THB)</span>
<span class="nc bnc" id="L3002" title="All 2 branches missed.">            || (wt.getAmmoType() == AmmoType.T_AC_LBX_THB)) {</span>
<span class="nc" id="L3003">            loaded_ammo = (AmmoType) weapon.getLinked().getType();</span>
<span class="nc bnc" id="L3004" title="All 2 branches missed.">            if (((loaded_ammo.getAmmoType() == AmmoType.T_AC_LBX) || (loaded_ammo</span>
<span class="nc bnc" id="L3005" title="All 2 branches missed.">                                                                              .getAmmoType() == AmmoType.T_AC_LBX_THB))</span>
<span class="nc bnc" id="L3006" title="All 2 branches missed.">                &amp;&amp; (loaded_ammo.getMunitionType() == AmmoType.M_CLUSTER)) {</span>
<span class="nc" id="L3007">                use_table = true;</span>
            }
        }

<span class="nc bnc" id="L3011" title="All 2 branches missed.">        if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3012" title="All 2 branches missed.">            || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</span>
<span class="nc bnc" id="L3013" title="All 2 branches missed.">            || (wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</span>
<span class="nc bnc" id="L3014" title="All 2 branches missed.">            if ((weapon.curMode().getName().equals(&quot;Ultra&quot;))</span>
<span class="nc bnc" id="L3015" title="All 2 branches missed.">                || (weapon.curMode().getName().equals(&quot;2-shot&quot;))</span>
<span class="nc bnc" id="L3016" title="All 2 branches missed.">                || (weapon.curMode().getName().equals(&quot;3-shot&quot;))</span>
<span class="nc bnc" id="L3017" title="All 2 branches missed.">                || (weapon.curMode().getName().equals(&quot;4-shot&quot;))</span>
<span class="nc bnc" id="L3018" title="All 2 branches missed.">                || (weapon.curMode().getName().equals(&quot;5-shot&quot;))</span>
<span class="nc bnc" id="L3019" title="All 2 branches missed.">                || (weapon.curMode().getName().equals(&quot;6-shot&quot;))) {</span>
<span class="nc" id="L3020">                use_table = true;</span>
            }
        }

        // Kinda cheap, but lets use the missile hits table for Battle armor
        // weapons too

<span class="nc bnc" id="L3027" title="All 2 branches missed.">        if (attacker instanceof BattleArmor) {</span>
<span class="nc bnc" id="L3028" title="All 2 branches missed.">            if ((wt.getInternalName() != Infantry.SWARM_MEK)</span>
<span class="nc bnc" id="L3029" title="All 2 branches missed.">                &amp;&amp; (wt.getInternalName() != Infantry.LEG_ATTACK)) {</span>
<span class="nc" id="L3030">                use_table = true;</span>
            }
        }

<span class="nc bnc" id="L3034" title="All 2 branches missed.">        if (use_table == true) {</span>
<span class="nc bnc" id="L3035" title="All 2 branches missed.">            if (!(attacker instanceof BattleArmor)) {</span>
<span class="nc bnc" id="L3036" title="All 2 branches missed.">                if (weapon.getLinked() == null) {</span>
<span class="nc" id="L3037">                    return 0.0f;</span>
                }
            }
<span class="nc" id="L3040">            AmmoType at = null;</span>
<span class="nc bnc" id="L3041" title="All 2 branches missed.">            if ((weapon.getLinked() != null)</span>
<span class="nc bnc" id="L3042" title="All 2 branches missed.">                    &amp;&amp; (weapon.getLinked().getType() instanceof AmmoType)) {</span>
<span class="nc" id="L3043">                at = (AmmoType) weapon.getLinked().getType();</span>
<span class="nc" id="L3044">                fDamage = at.getDamagePerShot();</span>
            }

<span class="nc" id="L3047">            float fHits = 0.0f;</span>
<span class="nc bnc" id="L3048" title="All 4 branches missed.">            if ((wt.getRackSize() != 40) &amp;&amp; (wt.getRackSize() != 30)) {</span>
<span class="nc" id="L3049">                fHits = expectedHitsByRackSize[wt.getRackSize()];</span>
            } else {
<span class="nc" id="L3051">                fHits = 2.0f * expectedHitsByRackSize[wt.getRackSize() / 2];</span>
            }
<span class="nc bnc" id="L3053" title="All 2 branches missed.">            if (((wt.getAmmoType() == AmmoType.T_SRM_STREAK)</span>
<span class="nc bnc" id="L3054" title="All 2 branches missed.">                    || (wt.getAmmoType() == AmmoType.T_MRM_STREAK) || (wt</span>
<span class="nc bnc" id="L3055" title="All 2 branches missed.">                    .getAmmoType() == AmmoType.T_LRM_STREAK))</span>
<span class="nc bnc" id="L3056" title="All 2 branches missed.">                    &amp;&amp; !ComputeECM.isAffectedByAngelECM(attacker, attacker</span>
<span class="nc" id="L3057">                            .getPosition(), waa.getTarget(g).getPosition(),</span>
                            allECMInfo)) {
<span class="nc" id="L3059">                fHits = wt.getRackSize();</span>
            }
<span class="nc bnc" id="L3061" title="All 2 branches missed.">            if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3062" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</span>
<span class="nc bnc" id="L3063" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</span>
<span class="nc bnc" id="L3064" title="All 2 branches missed.">                if ((weapon.curMode().getName().equals(&quot;Ultra&quot;))</span>
<span class="nc bnc" id="L3065" title="All 2 branches missed.">                    || (weapon.curMode().getName().equals(&quot;2-shot&quot;))) {</span>
<span class="nc" id="L3066">                    fHits = expectedHitsByRackSize[2];</span>
                }
<span class="nc bnc" id="L3068" title="All 2 branches missed.">                if (weapon.curMode().getName().equals(&quot;3-shot&quot;)) {</span>
<span class="nc" id="L3069">                    fHits = expectedHitsByRackSize[3];</span>
                }
<span class="nc bnc" id="L3071" title="All 2 branches missed.">                if (weapon.curMode().getName().equals(&quot;4-shot&quot;)) {</span>
<span class="nc" id="L3072">                    fHits = expectedHitsByRackSize[4];</span>
                }
<span class="nc bnc" id="L3074" title="All 2 branches missed.">                if (weapon.curMode().getName().equals(&quot;5-shot&quot;)) {</span>
<span class="nc" id="L3075">                    fHits = expectedHitsByRackSize[5];</span>
                }
<span class="nc bnc" id="L3077" title="All 2 branches missed.">                if (weapon.curMode().getName().equals(&quot;6-shot&quot;)) {</span>
<span class="nc" id="L3078">                    fHits = expectedHitsByRackSize[6];</span>
                }
            }

            // Most Battle Armor units have a weapon per trooper, plus their
            // weapons do odd things when mounting multiples
<span class="nc bnc" id="L3084" title="All 2 branches missed.">            if (attacker instanceof BattleArmor) {</span>
                // The number of troopers hitting
<span class="nc" id="L3086">                fHits = expectedHitsByRackSize[baShootingStrength];</span>
<span class="nc bnc" id="L3087" title="All 2 branches missed.">                if (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</span>
<span class="nc" id="L3088">                    fHits *= expectedHitsByRackSize[wt.getRackSize()];</span>
                }
<span class="nc bnc" id="L3090" title="All 2 branches missed.">                if (wt.getDamage() != WeaponType.DAMAGE_BY_CLUSTERTABLE) {</span>
<span class="nc bnc" id="L3091" title="All 2 branches missed.">                    if (wt.getDamage() != WeaponType.DAMAGE_VARIABLE) {</span>
<span class="nc" id="L3092">                        fDamage = wt.getDamage();</span>
                    } else {
<span class="nc" id="L3094">                        fDamage = wt.getRackSize();</span>
                    }
                }
<span class="nc bnc" id="L3097" title="All 2 branches missed.">                if (wt.hasFlag(WeaponType.F_MISSILE_HITS)) {</span>
<span class="nc" id="L3098">                    fHits *= expectedHitsByRackSize[wt.getRackSize()];</span>
                }
            }

            // If there is no ECM coverage to the target, guidance systems are
            // good for another 1.20x damage on missile weapons
<span class="nc bnc" id="L3104" title="All 2 branches missed.">            if ((!ComputeECM.isAffectedByECM(attacker, attacker.getPosition(), g</span>
<span class="nc" id="L3105">                    .getEntity(waa.getTargetId()).getPosition(), allECMInfo))</span>
<span class="nc bnc" id="L3106" title="All 2 branches missed.">                &amp;&amp; (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE)</span>
<span class="nc bnc" id="L3107" title="All 2 branches missed.">                &amp;&amp; (wt.hasFlag(WeaponType.F_MISSILE))) {</span>
                // Check for linked artemis guidance system
<span class="nc bnc" id="L3109" title="All 2 branches missed.">                if ((wt.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L3110" title="All 2 branches missed.">                        || (wt.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L3111" title="All 2 branches missed.">                        || (wt.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L3112" title="All 2 branches missed.">                        || (wt.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3113" title="All 2 branches missed.">                        || (wt.getAmmoType() == AmmoType.T_SRM_IMP)) {</span>
<span class="nc" id="L3114">                    lnk_guide = weapon.getLinkedBy();</span>
<span class="nc bnc" id="L3115" title="All 6 branches missed.">                    if ((lnk_guide != null) &amp;&amp; (lnk_guide.getType() instanceof MiscType) &amp;&amp; !lnk_guide.isDestroyed()</span>
<span class="nc bnc" id="L3116" title="All 4 branches missed.">                            &amp;&amp; !lnk_guide.isMissing() &amp;&amp; !lnk_guide.isBreached()</span>
<span class="nc bnc" id="L3117" title="All 2 branches missed.">                            &amp;&amp; lnk_guide.getType().hasFlag(MiscType.F_ARTEMIS)) {</span>

                        // Don't use artemis if this is indirect fire
                        // -&gt; Hook for Artemis V Level 3 Clan tech here; use
                        // 1.30f multiplier when implemented
<span class="nc bnc" id="L3122" title="All 4 branches missed.">                        if (((weapon.curMode() == null) || !weapon.curMode().equals(&quot;Indirect&quot;))</span>
<span class="nc bnc" id="L3123" title="All 2 branches missed.">                                &amp;&amp; (at.getMunitionType() == AmmoType.M_ARTEMIS_CAPABLE)) {</span>
<span class="nc" id="L3124">                            fHits *= 1.2f;</span>
                        }
<span class="nc bnc" id="L3126" title="All 4 branches missed.">                        if (((weapon.curMode() == null) || !weapon.curMode().equals(&quot;Indirect&quot;))</span>
<span class="nc bnc" id="L3127" title="All 2 branches missed.">                                &amp;&amp; (at.getMunitionType() == AmmoType.M_ARTEMIS_V_CAPABLE)) {</span>
<span class="nc" id="L3128">                            fHits *= 1.3f;</span>
                        }
                    }
                }

                // Check for ATMs, which have built in Artemis
<span class="nc bnc" id="L3134" title="All 2 branches missed.">                if (wt.getAmmoType() == AmmoType.T_ATM) {</span>
<span class="nc" id="L3135">                    fHits *= 1.2f;</span>
                }

                // Check for target with attached Narc or iNarc homing pod from
                // friendly unit
<span class="nc bnc" id="L3140" title="All 2 branches missed.">                if (target.isNarcedBy(attacker.getOwner().getTeam())</span>
<span class="nc bnc" id="L3141" title="All 2 branches missed.">                        || target.isINarcedBy(attacker.getOwner().getTeam())) {</span>
<span class="nc bnc" id="L3142" title="All 2 branches missed.">                    if (((at.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L3143" title="All 2 branches missed.">                            || (at.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L3144" title="All 2 branches missed.">                            || (at.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L3145" title="All 2 branches missed.">                            || (at.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3146" title="All 2 branches missed.">                            || (at.getAmmoType() == AmmoType.T_SRM_IMP))</span>
<span class="nc bnc" id="L3147" title="All 2 branches missed.">                            &amp;&amp; (at.getMunitionType() == AmmoType.M_NARC_CAPABLE)) {</span>
<span class="nc" id="L3148">                        fHits *= 1.2f;</span>
                    }
                }
            }

<span class="nc bnc" id="L3153" title="All 2 branches missed.">            if (wt.getAmmoType() == AmmoType.T_MRM) {</span>
<span class="nc" id="L3154">                lnk_guide = weapon.getLinkedBy();</span>
<span class="nc bnc" id="L3155" title="All 2 branches missed.">                if ((lnk_guide != null)</span>
<span class="nc bnc" id="L3156" title="All 2 branches missed.">                    &amp;&amp; (lnk_guide.getType() instanceof MiscType)</span>
<span class="nc bnc" id="L3157" title="All 4 branches missed.">                    &amp;&amp; !lnk_guide.isDestroyed() &amp;&amp; !lnk_guide.isMissing()</span>
<span class="nc bnc" id="L3158" title="All 2 branches missed.">                    &amp;&amp; !lnk_guide.isBreached()</span>
<span class="nc bnc" id="L3159" title="All 2 branches missed.">                    &amp;&amp; lnk_guide.getType().hasFlag(MiscType.F_APOLLO)) {</span>
<span class="nc" id="L3160">                    fHits *= .9f;</span>
                }
            }

            // adjust for previous AMS
<span class="nc bnc" id="L3165" title="All 2 branches missed.">            if ((wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE)</span>
<span class="nc bnc" id="L3166" title="All 2 branches missed.">                &amp;&amp; wt.hasFlag(WeaponType.F_MISSILE)) {</span>
<span class="nc" id="L3167">                ArrayList&lt;Mounted&gt; vCounters = waa.getCounterEquipment();</span>
<span class="nc bnc" id="L3168" title="All 2 branches missed.">                if (vCounters != null) {</span>
<span class="nc bnc" id="L3169" title="All 2 branches missed.">                    for (int x = 0; x &lt; vCounters.size(); x++) {</span>
<span class="nc" id="L3170">                        EquipmentType type = vCounters.get(x).getType();</span>
<span class="nc bnc" id="L3171" title="All 2 branches missed.">                        if ((type instanceof WeaponType)</span>
<span class="nc bnc" id="L3172" title="All 2 branches missed.">                            &amp;&amp; type.hasFlag(WeaponType.F_AMS)) {</span>
<span class="nc" id="L3173">                            fHits *= 0.6;</span>
                        }
                    }
                }
            }

            // * HAGs modify their cluster hits for range.
<span class="nc bnc" id="L3180" title="All 2 branches missed.">            if (wt instanceof HAGWeapon) {</span>
<span class="nc" id="L3181">                int distance = attacker.getPosition().distance(</span>
<span class="nc" id="L3182">                        target.getPosition());</span>
<span class="nc bnc" id="L3183" title="All 2 branches missed.">                if (distance &lt;= wt.getShortRange()) {</span>
<span class="nc" id="L3184">                    fHits *= 1.2;</span>
<span class="nc bnc" id="L3185" title="All 2 branches missed.">                } else if (distance &gt; wt.getMediumRange()) {</span>
<span class="nc" id="L3186">                    fHits *= 0.8;</span>
                }
            }

<span class="nc" id="L3190">            fDamage *= fHits;</span>

<span class="nc bnc" id="L3192" title="All 2 branches missed.">            if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3193" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</span>
<span class="nc bnc" id="L3194" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</span>
<span class="nc" id="L3195">                fDamage = fHits * wt.getDamage();</span>
            }

<span class="nc" id="L3198">        } else {</span>
            // Direct fire weapons (and LBX slug rounds) just do a single shot
            // so they don't use the missile hits table. Weapon bays also deal
            // damage in a single block
<span class="nc bnc" id="L3202" title="All 2 branches missed.">            if ((attacker.getPosition() != null)</span>
<span class="nc bnc" id="L3203" title="All 2 branches missed.">                &amp;&amp; (target.getPosition() != null)) {</span>
                // Damage may vary by range for some weapons, so let's see how far
                // away we actually are and then set the damage accordingly.
<span class="nc" id="L3206">                int rangeToTarget = attacker.getPosition().distance(target.getPosition());</span>
                
                //Convert AV to fDamage for bay weapons, fighters, etc
<span class="nc bnc" id="L3209" title="All 2 branches missed.">                if (attacker.usesWeaponBays()){</span>
<span class="nc" id="L3210">                    double av = 0;</span>
<span class="nc" id="L3211">                    double threat = 1;</span>
<span class="nc bnc" id="L3212" title="All 2 branches missed.">                    for (int wId : weapon.getBayWeapons()) {</span>
<span class="nc" id="L3213">                        Mounted bayW = attacker.getEquipment(wId);</span>
<span class="nc" id="L3214">                        WeaponType bayWType = ((WeaponType) bayW.getType());</span>
                        //Capital weapons have a different range scale
<span class="nc bnc" id="L3216" title="All 2 branches missed.">                        if (wt.isCapital()) {</span>
                            // Capital missiles get higher priority than standard missiles:
                            // damage plus a bonus for the critical hit threat they represent
<span class="nc" id="L3219">                            threat = 12;</span>
<span class="nc bnc" id="L3220" title="All 2 branches missed.">                            if (rangeToTarget &gt; 50) {</span>
<span class="nc" id="L3221">                                av = 0;</span>
<span class="nc bnc" id="L3222" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 40) {</span>
<span class="nc" id="L3223">                                av += bayWType.getExtAV();</span>
<span class="nc bnc" id="L3224" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 25) {</span>
<span class="nc" id="L3225">                                av += bayWType.getLongAV();</span>
<span class="nc bnc" id="L3226" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 12) {</span>
<span class="nc" id="L3227">                                av += bayWType.getMedAV();</span>
                            } else {
<span class="nc" id="L3229">                                av += bayWType.getShortAV();</span>
                            }
                        } else {
<span class="nc bnc" id="L3232" title="All 2 branches missed.">                            if (rangeToTarget &gt; 25) {</span>
<span class="nc" id="L3233">                                av = 0;</span>
<span class="nc bnc" id="L3234" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 20) {</span>
<span class="nc" id="L3235">                                av += bayWType.getExtAV();</span>
<span class="nc bnc" id="L3236" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 12) {</span>
<span class="nc" id="L3237">                                av += bayWType.getLongAV();</span>
<span class="nc bnc" id="L3238" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 6) {</span>
<span class="nc" id="L3239">                                av += bayWType.getMedAV();</span>
                            } else {
<span class="nc" id="L3241">                                av += bayWType.getShortAV();</span>
                            }
                        }
<span class="nc" id="L3244">                        fDamage = (float) (av * threat);</span>
<span class="nc" id="L3245">                    }</span>
<span class="nc bnc" id="L3246" title="All 2 branches missed.">                } else if (attacker.isCapitalFighter()) {</span>
<span class="nc" id="L3247">                    double av = 0;</span>
<span class="nc" id="L3248">                    double threat = 1;</span>
                    //Capital weapons have a different range scale
<span class="nc bnc" id="L3250" title="All 2 branches missed.">                    if (wt.isCapital()) {</span>
                        // Capital missiles should have higher priority than standard missiles
<span class="nc" id="L3252">                        threat = 12;</span>
<span class="nc bnc" id="L3253" title="All 2 branches missed.">                        if (rangeToTarget &gt; 50) {</span>
<span class="nc" id="L3254">                            av = 0;</span>
<span class="nc bnc" id="L3255" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 40) {</span>
<span class="nc" id="L3256">                            av += (wt.getExtAV() * weapon.getNWeapons());</span>
<span class="nc bnc" id="L3257" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 25) {</span>
<span class="nc" id="L3258">                            av += (wt.getLongAV() * weapon.getNWeapons());</span>
<span class="nc bnc" id="L3259" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 12) {</span>
<span class="nc" id="L3260">                            av += (wt.getMedAV() * weapon.getNWeapons());</span>
                        } else {
<span class="nc" id="L3262">                            av += (wt.getShortAV() * weapon.getNWeapons());</span>
                        }
                    } else {
<span class="nc bnc" id="L3265" title="All 2 branches missed.">                        if (rangeToTarget &gt; 25) {</span>
<span class="nc" id="L3266">                            av = 0;</span>
<span class="nc bnc" id="L3267" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 20) {</span>
<span class="nc" id="L3268">                            av += (wt.getExtAV() * weapon.getNWeapons());</span>
<span class="nc bnc" id="L3269" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 12) {</span>
<span class="nc" id="L3270">                            av += (wt.getLongAV() * weapon.getNWeapons());</span>
<span class="nc bnc" id="L3271" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 6) {</span>
<span class="nc" id="L3272">                            av += (wt.getMedAV() * weapon.getNWeapons());</span>
                        } else {
<span class="nc" id="L3274">                            av += (wt.getShortAV() * weapon.getNWeapons());</span>
                        }
                    }
<span class="nc" id="L3277">                    fDamage = (float) (av * threat);</span>

<span class="nc bnc" id="L3279" title="All 2 branches missed.">                } else if ((wt.getAmmoType() == AmmoType.T_ARROW_IV)</span>
<span class="nc bnc" id="L3280" title="All 2 branches missed.">                        || wt.getAmmoType() == BombType.B_HOMING) {</span>
                    //This is for arrow IV AMS threat processing
<span class="nc" id="L3282">                    fDamage = (float) wt.getRackSize();</span>
                } else {
<span class="nc" id="L3284">                    fDamage = wt.getDamage(rangeToTarget);</span>
                }
            }

            // Infantry follow some special rules, but do fixed amounts of damage
            // Anti-mek attacks are weapon-like in nature, so include them here as well
<span class="nc bnc" id="L3290" title="All 2 branches missed.">            if (attacker instanceof Infantry) {</span>
<span class="nc bnc" id="L3291" title="All 2 branches missed.">                if (wt.getInternalName() == Infantry.LEG_ATTACK) {</span>
<span class="nc" id="L3292">                    fDamage = 20.0f; // Actually 5, but the chance of crits</span>
                    // deserves a boost
                // leg attacks are mutually exclusive with swarm attacks, 
                } else {                
<span class="nc bnc" id="L3296" title="All 4 branches missed.">                    boolean targetIsSwarmable = (target instanceof Mech) || (target instanceof Tank);</span>
    
<span class="nc bnc" id="L3298" title="All 2 branches missed.">                    if (attacker.isConventionalInfantry()) {</span>
<span class="nc bnc" id="L3299" title="All 2 branches missed.">                        if (wt.getInternalName() == Infantry.SWARM_MEK) {</span>
                            // If the target is a Mek that is not swarmed, this is a
                            // good thing
<span class="nc bnc" id="L3302" title="All 4 branches missed.">                            if ((target.getSwarmAttackerId() == Entity.NONE) &amp;&amp; targetIsSwarmable) {</span>
<span class="nc" id="L3303">                                fDamage = 1.5f</span>
                                        * (float) infDamagePerTrooper
                                        * infShootingStrength;
                            }
                            // Otherwise, call it 0 damage
                            else {
<span class="nc" id="L3309">                                fDamage = 0.0f;</span>
                            }
                        } else {
                            // conventional weapons; field guns should be handled
                            // under the standard weapons section
<span class="nc" id="L3314">                            fDamage = 0.6f</span>
                                    * (float) infDamagePerTrooper
                                    * infShootingStrength;
                        }
                    } else {
                        // Battle armor units conducting swarm attack
<span class="nc bnc" id="L3320" title="All 2 branches missed.">                        if (wt.getInternalName() == Infantry.SWARM_MEK) {</span>
                            // If the target is a Mek that is not swarmed, this is a
                            // good thing
<span class="nc bnc" id="L3323" title="All 4 branches missed.">                            if ((target.getSwarmAttackerId() == Entity.NONE) &amp;&amp; targetIsSwarmable) {</span>
                                // Overestimated, but the chance at crits and head
                                // shots deserves a boost
<span class="nc" id="L3326">                                fDamage = 10.0f * baShootingStrength;</span>
                            }
                            // Otherwise, call it 0 damage
                            else {
<span class="nc" id="L3330">                                fDamage = 0.0f;</span>
                            }
                        }
                    }
                }
            }

        }

        // Need to adjust damage if the target is infantry.
<span class="nc bnc" id="L3340" title="All 2 branches missed.">        if (g.getEntity(waa.getTargetId()).isConventionalInfantry()) {</span>
<span class="nc" id="L3341">            fDamage = directBlowInfantryDamage(fDamage, 0,</span>
<span class="nc" id="L3342">                    wt.getInfantryDamageClass(), ((Infantry) (g.getEntity(waa</span>
<span class="nc" id="L3343">                            .getTargetId()))).isMechanized(), false);</span>
        }

<span class="nc" id="L3346">        fDamage *= fChance;</span>

        // Conventional infantry take double damage in the open
<span class="nc bnc" id="L3349" title="All 2 branches missed.">        if (g.getEntity(waa.getTargetId()).isConventionalInfantry()) {</span>
<span class="nc" id="L3350">            IHex e_hex = g.getBoard().getHex(</span>
<span class="nc" id="L3351">                    g.getEntity(waa.getTargetId()).getPosition().getX(),</span>
<span class="nc" id="L3352">                    g.getEntity(waa.getTargetId()).getPosition().getY());</span>
<span class="nc bnc" id="L3353" title="All 2 branches missed.">            if (!e_hex.containsTerrain(Terrains.WOODS)</span>
<span class="nc bnc" id="L3354" title="All 2 branches missed.">                &amp;&amp; !e_hex.containsTerrain(Terrains.JUNGLE)</span>
<span class="nc bnc" id="L3355" title="All 2 branches missed.">                &amp;&amp; !e_hex.containsTerrain(Terrains.BUILDING)) {</span>
<span class="nc" id="L3356">                fDamage *= 2.0f;</span>
            }

            // Cap damage to prevent run-away values
<span class="nc bnc" id="L3360" title="All 2 branches missed.">            if (infShootingStrength &gt; 0) {</span>
<span class="nc" id="L3361">                fDamage = Math.min(infShootingStrength, fDamage);</span>
            }
        }
<span class="nc" id="L3364">        return fDamage;</span>
    }

    /**
     * If the unit is carrying multiple types of ammo for the specified weapon,
     * cycle through them and choose the type best suited to engage the
     * specified target Value returned is expected damage Note that some ammo
     * types, such as infernos, do no damage or have special properties and so
     * the damage is an estimation of effectiveness
     */

    public static double getAmmoAdjDamage(IGame cgame, WeaponAttackAction atk) {
<span class="nc" id="L3376">        boolean no_bin = true;</span>
<span class="nc" id="L3377">        boolean multi_bin = false;</span>

        double ammo_multiple, ex_damage, max_damage;

        Entity shooter, target;

        Mounted fabin, best_bin;
<span class="nc" id="L3384">        AmmoType abin_type = new AmmoType();</span>
<span class="nc" id="L3385">        AmmoType fabin_type = new AmmoType();</span>
<span class="nc" id="L3386">        WeaponType wtype = new WeaponType();</span>
<span class="nc" id="L3387">        WeaponType target_weapon = new WeaponType();</span>

        // Get shooter entity, target entity, and weapon being fired
<span class="nc" id="L3390">        target = cgame.getEntity(atk.getTargetId());</span>
<span class="nc" id="L3391">        shooter = atk.getEntity(cgame);</span>
<span class="nc" id="L3392">        wtype = (WeaponType) shooter.getEquipment(atk.getWeaponId()).getType();</span>

<span class="nc" id="L3394">        max_damage = 0.0;</span>

        // If the weapon doesn't require ammo, just get the estimated damage
<span class="nc bnc" id="L3397" title="All 2 branches missed.">        if (wtype.hasFlag(WeaponType.F_ENERGY)</span>
<span class="nc bnc" id="L3398" title="All 2 branches missed.">            || wtype.hasFlag(WeaponType.F_ONESHOT)</span>
<span class="nc bnc" id="L3399" title="All 2 branches missed.">            || wtype.hasFlag(WeaponType.F_INFANTRY)</span>
<span class="nc bnc" id="L3400" title="All 2 branches missed.">            || (wtype.getAmmoType() == AmmoType.T_NA)) {</span>
<span class="nc" id="L3401">            return Compute.getExpectedDamage(cgame, atk, false);</span>
        }

        // Get a list of ammo bins and the first valid bin
<span class="nc" id="L3405">        fabin = null;</span>
<span class="nc" id="L3406">        best_bin = null;</span>

<span class="nc bnc" id="L3408" title="All 2 branches missed.">        for (Mounted abin : shooter.getAmmo()) {</span>
<span class="nc bnc" id="L3409" title="All 2 branches missed.">            if (shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</span>
                                   abin)) {
<span class="nc bnc" id="L3411" title="All 2 branches missed.">                if (abin.getUsableShotsLeft() &gt; 0) {</span>
<span class="nc" id="L3412">                    abin_type = (AmmoType) abin.getType();</span>
<span class="nc bnc" id="L3413" title="All 2 branches missed.">                    if (!AmmoType.canDeliverMinefield(abin_type)) {</span>
<span class="nc" id="L3414">                        fabin = abin;</span>
<span class="nc" id="L3415">                        fabin_type = (AmmoType) fabin.getType();</span>
<span class="nc" id="L3416">                        break;</span>
                    }
                }
            }
<span class="nc" id="L3420">        }</span>

        // To save processing time, lets see if we have more than one type of
        // bin
        // Thunder-type ammos and empty bins are excluded from the list
<span class="nc bnc" id="L3425" title="All 2 branches missed.">        for (Mounted abin : shooter.getAmmo()) {</span>
<span class="nc bnc" id="L3426" title="All 2 branches missed.">            if (shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</span>
                                   abin)) {
<span class="nc bnc" id="L3428" title="All 2 branches missed.">                if (abin.getUsableShotsLeft() &gt; 0) {</span>
<span class="nc" id="L3429">                    abin_type = (AmmoType) abin.getType();</span>
<span class="nc bnc" id="L3430" title="All 2 branches missed.">                    if (!AmmoType.canDeliverMinefield(abin_type)) {</span>
<span class="nc" id="L3431">                        no_bin = false;</span>
<span class="nc" id="L3432">                        if (abin_type.getMunitionType() != fabin_type</span>
<span class="nc bnc" id="L3433" title="All 2 branches missed.">                                .getMunitionType()) {</span>
<span class="nc" id="L3434">                            multi_bin = true;</span>
<span class="nc" id="L3435">                            break;</span>
                        }
                    }
                }
            }
<span class="nc" id="L3440">        }</span>

        // If no_bin is true, then either all bins are empty or contain
        // Thunder-type rounds and
        // we can safely say that the expected damage is 0.0
        // If no_bin is false, then we have at least one good bin
<span class="nc bnc" id="L3446" title="All 2 branches missed.">        if (no_bin) {</span>
<span class="nc" id="L3447">            return 0.0;</span>
        }
        // If multi_bin is true, then multiple ammo types are present and an
        // appropriate type must be selected
        // If multi_bin is false, then all bin types are the same; skip down
        // to getting the expected damage
<span class="nc bnc" id="L3453" title="All 2 branches missed.">        if (!multi_bin) {</span>
<span class="nc" id="L3454">            return Compute.getExpectedDamage(cgame, atk, false);</span>
        }
<span class="nc bnc" id="L3456" title="All 2 branches missed.">        if (multi_bin) {</span>

            // Set default max damage as 0, and the best bin as the first
            // bin
<span class="nc" id="L3460">            max_damage = 0.0;</span>
<span class="nc" id="L3461">            best_bin = fabin;</span>

            // For each valid ammo bin
<span class="nc bnc" id="L3464" title="All 2 branches missed.">            for (Mounted abin : shooter.getAmmo()) {</span>
<span class="nc bnc" id="L3465" title="All 2 branches missed.">                if (shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</span>
                                       abin)) {
<span class="nc bnc" id="L3467" title="All 2 branches missed.">                    if (abin.getUsableShotsLeft() &gt; 0) {</span>
<span class="nc" id="L3468">                        abin_type = (AmmoType) abin.getType();</span>
<span class="nc bnc" id="L3469" title="All 2 branches missed.">                        if (!AmmoType.canDeliverMinefield(abin_type)) {</span>

                            // Load weapon with specified bin
<span class="nc" id="L3472">                            shooter.loadWeapon(</span>
<span class="nc" id="L3473">                                    shooter.getEquipment(atk.getWeaponId()),</span>
                                    abin);
<span class="nc" id="L3475">                            atk.setAmmoId(shooter.getEquipmentNum(abin));</span>

                            // Get expected damage
<span class="nc" id="L3478">                            ex_damage = Compute.getExpectedDamage(cgame, atk,</span>
                                                                  false);

                            // Calculate any modifiers due to ammo type
<span class="nc" id="L3482">                            ammo_multiple = 1.0;</span>

                            // Frag missiles, flechette AC rounds do double
                            // damage against conventional infantry
                            // and 0 damage against everything else
                            // Any further anti-personnel specialized rounds
                            // should be tested for here
<span class="nc bnc" id="L3489" title="All 2 branches missed.">                            if (((((abin_type.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L3490" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L3491" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L3492" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3493" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_SRM_IMP)))</span>
<span class="nc bnc" id="L3494" title="All 2 branches missed.">                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_FRAGMENTATION))</span>
<span class="nc bnc" id="L3495" title="All 2 branches missed.">                                    || (((abin_type.getAmmoType() == AmmoType.T_AC)</span>
<span class="nc bnc" id="L3496" title="All 2 branches missed.">                                            || (abin_type.getAmmoType() == AmmoType.T_LAC)</span>
<span class="nc bnc" id="L3497" title="All 2 branches missed.">                                            || (abin_type.getAmmoType() == AmmoType.T_AC_IMP)</span>
<span class="nc bnc" id="L3498" title="All 2 branches missed.">                                            || (abin_type.getAmmoType() == AmmoType.T_PAC))</span>
<span class="nc bnc" id="L3499" title="All 2 branches missed.">                                            &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_FLECHETTE))) {</span>
<span class="nc" id="L3500">                                ammo_multiple = 0.0;</span>
<span class="nc bnc" id="L3501" title="All 2 branches missed.">                                if (target instanceof Infantry) {</span>
<span class="nc bnc" id="L3502" title="All 2 branches missed.">                                    if (!(target instanceof BattleArmor)) {</span>
<span class="nc" id="L3503">                                        ammo_multiple = 2.0;</span>
                                    }
                                }
                            }

                            // LBX cluster rounds work better against units
                            // with little armor, vehicles, and Meks in
                            // partial cover
                            // Other ammo that deliver lots of small
                            // submunitions should be tested for here too
<span class="nc bnc" id="L3513" title="All 2 branches missed.">                            if (((abin_type.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L3514" title="All 2 branches missed.">                                 || (abin_type.getAmmoType() == AmmoType.T_AC_LBX_THB) || (abin_type</span>
<span class="nc bnc" id="L3515" title="All 2 branches missed.">                                                                                                   .getAmmoType() ==</span>
                                                                                           AmmoType.T_SBGAUSS))
<span class="nc bnc" id="L3517" title="All 2 branches missed.">                                &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_CLUSTER)) {</span>
<span class="nc bnc" id="L3518" title="All 2 branches missed.">                                if (target.getArmorRemainingPercent() &lt;= 0.25) {</span>
<span class="nc" id="L3519">                                    ammo_multiple = 1.0 + (wtype.getRackSize() / 10);</span>
                                }
<span class="nc bnc" id="L3521" title="All 2 branches missed.">                                if (target instanceof Tank) {</span>
<span class="nc" id="L3522">                                    ammo_multiple += 1.0;</span>
                                }
                            }

                            // AP autocannon rounds work much better against
                            // Meks and vehicles than infantry,
                            // give a damage boost in proportion to calibre
                            // to reflect scaled crit chance
                            // Other armor-penetrating ammo types should be
                            // tested here, such as Tandem-charge SRMs
<span class="nc bnc" id="L3532" title="All 2 branches missed.">                            if (((abin_type.getAmmoType() == AmmoType.T_AC)</span>
<span class="nc bnc" id="L3533" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_LAC)</span>
<span class="nc bnc" id="L3534" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_AC_IMP)</span>
<span class="nc bnc" id="L3535" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_PAC))</span>
<span class="nc bnc" id="L3536" title="All 2 branches missed.">                                &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_ARMOR_PIERCING)) {</span>
<span class="nc bnc" id="L3537" title="All 4 branches missed.">                                if ((target instanceof Mech)</span>
                                    || (target instanceof Tank)) {
<span class="nc" id="L3539">                                    ammo_multiple = 1.0 + (wtype.getRackSize() / 10);</span>
                                }
<span class="nc bnc" id="L3541" title="All 2 branches missed.">                                if (target instanceof Infantry) {</span>
<span class="nc" id="L3542">                                    ammo_multiple = 0.6;</span>
                                }
                            }

                            // Inferno SRMs work better against overheating
                            // Meks that are not/almost not on fire,
                            // and against vehicles and protos if allowed by
                            // game option
<span class="nc bnc" id="L3550" title="All 2 branches missed.">                            if (((abin_type.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3551" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_SRM_IMP)</span>
<span class="nc bnc" id="L3552" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_MML))</span>
<span class="nc bnc" id="L3553" title="All 2 branches missed.">                                &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_INFERNO)) {</span>
<span class="nc" id="L3554">                                ammo_multiple = 0.5;</span>
<span class="nc bnc" id="L3555" title="All 2 branches missed.">                                if (target instanceof Mech) {</span>
<span class="nc bnc" id="L3556" title="All 4 branches missed.">                                    if ((target.infernos.getTurnsLeftToBurn() &lt; 4)</span>
                                        &amp;&amp; (target.heat &gt;= 5)) {
<span class="nc" id="L3558">                                        ammo_multiple = 1.1;</span>
                                    }
                                }
<span class="nc bnc" id="L3561" title="All 2 branches missed.">                                if ((target instanceof Tank)</span>
<span class="nc" id="L3562">                                    &amp;&amp; !(cgame.getOptions()</span>
<span class="nc bnc" id="L3563" title="All 2 branches missed.">                                              .booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_SAFE_FROM_INFERNOS))) {</span>
<span class="nc" id="L3564">                                    ammo_multiple = 1.1;</span>
                                }
<span class="nc bnc" id="L3566" title="All 2 branches missed.">                                if ((target instanceof Protomech)</span>
<span class="nc" id="L3567">                                    &amp;&amp; !(cgame.getOptions()</span>
<span class="nc bnc" id="L3568" title="All 2 branches missed.">                                              .booleanOption(OptionsConstants.ADVCOMBAT_PROTOS_SAFE_FROM_INFERNOS))) {</span>
<span class="nc" id="L3569">                                    ammo_multiple = 1.1;</span>
                                }
                            }

                            // Narc beacon doesn't really do damage but if
                            // the target is not infantry and doesn't have
                            // one, give 'em one by making it an attractive
                            // option
<span class="nc bnc" id="L3577" title="All 2 branches missed.">                            if ((wtype.getAmmoType() == AmmoType.T_NARC)</span>
<span class="nc bnc" id="L3578" title="All 2 branches missed.">                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_STANDARD)) {</span>
<span class="nc bnc" id="L3579" title="All 4 branches missed.">                                if (!(target.isNarcedBy(shooter.getOwner().getTeam()))</span>
                                        &amp;&amp; !(target instanceof Infantry)) {
<span class="nc" id="L3581">                                    ex_damage = 5.0;</span>
                                } else {
<span class="nc" id="L3583">                                    ex_damage = 0.5;</span>
                                }
                            }

                            // iNarc beacon doesn't really do damage, but if
                            // the target is not infantry and doesn't have
                            // one, give 'em one by making it an attractive
                            // option
<span class="nc bnc" id="L3591" title="All 2 branches missed.">                            if (wtype.getAmmoType() == AmmoType.T_INARC) {</span>
<span class="nc bnc" id="L3592" title="All 4 branches missed.">                                if ((abin_type.getMunitionType() == AmmoType.M_STANDARD)</span>
                                        &amp;&amp; !(target instanceof Infantry)) {
<span class="nc bnc" id="L3594" title="All 2 branches missed.">                                    if (!(target.isINarcedBy(shooter.getOwner().getTeam()))) {</span>
<span class="nc" id="L3595">                                        ex_damage = 7.0;</span>
                                    } else {
<span class="nc" id="L3597">                                        ex_damage = 1.0;</span>
                                    }
                                }

                                // iNarc ECM doesn't really do damage, but
                                // if the target has a C3 link or missile
                                // launchers
                                // make it a priority
                                // Checking for actual ammo types carried
                                // would be nice, but can't be sure of exact
                                // loads
                                // when &quot;true&quot; double blind is implemented
<span class="nc bnc" id="L3609" title="All 2 branches missed.">                                if ((abin_type.getAmmoType() == AmmoType.T_INARC)</span>
<span class="nc bnc" id="L3610" title="All 4 branches missed.">                                        &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_ECM)</span>
                                        &amp;&amp; !(target instanceof Infantry)) {
<span class="nc bnc" id="L3612" title="All 2 branches missed.">                                    if (!target.isINarcedWith(AmmoType.M_ECM)) {</span>
<span class="nc bnc" id="L3613" title="All 2 branches missed.">                                        if (!(target.getC3MasterId() == Entity.NONE)</span>
<span class="nc bnc" id="L3614" title="All 2 branches missed.">                                                || target.hasC3M()</span>
<span class="nc bnc" id="L3615" title="All 2 branches missed.">                                                || target.hasC3MM()</span>
<span class="nc bnc" id="L3616" title="All 2 branches missed.">                                                || target.hasC3i()) {</span>
<span class="nc" id="L3617">                                            ex_damage = 8.0;</span>
                                        } else {
<span class="nc" id="L3619">                                            ex_damage = 0.5;</span>
                                        }
<span class="nc bnc" id="L3621" title="All 2 branches missed.">                                        for (Mounted weapon : shooter.getWeaponList()) {</span>
<span class="nc" id="L3622">                                            target_weapon = (WeaponType) weapon.getType();</span>
<span class="nc bnc" id="L3623" title="All 2 branches missed.">                                            if ((target_weapon.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L3624" title="All 2 branches missed.">                                                    || (target_weapon.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L3625" title="All 2 branches missed.">                                                    || (target_weapon.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L3626" title="All 2 branches missed.">                                                    || (target_weapon.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3627" title="All 2 branches missed.">                                                    || (target_weapon.getAmmoType() == AmmoType.T_SRM_IMP)) {</span>
<span class="nc" id="L3628">                                                ex_damage = ex_damage + (target_weapon.getRackSize() / 2);</span>
                                            }
<span class="nc" id="L3630">                                        }</span>
                                    }
                                }

                                // iNarc Nemesis doesn't really do damage,
                                // but if the target is not infantry and
                                // doesn't have
                                // one give it a try; make fast units a
                                // priority because they are usually out
                                // front
<span class="nc bnc" id="L3640" title="All 2 branches missed.">                                if ((abin_type.getAmmoType() == AmmoType.T_INARC)</span>
<span class="nc bnc" id="L3641" title="All 4 branches missed.">                                        &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_NEMESIS)</span>
                                        &amp;&amp; !(target instanceof Infantry)) {
<span class="nc bnc" id="L3643" title="All 2 branches missed.">                                    if (!target.isINarcedWith(AmmoType.M_NEMESIS)) {</span>
<span class="nc" id="L3644">                                        ex_damage = (double) (target.getWalkMP() + target.getJumpMP()) / 2;</span>
                                    } else {
<span class="nc" id="L3646">                                        ex_damage = 0.5;</span>
                                    }
                                }
                            }

                            // If the adjusted damage is highest, store the
                            // damage and bin
<span class="nc bnc" id="L3653" title="All 2 branches missed.">                            if ((ex_damage * ammo_multiple) &gt; max_damage) {</span>
<span class="nc" id="L3654">                                max_damage = ex_damage * ammo_multiple;</span>
<span class="nc" id="L3655">                                best_bin = abin;</span>
                            }
                        }
                    }
                }
<span class="nc" id="L3660">            }</span>

            // Now that the best bin has been found, reload the weapon with
            // it
<span class="nc" id="L3664">            shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</span>
                               best_bin);
<span class="nc" id="L3666">            atk.setAmmoId(shooter.getEquipmentNum(best_bin));</span>
        }
<span class="nc" id="L3668">        return max_damage;</span>
    }

    /**
     * If this is an ultra or rotary cannon, lets see about 'spinning it up' for
     * extra damage
     *
     * @return the &lt;code&gt;int&lt;/code&gt; ID of weapon mode
     */
    public static int spinUpCannon(IGame cgame, WeaponAttackAction atk) {
<span class="nc" id="L3678">        return spinUpCannon(cgame, atk, Compute.d6(2) - 1);</span>
    }
    
    /**
     * If this is an ultra or rotary cannon, lets see about 'spinning it up' for
     * extra damage
     *
     * @return the &lt;code&gt;int&lt;/code&gt; ID of weapon mode
     */

    public static int spinUpCannon(IGame cgame, WeaponAttackAction atk, int spinupThreshold) {

<span class="nc" id="L3690">        int threshold = 12;</span>
        int final_spin;
        Entity shooter;
        Mounted weapon;
<span class="nc" id="L3694">        WeaponType wtype = new WeaponType();</span>

        // Double check this is an Ultra or Rotary cannon
        // or a standard AC with the TacOps rapid fire rule turned on
<span class="nc" id="L3698">        shooter = atk.getEntity(cgame);</span>
<span class="nc" id="L3699">        weapon = shooter.getEquipment(atk.getWeaponId());</span>
<span class="nc" id="L3700">        wtype = (WeaponType) shooter.getEquipment(atk.getWeaponId()).getType();</span>
        
<span class="nc bnc" id="L3702" title="All 4 branches missed.">        boolean rapidAC = (wtype.getAmmoType() == AmmoType.T_AC) &amp;&amp; cgame.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RAPID_AC);</span>

<span class="nc bnc" id="L3704" title="All 2 branches missed.">        if (!((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3705" title="All 2 branches missed.">              || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB) </span>
<span class="nc bnc" id="L3706" title="All 4 branches missed.">              || (wtype.getAmmoType() == AmmoType.T_AC_ROTARY)</span>
              || rapidAC)) {
<span class="nc" id="L3708">            return 0;</span>
        }

        // Get the to-hit number
<span class="nc" id="L3712">        threshold = atk.toHit(cgame).getValue();</span>

        // Set the weapon to single shot mode
<span class="nc bnc" id="L3715" title="All 2 branches missed.">        weapon.setMode(rapidAC ? &quot;&quot; : Weapon.MODE_AC_SINGLE);</span>
<span class="nc" id="L3716">        final_spin = 0;</span>

        // If weapon can't hit target, exit the function with the weapon on
        // single shot
<span class="nc bnc" id="L3720" title="All 4 branches missed.">        if ((threshold == TargetRoll.IMPOSSIBLE)</span>
            || (threshold == TargetRoll.AUTOMATIC_FAIL)) {
<span class="nc" id="L3722">            return final_spin;</span>
        }

        // If random roll is &gt;= to-hit + 1, then set double-spin
<span class="nc bnc" id="L3726" title="All 2 branches missed.">        if (spinupThreshold &gt;= threshold) {</span>
<span class="nc" id="L3727">            final_spin = 1;</span>
<span class="nc bnc" id="L3728" title="All 2 branches missed.">            if ((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3729" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB)) {</span>
<span class="nc" id="L3730">                weapon.setMode(Weapon.MODE_UAC_ULTRA);</span>
<span class="nc bnc" id="L3731" title="All 2 branches missed.">            } else if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {</span>
<span class="nc" id="L3732">                weapon.setMode(Weapon.MODE_RAC_TWO_SHOT);</span>
<span class="nc bnc" id="L3733" title="All 2 branches missed.">            } else if (rapidAC) {</span>
<span class="nc" id="L3734">                weapon.setMode(Weapon.MODE_AC_RAPID);</span>
            }
        }

        // If this is a Rotary cannon
<span class="nc bnc" id="L3739" title="All 2 branches missed.">        if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {</span>

            // If random roll is &gt;= to-hit + 2 then set to quad-spin
<span class="nc bnc" id="L3742" title="All 2 branches missed.">            if (spinupThreshold &gt;= (threshold + 1)) {</span>
<span class="nc" id="L3743">                final_spin = 2;</span>
<span class="nc" id="L3744">                weapon.setMode(Weapon.MODE_RAC_FOUR_SHOT);</span>
            }

            // If random roll is &gt;= to-hit + 3 then set to six-spin
<span class="nc bnc" id="L3748" title="All 2 branches missed.">            if (spinupThreshold &gt;= (threshold + 2)) {</span>
<span class="nc" id="L3749">                final_spin = 3;</span>
<span class="nc" id="L3750">                weapon.setMode(Weapon.MODE_RAC_SIX_SHOT);</span>
            }
        }
<span class="nc" id="L3753">        return final_spin;</span>
    }

    /**
     * Checks to see if a target is in arc of the specified weapon, on the
     * specified entity
     */
    public static boolean isInArc(IGame game, int attackerId, int weaponId,
            Targetable t) {
<span class="nc" id="L3762">        Entity ae = game.getEntity(attackerId);</span>
<span class="nc bnc" id="L3763" title="All 2 branches missed.">        if ((ae instanceof Mech)</span>
<span class="nc bnc" id="L3764" title="All 2 branches missed.">            &amp;&amp; (((Mech) ae).getGrappled() == t.getTargetId())) {</span>
<span class="nc" id="L3765">            return true;</span>
        }
<span class="nc bnc" id="L3767" title="All 2 branches missed.">        int facing = ae.isSecondaryArcWeapon(weaponId) ? ae</span>
<span class="nc" id="L3768">                .getSecondaryFacing() : ae.getFacing();</span>
<span class="nc bnc" id="L3769" title="All 2 branches missed.">        if ((ae instanceof Tank)</span>
<span class="nc" id="L3770">            &amp;&amp; (ae.getEquipment(weaponId).getLocation() == ((Tank) ae)</span>
<span class="nc bnc" id="L3771" title="All 2 branches missed.">                .getLocTurret2())) {</span>
<span class="nc" id="L3772">            facing = ((Tank) ae).getDualTurretFacing();</span>
        }
<span class="nc bnc" id="L3774" title="All 2 branches missed.">        if (ae.getEquipment(weaponId).isMechTurretMounted()) {</span>
<span class="nc" id="L3775">            facing = ae.getSecondaryFacing()</span>
<span class="nc" id="L3776">                     + (ae.getEquipment(weaponId).getFacing() % 6);</span>
        }
<span class="nc" id="L3778">        Coords aPos = ae.getPosition();</span>
<span class="nc" id="L3779">        Vector&lt;Coords&gt; tPosV = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L3780">        Coords tPos = t.getPosition();</span>
        // aeros in the same hex in space may still be able to fire at one
        // another. First I need to translate
        // their positions to see who was further back
<span class="nc bnc" id="L3784" title="All 2 branches missed.">        if (game.getBoard().inSpace()</span>
<span class="nc bnc" id="L3785" title="All 2 branches missed.">            &amp;&amp; ae.getPosition().equals(t.getPosition())</span>
<span class="nc bnc" id="L3786" title="All 4 branches missed.">            &amp;&amp; ae.isAero() &amp;&amp; t.isAero()) {</span>
<span class="nc" id="L3787">            int moveSort = shouldMoveBackHex(ae, (Entity)t);</span>
<span class="nc bnc" id="L3788" title="All 2 branches missed.">            if (moveSort &lt; 0) {</span>
<span class="nc" id="L3789">                aPos = ae.getPriorPosition();</span>
            }
<span class="nc bnc" id="L3791" title="All 2 branches missed.">            if (moveSort &gt; 0) {</span>
<span class="nc" id="L3792">                tPos = ((Entity) t).getPriorPosition();</span>
            }
        }

        // if using advanced AA options, then ground-to-air fire determines arc
        // by closest position
<span class="nc bnc" id="L3798" title="All 4 branches missed.">        if (isGroundToAir(ae, t) &amp;&amp; (t instanceof Entity)) {</span>
<span class="nc" id="L3799">            tPos = getClosestFlightPath(ae.getId(), ae.getPosition(),</span>
                    (Entity) t);
        }

        // AMS defending against Ground to Air fire needs to calculate arc based on the closest flight path
        // Technically it's an AirToGround attack since the AMS is on the aircraft
<span class="nc bnc" id="L3805" title="All 4 branches missed.">        if (isAirToGround(ae, t) &amp;&amp; (t instanceof Entity)</span>
<span class="nc bnc" id="L3806" title="All 2 branches missed.">                &amp;&amp; (ae.getEquipment(weaponId).getType().hasFlag(WeaponType.F_AMS)</span>
<span class="nc bnc" id="L3807" title="All 2 branches missed.">                        || ae.getEquipment(weaponId).getType().hasFlag(WeaponType.F_AMSBAY))) {</span>
<span class="nc" id="L3808">            Entity te = (Entity) t;</span>
<span class="nc" id="L3809">            aPos = getClosestFlightPath(te.getId(), te.getPosition(),</span>
                    ae);
        }

<span class="nc" id="L3813">        tPosV.add(tPos);</span>
        // check for secondary positions
<span class="nc bnc" id="L3815" title="All 2 branches missed.">        if ((t instanceof Entity)</span>
<span class="nc bnc" id="L3816" title="All 2 branches missed.">            &amp;&amp; (null != ((Entity) t).getSecondaryPositions())) {</span>
<span class="nc bnc" id="L3817" title="All 2 branches missed.">            for (int key : ((Entity) t).getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3818">                tPosV.add(((Entity) t).getSecondaryPositions().get(key));</span>
<span class="nc" id="L3819">            }</span>
        }
<span class="nc" id="L3821">        return Compute.isInArc(aPos, facing, tPosV, ae.getWeaponArc(weaponId));</span>
    }

    /**
     * Returns true if the line between source Coords and target goes through
     * the hex in front of the attacker
     */
    public static boolean isThroughFrontHex(IGame game, Coords src, Entity t) {
<span class="nc" id="L3829">        Coords dest = t.getPosition();</span>
<span class="nc" id="L3830">        int fa = dest.degree(src) - (t.getFacing() * 60);</span>
<span class="nc bnc" id="L3831" title="All 2 branches missed.">        if (fa &lt; 0) {</span>
<span class="nc" id="L3832">            fa += 360;</span>
        }
<span class="nc bnc" id="L3834" title="All 4 branches missed.">        return (fa &gt; 330) || (fa &lt; 30);</span>
    }
    
    /**
     * Converts the facing of a vehicular grenade launcher to the corresponding firing arc.
     * 
     * @param facing The VGL facing returned by {@link Mounted#getFacing()}
     * @return       The firing arc
     */
    public static int firingArcFromVGLFacing(int facing) {
<span class="nc" id="L3844">        return VGL_FIRING_ARCS[facing % 6];</span>
    }

    public static boolean isInArc(Coords src, int facing, Targetable target,
                                  int arc) {

<span class="nc" id="L3850">        Vector&lt;Coords&gt; tPosV = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L3851">        tPosV.add(target.getPosition());</span>
        // check for secondary positions
<span class="nc bnc" id="L3853" title="All 2 branches missed.">        if ((target instanceof Entity)</span>
<span class="nc bnc" id="L3854" title="All 2 branches missed.">            &amp;&amp; (null != ((Entity) target).getSecondaryPositions())) {</span>
<span class="nc bnc" id="L3855" title="All 2 branches missed.">            for (int key : ((Entity) target).getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3856">                tPosV.add(((Entity) target).getSecondaryPositions().get(key));</span>
<span class="nc" id="L3857">            }</span>
        }

<span class="nc" id="L3860">        return isInArc(src, facing, tPosV, arc);</span>
    }

    public static boolean isInArc(Coords src, int facing, Coords dest, int arc) {
<span class="nc" id="L3864">        Vector&lt;Coords&gt; destV = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L3865">        destV.add(dest);</span>
<span class="nc" id="L3866">        return isInArc(src, facing, destV, arc);</span>
    }

    /**
     * Returns true if the target is in the specified arc. Note: This has to
     * take vectors of coordinates to account for potential secondary positions
     *
     * @param src    the attack coordinates
     * @param facing the appropriate attacker sfacing
     * @param destV  A vector of target coordinates
     * @param arc    the arc
     */
    public static boolean isInArc(Coords src, int facing, Vector&lt;Coords&gt; destV,
                                  int arc) {
<span class="nc bnc" id="L3880" title="All 4 branches missed.">        if ((src == null) || (destV == null)) {</span>
<span class="nc" id="L3881">            return true;</span>
        }

        // Jay: I have to adjust this to take in vectors of coordinates to
        // account for secondary positions of the
        // target - I am fairly certain that secondary positions of the attacker
        // shouldn't matter because you don't get
        // to move the angle based on the secondary positions

        // if any of the destination coords are in the right place, then return
        // true
<span class="nc bnc" id="L3892" title="All 2 branches missed.">        for (Coords dest : destV) {</span>
            // calculate firing angle
<span class="nc" id="L3894">            int fa = src.degree(dest) - (facing * 60);</span>
<span class="nc bnc" id="L3895" title="All 2 branches missed.">            if (fa &lt; 0) {</span>
<span class="nc" id="L3896">                fa += 360;</span>
            }
            // is it in the specifed arc?
<span class="nc bnc" id="L3899" title="All 49 branches missed.">            switch (arc) {</span>
                case ARC_FORWARD:
<span class="nc bnc" id="L3901" title="All 4 branches missed.">                    if ((fa &gt;= 300) || (fa &lt;= 60)) {</span>
<span class="nc" id="L3902">                        return true;</span>
                    }
                    break;
                case Compute.ARC_RIGHTARM:
<span class="nc bnc" id="L3906" title="All 4 branches missed.">                    if ((fa &gt;= 300) || (fa &lt;= 120)) {</span>
<span class="nc" id="L3907">                        return true;</span>
                    }
                    break;
                case Compute.ARC_LEFTARM:
<span class="nc bnc" id="L3911" title="All 4 branches missed.">                    if ((fa &gt;= 240) || (fa &lt;= 60)) {</span>
<span class="nc" id="L3912">                        return true;</span>
                    }
                    break;
                case ARC_REAR:
<span class="nc bnc" id="L3916" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L3917">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDE:
<span class="nc bnc" id="L3921" title="All 4 branches missed.">                    if ((fa &gt; 60) &amp;&amp; (fa &lt;= 120)) {</span>
<span class="nc" id="L3922">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDE:
<span class="nc bnc" id="L3926" title="All 4 branches missed.">                    if ((fa &lt; 300) &amp;&amp; (fa &gt;= 240)) {</span>
<span class="nc" id="L3927">                        return true;</span>
                    }
                    break;
                case ARC_MAINGUN:
<span class="nc bnc" id="L3931" title="All 4 branches missed.">                    if ((fa &gt;= 240) || (fa &lt;= 120)) {</span>
<span class="nc" id="L3932">                        return true;</span>
                    }
                    break;
                case ARC_360:
<span class="nc" id="L3936">                    return true;</span>
                case ARC_NORTH:
<span class="nc bnc" id="L3938" title="All 4 branches missed.">                    if ((fa &gt;= 270) || (fa &lt;= 30)) {</span>
<span class="nc" id="L3939">                        return true;</span>
                    }
                    break;
                case ARC_EAST:
<span class="nc bnc" id="L3943" title="All 4 branches missed.">                    if ((fa &gt;= 30) &amp;&amp; (fa &lt;= 150)) {</span>
<span class="nc" id="L3944">                        return true;</span>
                    }
                    break;
                case ARC_WEST:
<span class="nc bnc" id="L3948" title="All 4 branches missed.">                    if ((fa &gt;= 150) &amp;&amp; (fa &lt;= 270)) {</span>
<span class="nc" id="L3949">                        return true;</span>
                    }
                    break;
                case ARC_NOSE:
<span class="nc bnc" id="L3953" title="All 4 branches missed.">                    if ((fa &gt; 300) || (fa &lt; 60)) {</span>
<span class="nc" id="L3954">                        return true;</span>
                    }
                    break;
                case ARC_NOSE_WPL:
<span class="nc bnc" id="L3958" title="All 4 branches missed.">                    if ((fa &gt; 240) || (fa &lt; 120)) {</span>
<span class="nc" id="L3959">                        return true;</span>
                    }
                    break;
                case ARC_LWING:
<span class="nc bnc" id="L3963" title="All 4 branches missed.">                    if ((fa &gt; 300) || (fa &lt;= 0)) {</span>
<span class="nc" id="L3964">                        return true;</span>
                    }
                    break;
                case ARC_LWING_WPL:
<span class="nc bnc" id="L3968" title="All 4 branches missed.">                    if ((fa &gt; 240) || (fa &lt; 60)) {</span>
<span class="nc" id="L3969">                        return true;</span>
                    }
                    break;
                case ARC_RWING:
<span class="nc bnc" id="L3973" title="All 4 branches missed.">                    if ((fa &gt;= 0) &amp;&amp; (fa &lt; 60)) {</span>
<span class="nc" id="L3974">                        return true;</span>
                    }
                    break;
                case ARC_RWING_WPL:
<span class="nc bnc" id="L3978" title="All 4 branches missed.">                    if ((fa &gt; 300) || (fa &lt; 120)) {</span>
<span class="nc" id="L3979">                        return true;</span>
                    }
                    break;
                case ARC_LWINGA:
<span class="nc bnc" id="L3983" title="All 4 branches missed.">                    if ((fa &gt;= 180) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L3984">                        return true;</span>
                    }
                    break;
                case ARC_LWINGA_WPL:
<span class="nc bnc" id="L3988" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 300)) {</span>
<span class="nc" id="L3989">                        return true;</span>
                    }
                    break;
                case ARC_RWINGA:
<span class="nc bnc" id="L3993" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt;= 180)) {</span>
<span class="nc" id="L3994">                        return true;</span>
                    }
                    break;
                case ARC_RWINGA_WPL:
<span class="nc bnc" id="L3998" title="All 4 branches missed.">                    if ((fa &gt; 60) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L3999">                        return true;</span>
                    }
                    break;
                case ARC_AFT:
<span class="nc bnc" id="L4003" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L4004">                        return true;</span>
                    }
                    break;
                case ARC_AFT_WPL:
<span class="nc bnc" id="L4008" title="All 4 branches missed.">                    if ((fa &gt; 60) &amp;&amp; (fa &lt; 300)) {</span>
<span class="nc" id="L4009">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDE_SPHERE:
<span class="nc bnc" id="L4013" title="All 4 branches missed.">                    if ((fa &gt; 240) || (fa &lt; 0)) {</span>
<span class="nc" id="L4014">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDE_SPHERE_WPL:
<span class="nc bnc" id="L4018" title="All 4 branches missed.">                    if ((fa &gt; 180) || (fa &lt; 60)) {</span>
<span class="nc" id="L4019">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDE_SPHERE:
<span class="nc bnc" id="L4023" title="All 4 branches missed.">                    if ((fa &gt; 0) &amp;&amp; (fa &lt; 120)) {</span>
<span class="nc" id="L4024">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDE_SPHERE_WPL:
<span class="nc bnc" id="L4028" title="All 4 branches missed.">                    if ((fa &gt; 300) || (fa &lt; 180)) {</span>
<span class="nc" id="L4029">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDEA_SPHERE:
<span class="nc bnc" id="L4033" title="All 4 branches missed.">                    if ((fa &gt; 180) &amp;&amp; (fa &lt; 300)) {</span>
<span class="nc" id="L4034">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDEA_SPHERE_WPL:
<span class="nc bnc" id="L4038" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 360)) {</span>
<span class="nc" id="L4039">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDEA_SPHERE:
<span class="nc bnc" id="L4043" title="All 4 branches missed.">                    if ((fa &gt; 60) &amp;&amp; (fa &lt; 180)) {</span>
<span class="nc" id="L4044">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDEA_SPHERE_WPL:
<span class="nc bnc" id="L4048" title="All 4 branches missed.">                    if ((fa &gt; 0) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L4049">                        return true;</span>
                    }
                    break;
                case ARC_LEFT_BROADSIDE:
<span class="nc bnc" id="L4053" title="All 4 branches missed.">                    if ((fa &gt;= 240) &amp;&amp; (fa &lt;= 300)) {</span>
<span class="nc" id="L4054">                        return true;</span>
                    }
                    break;
                case ARC_LEFT_BROADSIDE_WPL:
<span class="nc bnc" id="L4058" title="All 4 branches missed.">                    if ((fa &gt; 180) &amp;&amp; (fa &lt;= 360)) {</span>
<span class="nc" id="L4059">                        return true;</span>
                    }
                    break;
                case ARC_RIGHT_BROADSIDE:
<span class="nc bnc" id="L4063" title="All 4 branches missed.">                    if ((fa &gt;= 60) &amp;&amp; (fa &lt;= 120)) {</span>
<span class="nc" id="L4064">                        return true;</span>
                    }
                    break;
                case ARC_RIGHT_BROADSIDE_WPL:
<span class="nc bnc" id="L4068" title="All 4 branches missed.">                    if ((fa &gt; 0) &amp;&amp; (fa &lt; 180)) {</span>
<span class="nc" id="L4069">                        return true;</span>
                    }
                    break;
                case ARC_LEFT_SPHERE_GROUND:
<span class="nc bnc" id="L4073" title="All 4 branches missed.">                    if ((fa &gt;= 180) &amp;&amp; (fa &lt; 360)) {</span>
<span class="nc" id="L4074">                        return true;</span>
                    }
                    break;
                case ARC_RIGHT_SPHERE_GROUND:
<span class="nc bnc" id="L4078" title="All 4 branches missed.">                    if ((fa &gt;= 0) &amp;&amp; (fa &lt; 180)) {</span>
<span class="nc" id="L4079">                        return true;</span>
                    }
                    break;
                case ARC_TURRET:
<span class="nc bnc" id="L4083" title="All 4 branches missed.">                    if ((fa &gt;= 330) || (fa &lt;= 30)) {</span>
<span class="nc" id="L4084">                        return true;</span>
                    }
                    break;
                case ARC_SPONSON_TURRET_LEFT:
                case ARC_PINTLE_TURRET_LEFT:
<span class="nc bnc" id="L4089" title="All 4 branches missed.">                    if ((fa &gt;= 180) || (fa == 0)) {</span>
<span class="nc" id="L4090">                        return true;</span>
                    }
                    break;
                case ARC_SPONSON_TURRET_RIGHT:
                case ARC_PINTLE_TURRET_RIGHT:
<span class="nc bnc" id="L4095" title="All 4 branches missed.">                    if ((fa &gt;= 0) &amp;&amp; (fa &lt;= 180)) {</span>
<span class="nc" id="L4096">                        return true;</span>
                    }
                    break;
                case ARC_PINTLE_TURRET_FRONT:
<span class="nc bnc" id="L4100" title="All 4 branches missed.">                    if ((fa &gt;= 270) || (fa &lt;= 90)) {</span>
<span class="nc" id="L4101">                        return true;</span>
                    }
                    break;
                case ARC_PINTLE_TURRET_REAR:
<span class="nc bnc" id="L4105" title="All 4 branches missed.">                    if ((fa &gt;= 90) &amp;&amp; (fa &lt;= 270)) {</span>
<span class="nc" id="L4106">                        return true;</span>
                    }
                    break;
                case ARC_VGL_FRONT:
<span class="nc bnc" id="L4110" title="All 4 branches missed.">                    return (fa &gt;= 270) || (fa &lt;= 90);</span>
                case ARC_VGL_RF:
<span class="nc bnc" id="L4112" title="All 4 branches missed.">                    return (fa &gt;= 330) || (fa &lt;= 150);</span>
                case ARC_VGL_RR:
<span class="nc bnc" id="L4114" title="All 4 branches missed.">                    return (fa &gt;= 30) &amp;&amp; (fa &lt;= 210);</span>
                case ARC_VGL_REAR:
<span class="nc bnc" id="L4116" title="All 4 branches missed.">                    return (fa &gt;= 90) &amp;&amp; (fa &lt;= 270);</span>
                case ARC_VGL_LR:
<span class="nc bnc" id="L4118" title="All 4 branches missed.">                    return (fa &gt;= 150) &amp;&amp; (fa &lt;= 330);</span>
                case ARC_VGL_LF:
<span class="nc bnc" id="L4120" title="All 4 branches missed.">                    return (fa &gt;= 210) || (fa &lt;= 30);</span>
            }
<span class="nc" id="L4122">        }</span>
        // if we got here then no matches
<span class="nc" id="L4124">        return false;</span>
    }

    /**
     * checks to see whether the target is within visual range of the entity,
     * but not necessarily LoS
     */
    public static boolean inVisualRange(IGame game, Entity ae, Targetable target) {
<span class="nc" id="L4132">        return inVisualRange(game, null, ae, target);</span>
    }

    /**
     * Determine whether the attacking entity is within visual range of the
     * target.  This requires line of sight effects to determine if there are
     * certain intervening obstructions, like smoke, that can reduce visual
     * range.  Since repeated LoSEffects computations can be expensive, it is
     * possible to pass in the LosEffects, since they are commonly already
     * computed when this method is called.
     *
     * @param game
     * @param los
     * @param ae
     * @param target
     * @return
     */
    public static boolean inVisualRange(IGame game, LosEffects los, Entity ae,
            Targetable target) {
        //Use firing solution if Advanced Sensors is on
<span class="nc bnc" id="L4152" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)</span>
<span class="nc bnc" id="L4153" title="All 2 branches missed.">                &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY</span>
<span class="nc bnc" id="L4154" title="All 2 branches missed.">                &amp;&amp; game.getBoard().inSpace()) {</span>
<span class="nc" id="L4155">            Entity te = (Entity) target;</span>
<span class="nc" id="L4156">            return hasAnyFiringSolution(game, te.getId());</span>
        }
<span class="nc" id="L4158">        boolean teIlluminated = false;</span>
<span class="nc bnc" id="L4159" title="All 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4160">            Entity te = (Entity) target;</span>
<span class="nc" id="L4161">            teIlluminated = te.isIlluminated();</span>
<span class="nc bnc" id="L4162" title="All 2 branches missed.">            if (te.isOffBoard()) {</span>
<span class="nc" id="L4163">                return false;</span>
            }
        }

        // Target may be in an illuminated hex
<span class="nc bnc" id="L4168" title="All 2 branches missed.">        if (!teIlluminated) {</span>
<span class="nc" id="L4169">            int lightLvl = game.isPositionIlluminated(target.getPosition());</span>
<span class="nc bnc" id="L4170" title="All 2 branches missed.">            teIlluminated = lightLvl != Game.ILLUMINATED_NONE;</span>
        }

        // if either does not have a position then return false
<span class="nc bnc" id="L4174" title="All 4 branches missed.">        if ((ae.getPosition() == null) || (target.getPosition() == null)) {</span>
<span class="nc" id="L4175">            return false;</span>
        }

        // check visual range based on planetary conditions
<span class="nc bnc" id="L4179" title="All 2 branches missed.">        if (los == null) {</span>
<span class="nc" id="L4180">            los = LosEffects.calculateLos(game, ae.getId(), target);</span>
        }
<span class="nc" id="L4182">        int visualRange = getVisualRange(game, ae, los, teIlluminated);</span>

        //Check for factors that only apply to an entity target
<span class="nc" id="L4185">        Coords targetPos = target.getPosition();</span>
<span class="nc bnc" id="L4186" title="All 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4187">            Entity te = (Entity) target;</span>

            // check for camo and null sig on the target
<span class="nc bnc" id="L4190" title="All 2 branches missed.">            if (te.isVoidSigActive()) {</span>
<span class="nc" id="L4191">                visualRange = visualRange / 4;</span>
<span class="nc bnc" id="L4192" title="All 2 branches missed.">            } else if (te.hasWorkingMisc(MiscType.F_VISUAL_CAMO, -1)) {</span>
<span class="nc" id="L4193">                visualRange = visualRange / 2;</span>
<span class="nc bnc" id="L4194" title="All 2 branches missed.">            } else if (te.isChameleonShieldActive()) {</span>
<span class="nc" id="L4195">                visualRange = visualRange / 2;</span>
<span class="nc bnc" id="L4196" title="All 4 branches missed.">            } else if ((te instanceof Infantry) &amp;&amp; !(te instanceof BattleArmor)</span>
<span class="nc bnc" id="L4197" title="All 2 branches missed.">                       &amp;&amp; ((Infantry) te).hasSneakCamo()) {</span>
<span class="nc" id="L4198">                visualRange = visualRange / 2;</span>
            }

            // Ground targets pick the closest path to Aeros (TW pg 107)
<span class="nc bnc" id="L4202" title="All 4 branches missed.">            if ((te.isAero()) &amp;&amp; isGroundToAir(ae, target)) {</span>
<span class="nc" id="L4203">                targetPos = Compute.getClosestFlightPath(ae.getId(),</span>
<span class="nc" id="L4204">                        ae.getPosition(), te);</span>
            }
            //Airborne aeros can only see ground targets they overfly, and only at Alt &lt;=8
<span class="nc bnc" id="L4207" title="All 2 branches missed.">            if (isAirToGround(ae, target)) {</span>
<span class="nc bnc" id="L4208" title="All 2 branches missed.">                if (ae.getAltitude() &gt; 8) {</span>
<span class="nc" id="L4209">                    return false;</span>
                }
<span class="nc bnc" id="L4211" title="All 2 branches missed.">                if (ae.passedOver(target)) {</span>
<span class="nc" id="L4212">                    return true;</span>
                } else {
<span class="nc" id="L4214">                    return false;</span>
                }
            }
        }

<span class="nc" id="L4219">        visualRange = Math.max(visualRange, 1);</span>
        int distance;
        // Ground distance
<span class="nc" id="L4222">        distance = ae.getPosition().distance(targetPos);</span>
        //Need to track difference in altitude, not just add altitude to the range
<span class="nc" id="L4224">        distance += Math.abs(2 * target.getAltitude() - 2 * ae.getAltitude());</span>
<span class="nc bnc" id="L4225" title="All 2 branches missed.">        return distance &lt;= visualRange;</span>

    }

    //Space Combat Detection stuff

    /**
     * Checks to see if an entity has already been detected by anyone
     * Used for sensor return icons on board
     *
     * @param game - the current game
     * @param targetId - the ID# of the target entity we're looking for
     */
    public static boolean isAnySensorContact(IGame game, int targetId) {
<span class="nc bnc" id="L4239" title="All 2 branches missed.">        for (Entity detector : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4240" title="All 4 branches missed.">            if (detector.hasSensorContactFor(targetId) &amp;&amp; game.getEntity(targetId) != null) {</span>
<span class="nc" id="L4241">                game.getEntity(targetId).addBeenDetectedBy(detector.getOwner());</span>
<span class="nc" id="L4242">                return true;</span>
            }
<span class="nc" id="L4244">        }</span>
<span class="nc" id="L4245">        return false;</span>
    }

    /**
     * Checks to see if target entity has already appeared on @detector's sensors
     * Used with Naval C3 to determine if @detector can fire weapons at @target
     * @param detector - the entity making a sensor scan
     * @param targetId - the entity id of the scan target
     */
    public static boolean hasSensorContact(Entity detector, int targetId) {
<span class="nc" id="L4255">        return detector.hasSensorContactFor(targetId);</span>
    }

    /**
     * Checks to see if an entity is in anyone's firing solutions list
     * Used for visibility
     *
     * @param game - the current game
     * @param targetId - the ID # of the target we're firing at
     */
    public static boolean hasAnyFiringSolution(IGame game, int targetId) {
<span class="nc bnc" id="L4266" title="All 2 branches missed.">        for (Entity detector : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4267" title="All 4 branches missed.">            if (detector.hasFiringSolutionFor(targetId) &amp;&amp; game.getEntity(targetId) != null) {</span>
<span class="nc" id="L4268">                game.getEntity(targetId).addBeenSeenBy(detector.getOwner());</span>
<span class="nc" id="L4269">                return true;</span>
            }
<span class="nc" id="L4271">        }</span>
<span class="nc" id="L4272">        return false;</span>
    }

    /**
     * Calculates the ECM effects in play between a detector and target pair
     *
     * @param game - the current game
     * @param ae - the entity making a sensor scan
     * @param target - the entity we're trying to spot
     * @return
     */
    private static int calcSpaceECM(IGame game, Entity ae,
            Targetable target) {
<span class="nc" id="L4285">        int mod = 0;</span>
<span class="nc" id="L4286">        int ecm = ComputeECM.getLargeCraftECM(ae, ae.getPosition(), target.getPosition());</span>
<span class="nc bnc" id="L4287" title="All 2 branches missed.">        if (!ae.isLargeCraft()) {</span>
<span class="nc" id="L4288">            ecm += ComputeECM.getSmallCraftECM(ae, ae.getPosition(), target.getPosition());</span>
        }
<span class="nc" id="L4290">        ecm = Math.min(4, ecm);</span>
<span class="nc" id="L4291">        int eccm = 0;</span>
<span class="nc bnc" id="L4292" title="All 2 branches missed.">        if (ae.isLargeCraft()) {</span>
<span class="nc" id="L4293">            eccm = ((Aero) ae).getECCMBonus();</span>
        }
<span class="nc bnc" id="L4295" title="All 2 branches missed.">        if (ecm &gt; 0) {</span>
<span class="nc" id="L4296">            mod += ecm;</span>
<span class="nc bnc" id="L4297" title="All 2 branches missed.">            if (eccm &gt; 0) {</span>
<span class="nc" id="L4298">                mod -= (Math.min(ecm, eccm));</span>
            }
        }
<span class="nc" id="L4301">        return mod;</span>
    }

    /**
     * Calculates the Sensor Shadow effect in play between a detector and target pair
     *
     * @param game - the current game
     * @param ae - the entity making a sensor scan
     * @param target - the entity we're trying to spot
     * @return
     */
    private static int calcSensorShadow(IGame game, Entity ae,
            Targetable target) {
<span class="nc" id="L4314">        int mod = 0;</span>
<span class="nc bnc" id="L4315" title="All 2 branches missed.">        if (target.getTargetType() != Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4316">            return 0;</span>
        }
<span class="nc" id="L4318">        Entity te = (Entity) target;</span>
<span class="nc bnc" id="L4319" title="All 2 branches missed.">        for (Entity en : Compute.getAdjacentEntitiesAlongAttack(ae.getPosition(), target.getPosition(), game)) {</span>
<span class="nc bnc" id="L4320" title="All 8 branches missed.">            if (!en.isEnemyOf(te) &amp;&amp; en.isLargeCraft() &amp;&amp; !en.equals((Entity) te) &amp;&amp; ((en.getWeight() - te.getWeight()) &gt;= -100000.0)) {</span>
<span class="nc" id="L4321">                mod ++;</span>
<span class="nc" id="L4322">                break;</span>
            }
<span class="nc" id="L4324">        }</span>
<span class="nc bnc" id="L4325" title="All 2 branches missed.">        for (Entity en : game.getEntitiesVector(target.getPosition())) {</span>
<span class="nc bnc" id="L4326" title="All 8 branches missed.">            if (!en.isEnemyOf(te) &amp;&amp; en.isLargeCraft() &amp;&amp; !en.equals((Entity) ae) &amp;&amp; !en.equals((Entity) te)</span>
<span class="nc bnc" id="L4327" title="All 2 branches missed.">                    &amp;&amp; ((en.getWeight() - te.getWeight()) &gt;= -100000.0)) {</span>
<span class="nc" id="L4328">                mod ++;</span>
<span class="nc" id="L4329">                break;</span>
            }
<span class="nc" id="L4331">        }</span>
<span class="nc" id="L4332">        return mod;</span>
    }

    /**
     * Updates an entity's firingSolutions, removing any objects that no longer meet criteria for being
     * tracked as targets. Also, if the detecting entity no longer meets criteria for having firing solutions,
     * empty the list. We wouldn't want a dead ship to be providing NC3 data, now would we...
     */
    public static void updateFiringSolutions(IGame game, Entity detector) {
<span class="nc" id="L4341">        List&lt;Integer&gt; toRemove = new ArrayList&lt;Integer&gt;();</span>
        //Flush the detecting unit's firing solutions if any of these conditions applies
<span class="nc bnc" id="L4343" title="All 2 branches missed.">        if (detector.isDestroyed()</span>
<span class="nc bnc" id="L4344" title="All 2 branches missed.">                || detector.isDoomed()</span>
<span class="nc bnc" id="L4345" title="All 2 branches missed.">                || detector.getTransportId() != Entity.NONE</span>
<span class="nc bnc" id="L4346" title="All 2 branches missed.">                || detector.isPartOfFighterSquadron()</span>
<span class="nc bnc" id="L4347" title="All 2 branches missed.">                || detector.isOffBoard()</span>
<span class="nc bnc" id="L4348" title="All 2 branches missed.">                || detector.getPosition() == null) {</span>
<span class="nc" id="L4349">            detector.clearFiringSolutions();</span>
<span class="nc" id="L4350">            return;</span>
        }
<span class="nc bnc" id="L4352" title="All 2 branches missed.">        for (int id : detector.getFiringSolutions()) {</span>
<span class="nc" id="L4353">            Entity target = game.getEntity(id);</span>
            //The target should be removed if it's off the board for any of these reasons
<span class="nc bnc" id="L4355" title="All 2 branches missed.">            if (target == null</span>
<span class="nc bnc" id="L4356" title="All 2 branches missed.">                    || target.getPosition() == null</span>
<span class="nc bnc" id="L4357" title="All 2 branches missed.">                    || target.isDestroyed()</span>
<span class="nc bnc" id="L4358" title="All 2 branches missed.">                    || target.isDoomed()</span>
<span class="nc bnc" id="L4359" title="All 2 branches missed.">                    || target.getTransportId() != Entity.NONE</span>
<span class="nc bnc" id="L4360" title="All 2 branches missed.">                    || target.isPartOfFighterSquadron()</span>
<span class="nc bnc" id="L4361" title="All 2 branches missed.">                    || target.isOffBoard()) {</span>
<span class="nc" id="L4362">                toRemove.add(id);</span>
<span class="nc" id="L4363">                continue;</span>
            }
<span class="nc" id="L4365">            Coords targetPos = target.getPosition();</span>
<span class="nc" id="L4366">            int distance = detector.getPosition().distance(targetPos);</span>
            //Per SO p119, optical firing solutions are lost if the target moves beyond 1/10 max range
<span class="nc bnc" id="L4368" title="All 4 branches missed.">            if (detector.getActiveSensor().getType() == Sensor.TYPE_AERO_THERMAL</span>
                    &amp;&amp; distance &gt; Sensor.ASF_OPTICAL_FIRING_SOLUTION_RANGE) {
<span class="nc" id="L4370">                    toRemove.add(id);</span>
<span class="nc bnc" id="L4371" title="All 4 branches missed.">            } else if (detector.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_THERMAL</span>
                    &amp;&amp; distance &gt; Sensor.LC_OPTICAL_FIRING_SOLUTION_RANGE) {
<span class="nc" id="L4373">                    toRemove.add(id);</span>
            //For ASF sensors, make sure we're using the space range of 555...
<span class="nc bnc" id="L4375" title="All 4 branches missed.">            } else if (detector.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR</span>
                    &amp;&amp; distance &gt; Sensor.ASF_RADAR_MAX_RANGE) {
<span class="nc" id="L4377">                    toRemove.add(id);</span>
            } else {
                //Radar firing solutions are only lost if the target moves out of range
<span class="nc bnc" id="L4380" title="All 2 branches missed.">                if (distance &gt; detector.getActiveSensor().getRangeByBracket()) {</span>
<span class="nc" id="L4381">                    toRemove.add(id);</span>
                }
            }
<span class="nc" id="L4384">        }</span>
<span class="nc" id="L4385">        detector.removeFiringSolution(toRemove);</span>
<span class="nc" id="L4386">    }</span>

    /**
     * Updates an entity's sensorContacts, removing any objects that no longer meet criteria for being
     * tracked. Also, if the detecting entity no longer meets criteria for having sensor contacts,
     * empty the list. We wouldn't want a dead ship to be providing sensor data, now would we...
     */
    public static void updateSensorContacts(IGame game, Entity detector) {
<span class="nc" id="L4394">        List&lt;Integer&gt; toRemove = new ArrayList&lt;Integer&gt;();</span>
        //Flush the detecting unit's sensor contacts if any of these conditions applies
<span class="nc bnc" id="L4396" title="All 2 branches missed.">        if (detector.getPosition() == null</span>
<span class="nc bnc" id="L4397" title="All 2 branches missed.">                || detector.isDestroyed()</span>
<span class="nc bnc" id="L4398" title="All 2 branches missed.">                || detector.isDoomed()</span>
<span class="nc bnc" id="L4399" title="All 2 branches missed.">                || detector.getTransportId() != Entity.NONE</span>
<span class="nc bnc" id="L4400" title="All 2 branches missed.">                || detector.isPartOfFighterSquadron()</span>
<span class="nc bnc" id="L4401" title="All 2 branches missed.">                || detector.isOffBoard()) {</span>
<span class="nc" id="L4402">            detector.clearSensorContacts();</span>
<span class="nc" id="L4403">            return;</span>
        }
<span class="nc bnc" id="L4405" title="All 2 branches missed.">        for (int id : detector.getSensorContacts()) {</span>
<span class="nc" id="L4406">            Entity target = game.getEntity(id);</span>
            //The target should be removed if it's off the board for any of these reasons
<span class="nc bnc" id="L4408" title="All 2 branches missed.">            if (target == null</span>
<span class="nc bnc" id="L4409" title="All 2 branches missed.">                    || target.getPosition() == null</span>
<span class="nc bnc" id="L4410" title="All 2 branches missed.">                    || target.isDestroyed()</span>
<span class="nc bnc" id="L4411" title="All 2 branches missed.">                    || target.isDoomed()</span>
<span class="nc bnc" id="L4412" title="All 2 branches missed.">                    || target.getTransportId() != Entity.NONE</span>
<span class="nc bnc" id="L4413" title="All 2 branches missed.">                    || target.isPartOfFighterSquadron()</span>
<span class="nc bnc" id="L4414" title="All 2 branches missed.">                    || target.isOffBoard()) {</span>
<span class="nc" id="L4415">                toRemove.add(id);</span>
<span class="nc" id="L4416">                continue;</span>
            }
            //And now calculate whether or not the target has moved out of range. Per SO p117-119,
            //sensor contacts remain tracked on the plotting board until this occurs.
<span class="nc" id="L4420">            Coords targetPos = target.getPosition();</span>
<span class="nc" id="L4421">            int distance = detector.getPosition().distance(targetPos);</span>
<span class="nc bnc" id="L4422" title="All 2 branches missed.">            if (distance &gt; detector.getActiveSensor().getRangeByBracket()) {</span>
<span class="nc" id="L4423">                toRemove.add(id);</span>
            }
<span class="nc" id="L4425">        }</span>
<span class="nc" id="L4426">        detector.removeSensorContact(toRemove);</span>
<span class="nc" id="L4427">    }</span>


    /**
     *If the game is in space, &quot;visual range&quot; represents a firing solution as defined in SO starting on p117
     *Also, in most cases each target must be detected with sensors before it can be seen, so we need to make
     *sensor rolls for detection. This should only be used if Tacops sensor rules are in use.
     * This requires line of sight effects to determine if there are
     * certain intervening obstructions, like sensor shadows, asteroids and that sort of thing, that can reduce visual
     * range.  Since repeated LoSEffects computations can be expensive, it is
     * possible to pass in the LosEffects, since they are commonly already
     * computed when this method is called.
     *
     * @param game - the current game
     * @param ae - the entity making a sensor scan
     * @param target - the entity we're trying to spot
     * @return
     */

    public static boolean calcFiringSolution(IGame game, Entity ae,
            Targetable target) {
<span class="nc bnc" id="L4448" title="All 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4449">            Entity te = (Entity) target;</span>
<span class="nc bnc" id="L4450" title="All 2 branches missed.">            if (te.isOffBoard()) {</span>
<span class="nc" id="L4451">                return false;</span>
            }
        }

        //NPE check. Fighter squadrons don't start with sensors, but pick them up from the component fighters each round
<span class="nc bnc" id="L4456" title="All 2 branches missed.">        if (ae.getActiveSensor() == null) {</span>
<span class="nc" id="L4457">            return false;</span>
        }

        //ESM sensor can't produce a firing solution
<span class="nc bnc" id="L4461" title="All 2 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_ESM) {</span>
<span class="nc" id="L4462">            return false;</span>
        }
<span class="nc" id="L4464">        Coords targetPos = target.getPosition();</span>
<span class="nc" id="L4465">        int distance = ae.getPosition().distance(targetPos);</span>
<span class="nc" id="L4466">        int roll = Compute.d6(2);</span>
<span class="nc" id="L4467">        int tn = ae.getCrew().getPiloting();</span>
<span class="nc" id="L4468">        int autoVisualRange = 1;</span>
<span class="nc" id="L4469">        int outOfVisualRange = (ae.getActiveSensor().getRangeByBracket());</span>
<span class="nc" id="L4470">        int rangeIncrement = (int) Math.ceil(outOfVisualRange / 10.0);</span>

        //A bit of a hack here. &quot;Aero Sensors&quot; return the ground range, because Sensor doesn't know about Game or Entity
        //to do otherwise. We need to use the space range instead.
<span class="nc bnc" id="L4474" title="All 2 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</span>
<span class="nc" id="L4475">            outOfVisualRange = Sensor.ASF_RADAR_MAX_RANGE;</span>
<span class="nc" id="L4476">            rangeIncrement = Sensor.ASF_RADAR_AUTOSPOT_RANGE;</span>
        }
        
<span class="nc bnc" id="L4479" title="All 2 branches missed.">        if (distance &gt; outOfVisualRange) {</span>
<span class="nc" id="L4480">            return false;</span>
        }

<span class="nc bnc" id="L4483" title="All 2 branches missed.">        if (ae instanceof Aero) {</span>
<span class="nc" id="L4484">            Aero aero = (Aero) ae;</span>
            //Account for sensor damage
<span class="nc bnc" id="L4486" title="All 2 branches missed.">            if (aero.isAeroSensorDestroyed()) {</span>
<span class="nc" id="L4487">                return false;</span>
            } else {
<span class="nc" id="L4489">                tn += aero.getSensorHits();</span>
            }
        }

        //Targets at 1/10 max range are automatically detected
<span class="nc bnc" id="L4494" title="All 2 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</span>
<span class="nc" id="L4495">            autoVisualRange = Sensor.ASF_RADAR_AUTOSPOT_RANGE;</span>
<span class="nc bnc" id="L4496" title="All 2 branches missed.">        } else if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_RADAR) {</span>
<span class="nc" id="L4497">            autoVisualRange = Sensor.LC_RADAR_AUTOSPOT_RANGE;</span>
<span class="nc bnc" id="L4498" title="All 2 branches missed.">        } else if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_THERMAL) {</span>
<span class="nc" id="L4499">            autoVisualRange = Sensor.ASF_OPTICAL_FIRING_SOLUTION_RANGE;</span>
<span class="nc bnc" id="L4500" title="All 2 branches missed.">        } else if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_THERMAL) {</span>
<span class="nc" id="L4501">            autoVisualRange = Sensor.LC_OPTICAL_FIRING_SOLUTION_RANGE;</span>
        }

<span class="nc bnc" id="L4504" title="All 2 branches missed.">        if (distance &lt;= autoVisualRange) {</span>
<span class="nc" id="L4505">            return true;</span>
        }

        //Apply Sensor Geek SPA, if present
<span class="nc bnc" id="L4509" title="All 2 branches missed.">        if (ae.hasAbility(OptionsConstants.UNOFF_SENSOR_GEEK)) {</span>
<span class="nc" id="L4510">            tn -= 2;</span>
        }

        //Otherwise, we add +1 to the tn for detection for each increment of the autovisualrange between attacker and target
<span class="nc" id="L4514">        tn += (distance / rangeIncrement);</span>

        // Apply ECM/ECCM effects
<span class="nc bnc" id="L4517" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</span>
<span class="nc" id="L4518">            tn += calcSpaceECM(game, ae, target);</span>
        }

        // Apply large craft sensor shadows
<span class="nc bnc" id="L4522" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_SENSOR_SHADOW)) {</span>
<span class="nc" id="L4523">            tn += calcSensorShadow(game, ae, target);</span>
        }

        //Apply modifiers for attacker's equipment
        //-2 for a working Large NCSS
<span class="nc bnc" id="L4528" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_LARGE_COMM_SCANNER_SUITE)) {</span>
<span class="nc" id="L4529">            tn -= 2;</span>
        }
        //-1 for a working Small NCSS
<span class="nc bnc" id="L4532" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_SMALL_COMM_SCANNER_SUITE)) {</span>
<span class="nc" id="L4533">            tn -= 1;</span>
        }
        //-2 for any type of BAP or EW Equipment. ECM is already accounted for, so don't let the BAP check do that
<span class="nc bnc" id="L4536" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_EW_EQUIPMENT)</span>
<span class="nc bnc" id="L4537" title="All 2 branches missed.">                || ae.hasBAP(false)) {</span>
<span class="nc" id="L4538">            tn -= 2;</span>
        }

        //Now, determine if we've detected the target this round
<span class="nc bnc" id="L4542" title="All 2 branches missed.">        return roll &gt;= tn;</span>
    }

    /**
     *Determines whether we have an &quot;object&quot; detection as defined in SO's Advanced Sensors rules starting on p117
     *
     * @param game - the current game
     * @param ae - the entity making a sensor scan
     * @param target - the entity we're trying to spot
     * @return
     */

    public static boolean calcSensorContact(IGame game, Entity ae,
            Targetable target) {

        //NPE check. Fighter squadrons don't start with sensors, but pick them up from the component fighters each round
<span class="nc bnc" id="L4558" title="All 2 branches missed.">        if (ae.getActiveSensor() == null) {</span>
<span class="nc" id="L4559">            return false;</span>
        }
<span class="nc" id="L4561">        Coords targetPos = target.getPosition();</span>
<span class="nc" id="L4562">        int distance = ae.getPosition().distance(targetPos);</span>
<span class="nc" id="L4563">        int roll = Compute.d6(2);</span>
<span class="nc" id="L4564">        int tn = ae.getCrew().getPiloting();</span>
<span class="nc" id="L4565">        int maxSensorRange = ae.getActiveSensor().getRangeByBracket();</span>
<span class="nc" id="L4566">        int rangeIncrement = (int) Math.ceil(maxSensorRange / 10.0);</span>

        //A bit of a hack here. &quot;Aero Sensors&quot; return the ground range, because Sensor doesn't know about Game or Entity
        //to do otherwise. We need to use the space range instead.
<span class="nc bnc" id="L4570" title="All 2 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</span>
<span class="nc" id="L4571">            maxSensorRange = Sensor.ASF_RADAR_MAX_RANGE;</span>
<span class="nc" id="L4572">            rangeIncrement = Sensor.ASF_RADAR_AUTOSPOT_RANGE;</span>
        }

<span class="nc bnc" id="L4575" title="All 2 branches missed.">        if (ae instanceof Aero) {</span>
<span class="nc" id="L4576">            Aero aero = (Aero) ae;</span>
            //Account for sensor damage
<span class="nc bnc" id="L4578" title="All 2 branches missed.">            if (aero.isAeroSensorDestroyed()) {</span>
<span class="nc" id="L4579">                return false;</span>
            } else {
<span class="nc" id="L4581">                tn += aero.getSensorHits();</span>
            }
        }

        //Apply modifiers for attacker's equipment
        //-2 for a working Large NCSS.  Triple the detection range.
<span class="nc bnc" id="L4587" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_LARGE_COMM_SCANNER_SUITE)) {</span>
<span class="nc" id="L4588">            maxSensorRange *= 3;</span>
<span class="nc" id="L4589">            tn -= 2;</span>
        }
        //-1 for a working Small NCSS. Double the detection range.
<span class="nc bnc" id="L4592" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_SMALL_COMM_SCANNER_SUITE)) {</span>
<span class="nc" id="L4593">            maxSensorRange *= 2;</span>
<span class="nc" id="L4594">            tn -= 1;</span>
        }
        //-2 for any type of BAP or EW Equipment. ECM is already accounted for, so don't let the BAP check do that
<span class="nc bnc" id="L4597" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_EW_EQUIPMENT)</span>
<span class="nc bnc" id="L4598" title="All 2 branches missed.">                || ae.hasBAP(false)) {</span>
<span class="nc" id="L4599">            tn -= 2;</span>
        }

        //Military ESM automatically detects anyone using active sensors, which includes all telemissiles
<span class="nc bnc" id="L4603" title="All 4 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_ESM &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4604">            Entity te = (Entity) target;</span>
<span class="nc bnc" id="L4605" title="All 2 branches missed.">            if (te.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR</span>
<span class="nc bnc" id="L4606" title="All 4 branches missed.">                    || te.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_RADAR</span>
                    || te instanceof TeleMissile) {
<span class="nc" id="L4608">                return true;</span>
            }
<span class="nc" id="L4610">            return false;</span>
        }

        //Can't detect anything beyond this distance
<span class="nc bnc" id="L4614" title="All 2 branches missed.">        if (distance &gt; maxSensorRange) {</span>
<span class="nc" id="L4615">            return false;</span>
        }

        //Apply Sensor Geek SPA, if present
<span class="nc bnc" id="L4619" title="All 2 branches missed.">        if (ae.hasAbility(OptionsConstants.UNOFF_SENSOR_GEEK)) {</span>
<span class="nc" id="L4620">            tn -= 2;</span>
        }

        //Otherwise, we add +1 to the tn for each 1/10 of the max sensor range (rounded up) between attacker and target
<span class="nc" id="L4624">        tn += (distance / rangeIncrement);</span>

        // Apply ECM/ECCM effects
<span class="nc bnc" id="L4627" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</span>
<span class="nc" id="L4628">            tn += calcSpaceECM(game, ae, target);</span>
        }

        // Apply large craft sensor shadows
<span class="nc bnc" id="L4632" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_SENSOR_SHADOW)) {</span>
<span class="nc" id="L4633">            tn += calcSensorShadow(game, ae, target);</span>
        }

        //Now, determine if we've detected the target this round
<span class="nc bnc" id="L4637" title="All 2 branches missed.">        return roll &gt;= tn;</span>
    }

    public static int getVisualRange(IGame game, Entity ae, LosEffects los,
            boolean teIlluminated) {
<span class="nc" id="L4642">        int visualRange = game.getPlanetaryConditions().getVisualRange(ae,</span>
                teIlluminated);
<span class="nc" id="L4644">        visualRange -= los.getLightSmoke();</span>
<span class="nc" id="L4645">        visualRange -= 2 * los.getHeavySmoke();</span>
<span class="nc" id="L4646">        visualRange = Math.max(1, visualRange);</span>
<span class="nc" id="L4647">        return visualRange;</span>
    }

    /**
     * Checks to see whether the target is within sensor range (but not
     * necessarily LoS or visual range)
     *
     * @param allECMInfo A collection of ECMInfo for all entities, this value
     *                   can be null and it will be computed when it's
     *                   needed, however passing in the pre-computed
     *                   collection is much faster
     */
    public static boolean inSensorRange(IGame game, Entity ae,
            Targetable target, List&lt;ECMInfo&gt; allECMInfo) {
<span class="nc" id="L4661">        return inSensorRange(game, null, ae, target, allECMInfo);</span>
    }

    public static boolean inSensorRange(IGame game, LosEffects los, Entity ae,
            Targetable target, List&lt;ECMInfo&gt; allECMInfo) {
        // This is not applicable to objects on the same team.
<span class="nc bnc" id="L4667" title="All 2 branches missed.">        if(!target.isEnemyOf(ae)) {</span>
<span class="nc" id="L4668">            return false;</span>
        }

        //For Space games with this option, return something different
<span class="nc bnc" id="L4672" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)</span>
<span class="nc bnc" id="L4673" title="All 2 branches missed.">                &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY</span>
<span class="nc bnc" id="L4674" title="All 2 branches missed.">                &amp;&amp; game.getBoard().inSpace()) {</span>
<span class="nc" id="L4675">            Entity te = (Entity) target;</span>
<span class="nc" id="L4676">            return hasSensorContact(ae, te.getId());</span>
        }

<span class="nc bnc" id="L4679" title="All 2 branches missed.">        if (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {</span>
<span class="nc" id="L4680">            return false;</span>
        }

        // if either does not have a position then return false
<span class="nc bnc" id="L4684" title="All 4 branches missed.">        if ((ae.getPosition() == null) || (target.getPosition() == null)) {</span>
<span class="nc" id="L4685">            return false;</span>
        }

        // If we have no sensors then return false
<span class="nc bnc" id="L4689" title="All 2 branches missed.">        if (ae.getActiveSensor() == null) {</span>
<span class="nc" id="L4690">            return false;</span>
        }

<span class="nc" id="L4693">        int bracket = Compute.getSensorRangeBracket(ae, target, allECMInfo);</span>
<span class="nc" id="L4694">        int range = Compute.getSensorRangeByBracket(game, ae, target, los);</span>

<span class="nc" id="L4696">        int maxSensorRange = bracket * range;</span>
<span class="nc" id="L4697">        int minSensorRange = Math.max((bracket - 1) * range, 0);</span>
<span class="nc bnc" id="L4698" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_INCLUSIVE_SENSOR_RANGE)) {</span>
<span class="nc" id="L4699">            minSensorRange = 0;</span>
        }

<span class="nc" id="L4702">        int distance = ae.getPosition().distance(target.getPosition());</span>

        //Aeros have to check visibility to ground targets for the closest point of approach along their flight path
        //Because the rules state &quot;within X hexes of the flight path&quot; we're using ground distance so altitude doesn't screw us up
<span class="nc bnc" id="L4706" title="All 4 branches missed.">        if (isAirToGround(ae, target) &amp;&amp; (target instanceof Entity)) {</span>
<span class="nc" id="L4707">            Entity te = (Entity) target;</span>
<span class="nc" id="L4708">            distance = te.getPosition().distance(</span>
<span class="nc" id="L4709">                    getClosestFlightPath(te.getId(),</span>
<span class="nc" id="L4710">                            te.getPosition(), (Entity) ae));</span>
<span class="nc bnc" id="L4711" title="All 4 branches missed.">            return (distance &gt; minSensorRange) &amp;&amp; (distance &lt;= maxSensorRange);</span>
        }
        //This didn't work right for Aeros. Should account for the difference in altitude, not just add the target's altitude to distance
<span class="nc" id="L4714">        distance += Math.abs(2 * target.getAltitude() - 2 * ae.getAltitude());</span>

        // if this is an air-to-air scan on the ground map, then divide distance by 16 to match weapon ranges
        // I purposely left this calculation out of visual spotting, so we should do some testing with this and
        // see if it's errata-worthy. The idea is that you'll boost sensor range to help find an enemy aero on the map
        // but still won't be able to see it and shoot at it beyond normal visual conditions.
<span class="nc bnc" id="L4720" title="All 4 branches missed.">        if (isAirToAir(ae, target) &amp;&amp; game.getBoard().onGround()) {</span>
<span class="nc" id="L4721">            distance = (int) Math.ceil(distance / 16.0);</span>
        }
<span class="nc bnc" id="L4723" title="All 4 branches missed.">        return (distance &gt; minSensorRange) &amp;&amp; (distance &lt;= maxSensorRange);</span>
    }

    /**
     * Checks to see if the target is visible to the unit, always considering
     * sensors.
     */
    public static boolean canSee(IGame game, Entity ae, Targetable target) {
<span class="nc" id="L4731">        return canSee(game, ae, target, true, null, null);</span>
    }

    /**
     * Checks to see if the target is visible to the unit, if the sensor flag
     * is true then sensors are checked as well.
     */
    public static boolean canSee(IGame game, Entity ae, Targetable target,
            boolean useSensors, LosEffects los, List&lt;ECMInfo&gt; allECMInfo) {

<span class="nc bnc" id="L4741" title="All 2 branches missed.">        if (!ae.getCrew().isActive()) {</span>
<span class="nc" id="L4742">            return false;</span>
        }
<span class="nc bnc" id="L4744" title="All 2 branches missed.">        if (target.isOffBoard()) {</span>
<span class="nc" id="L4745">            return false;</span>
        }

<span class="nc bnc" id="L4748" title="All 2 branches missed.">        if (los == null) {</span>
<span class="nc" id="L4749">            los = LosEffects.calculateLos(game, ae.getId(), target);</span>
        }
<span class="nc bnc" id="L4751" title="All 2 branches missed.">        boolean isVisible = los.canSee()</span>
<span class="nc bnc" id="L4752" title="All 2 branches missed.">                            &amp;&amp; Compute.inVisualRange(game, los, ae, target);</span>
<span class="nc bnc" id="L4753" title="All 2 branches missed.">        if (useSensors) {</span>
<span class="nc bnc" id="L4754" title="All 2 branches missed.">            isVisible = isVisible</span>
<span class="nc bnc" id="L4755" title="All 2 branches missed.">                    || Compute.inSensorRange(game, los, ae, target, allECMInfo);</span>
        }
<span class="nc" id="L4757">        return isVisible;</span>
    }

    /**
     * gets the sensor range bracket when detecting a particular type of target.
     * target may be null here, which gives you the bracket without target
     * entity modifiers
     *
     * @param allECMInfo A collection of ECMInfo for all entities, this value
     *                   can be null and it will be computed when it's
     *                   needed, however passing in the pre-computed
     *                   collection is much faster
     */
    public static int getSensorRangeBracket(Entity ae, Targetable target,
                                            List&lt;ECMInfo&gt; allECMInfo) {

<span class="nc" id="L4773">        Sensor sensor = ae.getActiveSensor();</span>
<span class="nc bnc" id="L4774" title="All 2 branches missed.">        if (null == sensor) {</span>
<span class="nc" id="L4775">            return 0;</span>
        }
        // only works for entities
<span class="nc" id="L4778">        Entity te = null;</span>
<span class="nc bnc" id="L4779" title="All 2 branches missed.">        if (null != target) {</span>
<span class="nc bnc" id="L4780" title="All 2 branches missed.">            if (target.getTargetType() != Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4781">                return 0;</span>
            }
<span class="nc" id="L4783">            te = (Entity) target;</span>
        }

        // if this sensor is an active probe and it is critted, then no can see
<span class="nc bnc" id="L4787" title="All 4 branches missed.">        if (sensor.isBAP() &amp;&amp; !ae.hasBAP(false)) {</span>
<span class="nc" id="L4788">            return 0;</span>
        }

        //In space, sensors don't have brackets, so we should always return the range for bracket 1.
<span class="nc bnc" id="L4792" title="All 2 branches missed.">        if (ae.isSpaceborne()) {</span>
<span class="nc" id="L4793">            return Compute.getSensorBracket(7);</span>
        }

<span class="nc" id="L4796">        int check = ae.getSensorCheck();</span>
<span class="nc bnc" id="L4797" title="All 4 branches missed.">        if ((null != ae.getCrew()) &amp;&amp; ae.hasAbility(OptionsConstants.UNOFF_SENSOR_GEEK)) {</span>
<span class="nc" id="L4798">            check -= 2;</span>
        }
<span class="nc bnc" id="L4800" title="All 2 branches missed.">        if (null != te) {</span>
<span class="nc" id="L4801">            check += sensor.getModsForStealth(te);</span>
            // Metal Content...
<span class="nc bnc" id="L4803" title="All 2 branches missed.">            if (ae.getGame().getOptions().booleanOption(OptionsConstants.ADVANCED_METAL_CONTENT)) {</span>
<span class="nc" id="L4804">                check += sensor.getModForMetalContent(ae, te);</span>
            }
        }
        // ECM bubbles
<span class="nc" id="L4808">        check += sensor.getModForECM(ae, allECMInfo);</span>

<span class="nc" id="L4810">        return Compute.getSensorBracket(check);</span>
    }

    /**
     * returns the brackets for sensor checks
     */
    public static int getSensorBracket(int check) {
        // get the range bracket (0 - none; 1 - short; 2 - medium; 3 - long)
<span class="nc" id="L4818">        int bracket = 0;</span>
<span class="nc bnc" id="L4819" title="All 4 branches missed.">        if ((check == 7) || (check == 8)) {</span>
<span class="nc" id="L4820">            bracket = 1;</span>
        }
<span class="nc bnc" id="L4822" title="All 4 branches missed.">        if ((check == 5) || (check == 6)) {</span>
<span class="nc" id="L4823">            bracket = 2;</span>
        }
<span class="nc bnc" id="L4825" title="All 2 branches missed.">        if (check &lt; 5) {</span>
<span class="nc" id="L4826">            bracket = 3;</span>
        }
<span class="nc" id="L4828">        return bracket;</span>
    }

    /**
     * gets the size of the sensor range bracket when detecting a particular
     * type of target. target may be null here, which gives you the range
     * without target entity modifiers
     */
    public static int getSensorRangeByBracket(IGame game, Entity ae,
            Targetable target, LosEffects los) {
<span class="nc bnc" id="L4838" title="All 2 branches missed.">        if (los == null) {</span>
<span class="nc" id="L4839">            los = LosEffects.calculateLos(game, ae.getId(), target);</span>
        }
<span class="nc" id="L4841">        Sensor sensor = ae.getActiveSensor();</span>
<span class="nc bnc" id="L4842" title="All 2 branches missed.">        if (null == sensor) {</span>
<span class="nc" id="L4843">            return 0;</span>
        }
        // only works for entities
<span class="nc" id="L4846">        Entity te = null;</span>
<span class="nc bnc" id="L4847" title="All 2 branches missed.">        if (null != target) {</span>
<span class="nc bnc" id="L4848" title="All 2 branches missed.">            if (target.getTargetType() != Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4849">                return 0;</span>
            }
<span class="nc" id="L4851">            te = (Entity) target;</span>
        }

        // if this sensor is an active probe and it is critted, then no can see
<span class="nc bnc" id="L4855" title="All 4 branches missed.">        if (sensor.isBAP() &amp;&amp; !ae.hasBAP(false)) {</span>
<span class="nc" id="L4856">            return 0;</span>
        }

        // if we are crossing water then only magscan will work unless we are a
        // naval vessel
<span class="nc bnc" id="L4861" title="All 4 branches missed.">        if ((null != te) &amp;&amp; los.isBlockedByWater()</span>
<span class="nc bnc" id="L4862" title="All 2 branches missed.">            &amp;&amp; (sensor.getType() != Sensor.TYPE_MEK_MAGSCAN)</span>
<span class="nc bnc" id="L4863" title="All 2 branches missed.">            &amp;&amp; (sensor.getType() != Sensor.TYPE_VEE_MAGSCAN)</span>
<span class="nc bnc" id="L4864" title="All 2 branches missed.">            &amp;&amp; (ae.getMovementMode() != EntityMovementMode.HYDROFOIL)</span>
<span class="nc bnc" id="L4865" title="All 2 branches missed.">            &amp;&amp; (ae.getMovementMode() != EntityMovementMode.NAVAL)) {</span>
<span class="nc" id="L4866">            return 0;</span>
        }

        // now get the range
<span class="nc" id="L4870">        int range = sensor.getRangeByBracket();</span>

        // adjust the range based on LOS and planetary conditions
<span class="nc" id="L4873">        range = sensor.adjustRange(range, game, los);</span>

        //If we're an airborne aero, sensor range is limited to within a few hexes of the flightline against ground targets
        //TO Dec 2017 Errata p17
<span class="nc bnc" id="L4877" title="All 6 branches missed.">        if (te != null &amp;&amp; ae.isAirborne() &amp;&amp; !te.isAirborne()) {</span>
            //Can't see anything if above Alt 8.
<span class="nc bnc" id="L4879" title="All 2 branches missed.">            if (ae.getAltitude() &gt; 8) {</span>
<span class="nc" id="L4880">                range = 0;</span>
<span class="nc bnc" id="L4881" title="All 2 branches missed.">            } else if (sensor.isBAP()) {</span>
            //Add 1 to range for active probe of any type
<span class="nc" id="L4883">                range = 2;</span>
            } else {
            //Basic sensor range listed in errata
<span class="nc" id="L4886">                range = 1;</span>
            }
<span class="nc" id="L4888">            return range;</span>
        }

        // now adjust for anything about the target entity (size, heat, etc)
<span class="nc bnc" id="L4892" title="All 2 branches missed.">        if (null != te) {</span>
<span class="nc" id="L4893">            range = sensor.entityAdjustments(range, te, game);</span>
        }

<span class="nc bnc" id="L4896" title="All 2 branches missed.">        if (range &lt; 0) {</span>
<span class="nc" id="L4897">            range = 0;</span>
        }

<span class="nc" id="L4900">        return range;</span>

    }

    public static int targetSideTable(Coords inPosition, Targetable target) {
<span class="nc" id="L4905">        return target.sideTable(inPosition);</span>
    }

    public static int targetSideTable(Entity attacker, Targetable target) {
<span class="nc" id="L4909">        return Compute</span>
<span class="nc" id="L4910">                .targetSideTable(attacker, target, CalledShot.CALLED_NONE);</span>
    }

    public static int targetSideTable(Entity attacker, Targetable target,
                                      int called) {
<span class="nc" id="L4915">        Coords attackPos = attacker.getPosition();</span>

<span class="nc" id="L4917">        Entity te = null;</span>
<span class="nc bnc" id="L4918" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L4919">            te = (Entity) target;</span>
        }

<span class="nc" id="L4922">        boolean usePrior = false;</span>
        // aeros in the same hex need to adjust position to get side
        // table
<span class="nc bnc" id="L4925" title="All 2 branches missed.">        if (isAirToAir(attacker, target)</span>
<span class="nc bnc" id="L4926" title="All 2 branches missed.">            &amp;&amp; attackPos.equals(target.getPosition())</span>
<span class="nc bnc" id="L4927" title="All 4 branches missed.">            &amp;&amp; attacker.isAero() &amp;&amp; target.isAero()) {</span>
<span class="nc" id="L4928">            int moveSort = shouldMoveBackHex(attacker, (Entity)target);</span>
<span class="nc bnc" id="L4929" title="All 2 branches missed.">            if (moveSort &lt; 0) {</span>
<span class="nc" id="L4930">                attackPos = attacker.getPriorPosition();</span>
            }
<span class="nc bnc" id="L4932" title="All 2 branches missed.">            usePrior = moveSort &gt; 0;</span>
        }

        // if this is a air to ground attack, then attacker position is given by
        // the direction from which they entered the target hex
<span class="nc bnc" id="L4937" title="All 2 branches missed.">        if (isAirToGround(attacker, target)) {</span>
<span class="nc" id="L4938">            attackPos = attacker.passedThroughPrevious(target.getPosition());</span>
        }

<span class="nc bnc" id="L4941" title="All 4 branches missed.">        if (isGroundToAir(attacker, target) &amp;&amp; (null != te)) {</span>
<span class="nc" id="L4942">            int facing = Compute.getClosestFlightPathFacing(attacker.getId(),</span>
                    attackPos, te);
<span class="nc" id="L4944">            Coords pos = Compute.getClosestFlightPath(attacker.getId(),</span>
                    attackPos, te);
<span class="nc" id="L4946">            return te.sideTable(attackPos, usePrior, facing, pos);</span>
        }

<span class="nc bnc" id="L4949" title="All 4 branches missed.">        if ((null != te) &amp;&amp; (called == CalledShot.CALLED_LEFT)) {</span>
<span class="nc" id="L4950">            return te.sideTable(attackPos, usePrior, (te.getFacing() + 5) % 6);</span>
<span class="nc bnc" id="L4951" title="All 4 branches missed.">        } else if ((null != te) &amp;&amp; (called == CalledShot.CALLED_RIGHT)) {</span>
<span class="nc" id="L4952">            return te.sideTable(attackPos, usePrior, (te.getFacing() + 1) % 6);</span>
        }

<span class="nc" id="L4955">        return target.sideTable(attackPos, usePrior);</span>
    }


        /**
         * Compares the initiative of two aerospace units in the same hex to determine attack angle.
         * The attack angle is computed as if the unit with the higher initiative were in its previous hex.
         *
         * @param e1 The first &lt;code&gt;Entity&lt;/code&gt; to compare
         * @param e2 The second &lt;code&gt;Entity&lt;/code&gt; to compare
         * @return &lt; 0 if the first unit has a higher initiative, &gt; 0 if the second is higher,
         *         or 0 if one of the units is not an aerospace unit, does not have a valid position,
         *         or the two units are not in the same hex.
         */
    public static int shouldMoveBackHex(Entity e1, Entity e2) {
<span class="nc bnc" id="L4970" title="All 4 branches missed.">        if (null == e1.getPosition() || null == e2.getPosition()</span>
<span class="nc bnc" id="L4971" title="All 2 branches missed.">                || !e1.getPosition().equals(e2.getPosition())</span>
<span class="nc bnc" id="L4972" title="All 4 branches missed.">                || !e1.isAero() || !e2.isAero()) {</span>
<span class="nc" id="L4973">            return 0;</span>
        }

<span class="nc" id="L4976">        int retVal = e1.getUnitType() - e2.getUnitType();</span>
<span class="nc bnc" id="L4977" title="All 2 branches missed.">        if (retVal == 0) {</span>
<span class="nc" id="L4978">            retVal = ((IAero)e2).getCurrentVelocity() -</span>
<span class="nc" id="L4979">                    ((IAero)e1).getCurrentVelocity();</span>
        }
        // if all criteria are the same, select randomly
<span class="nc bnc" id="L4982" title="All 2 branches missed.">        if (retVal == 0) {</span>
<span class="nc bnc" id="L4983" title="All 2 branches missed.">            retVal = d6() &lt; 4? -1 : 1;</span>
        }
<span class="nc" id="L4985">        return retVal;</span>
    }

    /**
     * Maintain backwards compatability.
     *
     * @param missiles - the &lt;code&gt;int&lt;/code&gt; number of missiles in the pack.
     */
    public static int missilesHit(int missiles) {
<span class="nc" id="L4994">        return Compute.missilesHit(missiles, 0);</span>
    }

    /**
     * Maintain backwards compatability.
     *
     * @param missiles
     * @param nMod
     * @return
     */
    public static int missilesHit(int missiles, int nMod) {
<span class="nc" id="L5005">        return Compute.missilesHit(missiles, nMod, false);</span>
    }

    /**
     * Maintain backwards compatability.
     *
     * @param missiles
     * @param nMod
     * @param hotloaded
     * @return
     */
    public static int missilesHit(int missiles, int nMod, boolean hotloaded) {
<span class="nc" id="L5017">        return Compute.missilesHit(missiles, nMod, hotloaded, false, false);</span>
    }

    /**
     * Roll the number of missiles (or whatever) on the missile hit table, with
     * the specified mod to the roll.
     *
     * @param missiles    - the &lt;code&gt;int&lt;/code&gt; number of missiles in the pack.
     * @param nMod        - the &lt;code&gt;int&lt;/code&gt; modifier to the roll for number of
     *                    missiles that hit.
     * @param hotloaded   - roll 3d6 take worst 2
     * @param streak      - force a roll of 11 on the cluster table
     * @param advancedAMS - the roll can now go below 2, indicating no damage
     */
    public static int missilesHit(int missiles, int nMod, boolean hotloaded,
                                  boolean streak, boolean advancedAMS) {
<span class="nc" id="L5033">        int nRoll = Compute.d6(2);</span>

<span class="nc bnc" id="L5035" title="All 2 branches missed.">        if (hotloaded) {</span>
<span class="nc" id="L5036">            int roll1 = Compute.d6();</span>
<span class="nc" id="L5037">            int roll2 = Compute.d6();</span>
<span class="nc" id="L5038">            int roll3 = Compute.d6();</span>
<span class="nc" id="L5039">            int lowRoll1 = 0;</span>
<span class="nc" id="L5040">            int lowRoll2 = 0;</span>

<span class="nc bnc" id="L5042" title="All 4 branches missed.">            if ((roll1 &lt;= roll2) &amp;&amp; (roll1 &lt;= roll3)) {</span>
<span class="nc" id="L5043">                lowRoll1 = roll1;</span>
<span class="nc" id="L5044">                lowRoll2 = Math.min(roll2, roll3);</span>
<span class="nc bnc" id="L5045" title="All 4 branches missed.">            } else if ((roll2 &lt;= roll1) &amp;&amp; (roll2 &lt;= roll3)) {</span>
<span class="nc" id="L5046">                lowRoll1 = roll2;</span>
<span class="nc" id="L5047">                lowRoll2 = Math.min(roll1, roll3);</span>
<span class="nc bnc" id="L5048" title="All 4 branches missed.">            } else if ((roll3 &lt;= roll1) &amp;&amp; (roll3 &lt;= roll2)) {</span>
<span class="nc" id="L5049">                lowRoll1 = roll3;</span>
<span class="nc" id="L5050">                lowRoll2 = Math.min(roll2, roll1);</span>
            }
<span class="nc" id="L5052">            nRoll = lowRoll1 + lowRoll2;</span>
        }
<span class="nc bnc" id="L5054" title="All 2 branches missed.">        if (streak) {</span>
<span class="nc" id="L5055">            nRoll = 11;</span>
        }
<span class="nc" id="L5057">        nRoll += nMod;</span>
<span class="nc bnc" id="L5058" title="All 2 branches missed.">        if (!advancedAMS) {</span>
<span class="nc" id="L5059">            nRoll = Math.min(Math.max(nRoll, 2), 12);</span>
        } else {
<span class="nc" id="L5061">            nRoll = Math.min(nRoll, 12);</span>
        }
<span class="nc bnc" id="L5063" title="All 2 branches missed.">        if (nRoll &lt; 2) {</span>
<span class="nc" id="L5064">            return 0;</span>
        }

<span class="nc bnc" id="L5067" title="All 2 branches missed.">        for (int[] element : clusterHitsTable) {</span>
<span class="nc bnc" id="L5068" title="All 2 branches missed.">            if (element[0] == missiles) {</span>
<span class="nc" id="L5069">                return element[nRoll - 1];</span>
            }
        }
        // BA missiles may have larger number of missiles than max entry on the
        // table
        // if so, take largest, subtract value and try again
<span class="nc bnc" id="L5075" title="All 2 branches missed.">        for (int i = clusterHitsTable.length - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L5076" title="All 2 branches missed.">            if (missiles &gt; clusterHitsTable[i][0]) {</span>
<span class="nc" id="L5077">                return clusterHitsTable[i][nRoll - 1]</span>
<span class="nc" id="L5078">                       + Compute.missilesHit(</span>
                        missiles - clusterHitsTable[i][0], nMod,
                        hotloaded, streak, advancedAMS);
            }
        }
<span class="nc" id="L5083">        throw new RuntimeException(</span>
                &quot;Could not find number of missiles in hit table&quot;);
    }

    public static int calculateClusterHitTableAmount(int roll, int rackSize) {
<span class="nc bnc" id="L5088" title="All 2 branches missed.">        for (int[] element : clusterHitsTable) {</span>
<span class="nc bnc" id="L5089" title="All 2 branches missed.">            if (element[0] == rackSize) {</span>
<span class="nc" id="L5090">                return element[roll - 1];</span>
            }
        }

<span class="nc" id="L5094">        return 0;</span>
    }

    /**
     * Returns the consciousness roll number
     *
     * @param hit - the &lt;code&gt;int&lt;/code&gt; number of the crew hit currently being
     *            rolled.
     * @return The &lt;code&gt;int&lt;/code&gt; number that must be rolled on 2d6 for the
     * crew to stay conscious.
     */
    public static int getConsciousnessNumber(int hit) {
<span class="nc bnc" id="L5106" title="All 7 branches missed.">        switch (hit) {</span>
            case 0:
<span class="nc" id="L5108">                return 2;</span>
            case 1:
<span class="nc" id="L5110">                return 3;</span>
            case 2:
<span class="nc" id="L5112">                return 5;</span>
            case 3:
<span class="nc" id="L5114">                return 7;</span>
            case 4:
<span class="nc" id="L5116">                return 10;</span>
            case 5:
<span class="nc" id="L5118">                return 11;</span>
            default:
<span class="nc" id="L5120">                return Integer.MAX_VALUE;</span>
        }
    }

    /**
     * Check for ferrous metal content in terrain on path from a to b return the
     * total content.
     */
    public static int getMetalInPath(Entity ae, Coords a, Coords b) {
        // If we're in space, or anything is null... get out.
<span class="nc bnc" id="L5130" title="All 6 branches missed.">        if ((ae == null) || (a == null) || (b == null)) {</span>
<span class="nc" id="L5131">            return 0;</span>
        }
<span class="nc" id="L5133">        IBoard board = ae.getGame().getBoard();</span>
<span class="nc bnc" id="L5134" title="All 2 branches missed.">        if (board.inSpace()) {</span>
<span class="nc" id="L5135">            return 0;</span>
        }

<span class="nc bnc" id="L5138" title="All 4 branches missed.">        if (!board.contains(a) || !board.contains(b)) {</span>
<span class="nc" id="L5139">            return 0;</span>
        }

        // get intervening Coords.
<span class="nc" id="L5143">        ArrayList&lt;Coords&gt; coords = Coords.intervening(a, b);</span>
        // loop through all intervening coords, check each if they are ECM
        // affected
<span class="nc" id="L5146">        int metalContent = 0;</span>
<span class="nc bnc" id="L5147" title="All 2 branches missed.">        for (Coords c : coords) {</span>
<span class="nc" id="L5148">            IHex hex = board.getHex(c);</span>
<span class="nc bnc" id="L5149" title="All 4 branches missed.">            if (hex != null &amp;&amp; hex.containsTerrain(Terrains.METAL_CONTENT)) {</span>
<span class="nc" id="L5150">                metalContent += hex.terrainLevel(Terrains.METAL_CONTENT);</span>
            }
<span class="nc" id="L5152">        }</span>
<span class="nc" id="L5153">        return metalContent;</span>
    }

    /**
     * Check for ECM bubbles in Ghost Target mode along the path from a to b and
     * return the highest target roll. -1 if no Ghost Targets
     */
    public static int getGhostTargetNumber(Entity ae, Coords a, Coords b) {
<span class="nc bnc" id="L5161" title="All 2 branches missed.">        if (ae.getGame().getBoard().inSpace()) {</span>
            // ghost targets don't work in space
<span class="nc" id="L5163">            return 0;</span>
        }
<span class="nc bnc" id="L5165" title="All 4 branches missed.">        if ((a == null) || (b == null)) {</span>
<span class="nc" id="L5166">            return 0;</span>
        }

        // Only grab enemies with active ECM
        // need to create two hashtables for ghost targeting, one with mods
        // and one with booleans indicating that this ghost target was
        // intersected
        // the keys will be the entity id
<span class="nc" id="L5174">        Hashtable&lt;Integer, Boolean&gt; hEnemyGTCrossed = new Hashtable&lt;Integer, Boolean&gt;();</span>
<span class="nc" id="L5175">        Hashtable&lt;Integer, Integer&gt; hEnemyGTMods = new Hashtable&lt;Integer, Integer&gt;();</span>
<span class="nc" id="L5176">        Vector&lt;Coords&gt; vEnemyECCMCoords = new Vector&lt;Coords&gt;(16);</span>
<span class="nc" id="L5177">        Vector&lt;Integer&gt; vEnemyECCMRanges = new Vector&lt;Integer&gt;(16);</span>
<span class="nc" id="L5178">        Vector&lt;Double&gt; vEnemyECCMStrengths = new Vector&lt;Double&gt;(16);</span>
<span class="nc" id="L5179">        Vector&lt;Coords&gt; vEnemyGTCoords = new Vector&lt;Coords&gt;(16);</span>
<span class="nc" id="L5180">        Vector&lt;Integer&gt; vEnemyGTRanges = new Vector&lt;Integer&gt;(16);</span>
<span class="nc" id="L5181">        Vector&lt;Integer&gt; vEnemyGTId = new Vector&lt;Integer&gt;(16);</span>
<span class="nc" id="L5182">        Vector&lt;Coords&gt; vFriendlyECMCoords = new Vector&lt;Coords&gt;(16);</span>
<span class="nc" id="L5183">        Vector&lt;Integer&gt; vFriendlyECMRanges = new Vector&lt;Integer&gt;(16);</span>
<span class="nc" id="L5184">        Vector&lt;Double&gt; vFriendlyECMStrengths = new Vector&lt;Double&gt;(16);</span>
<span class="nc bnc" id="L5185" title="All 2 branches missed.">        for (Entity ent : ae.getGame().getEntitiesVector()) {</span>
<span class="nc" id="L5186">            Coords entPos = ent.getPosition();</span>
<span class="nc bnc" id="L5187" title="All 6 branches missed.">            if (ent.isEnemyOf(ae) &amp;&amp; ent.hasGhostTargets(true)</span>
                &amp;&amp; (entPos != null)) {
<span class="nc" id="L5189">                vEnemyGTCoords.addElement(entPos);</span>
<span class="nc" id="L5190">                vEnemyGTRanges.addElement(ent.getECMRange());</span>
<span class="nc" id="L5191">                vEnemyGTId.addElement(ent.getId());</span>
<span class="nc" id="L5192">                hEnemyGTCrossed.put(ent.getId(), false);</span>
<span class="nc" id="L5193">                hEnemyGTMods.put(ent.getId(), ent.getGhostTargetRollMoS());</span>
            }
<span class="nc bnc" id="L5195" title="All 6 branches missed.">            if (ent.isEnemyOf(ae) &amp;&amp; ent.hasActiveECCM() &amp;&amp; (entPos != null)) {</span>
<span class="nc" id="L5196">                vEnemyECCMCoords.addElement(entPos);</span>
<span class="nc" id="L5197">                vEnemyECCMRanges.addElement(ent.getECMRange());</span>
<span class="nc" id="L5198">                vEnemyECCMStrengths.add(ent.getECCMStrength());</span>
            }
<span class="nc bnc" id="L5200" title="All 6 branches missed.">            if (!ent.isEnemyOf(ae) &amp;&amp; ent.hasActiveECM() &amp;&amp; (entPos != null)) {</span>
<span class="nc" id="L5201">                vFriendlyECMCoords.addElement(entPos);</span>
<span class="nc" id="L5202">                vFriendlyECMRanges.addElement(ent.getECMRange());</span>
<span class="nc" id="L5203">                vFriendlyECMStrengths.add(ent.getECMStrength());</span>
            }

            // Check the ECM effects of the entity's passengers.
<span class="nc bnc" id="L5207" title="All 2 branches missed.">            for (Entity other : ent.getLoadedUnits()) {</span>
<span class="nc bnc" id="L5208" title="All 6 branches missed.">                if (other.isEnemyOf(ae) &amp;&amp; other.hasGhostTargets(true)</span>
                    &amp;&amp; (entPos != null)) {
<span class="nc" id="L5210">                    vEnemyGTCoords.addElement(entPos);</span>
<span class="nc" id="L5211">                    vEnemyGTRanges.addElement(other.getECMRange());</span>
<span class="nc" id="L5212">                    vEnemyGTId.addElement(ent.getId());</span>
<span class="nc" id="L5213">                    hEnemyGTCrossed.put(ent.getId(), false);</span>
<span class="nc" id="L5214">                    hEnemyGTMods.put(ent.getId(), ent.getGhostTargetRollMoS());</span>
                }
<span class="nc bnc" id="L5216" title="All 6 branches missed.">                if (other.isEnemyOf(ae) &amp;&amp; other.hasActiveECCM()</span>
                    &amp;&amp; (entPos != null)) {
<span class="nc" id="L5218">                    vEnemyECCMCoords.addElement(entPos);</span>
<span class="nc" id="L5219">                    vEnemyECCMRanges</span>
<span class="nc" id="L5220">                            .addElement(other.getECMRange());</span>
<span class="nc" id="L5221">                    vEnemyECCMStrengths.add(ent.getECCMStrength());</span>
                }
<span class="nc bnc" id="L5223" title="All 6 branches missed.">                if (!other.isEnemyOf(ae) &amp;&amp; ent.hasActiveECM()</span>
                    &amp;&amp; (entPos != null)) {
<span class="nc" id="L5225">                    vFriendlyECMCoords.addElement(entPos);</span>
<span class="nc" id="L5226">                    vFriendlyECMRanges</span>
<span class="nc" id="L5227">                            .addElement(ent.getECMRange());</span>
<span class="nc" id="L5228">                    vFriendlyECMStrengths.add(ent.getECMStrength());</span>
                }
<span class="nc" id="L5230">            }</span>
<span class="nc" id="L5231">        }</span>

        // none? get out of here
<span class="nc bnc" id="L5234" title="All 2 branches missed.">        if (vEnemyGTCoords.size() == 0) {</span>
<span class="nc" id="L5235">            return -1;</span>
        }

        // get intervening Coords.
<span class="nc" id="L5239">        ArrayList&lt;Coords&gt; coords = Coords.intervening(a, b);</span>
        // loop through all intervening coords, if they are not ecm'ed by
        // friendlys then add any Ghost Targets
        // to the hashlist
        // According to the rules clarification below ECM cancels Ghost Targets
        // http://www.classicbattletech.com/forums/index.php/topic,66035.new.html#new
<span class="nc bnc" id="L5245" title="All 2 branches missed.">        for (Coords c : coords) {</span>
            // &gt;0: in friendly ECM
            // &lt;=0: not in friendly ECM
<span class="nc" id="L5248">            int ecmStatus = 0;</span>
            // first, add 1 for each friendly ECM that affects us
<span class="nc" id="L5250">            Enumeration&lt;Integer&gt; ranges = vFriendlyECMRanges.elements();</span>
<span class="nc" id="L5251">            Enumeration&lt;Double&gt; strengths = vFriendlyECMStrengths.elements();</span>
<span class="nc bnc" id="L5252" title="All 2 branches missed.">            for (Coords friendlyECMCoords : vFriendlyECMCoords) {</span>
<span class="nc" id="L5253">                int range = ranges.nextElement().intValue();</span>
<span class="nc" id="L5254">                int nDist = c.distance(friendlyECMCoords);</span>
<span class="nc" id="L5255">                double strength = strengths.nextElement().doubleValue();</span>
<span class="nc bnc" id="L5256" title="All 2 branches missed.">                if (nDist &lt;= range) {</span>
<span class="nc" id="L5257">                    ecmStatus += strength;</span>
                }
<span class="nc" id="L5259">            }</span>
            // now, subtract one for each enemy ECCM
<span class="nc" id="L5261">            ranges = vEnemyECCMRanges.elements();</span>
<span class="nc" id="L5262">            strengths = vEnemyECCMStrengths.elements();</span>
<span class="nc bnc" id="L5263" title="All 2 branches missed.">            for (Coords enemyECCMCoords : vEnemyECCMCoords) {</span>
<span class="nc" id="L5264">                int range = ranges.nextElement().intValue();</span>
<span class="nc" id="L5265">                int nDist = c.distance(enemyECCMCoords);</span>
<span class="nc" id="L5266">                double strength = strengths.nextElement().doubleValue();</span>
<span class="nc bnc" id="L5267" title="All 2 branches missed.">                if (nDist &lt;= range) {</span>
<span class="nc" id="L5268">                    ecmStatus -= strength;</span>
                }
<span class="nc" id="L5270">            }</span>

<span class="nc bnc" id="L5272" title="All 2 branches missed.">            if (ecmStatus &lt; 1) {</span>
                // find any new Ghost Targets that we have crossed
<span class="nc" id="L5274">                ranges = vEnemyGTRanges.elements();</span>
<span class="nc" id="L5275">                Enumeration&lt;Integer&gt; ids = vEnemyGTId.elements();</span>
<span class="nc bnc" id="L5276" title="All 2 branches missed.">                for (Coords enemyGTCoords : vEnemyGTCoords) {</span>
<span class="nc" id="L5277">                    int range = ranges.nextElement().intValue();</span>
<span class="nc" id="L5278">                    int id = ids.nextElement().intValue();</span>
<span class="nc" id="L5279">                    int nDist = c.distance(enemyGTCoords);</span>
<span class="nc bnc" id="L5280" title="All 4 branches missed.">                    if ((nDist &lt;= range) &amp;&amp; !hEnemyGTCrossed.get(id)) {</span>
<span class="nc" id="L5281">                        hEnemyGTCrossed.put(id, true);</span>
                    }
<span class="nc" id="L5283">                }</span>
            }
<span class="nc" id="L5285">        }</span>

        // ok so now we have a hashtable that tells us which Ghost Targets have
        // been crossed
        // lets loop through that and identify the highest bonus and count the
        // total number crossed
<span class="nc" id="L5291">        int totalGT = -1;</span>
<span class="nc" id="L5292">        int highestMod = -1;</span>
<span class="nc" id="L5293">        Enumeration&lt;Integer&gt; ids = hEnemyGTCrossed.keys();</span>
<span class="nc bnc" id="L5294" title="All 2 branches missed.">        while (ids.hasMoreElements()) {</span>
<span class="nc" id="L5295">            int id = ids.nextElement();</span>
<span class="nc bnc" id="L5296" title="All 2 branches missed.">            if (hEnemyGTCrossed.get(id)) {</span>
<span class="nc" id="L5297">                totalGT++;</span>
<span class="nc bnc" id="L5298" title="All 2 branches missed.">                if (hEnemyGTMods.get(id) &gt; highestMod) {</span>
<span class="nc" id="L5299">                    highestMod = hEnemyGTMods.get(id);</span>
                }
            }
<span class="nc" id="L5302">        }</span>

        // according to the following rules clarification, this should be maxed
        // out at +4
        // http://www.classicbattletech.com/forums/index.php?topic=66036.0
<span class="nc" id="L5307">        return Math.min(4, highestMod + totalGT);</span>
    }

    /**
     * Get the base to-hit number of a space bomb attack by the given attacker
     * upon the given defender
     *
     * @param attacker - the &lt;code&gt;Entity&lt;/code&gt; conducting the leg attack.
     * @param defender - the &lt;code&gt;Entity&lt;/code&gt; being attacked.
     * @return The base &lt;code&gt;ToHitData&lt;/code&gt; of the attack.
     */
    public static ToHitData getSpaceBombBaseToHit(Entity attacker,
                                                  Entity defender, IGame game) {
<span class="nc" id="L5320">        int base = TargetRoll.IMPOSSIBLE;</span>
<span class="nc" id="L5321">        StringBuffer reason = new StringBuffer();</span>

<span class="nc bnc" id="L5323" title="All 2 branches missed.">        if (!attacker.isAero()) {</span>
<span class="nc" id="L5324">            return new ToHitData(base, &quot;attacker is not an Aero&quot;);</span>
        }

<span class="nc" id="L5327">        IAero a = (IAero) attacker;</span>

        // the fighters nose must be aligned with its direction of travel
<span class="nc" id="L5330">        boolean rightFacing = false;</span>
        // using normal movement, I think this means that the last move can't be
        // a turn
<span class="nc bnc" id="L5333" title="All 2 branches missed.">        if (!game.useVectorMove()) {</span>
<span class="nc" id="L5334">            rightFacing = true;</span>
        }
        // for advanced movement, it must be aligned with largest vector
<span class="nc bnc" id="L5337" title="All 2 branches missed.">        if (game.useVectorMove()) {</span>
<span class="nc bnc" id="L5338" title="All 2 branches missed.">            for (int h : attacker.getHeading()) {</span>
<span class="nc bnc" id="L5339" title="All 2 branches missed.">                if (h == attacker.facing) {</span>
<span class="nc" id="L5340">                    rightFacing = true;</span>
<span class="nc" id="L5341">                    break;</span>
                }
<span class="nc" id="L5343">            }</span>
        }

<span class="nc" id="L5346">        boolean canTarget = false;</span>
<span class="nc" id="L5347">        Coords attackCoords = null;</span>
<span class="nc bnc" id="L5348" title="All 2 branches missed.">        for (Coords c : attacker.getPassedThrough()) {</span>
<span class="nc bnc" id="L5349" title="All 2 branches missed.">            for (Entity target : game.getEntitiesVector(c)) {</span>
<span class="nc bnc" id="L5350" title="All 2 branches missed.">                if (target.getId() == defender.getId()) {</span>
<span class="nc" id="L5351">                    canTarget = true;</span>
                }
<span class="nc" id="L5353">            }</span>
<span class="nc bnc" id="L5354" title="All 2 branches missed.">            if (canTarget) {</span>
<span class="nc" id="L5355">                break;</span>
            }
<span class="nc" id="L5357">            attackCoords = c;</span>
<span class="nc" id="L5358">        }</span>
<span class="nc bnc" id="L5359" title="All 2 branches missed.">        if (null == attackCoords) {</span>
<span class="nc" id="L5360">            attackCoords = attacker.getPosition();</span>
        }

        // must be in control
<span class="nc bnc" id="L5364" title="All 2 branches missed.">        if (a.isOutControlTotal()) {</span>
<span class="nc" id="L5365">            reason.append(&quot;the attacker is out of control&quot;);</span>
<span class="nc bnc" id="L5366" title="All 2 branches missed.">        } else if (attacker.getBombs(AmmoType.F_SPACE_BOMB).size() &lt; 1) {</span>
<span class="nc" id="L5367">            reason.append(&quot;the attacker has no useable bombs&quot;);</span>
<span class="nc bnc" id="L5368" title="All 2 branches missed.">        } else if (!rightFacing) {</span>
<span class="nc" id="L5369">            reason.append(&quot;the attacker is not facing the direction of travel&quot;);</span>
        }
        // attacker and defender must both be in space hex
<span class="nc" id="L5372">        else if (!game.getBoard().getHex(attacker.getPosition())</span>
<span class="nc bnc" id="L5373" title="All 2 branches missed.">                      .containsTerrain(Terrains.SPACE)) {</span>
<span class="nc" id="L5374">            reason.append(&quot;attacker not in space hex&quot;);</span>
<span class="nc" id="L5375">        } else if (!game.getBoard().getHex(defender.getPosition())</span>
<span class="nc bnc" id="L5376" title="All 2 branches missed.">                        .containsTerrain(Terrains.SPACE)) {</span>
<span class="nc" id="L5377">            reason.append(&quot;defender not in space hex&quot;);</span>
<span class="nc bnc" id="L5378" title="All 2 branches missed.">        } else if (!canTarget) {</span>
<span class="nc" id="L5379">            reason.append(&quot;defender is not in hex passed through by attacker this turn&quot;);</span>
        }
        // the defender must weight 10000+ tons
<span class="nc bnc" id="L5382" title="All 2 branches missed.">        else if (defender.weight &lt; 10000) {</span>
<span class="nc" id="L5383">            reason.append(&quot;the defender weighs less than 10,000 tons&quot;);</span>
        }

        // ok if we are still alive then lets calculate the tohit
        else {
<span class="nc" id="L5388">            base = attacker.getCrew().getGunnery();</span>
<span class="nc" id="L5389">            reason.append(&quot;base&quot;);</span>
        }

<span class="nc" id="L5392">        ToHitData toHit = new ToHitData(base, reason.toString(),</span>
<span class="nc" id="L5393">                                        ToHitData.HIT_NORMAL, defender.sideTable(attackCoords));</span>

<span class="nc" id="L5395">        toHit.addModifier(+4, &quot;space bomb attack&quot;);</span>
<span class="nc bnc" id="L5396" title="All 2 branches missed.">        if (attacker.mpUsed &gt; 0) {</span>
<span class="nc" id="L5397">            toHit.addModifier(attacker.mpUsed, &quot;attacker thrust&quot;);</span>
        }
<span class="nc bnc" id="L5399" title="All 2 branches missed.">        if (defender.mpUsed &gt; 0) {</span>
<span class="nc" id="L5400">            toHit.addModifier(defender.mpUsed, &quot;defender thrust&quot;);</span>
        }
<span class="nc bnc" id="L5402" title="All 4 branches missed.">        if ((defender instanceof SpaceStation) || (defender.getWalkMP() == 0)) {</span>
<span class="nc" id="L5403">            toHit.addModifier(-4, &quot;immobile&quot;);</span>
        }
<span class="nc bnc" id="L5405" title="All 2 branches missed.">        if (defender.weight &lt; 100000) {</span>
<span class="nc" id="L5406">            int penalty = (int) Math.ceil((100000 - defender.weight) / 10000);</span>
<span class="nc" id="L5407">            toHit.addModifier(penalty, &quot;defender weight&quot;);</span>
        }

<span class="nc" id="L5410">        return toHit;</span>
    }

    private static ToHitData getAntiMechMods(ToHitData data, Infantry attacker,
                                             Entity defender) {
<span class="nc bnc" id="L5415" title="All 2 branches missed.">        if (attacker == null) {</span>
<span class="nc" id="L5416">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Unknown attacker&quot;);</span>
<span class="nc" id="L5417">            return data;</span>
        }
<span class="nc bnc" id="L5419" title="All 2 branches missed.">        if (defender == null) {</span>
<span class="nc" id="L5420">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Unknown defender&quot;);</span>
<span class="nc" id="L5421">            return data;</span>
        }

<span class="nc bnc" id="L5424" title="All 2 branches missed.">        if (attacker instanceof BattleArmor) {</span>
            // Battle Armor units can't do an AM Attack if they're burdened.
<span class="nc bnc" id="L5426" title="All 2 branches missed.">            if (((BattleArmor) attacker).isBurdened()) {</span>
<span class="nc" id="L5427">                data.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                 &quot;Launcher not jettisoned.&quot;);
<span class="nc" id="L5429">                return data;</span>
            }
            // BA units that jumped using mechanical jump boosters can't attack
<span class="nc bnc" id="L5432" title="All 2 branches missed.">            if (attacker.hasWorkingMisc(MiscType.F_MECHANICAL_JUMP_BOOSTER)</span>
                // we used a mechanical jump booster for jumping only if we
                // don't have normal JJs, or if we are underwater-capable
                // because we underwatercapable BAs can only jump via
                // mechanical jump boosters
                // otherwise, normal JJs give the same MP and do not have
                // this restriction
<span class="nc bnc" id="L5439" title="All 2 branches missed.">                &amp;&amp; ((attacker.getOriginalJumpMP() == 0) || (attacker</span>
<span class="nc bnc" id="L5440" title="All 4 branches missed.">                                                                    .getMovementMode() == EntityMovementMode.INF_UMU))</span>
                &amp;&amp; (attacker.moved == EntityMovementType.MOVE_JUMP)) {
<span class="nc" id="L5442">                data.addModifier(</span>
                        TargetRoll.IMPOSSIBLE,
                        &quot;can't jump using mechanical jump booster and anti-mech attack in the same turn&quot;);
<span class="nc" id="L5445">                return data;</span>
            }
        } else {
            // Infantry can't have encumbering armor
<span class="nc bnc" id="L5449" title="All 2 branches missed.">            if (attacker.isArmorEncumbering()) {</span>
<span class="nc" id="L5450">                data.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                 &quot;can't engage in anti-mek attacks with encumbering armor.&quot;);
<span class="nc" id="L5452">                return data;</span>
            }
        }

        // Can't target a transported entity.
<span class="nc bnc" id="L5457" title="All 2 branches missed.">        if (Entity.NONE != defender.getTransportId()) {</span>
<span class="nc" id="L5458">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Target is a passenger.&quot;);</span>
<span class="nc" id="L5459">            return data;</span>
        }

<span class="nc bnc" id="L5462" title="All 2 branches missed.">        if (defender.isMakingDfa()) {</span>
<span class="nc" id="L5463">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Target is making a DFA.&quot;);</span>
<span class="nc" id="L5464">            return data;</span>
        }

        // Already conducting a swarm attack.
<span class="nc bnc" id="L5468" title="All 2 branches missed.">        if (Entity.NONE != attacker.getSwarmTargetId()) {</span>
<span class="nc" id="L5469">            data.addModifier(TargetRoll.IMPOSSIBLE,</span>
                             &quot;Attacker is currently swarming.&quot;);
<span class="nc" id="L5471">            return data;</span>
        }

<span class="nc bnc" id="L5474" title="All 4 branches missed.">        if ((defender instanceof Mech) &amp;&amp; ((Mech) defender).isIndustrial()) {</span>
<span class="nc" id="L5475">            data.addModifier(-1, &quot;targeting industrial mech&quot;);</span>
        }

        // protected/exposed actuator quirk may adjust target roll
<span class="nc bnc" id="L5479" title="All 2 branches missed.">        if (defender.hasQuirk(OptionsConstants.QUIRK_POS_PRO_ACTUATOR)) {</span>
<span class="nc" id="L5480">            data.addModifier(+1, &quot;protected actuators&quot;);</span>
        }
<span class="nc bnc" id="L5482" title="All 2 branches missed.">        if (defender.hasQuirk(OptionsConstants.QUIRK_NEG_EXP_ACTUATOR)) {</span>
<span class="nc" id="L5483">            data.addModifier(-1, &quot;exposed actuators&quot;);</span>
        }

        // MD Infantry with grappler/magnets get bonus
<span class="nc bnc" id="L5487" title="All 2 branches missed.">        if (attacker.hasAbility(OptionsConstants.MD_PL_ENHANCED)) {</span>
<span class="nc" id="L5488">            data.addModifier(-2, &quot;MD Grapple/Magnet&quot;);</span>
        }

<span class="nc" id="L5491">        return data;</span>
    }

    /**
     * Get the base to-hit number of a Leg Attack by the given attacker upon the
     * given defender
     *
     * @param attacker - the &lt;code&gt;Entity&lt;/code&gt; conducting the leg attack.
     * @param defender - the &lt;code&gt;Entity&lt;/code&gt; being attacked.
     * @return The base &lt;code&gt;ToHitData&lt;/code&gt; of the attack.
     */
    public static ToHitData getLegAttackBaseToHit(Entity attacker,
            Entity defender, IGame game) {
<span class="nc" id="L5504">        String reason = &quot;Non Infantry not allowed to do AM attacks.&quot;;</span>
<span class="nc" id="L5505">        ToHitData toReturn = null;</span>
<span class="nc" id="L5506">        boolean alreadyPerformingOther = false;</span>
<span class="nc" id="L5507">        for (Enumeration&lt;EntityAction&gt; actions = game.getActions(); actions</span>
<span class="nc bnc" id="L5508" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L5509">            EntityAction ea = actions.nextElement();</span>
<span class="nc bnc" id="L5510" title="All 2 branches missed.">            if (ea instanceof WeaponAttackAction) {</span>
<span class="nc" id="L5511">                WeaponAttackAction waa = (WeaponAttackAction) ea;</span>
<span class="nc" id="L5512">                Entity waaAE = waa.getEntity(game);</span>
<span class="nc bnc" id="L5513" title="All 4 branches missed.">                if ((waaAE != null) &amp;&amp; waaAE.equals(attacker)) {</span>
                    // impossible if already doing a swarm attack
<span class="nc" id="L5515">                    if (waa.getEntity(game).getEquipment(waa.getWeaponId())</span>
<span class="nc" id="L5516">                           .getType().getInternalName()</span>
<span class="nc bnc" id="L5517" title="All 2 branches missed.">                           .equals(Infantry.SWARM_MEK)) {</span>
<span class="nc" id="L5518">                        alreadyPerformingOther = true;</span>

                    }
                }
            }
<span class="nc" id="L5523">        }</span>

<span class="nc bnc" id="L5525" title="All 2 branches missed.">        if (alreadyPerformingOther) {</span>
<span class="nc" id="L5526">            reason = &quot;already performing a swarm attack&quot;;</span>
        }
        // Can only attack a Mek's legs.
<span class="nc bnc" id="L5529" title="All 2 branches missed.">        else if (!(defender instanceof Mech)) {</span>
<span class="nc" id="L5530">            reason = &quot;Defender is not a Mech.&quot;;</span>
        }

        // Can't attack if flying
<span class="nc bnc" id="L5534" title="All 2 branches missed.">        else if (attacker.getElevation() &gt; defender.getElevation()) {</span>
<span class="nc" id="L5535">            reason = &quot;Cannot do leg attack while flying.&quot;;</span>
        }

        // Handle BattleArmor attackers.
<span class="nc bnc" id="L5539" title="All 2 branches missed.">        else if (attacker instanceof BattleArmor) {</span>
<span class="nc" id="L5540">            BattleArmor inf = (BattleArmor) attacker;</span>
<span class="nc" id="L5541">            toReturn = new ToHitData(inf.getCrew().getPiloting(),</span>
                    &quot;anti-mech skill&quot;, ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
<span class="nc" id="L5543">            int men = inf.getShootingStrength();</span>
<span class="nc" id="L5544">            int modifier = TargetRoll.IMPOSSIBLE;</span>
<span class="nc bnc" id="L5545" title="All 2 branches missed.">            if (men &gt;= 4) {</span>
<span class="nc" id="L5546">                modifier = 0;</span>
<span class="nc bnc" id="L5547" title="All 2 branches missed.">            } else if (men &gt;= 3) {</span>
<span class="nc" id="L5548">                modifier = 2;</span>
<span class="nc bnc" id="L5549" title="All 2 branches missed.">            } else if (men &gt;= 2) {</span>
<span class="nc" id="L5550">                modifier = 5;</span>
<span class="nc bnc" id="L5551" title="All 2 branches missed.">            } else if (men &gt;= 1) {</span>
<span class="nc" id="L5552">                modifier = 7;</span>
            }
<span class="nc" id="L5554">            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</span>
<span class="nc bnc" id="L5555" title="All 2 branches missed.">        } else if (attacker instanceof Infantry) {</span>
            // Non-BattleArmor infantry need many more men.
<span class="nc" id="L5557">            Infantry inf = (Infantry) attacker;</span>
<span class="nc" id="L5558">            toReturn = new ToHitData(inf.getCrew().getPiloting(),</span>
                    &quot;anti-mech skill&quot;, ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
<span class="nc" id="L5560">            int men = inf.getShootingStrength();</span>
<span class="nc" id="L5561">            int modifier = TargetRoll.IMPOSSIBLE;</span>
<span class="nc bnc" id="L5562" title="All 2 branches missed.">            if (men &gt;= 22) {</span>
<span class="nc" id="L5563">                modifier = 0;</span>
<span class="nc bnc" id="L5564" title="All 2 branches missed.">            } else if (men &gt;= 16) {</span>
<span class="nc" id="L5565">                modifier = 2;</span>
<span class="nc bnc" id="L5566" title="All 2 branches missed.">            } else if (men &gt;= 10) {</span>
<span class="nc" id="L5567">                modifier = 5;</span>
<span class="nc bnc" id="L5568" title="All 2 branches missed.">            } else if (men &gt;= 5) {</span>
<span class="nc" id="L5569">                modifier = 7;</span>
            }
<span class="nc" id="L5571">            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</span>
        }

<span class="nc bnc" id="L5574" title="All 4 branches missed.">        if (defender instanceof Mech &amp;&amp; ((Mech)defender).hasTracks()) {</span>
<span class="nc" id="L5575">            toReturn.addModifier(-2, &quot;has tracks&quot;);</span>
        }

        // If the swarm is impossible, ToHitData wasn't created
<span class="nc bnc" id="L5579" title="All 2 branches missed.">        if (toReturn == null) {</span>
<span class="nc" id="L5580">            toReturn = new ToHitData(TargetRoll.IMPOSSIBLE, reason.toString(),</span>
                    ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
        }
<span class="nc bnc" id="L5583" title="All 2 branches missed.">        if (toReturn.getValue() == TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5584">            return toReturn;</span>
        }
<span class="nc" id="L5586">        toReturn = Compute.getAntiMechMods(toReturn, (Infantry) attacker,</span>
                defender);
<span class="nc" id="L5588">        return toReturn;</span>
    }

    /**
     * Get the base to-hit number of a Swarm Mek by the given attacker upon the
     * given defender.
     *
     * @param attacker - the &lt;code&gt;Entity&lt;/code&gt; swarming.
     * @param defender - the &lt;code&gt;Entity&lt;/code&gt; being swarmed.
     * @return The base &lt;code&gt;ToHitData&lt;/code&gt; of the mek.
     */
    public static ToHitData getSwarmMekBaseToHit(Entity attacker,
            Entity defender, IGame game) {
<span class="nc" id="L5601">        ToHitData toReturn = null;</span>
<span class="nc" id="L5602">        String reason = &quot;Non Infantry not allowed to do AM attacks.&quot;;</span>

<span class="nc" id="L5604">        boolean alreadyPerformingOther = false;</span>
<span class="nc" id="L5605">        for (Enumeration&lt;EntityAction&gt; actions = game.getActions(); actions</span>
<span class="nc bnc" id="L5606" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L5607">            EntityAction ea = actions.nextElement();</span>
<span class="nc bnc" id="L5608" title="All 2 branches missed.">            if (ea instanceof WeaponAttackAction) {</span>
<span class="nc" id="L5609">                WeaponAttackAction waa = (WeaponAttackAction) ea;</span>
<span class="nc" id="L5610">                Entity waaAE = waa.getEntity(game);</span>
<span class="nc bnc" id="L5611" title="All 4 branches missed.">                if ((waaAE != null) &amp;&amp; waaAE.equals(attacker)) {</span>
                    // impossible if already doing a swarm attack
<span class="nc" id="L5613">                    if (waa.getEntity(game).getEquipment(waa.getWeaponId())</span>
<span class="nc" id="L5614">                           .getType().getInternalName()</span>
<span class="nc bnc" id="L5615" title="All 2 branches missed.">                           .equals(Infantry.LEG_ATTACK)) {</span>
<span class="nc" id="L5616">                        alreadyPerformingOther = true;</span>

                    }
                }
            }
<span class="nc" id="L5621">        }</span>
<span class="nc bnc" id="L5622" title="All 2 branches missed.">        if (alreadyPerformingOther) {</span>
<span class="nc" id="L5623">            reason = &quot;attacker is already performing a leg attack&quot;;</span>
        }
        // Can only swarm a Mek.
<span class="nc bnc" id="L5626" title="All 4 branches missed.">        else if (!(defender instanceof Mech) &amp;&amp; !(defender instanceof Tank)) {</span>
<span class="nc" id="L5627">            reason = &quot;Defender is not a Mech or vehicle.&quot;;</span>
        }
        // Can't swarm a friendly Mek. See
        // http://www.classicbattletech.com/w3t/showflat
        // .php?Cat=&amp;Board=ask&amp;Number=632321&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0&amp;fpart=
<span class="nc bnc" id="L5632" title="All 2 branches missed.">        else if (!attacker.isEnemyOf(defender)</span>
<span class="nc" id="L5633">                 &amp;&amp; !attacker.getGame().getOptions()</span>
<span class="nc bnc" id="L5634" title="All 2 branches missed.">                             .booleanOption(OptionsConstants.BASE_FRIENDLY_FIRE)) {</span>
<span class="nc" id="L5635">            reason = &quot;Can only swarm an enemy.&quot;;</span>
        }
        // target is already swarmed
<span class="nc bnc" id="L5638" title="All 2 branches missed.">        else if (defender.getSwarmAttackerId() != Entity.NONE) {</span>
<span class="nc" id="L5639">            reason = &quot;Only one swarm allowed at a time.&quot;;</span>
        }
        // Handle BattleArmor attackers.
<span class="nc bnc" id="L5642" title="All 2 branches missed.">        else if (attacker instanceof BattleArmor) {</span>
<span class="nc" id="L5643">            BattleArmor inf = (BattleArmor) attacker;</span>
<span class="nc" id="L5644">            toReturn = new ToHitData(inf.getCrew().getPiloting(), &quot;anti-mech skill&quot;);</span>
<span class="nc" id="L5645">            int men = inf.getShootingStrength();</span>
<span class="nc" id="L5646">            int modifier = TargetRoll.IMPOSSIBLE;</span>
<span class="nc bnc" id="L5647" title="All 2 branches missed.">            if (men &gt;= 4) {</span>
<span class="nc" id="L5648">                modifier = 2;</span>
<span class="nc bnc" id="L5649" title="All 2 branches missed.">            } else if (men &gt;= 1) {</span>
<span class="nc" id="L5650">                modifier = 5;</span>
            }
<span class="nc" id="L5652">            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</span>
<span class="nc" id="L5653">        }</span>
        // Non-BattleArmor infantry need many more men.
<span class="nc bnc" id="L5655" title="All 2 branches missed.">        else if (attacker instanceof Infantry) {</span>
<span class="nc" id="L5656">            Infantry inf = (Infantry) attacker;</span>
<span class="nc" id="L5657">            toReturn = new ToHitData(inf.getCrew().getPiloting(), &quot;anti-mech skill&quot;);</span>
<span class="nc" id="L5658">            int men = inf.getShootingStrength();</span>
<span class="nc" id="L5659">            int modifier = TargetRoll.IMPOSSIBLE;</span>
<span class="nc bnc" id="L5660" title="All 2 branches missed.">            if (men &gt;= 22) {</span>
<span class="nc" id="L5661">                modifier = 2;</span>
<span class="nc bnc" id="L5662" title="All 2 branches missed.">            } else if (men &gt;= 16) {</span>
<span class="nc" id="L5663">                modifier = 5;</span>
            }
<span class="nc" id="L5665">            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</span>
        }
        // If the swarm is impossible, ToHitData wasn't created
<span class="nc bnc" id="L5668" title="All 2 branches missed.">        if (toReturn == null) {</span>
<span class="nc" id="L5669">            toReturn = new ToHitData(TargetRoll.IMPOSSIBLE, reason.toString());</span>
        }
<span class="nc bnc" id="L5671" title="All 2 branches missed.">        if (toReturn.getValue() == TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5672">            return toReturn;</span>
        }
<span class="nc" id="L5674">        toReturn = Compute.getAntiMechMods(toReturn, (Infantry) attacker,</span>
                                           defender);

        // If the attacker has assault claws, give a -1 modifier.
        // We can stop looking when we find our first match.
<span class="nc bnc" id="L5679" title="All 2 branches missed.">        for (Mounted mount : attacker.getMisc()) {</span>
<span class="nc" id="L5680">            EquipmentType equip = mount.getType();</span>
<span class="nc bnc" id="L5681" title="All 2 branches missed.">            if (equip.hasFlag(MiscType.F_MAGNET_CLAW)) {</span>
<span class="nc" id="L5682">                toReturn.addModifier(-1, &quot;attacker has magnetic claws&quot;);</span>
<span class="nc" id="L5683">                break;</span>
            }
<span class="nc" id="L5685">        }</span>
<span class="nc" id="L5686">        return toReturn;</span>
    }

    public static boolean canPhysicalTarget(IGame game, int entityId,
                                            Targetable target) {

<span class="nc" id="L5692">        if (PunchAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5693" title="All 2 branches missed.">                                    PunchAttackAction.LEFT, false).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5694">            return true;</span>
        }

<span class="nc" id="L5697">        if (PunchAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5698" title="All 2 branches missed.">                                    PunchAttackAction.RIGHT, false).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5699">            return true;</span>
        }

<span class="nc" id="L5702">        if (KickAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5703" title="All 2 branches missed.">                                   KickAttackAction.LEFT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5704">            return true;</span>
        }

<span class="nc" id="L5707">        if (KickAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5708" title="All 2 branches missed.">                                   KickAttackAction.RIGHT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5709">            return true;</span>
        }

<span class="nc bnc" id="L5712" title="All 2 branches missed.">        if ((game.getEntity(entityId) instanceof QuadMech)</span>
<span class="nc" id="L5713">            &amp;&amp; ((KickAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5714" title="All 2 branches missed.">                                        KickAttackAction.LEFTMULE).getValue() != TargetRoll.IMPOSSIBLE) ||</span>
                (KickAttackAction
<span class="nc" id="L5716">                         .toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5717" title="All 2 branches missed.">                                KickAttackAction.RIGHTMULE).getValue() != TargetRoll.IMPOSSIBLE))) {</span>
<span class="nc" id="L5718">            return true;</span>
        }

<span class="nc" id="L5721">        if (BrushOffAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5722" title="All 2 branches missed.">                                       BrushOffAttackAction.LEFT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5723">            return true;</span>
        }

<span class="nc" id="L5726">        if (BrushOffAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5727" title="All 2 branches missed.">                                       BrushOffAttackAction.RIGHT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5728">            return true;</span>
        }

<span class="nc bnc" id="L5731" title="All 2 branches missed.">        if (new ThrashAttackAction(entityId, target).toHit(game).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5732">            return true;</span>
        }

<span class="nc" id="L5735">        if (ProtomechPhysicalAttackAction.toHit(game, entityId, target)</span>
<span class="nc bnc" id="L5736" title="All 2 branches missed.">                                         .getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5737">            return true;</span>
        }

<span class="nc bnc" id="L5740" title="All 2 branches missed.">        if (PushAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5741">            return true;</span>
        }

<span class="nc bnc" id="L5744" title="All 2 branches missed.">        if (LayExplosivesAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5745">            return true;</span>
        }

<span class="nc bnc" id="L5748" title="All 2 branches missed.">        if (TripAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5749">            return true;</span>
        }

<span class="nc bnc" id="L5752" title="All 2 branches missed.">        if (GrappleAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5753">            return true;</span>
        }

<span class="nc bnc" id="L5756" title="All 2 branches missed.">        if (BreakGrappleAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5757">            return true;</span>
        }

<span class="nc bnc" id="L5760" title="All 2 branches missed.">        for (Mounted club : game.getEntity(entityId).getClubs()) {</span>
<span class="nc bnc" id="L5761" title="All 2 branches missed.">            if (null != club) {</span>
<span class="nc" id="L5762">                if (ClubAttackAction.toHit(game, entityId, target, club,</span>
<span class="nc bnc" id="L5763" title="All 2 branches missed.">                                           ToHitData.HIT_NORMAL, false).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5764">                    return true;</span>
                }
            }
<span class="nc" id="L5767">        }</span>

<span class="nc" id="L5769">        if (JumpJetAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5770" title="All 2 branches missed.">                                      JumpJetAttackAction.BOTH).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5771">            return true;</span>
        }
<span class="nc" id="L5773">        if (JumpJetAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5774" title="All 2 branches missed.">                                      JumpJetAttackAction.LEFT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5775">            return true;</span>
        }
<span class="nc" id="L5777">        if (JumpJetAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5778" title="All 2 branches missed.">                                      JumpJetAttackAction.RIGHT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5779">            return true;</span>
        }

<span class="nc bnc" id="L5782" title="All 2 branches missed.">        if (BAVibroClawAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5783">            return true;</span>
        }

<span class="nc" id="L5786">        return false;</span>
    }

    /**
     * Can movement between the two coordinates be on pavement (which includes
     * roads and bridges)? If so it will override prohibited terrain, it may
     * change movement costs, and it may lead to skids.
     *
     * @param game     - the &lt;code&gt;IGame&lt;/code&gt; object.
     * @param src      - the &lt;code&gt;Coords&lt;/code&gt; being left.
     * @param dest     - the &lt;code&gt;Coords&lt;/code&gt; being entered.
     * @param moveStep
     * @return &lt;code&gt;true&lt;/code&gt; if movement between &lt;code&gt;src&lt;/code&gt; and
     * &lt;code&gt;dest&lt;/code&gt; can be on pavement; &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     */
    public static boolean canMoveOnPavement(IGame game, Coords src,
            Coords dest, MoveStep moveStep) {
<span class="nc" id="L5804">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L5805">        final IHex destHex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L5806">        final int src2destDir = src.direction(dest);</span>
<span class="nc" id="L5807">        final int dest2srcDir = (src2destDir + 3) % 6;</span>
<span class="nc" id="L5808">        boolean result = false;</span>

        // Jumping shouldn't be considered to be moving on pavement
<span class="nc bnc" id="L5811" title="All 2 branches missed.">        if (moveStep.isJumping()) {</span>
<span class="nc" id="L5812">            return false;</span>
        }

        // We may be moving in the same hex.
<span class="nc bnc" id="L5816" title="All 2 branches missed.">        if (src.equals(dest)</span>
<span class="nc bnc" id="L5817" title="All 2 branches missed.">                &amp;&amp; (srcHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L5818" title="All 2 branches missed.">                        || srcHex.containsTerrain(Terrains.ROAD) || srcHex</span>
<span class="nc bnc" id="L5819" title="All 2 branches missed.">                            .containsTerrain(Terrains.BRIDGE))) {</span>
<span class="nc" id="L5820">            result = true;</span>
        }
        // If the source is a pavement hex, then see if the destination
        // hex is also a pavement hex or has a road or bridge that exits
        // into the source hex and the entity is climbing onto the bridge.
<span class="nc bnc" id="L5825" title="All 2 branches missed.">        else if (srcHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L5826" title="All 2 branches missed.">                &amp;&amp; (destHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L5827" title="All 2 branches missed.">                        || destHex.containsTerrainExit(Terrains.ROAD,</span>
<span class="nc bnc" id="L5828" title="All 2 branches missed.">                                dest2srcDir) || (destHex.containsTerrainExit(</span>
<span class="nc bnc" id="L5829" title="All 2 branches missed.">                        Terrains.BRIDGE, dest2srcDir) &amp;&amp; moveStep.climbMode()))) {</span>
<span class="nc" id="L5830">            result = true;</span>
        }
        // See if the source hex has a road or bridge (and the entity is on the
        // bridge) that exits into the destination hex, and the dest hex has
        // pavement or a corresponding exit to the src hex
<span class="nc bnc" id="L5835" title="All 2 branches missed.">        else if ((srcHex.containsTerrainExit(Terrains.ROAD, src2destDir) || (srcHex</span>
<span class="nc bnc" id="L5836" title="All 2 branches missed.">                .containsTerrainExit(Terrains.BRIDGE, src2destDir) &amp;&amp; (moveStep.getElevation() == srcHex</span>
<span class="nc bnc" id="L5837" title="All 2 branches missed.">                .terrainLevel(Terrains.BRIDGE_ELEV))))</span>
<span class="nc bnc" id="L5838" title="All 2 branches missed.">                &amp;&amp; (destHex.containsTerrainExit(Terrains.ROAD, dest2srcDir)</span>
<span class="nc bnc" id="L5839" title="All 2 branches missed.">                        || (destHex.containsTerrainExit(Terrains.BRIDGE,</span>
<span class="nc bnc" id="L5840" title="All 2 branches missed.">                                dest2srcDir) &amp;&amp; moveStep.climbMode()) || destHex</span>
<span class="nc bnc" id="L5841" title="All 2 branches missed.">                            .containsTerrain(Terrains.PAVEMENT))) {</span>
<span class="nc" id="L5842">            result = true;</span>
        }

<span class="nc" id="L5845">        return result;</span>
    }

    /**
     * Determines whether the attacker and the target are in the same building.
     *
     * @return true if the target can and does occupy the same building, false
     *         otherwise.
     */
    public static boolean isInSameBuilding(IGame game, Entity attacker,
            Targetable target) {
<span class="nc bnc" id="L5856" title="All 2 branches missed.">        if (!(target instanceof Entity)) {</span>
<span class="nc" id="L5857">            return false;</span>
        }
<span class="nc" id="L5859">        Entity targetEntity = (Entity) target;</span>
<span class="nc bnc" id="L5860" title="All 2 branches missed.">        if (!Compute.isInBuilding(game, attacker)</span>
<span class="nc bnc" id="L5861" title="All 2 branches missed.">                || !Compute.isInBuilding(game, targetEntity)) {</span>
<span class="nc" id="L5862">            return false;</span>
        }

<span class="nc" id="L5865">        Building attkBldg = game.getBoard().getBuildingAt(</span>
<span class="nc" id="L5866">                attacker.getPosition());</span>
<span class="nc" id="L5867">        Building targBldg = game.getBoard().getBuildingAt(target.getPosition());</span>

<span class="nc" id="L5869">        return attkBldg.equals(targBldg);</span>
    }

    /**
     * Determine if the given unit is inside of a building at the given
     * coordinates.
     *
     * @param game   - the &lt;code&gt;IGame&lt;/code&gt; object. This value may be
     *               &lt;code&gt;null&lt;/code&gt;.
     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; to be checked. This value may be
     *               &lt;code&gt;null&lt;/code&gt;.
     * @return &lt;code&gt;true&lt;/code&gt; if the entity is inside of the building at
     * those coordinates. &lt;code&gt;false&lt;/code&gt; if there is no building at
     * those coordinates or if the entity is on the roof or in the air
     * above the building, or if any input argument is &lt;code&gt;null&lt;/code&gt;
     * .
     */
    public static boolean isInBuilding(IGame game, Entity entity) {

        // No game, no building.
<span class="nc bnc" id="L5889" title="All 2 branches missed.">        if (game == null) {</span>
<span class="nc" id="L5890">            return false;</span>
        }

        // Null entities can't be in a building.
<span class="nc bnc" id="L5894" title="All 2 branches missed.">        if (entity == null) {</span>
<span class="nc" id="L5895">            return false;</span>
        }

        // Call the version of the function that requires coordinates.
<span class="nc" id="L5899">        return Compute.isInBuilding(game, entity, entity.getPosition());</span>
    }

    /**
     * Determine if the given unit is inside of a building at the given
     * coordinates.
     *
     * @param game   - the &lt;code&gt;IGame&lt;/code&gt; object. This value may be
     *               &lt;code&gt;null&lt;/code&gt;.
     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; to be checked. This value may be
     *               &lt;code&gt;null&lt;/code&gt;.
     * @param coords - the &lt;code&gt;Coords&lt;/code&gt; of the building hex. This value may
     *               be &lt;code&gt;null&lt;/code&gt;.
     * @return &lt;code&gt;true&lt;/code&gt; if the entity is inside of the building at
     * those coordinates. &lt;code&gt;false&lt;/code&gt; if there is no building at
     * those coordinates or if the entity is on the roof or in the air
     * above the building, or if any input argument is &lt;code&gt;null&lt;/code&gt;
     * .
     */
    public static boolean isInBuilding(IGame game, Entity entity, Coords coords) {

        // No game, no building.
<span class="nc bnc" id="L5921" title="All 2 branches missed.">        if (game == null) {</span>
<span class="nc" id="L5922">            return false;</span>
        }

        // Null entities can't be in a building.
<span class="nc bnc" id="L5926" title="All 2 branches missed.">        if (entity == null) {</span>
<span class="nc" id="L5927">            return false;</span>
        }

        // Null coordinates can't have buildings.
<span class="nc bnc" id="L5931" title="All 2 branches missed.">        if (coords == null) {</span>
<span class="nc" id="L5932">            return false;</span>
        }

        // Get the Hex at those coordinates.

<span class="nc" id="L5937">        return Compute.isInBuilding(game, entity.getElevation(), coords);</span>
    }

    public static boolean isInBuilding(IGame game, int entityElev, Coords coords) {

        // Get the Hex at those coordinates.
<span class="nc" id="L5943">        final IHex curHex = game.getBoard().getHex(coords);</span>

<span class="nc bnc" id="L5945" title="All 2 branches missed.">        if (curHex == null) {</span>
            // probably off board artillery or reinforcement
<span class="nc" id="L5947">            return false;</span>
        }

        // The entity can't be inside of a building that isn't there.
<span class="nc bnc" id="L5951" title="All 2 branches missed.">        if (!curHex.containsTerrain(Terrains.BLDG_ELEV)) {</span>
<span class="nc" id="L5952">            return false;</span>
        }

        // The entity can't be inside of a building that isn't there.
<span class="nc bnc" id="L5956" title="All 2 branches missed.">        if (!curHex.containsTerrain(Terrains.BUILDING)) {</span>
<span class="nc" id="L5957">            return false;</span>
        }

        // Get the elevations occupied by the building.
<span class="nc" id="L5961">        int bldgHeight = curHex.terrainLevel(Terrains.BLDG_ELEV);</span>
<span class="nc" id="L5962">        int basement = 0;</span>
<span class="nc bnc" id="L5963" title="All 2 branches missed.">        if (curHex.containsTerrain(Terrains.BLDG_BASEMENT_TYPE)) {</span>
<span class="nc" id="L5964">            basement = BasementType.getType(</span>
<span class="nc" id="L5965">                    curHex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE))</span>
<span class="nc" id="L5966">                                   .getDepth();</span>
        }

        // Return true if the entity is in the range of building elevations.
<span class="nc bnc" id="L5970" title="All 4 branches missed.">        if ((entityElev &gt;= (-basement)) &amp;&amp; (entityElev &lt; (bldgHeight))) {</span>
<span class="nc" id="L5971">            return true;</span>
        }

        // Entity is not *inside* of the building.
<span class="nc" id="L5975">        return false;</span>
    }

    /**
     * Scatter from hex according to dive bombing rules (based on MoF),
     * TW pg 246.  The scatter can happen in any direction.
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param moF The margin of failure, which deterimines scatter distance
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to and distance (moF)
     */
    public static Coords scatterDiveBombs(Coords coords, int moF) {
<span class="nc" id="L5987">        return Compute.scatter(coords, moF);</span>
    }

    /**
     * Scatter from hex according to altitude bombing rules (based on MoF),
     * TW pg 246.  The scatter only happens in the &quot;front&quot; three facings.
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param facing
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to and distance (moF)
     */
    public static Coords scatterAltitudeBombs(Coords coords, int facing) {
<span class="nc" id="L5999">        int dir = 0;</span>
<span class="nc" id="L6000">        int scatterDirection = Compute.d6(1);</span>
<span class="nc bnc" id="L6001" title="All 4 branches missed.">        switch (scatterDirection) {</span>
            case 1:
            case 2:
<span class="nc" id="L6004">                dir = (facing - 1) % 6;</span>
<span class="nc" id="L6005">                break;</span>
            case 3:
            case 4:
<span class="nc" id="L6008">                dir = facing;</span>
<span class="nc" id="L6009">                break;</span>
            case 5:
            case 6:
<span class="nc" id="L6012">                dir = (facing + 1) % 6;</span>
                break;
        }
<span class="nc" id="L6015">        int dist = Compute.d6(1);</span>
<span class="nc" id="L6016">        return coords.translated(dir, dist);</span>
    }

    /**
     * scatter from hex according to direct fire artillery rules (based on MoF)
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param moF The margin of failure, which deterimines scatter distance
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to
     */
    public static Coords scatterDirectArty(Coords coords, int moF) {
<span class="nc" id="L6027">        return Compute.scatter(coords, moF);</span>
    }

    /**
     * scatter from a hex according, roll d6 to choose scatter direction
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param margin the &lt;code&gt;int&lt;/code&gt; margin of failure, scatter distance will
     *               be the margin of failure
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to
     */
    public static Coords scatter(Coords coords, int margin) {
<span class="nc" id="L6039">        int scatterDirection = Compute.d6(1) - 1;</span>
<span class="nc" id="L6040">        return coords.translated(scatterDirection, margin);</span>
    }

    /**
     * scatter from hex according to atmospheric drop rules d6 for direction,
     * 1d6 per point of MOF
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param margin the &lt;code&gt;int&lt;/code&gt; margin of failure
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to
     */
    public static Coords scatterAssaultDrop(Coords coords, int margin) {
<span class="nc" id="L6052">        int scatterDirection = Compute.d6(1) - 1;</span>
<span class="nc" id="L6053">        int distance = Compute.d6(margin);</span>
<span class="nc" id="L6054">        return coords.translated(scatterDirection, distance);</span>
    }

    /**
     * Gets a new target for a flight of swarm missiles that was just shot at an
     * entity and has missiles left
     *
     * @param game
     * @param aeId     The attacking &lt;code&gt;Entity&lt;/code&gt;
     * @param coords
     * @param weaponId The &lt;code&gt;int&lt;/code&gt; ID of the launcher used to fire this
     *                 volley
     * @return the new target &lt;code&gt;Entity&lt;/code&gt;. May return null if no new
     * target available
     */
    public static Entity getSwarmMissileTarget(IGame game, int aeId,
                                               Coords coords, int weaponId) {
<span class="nc" id="L6071">        Entity tempEntity = null;</span>
        // first, check the hex of the original target
<span class="nc" id="L6073">        Iterator&lt;Entity&gt; entities = game.getEntities(coords);</span>
<span class="nc" id="L6074">        Vector&lt;Entity&gt; possibleTargets = new Vector&lt;Entity&gt;();</span>
<span class="nc bnc" id="L6075" title="All 2 branches missed.">        while (entities.hasNext()) {</span>
<span class="nc" id="L6076">            tempEntity = entities.next();</span>
<span class="nc bnc" id="L6077" title="All 2 branches missed.">            if (!tempEntity.getTargetedBySwarm(aeId, weaponId)) {</span>
                // we found a target
<span class="nc" id="L6079">                possibleTargets.add(tempEntity);</span>
            }
        }
        // if there is at least one target, get a random one of them
<span class="nc bnc" id="L6083" title="All 2 branches missed.">        if (!possibleTargets.isEmpty()) {</span>
<span class="nc" id="L6084">            return possibleTargets</span>
<span class="nc" id="L6085">                    .get(Compute.randomInt(possibleTargets.size()));</span>
        }
        // loop through adjacent hexes
<span class="nc bnc" id="L6088" title="All 2 branches missed.">        for (int dir = 0; dir &lt;= 5; dir++) {</span>
<span class="nc" id="L6089">            Coords tempcoords = coords.translated(dir);</span>
<span class="nc bnc" id="L6090" title="All 2 branches missed.">            if (!game.getBoard().contains(tempcoords)) {</span>
<span class="nc" id="L6091">                continue;</span>
            }
<span class="nc bnc" id="L6093" title="All 2 branches missed.">            if (coords.equals(tempcoords)) {</span>
<span class="nc" id="L6094">                continue;</span>
            }
<span class="nc" id="L6096">            entities = game.getEntities(tempcoords);</span>
<span class="nc bnc" id="L6097" title="All 2 branches missed.">            if (entities.hasNext()) {</span>
<span class="nc" id="L6098">                tempEntity = entities.next();</span>
<span class="nc bnc" id="L6099" title="All 2 branches missed.">                if (!tempEntity.getTargetedBySwarm(aeId, weaponId)) {</span>
                    // we found a target
<span class="nc" id="L6101">                    possibleTargets.add(tempEntity);</span>
                }
            }
        }
        // if there is at least one target, get a random one of them
<span class="nc bnc" id="L6106" title="All 2 branches missed.">        if (!possibleTargets.isEmpty()) {</span>
<span class="nc" id="L6107">            return possibleTargets</span>
<span class="nc" id="L6108">                    .get(Compute.randomInt(possibleTargets.size()));</span>
        }
<span class="nc" id="L6110">        return null;</span>
    }

    /**
     * Gets a new target hex for a flight of smoke missiles fired at a hex, if
     * there are remaining missiles.
     */

    /**
     * * STUFF FOR VECTOR MOVEMENT CALCULATIONS **
     */
    public static Coords getFinalPosition(Coords curpos, int[] v) {

<span class="nc bnc" id="L6123" title="All 4 branches missed.">        if ((v == null) || (v.length != 6)) {</span>
<span class="nc" id="L6124">            return curpos;</span>
        }

        // step through each vector and move the direction indicated
<span class="nc" id="L6128">        int thrust = 0;</span>
<span class="nc" id="L6129">        Coords endpos = curpos;</span>
<span class="nc bnc" id="L6130" title="All 2 branches missed.">        for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L6131">            thrust = v[dir];</span>
<span class="nc bnc" id="L6132" title="All 2 branches missed.">            while (thrust &gt; 0) {</span>
<span class="nc" id="L6133">                endpos = endpos.translated(dir);</span>
<span class="nc" id="L6134">                thrust--;</span>
            }
        }

<span class="nc" id="L6138">        return endpos;</span>
    }

    /**
     * method to change a set of active vectors for a one-point thrust
     * expenditure in the giving facing
     *
     * @param v
     * @param facing
     * @return
     */
    public static int[] changeVectors(int[] v, int facing) {

<span class="nc bnc" id="L6151" title="All 4 branches missed.">        if ((v == null) || (v.length != 6)) {</span>
<span class="nc" id="L6152">            return v;</span>
        }

        // first look at opposing vectors
<span class="nc" id="L6156">        int oppv = facing + 3;</span>
<span class="nc bnc" id="L6157" title="All 2 branches missed.">        if (oppv &gt; 5) {</span>
<span class="nc" id="L6158">            oppv -= 6;</span>
        }
        // is this vector active
<span class="nc bnc" id="L6161" title="All 2 branches missed.">        if (v[oppv] &gt; 0) {</span>
            // then decrement it by one and return
<span class="nc" id="L6163">            v[oppv]--;</span>
<span class="nc" id="L6164">            return v;</span>
        }

        // now check oblique vectors
<span class="nc" id="L6168">        int oblv1 = facing + 2;</span>
<span class="nc bnc" id="L6169" title="All 2 branches missed.">        if (oblv1 &gt; 5) {</span>
<span class="nc" id="L6170">            oblv1 -= 6;</span>
        }
<span class="nc" id="L6172">        int oblv2 = facing - 2;</span>
<span class="nc bnc" id="L6173" title="All 2 branches missed.">        if (oblv2 &lt; 0) {</span>
<span class="nc" id="L6174">            oblv2 += 6;</span>
        }

        // check both of these and if either is active
        // deal with it and then return
<span class="nc bnc" id="L6179" title="All 4 branches missed.">        if ((v[oblv1] &gt; 0) || (v[oblv2] &gt; 0)) {</span>

<span class="nc" id="L6181">            int newface = facing + 1;</span>
<span class="nc bnc" id="L6182" title="All 2 branches missed.">            if (newface &gt; 5) {</span>
<span class="nc" id="L6183">                newface = 0;</span>
            }
<span class="nc bnc" id="L6185" title="All 2 branches missed.">            if (v[oblv1] &gt; 0) {</span>
<span class="nc" id="L6186">                v[oblv1]--;</span>
<span class="nc" id="L6187">                v[newface]++;</span>
            }

<span class="nc" id="L6190">            newface = facing - 1;</span>
<span class="nc bnc" id="L6191" title="All 2 branches missed.">            if (newface &lt; 0) {</span>
<span class="nc" id="L6192">                newface = 5;</span>
            }
<span class="nc bnc" id="L6194" title="All 2 branches missed.">            if (v[oblv2] &gt; 0) {</span>
<span class="nc" id="L6195">                v[oblv2]--;</span>
<span class="nc" id="L6196">                v[newface]++;</span>
            }
<span class="nc" id="L6198">            return v;</span>
        }

        // if nothing was found, then just increase velocity in this vector
<span class="nc" id="L6202">        v[facing]++;</span>
<span class="nc" id="L6203">        return v;</span>
    }

    /**
     * compare two vectors and determine if they are the same
     *
     * @param v1
     * @param v2
     * @return
     */
    public static boolean sameVectors(int[] v1, int[] v2) {

<span class="nc bnc" id="L6215" title="All 2 branches missed.">        for (int i = 0; i &lt; 6; i++) {</span>
<span class="nc bnc" id="L6216" title="All 2 branches missed.">            if (v1[i] != v2[i]) {</span>
<span class="nc" id="L6217">                return false;</span>
            }
        }

<span class="nc" id="L6221">        return true;</span>
    }

    /**
     * Get the net velocity of two aeros for ramming attacks
     */
    public static int getNetVelocity(Coords src, Entity te, int avel, int tvel) {
<span class="nc" id="L6228">        int angle = te.sideTableRam(src);</span>

<span class="nc bnc" id="L6230" title="All 5 branches missed.">        switch (angle) {</span>
            case Aero.RAM_TOWARD_DIR:
<span class="nc" id="L6232">                return Math.max(avel + tvel, 1);</span>
            case Aero.RAM_TOWARD_OBL:
<span class="nc" id="L6234">                return Math.max(avel + (tvel / 2), 1);</span>
            case Aero.RAM_AWAY_OBL:
<span class="nc" id="L6236">                return Math.max(avel - (tvel / 2), 1);</span>
            case Aero.RAM_AWAY_DIR:
<span class="nc" id="L6238">                return Math.max(avel - tvel, 1);</span>
        }
<span class="nc" id="L6240">        return 0;</span>
    }

    /**
     * Returns how much damage a weapon will do against against a BattleArmor
     * target if the BattleArmor vs BattleArmor rules on TO pg 109 are in
     * effect.
     *
     * @param damage     Original weapon damage
     * @param damageType The damage type for BA vs BA damage
     * @param target     The target, used for ensuring the target BA isn't
     *                   fire resistant
     * @return
     */
    public static int directBlowBADamage(double damage, int damageType,
                                         BattleArmor target) {
<span class="nc bnc" id="L6256" title="All 4 branches missed.">        switch (damageType) {</span>
            case WeaponType.WEAPON_BURST_1D6:
<span class="nc" id="L6258">                damage = Compute.d6();</span>
<span class="nc" id="L6259">                break;</span>
            case WeaponType.WEAPON_BURST_3D6:
<span class="nc" id="L6261">                damage = Compute.d6(3);</span>
<span class="nc" id="L6262">                break;</span>
            case WeaponType.WEAPON_PLASMA:
                // If the target is fire-resistant BA, damage is normal
<span class="nc bnc" id="L6265" title="All 2 branches missed.">                if (!target.isFireResistant()) {</span>
<span class="nc" id="L6266">                    damage = 1 + Compute.d6(1);</span>
                }
                break;
        }
<span class="nc" id="L6270">        damage = Math.ceil(damage);</span>
<span class="nc" id="L6271">        return (int) damage;</span>
    }

    /**
     * Used to get a human-readable string that represents the passed damage
     * type.
     *
     * @param damageType
     * @return
     */
    public static String getDamageTypeString(int damageType) {
<span class="nc bnc" id="L6282" title="All 5 branches missed.">        switch (damageType) {</span>
            case WeaponType.WEAPON_DIRECT_FIRE:
<span class="nc" id="L6284">                return Messages.getString(&quot;WeaponType.DirectFire&quot;);</span>
            case WeaponType.WEAPON_CLUSTER_BALLISTIC:
<span class="nc" id="L6286">                return Messages.getString(&quot;WeaponType.BallisticCluster&quot;);</span>
            case WeaponType.WEAPON_PULSE:
<span class="nc" id="L6288">                return Messages.getString(&quot;WeaponType.Pulse&quot;);</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE:
            case WeaponType.WEAPON_CLUSTER_MISSILE_1D6:
            case WeaponType.WEAPON_CLUSTER_MISSILE_2D6:
            case WeaponType.WEAPON_CLUSTER_MISSILE_3D6:
<span class="nc" id="L6293">                return Messages.getString(&quot;WeaponType.Missile&quot;);</span>
            case WeaponType.WEAPON_BURST_HALFD6:
            case WeaponType.WEAPON_BURST_1D6:
            case WeaponType.WEAPON_BURST_2D6:
            case WeaponType.WEAPON_BURST_3D6:
            case WeaponType.WEAPON_BURST_4D6:
            case WeaponType.WEAPON_BURST_5D6:
            case WeaponType.WEAPON_BURST_6D6:
            case WeaponType.WEAPON_BURST_7D6:
            default:
<span class="nc" id="L6303">                return Messages.getString(&quot;WeaponType.Burst&quot;);</span>
        }
    }

    public static int directBlowInfantryDamage(double damage, int mos,
            int damageType, boolean isNonInfantryAgainstMechanized,
            boolean isAttackThruBuilding) {
<span class="nc" id="L6310">        return directBlowInfantryDamage(damage, mos, damageType,</span>
                isNonInfantryAgainstMechanized, isAttackThruBuilding,
                Entity.NONE, null);
    }

    /**
     * Method replicates the Non-Conventional Damage against Infantry damage
     * table as well as shifting for direct blows. also adjust for non-infantry
     * damaging mechanized infantry
     *
     * @param damage
     * @param mos
     * @param damageType
     * @return
     */
    public static int directBlowInfantryDamage(double damage, int mos,
            int damageType, boolean isNonInfantryAgainstMechanized,
            boolean isAttackThruBuilding, int attackerId, Vector&lt;Report&gt; vReport) {

<span class="nc" id="L6329">        int origDamageType = damageType;</span>
<span class="nc" id="L6330">        damageType += mos;</span>
<span class="nc" id="L6331">        double origDamage = damage;</span>
<span class="nc bnc" id="L6332" title="All 16 branches missed.">        switch (damageType) {</span>
            case WeaponType.WEAPON_DIRECT_FIRE:
<span class="nc" id="L6334">                damage /= 10;</span>
<span class="nc" id="L6335">                break;</span>
            case WeaponType.WEAPON_CLUSTER_BALLISTIC:
<span class="nc" id="L6337">                damage /= 10;</span>
<span class="nc" id="L6338">                damage++;</span>
<span class="nc" id="L6339">                break;</span>
            case WeaponType.WEAPON_PULSE:
<span class="nc" id="L6341">                damage /= 10;</span>
<span class="nc" id="L6342">                damage += 2;</span>
<span class="nc" id="L6343">                break;</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE:
<span class="nc" id="L6345">                damage /= 5;</span>
<span class="nc" id="L6346">                break;</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE_1D6:
<span class="nc" id="L6348">                damage /= 5;</span>
<span class="nc" id="L6349">                damage += Compute.d6();</span>
<span class="nc" id="L6350">                break;</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE_2D6:
<span class="nc" id="L6352">                damage /= 5;</span>
<span class="nc" id="L6353">                damage += Compute.d6(2);</span>
<span class="nc" id="L6354">                break;</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE_3D6:
<span class="nc" id="L6356">                damage /= 5;</span>
<span class="nc" id="L6357">                damage += Compute.d6(3);</span>
<span class="nc" id="L6358">                break;</span>
            case WeaponType.WEAPON_BURST_HALFD6:
<span class="nc" id="L6360">                damage = Compute.d6() / 2.0;</span>
<span class="nc bnc" id="L6361" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6362">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_1D6:
<span class="nc" id="L6366">                damage = Compute.d6();</span>
<span class="nc bnc" id="L6367" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6368">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_2D6:
<span class="nc" id="L6372">                damage = Compute.d6(2);</span>
<span class="nc bnc" id="L6373" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6374">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_3D6:
<span class="nc" id="L6378">                damage = Compute.d6(3);</span>
<span class="nc bnc" id="L6379" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6380">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_4D6:
<span class="nc" id="L6384">                damage = Compute.d6(4);</span>
<span class="nc bnc" id="L6385" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6386">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_5D6:
<span class="nc" id="L6390">                damage = Compute.d6(5);</span>
<span class="nc bnc" id="L6391" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6392">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_6D6:
<span class="nc" id="L6396">                damage = Compute.d6(6);</span>
<span class="nc bnc" id="L6397" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6398">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_7D6:
<span class="nc" id="L6402">                damage = Compute.d6(7);</span>
<span class="nc bnc" id="L6403" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6404">                    damage *= 0.5;</span>
                }
                break;
        }
<span class="nc" id="L6408">        damage = Math.ceil(damage);</span>

        // according to the following ruling, the half damage that mechanized
        // inf get against burst fire should trump the double damage they get
        // from non-infantry rather than cancel it out
        // http://bg.battletech.com/forums/index.php/topic,23928.0.html
<span class="nc bnc" id="L6414" title="All 2 branches missed.">        if (isNonInfantryAgainstMechanized) {</span>
<span class="nc bnc" id="L6415" title="All 2 branches missed.">            if (damageType &lt; WeaponType.WEAPON_BURST_HALFD6) {</span>
<span class="nc" id="L6416">                damage *= 2;</span>
            } else {
<span class="nc" id="L6418">                damage /= 2;</span>
            }
        }

<span class="nc bnc" id="L6422" title="All 2 branches missed.">        if (vReport != null) {</span>
<span class="nc" id="L6423">            Report r = new Report();</span>
<span class="nc" id="L6424">            r.subject = attackerId;</span>
<span class="nc" id="L6425">            r.indent(2);</span>

<span class="nc" id="L6427">            r.add(getDamageTypeString(origDamageType));</span>
<span class="nc bnc" id="L6428" title="All 2 branches missed.">            if (origDamageType != damageType) {</span>
<span class="nc bnc" id="L6429" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6430">                    r.messageId = 9973;</span>
                } else {
<span class="nc" id="L6432">                    r.messageId = 9972;</span>
                }
<span class="nc" id="L6434">                r.add(getDamageTypeString(damageType));</span>
<span class="nc bnc" id="L6435" title="All 2 branches missed.">            } else if (isAttackThruBuilding) {</span>
<span class="nc" id="L6436">                r.messageId = 9971;</span>
            } else {
<span class="nc" id="L6438">                r.messageId = 9970;</span>
            }

<span class="nc" id="L6441">            r.add((int)origDamage);</span>
<span class="nc" id="L6442">            r.add((int)damage);</span>
<span class="nc" id="L6443">            vReport.addElement(r);</span>
        }
<span class="nc" id="L6445">        return (int) damage;</span>
    }


    /**
     * Method computes how much damage a dial down weapon has done
     *
     * @param weapon
     * @param wtype
     * @returnnew damage
     */
    public static int dialDownDamage(Mounted weapon, WeaponType wtype) {
<span class="nc" id="L6457">        return Compute.dialDownDamage(weapon, wtype, 1);</span>
    }

    /**
     * Method computes how much damage a dial down weapon has done
     *
     * @param weapon
     * @param wtype
     * @param range
     * @return new damage
     */
    public static int dialDownDamage(Mounted weapon, WeaponType wtype, int range) {
<span class="nc" id="L6469">        int toReturn = wtype.getDamage(range);</span>

<span class="nc bnc" id="L6471" title="All 2 branches missed.">        if (!wtype.hasModes()) {</span>
<span class="nc" id="L6472">            return toReturn;</span>
        }

<span class="nc" id="L6475">        String damage = weapon.curMode().getName();</span>

        // Vehicle flamers have damage and heat modes so lets make sure this is
        // an actual dial down Damage.
<span class="nc bnc" id="L6479" title="All 2 branches missed.">        if ((damage.trim().toLowerCase().indexOf(&quot;damage&quot;) == 0)</span>
<span class="nc bnc" id="L6480" title="All 2 branches missed.">            &amp;&amp; (damage.trim().length() &gt; 6)) {</span>
<span class="nc" id="L6481">            toReturn = Integer.parseInt(damage.substring(6).trim());</span>
        }

<span class="nc" id="L6484">        return Math.min(wtype.getDamage(range), toReturn);</span>

    }

    /**
     * Method computes how much heat a dial down weapon generates
     *
     * @param weapon
     * @param wtype
     * @return Heat, minimum of 1;
     */
    public static int dialDownHeat(Mounted weapon, WeaponType wtype) {
<span class="nc" id="L6496">        return Compute.dialDownHeat(weapon, wtype, 1);</span>
    }

    /**
     * Method computes how much heat a dial down weapon generates
     *
     * @param weapon
     * @param wtype
     * @param range
     * @return Heat, minimum of 1;
     */
    public static int dialDownHeat(Mounted weapon, WeaponType wtype, int range) {
<span class="nc" id="L6508">        int toReturn = wtype.getHeat();</span>

<span class="nc bnc" id="L6510" title="All 2 branches missed.">        if (!wtype.hasModes()) {</span>
<span class="nc" id="L6511">            return toReturn;</span>
        }

<span class="nc" id="L6514">        int damage = wtype.getDamage(range);</span>
<span class="nc" id="L6515">        int newDamage = Compute.dialDownDamage(weapon, wtype, range);</span>

<span class="nc" id="L6517">        toReturn = Math.max(1,</span>
<span class="nc" id="L6518">                            wtype.getHeat() - Math.max(0, damage - newDamage));</span>
<span class="nc" id="L6519">        return toReturn;</span>

    }

    /**
     * @param aPos - attacking entity
     * @param tPos - targeted entity
     * @return a vector of all the entities that are adjacent to the targeted
     * entity and would fall along the angle of attack
     */
    public static ArrayList&lt;Entity&gt; getAdjacentEntitiesAlongAttack(Coords aPos,
                                                                   Coords tPos, IGame game) {
<span class="nc" id="L6531">        ArrayList&lt;Entity&gt; entities = new ArrayList&lt;Entity&gt;();</span>
<span class="nc" id="L6532">        ArrayList&lt;Coords&gt; coords = Coords.intervening(aPos, tPos);</span>
        // loop through all intervening coords
<span class="nc bnc" id="L6534" title="All 2 branches missed.">        for (Coords c : coords) {</span>
            // must be adjacent to the target
<span class="nc bnc" id="L6536" title="All 4 branches missed.">            if ((c.distance(tPos) &gt; 1) || c.equals(tPos)) {</span>
<span class="nc" id="L6537">                continue;</span>
            }
            // now lets add all the entities here
<span class="nc bnc" id="L6540" title="All 2 branches missed.">            for (Entity en : game.getEntitiesVector(c)) {</span>
<span class="nc" id="L6541">                entities.add(en);</span>
<span class="nc" id="L6542">            }</span>
<span class="nc" id="L6543">        }</span>
<span class="nc" id="L6544">        return entities;</span>
    }

    public static boolean isInUrbanEnvironment(IGame game, Coords unitPOS) {
<span class="nc" id="L6548">        IHex unitHex = game.getBoard().getHex(unitPOS);</span>

<span class="nc bnc" id="L6550" title="All 2 branches missed.">        if (unitHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L6551" title="All 2 branches missed.">                || unitHex.containsTerrain(Terrains.BUILDING)</span>
<span class="nc bnc" id="L6552" title="All 2 branches missed.">                || unitHex.containsTerrain(Terrains.RUBBLE)) {</span>
<span class="nc" id="L6553">            return true;</span>
        }

        // loop through adjacent hexes
<span class="nc bnc" id="L6557" title="All 2 branches missed.">        for (int dir = 0; dir &lt;= 5; dir++) {</span>
<span class="nc" id="L6558">            Coords adjCoords = unitPOS.translated(dir);</span>
<span class="nc" id="L6559">            IHex adjHex = game.getBoard().getHex(adjCoords);</span>

<span class="nc bnc" id="L6561" title="All 2 branches missed.">            if (!game.getBoard().contains(adjCoords)) {</span>
<span class="nc" id="L6562">                continue;</span>
            }
<span class="nc bnc" id="L6564" title="All 2 branches missed.">            if (unitPOS.equals(adjCoords)) {</span>
<span class="nc" id="L6565">                continue;</span>
            }

            // hex pavement or building?
<span class="nc bnc" id="L6569" title="All 2 branches missed.">            if (adjHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L6570" title="All 2 branches missed.">                    || adjHex.containsTerrain(Terrains.BUILDING)</span>
<span class="nc bnc" id="L6571" title="All 2 branches missed.">                    || adjHex.containsTerrain(Terrains.RUBBLE)) {</span>
<span class="nc" id="L6572">                return true;</span>
            }
        }
<span class="nc" id="L6575">        return false;</span>
    }

    public static boolean isAirToGround(Entity attacker, Targetable target) {
<span class="nc bnc" id="L6579" title="All 4 branches missed.">        if ((attacker == null) || (target == null)) {</span>
<span class="nc" id="L6580">            return false;</span>
        }

        //Artillery attacks need to return differently, since none of the usual air to ground modifiers apply to them
<span class="nc bnc" id="L6584" title="All 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_HEX_ARTILLERY) {</span>
<span class="nc" id="L6585">            return false;</span>
        }

<span class="nc bnc" id="L6588" title="All 2 branches missed.">        if (attacker.isSpaceborne()) {</span>
<span class="nc" id="L6589">            return false;</span>
        }
        // According to errata, VTOL and WiGes are considered ground targets
<span class="nc bnc" id="L6592" title="All 6 branches missed.">        return attacker.isAirborne() &amp;&amp; !target.isAirborne() &amp;&amp; attacker.isAero();</span>

    }

    public static boolean isAirToAir(Entity attacker, Targetable target) {
<span class="nc bnc" id="L6597" title="All 4 branches missed.">        if ((attacker == null) || (target == null)) {</span>
<span class="nc" id="L6598">            return false;</span>
        }
        // According to errata, VTOL and WiGes are considered ground targets
<span class="nc bnc" id="L6601" title="All 4 branches missed.">        return attacker.isAirborne() &amp;&amp; target.isAirborne();</span>
    }

    public static boolean isGroundToAir(Entity attacker, Targetable target) {
<span class="nc bnc" id="L6605" title="All 4 branches missed.">        if ((attacker == null) || (target == null)) {</span>
<span class="nc" id="L6606">            return false;</span>
        }
<span class="nc bnc" id="L6608" title="All 4 branches missed.">        return !attacker.isAirborne() &amp;&amp; target.isAirborne();</span>
    }

    public static boolean isGroundToGround(Entity attacker, Targetable target) {
<span class="nc bnc" id="L6612" title="All 4 branches missed.">        if ((attacker == null) || (target == null)) {</span>
<span class="nc" id="L6613">            return false;</span>
        }
<span class="nc bnc" id="L6615" title="All 4 branches missed.">        return !attacker.isAirborne() &amp;&amp; !target.isAirborne();</span>
    }

    /**
     * This is a homebrew function partially drawn from pg. 40-1 of AT2R that
     * allows units that flee the field for any reason to return after a certain
     * number of rounds It can potentially be expanded to include other
     * conditions
     *
     * @param en
     * @return number of rounds until return (-1 if never)
     */
    public static int roundsUntilReturn(IGame game, Entity en) {

<span class="nc bnc" id="L6629" title="All 2 branches missed.">        if (!en.isAero()) {</span>
<span class="nc" id="L6630">            return -1;</span>
        }

<span class="nc bnc" id="L6633" title="All 2 branches missed.">        if (!game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_RETURN_FLYOVER)) {</span>
<span class="nc" id="L6634">            return -1;</span>
        }

<span class="nc" id="L6637">        IAero a = (IAero) en;</span>

        // the table in AT2R is backwards, it should take longer to return if
        // your velocity is higher
<span class="nc" id="L6641">        int turns = 1 + (int) Math.ceil(a.getCurrentVelocity() / 4.0);</span>

        // OOC units should take longer, how about two extra turns?
<span class="nc bnc" id="L6644" title="All 2 branches missed.">        if (a.isOutControlTotal()) {</span>
<span class="nc" id="L6645">            turns += 2;</span>
        }
<span class="nc" id="L6647">        return turns;</span>
    }

    public static boolean inDeadZone(IGame game, Entity ae, Targetable target) {
<span class="nc bnc" id="L6651" title="All 2 branches missed.">        if (ae.isSpaceborne()) {</span>
<span class="nc" id="L6652">            return false;</span>
        }
        // Account for &quot;dead zones&quot; between Aeros at different altitudes
<span class="nc bnc" id="L6655" title="All 2 branches missed.">        if (Compute.isAirToAir(ae, target)) {</span>
<span class="nc" id="L6656">            int distance = Compute.effectiveDistance(game, ae, target,</span>
<span class="nc" id="L6657">                                                     target.isAirborneVTOLorWIGE());</span>
<span class="nc" id="L6658">            int aAlt = ae.getAltitude();</span>
<span class="nc" id="L6659">            int tAlt = target.getAltitude();</span>
<span class="nc bnc" id="L6660" title="All 2 branches missed.">            if (target.isAirborneVTOLorWIGE()) {</span>
<span class="nc" id="L6661">                tAlt++;</span>
            }
<span class="nc" id="L6663">            int altDiff = Math.abs(aAlt - tAlt);</span>
<span class="nc bnc" id="L6664" title="All 2 branches missed.">            if (altDiff &gt;= (distance - altDiff)) {</span>
<span class="nc" id="L6665">                return true;</span>
            }
        }
<span class="nc" id="L6668">        return false;</span>
    }

    public static ArrayList&lt;Coords&gt; getAcceptableUnloadPositions(
            List&lt;Coords&gt; ring, Entity unit, IGame game, int elev) {

<span class="nc" id="L6674">        ArrayList&lt;Coords&gt; acceptable = new ArrayList&lt;Coords&gt;();</span>

<span class="nc bnc" id="L6676" title="All 2 branches missed.">        for (Coords pos : ring) {</span>
<span class="nc" id="L6677">            IHex hex = game.getBoard().getHex(pos);</span>
<span class="nc bnc" id="L6678" title="All 2 branches missed.">            if (null == hex) {</span>
<span class="nc" id="L6679">                continue;</span>
            }
            // no stacking violations, no prohibited terrain, and within 2
            // elevations

<span class="nc bnc" id="L6684" title="All 2 branches missed.">            if (!unit.isLocationProhibited(pos)</span>
<span class="nc bnc" id="L6685" title="All 2 branches missed.">                &amp;&amp; (null == stackingViolation(game, unit.getId(), pos))</span>
<span class="nc bnc" id="L6686" title="All 2 branches missed.">                &amp;&amp; (Math.abs(hex.getLevel() - elev) &lt; 3)) {</span>
<span class="nc" id="L6687">                acceptable.add(pos);</span>
            }
<span class="nc" id="L6689">        }</span>
<span class="nc" id="L6690">        return acceptable;</span>
    }

    /**
     * Builds a list of all adjacent units that can load the given Entity.
     * @param en   The entity to load
     * @param pos  The coordinates of the hex to load from
     * @param elev The absolute elevation of the unit at the point of loading (surface
     *             of the hex + elevation over the surface)
     * @param game The game object
     * @return     All adjacent units that can mount the Entity
     */
    public static List&lt;Entity&gt; getMountableUnits(Entity en, Coords pos, int elev, IGame game) {
<span class="nc" id="L6703">        List&lt;Entity&gt; mountable = new ArrayList&lt;&gt;();</span>
        // Expanded to include trains

        // the rules don't say that the unit must be facing loader
        // so lets take the ring
<span class="nc bnc" id="L6708" title="All 2 branches missed.">        for (Coords c : pos.allAdjacent()) {</span>
<span class="nc" id="L6709">            IHex hex = game.getBoard().getHex(c);</span>
<span class="nc bnc" id="L6710" title="All 2 branches missed.">            if (null == hex) {</span>
<span class="nc" id="L6711">                continue;</span>
            }
<span class="nc bnc" id="L6713" title="All 2 branches missed.">            for (Entity other : game.getEntitiesVector(c)) {</span>
                // Is the other unit friendly and not the current entity?
<span class="nc bnc" id="L6715" title="All 2 branches missed.">                if ((en.getOwner().equals(other.getOwner()) || (en.getOwner()</span>
<span class="nc bnc" id="L6716" title="All 2 branches missed.">                                                                  .getTeam() == other.getOwner().getTeam()))</span>
<span class="nc bnc" id="L6717" title="All 4 branches missed.">                    &amp;&amp; !en.equals(other)</span>
<span class="nc bnc" id="L6718" title="All 4 branches missed.">                    &amp;&amp; ((other instanceof SmallCraft) || other.getTowing() != Entity.NONE || other.getTowedBy() != Entity.NONE)</span>
<span class="nc bnc" id="L6719" title="All 2 branches missed.">                    &amp;&amp; other.canLoad(en)</span>
<span class="nc bnc" id="L6720" title="All 2 branches missed.">                    &amp;&amp; !other.isAirborne()</span>
<span class="nc bnc" id="L6721" title="All 2 branches missed.">                    &amp;&amp; (Math.abs((hex.surface() + other.getElevation())</span>
<span class="nc bnc" id="L6722" title="All 2 branches missed.">                                 - elev) &lt; 3) &amp;&amp; !mountable.contains(other)) {</span>
<span class="nc" id="L6723">                    mountable.add(other);</span>
                }
<span class="nc" id="L6725">            }</span>
<span class="nc" id="L6726">        }</span>

<span class="nc" id="L6728">        return mountable;</span>

    }

    public static boolean allowAimedShotWith(Mounted weapon, int aimingMode) {
<span class="nc" id="L6733">        WeaponType wtype = (WeaponType) weapon.getType();</span>
<span class="nc" id="L6734">        boolean isWeaponInfantry = wtype.hasFlag(WeaponType.F_INFANTRY);</span>
<span class="nc bnc" id="L6735" title="All 4 branches missed.">        boolean usesAmmo = (wtype.getAmmoType() != AmmoType.T_NA)</span>
                           &amp;&amp; !isWeaponInfantry;
<span class="nc bnc" id="L6737" title="All 2 branches missed.">        Mounted ammo = usesAmmo ? weapon.getLinked() : null;</span>
<span class="nc bnc" id="L6738" title="All 2 branches missed.">        AmmoType atype = ammo == null ? null : (AmmoType) ammo.getType();</span>

        // Leg and swarm attacks can't be aimed.
<span class="nc bnc" id="L6741" title="All 2 branches missed.">        if (wtype.getInternalName().equals(Infantry.LEG_ATTACK)</span>
<span class="nc bnc" id="L6742" title="All 2 branches missed.">            || wtype.getInternalName().equals(Infantry.SWARM_MEK)) {</span>
<span class="nc" id="L6743">            return false;</span>
        }
<span class="nc bnc" id="L6745" title="All 4 branches missed.">        switch (aimingMode) {</span>
            case (IAimingModes.AIM_MODE_NONE):
<span class="nc" id="L6747">                return false;</span>
            case (IAimingModes.AIM_MODE_IMMOBILE):
<span class="nc bnc" id="L6749" title="All 2 branches missed.">                if (weapon.getCurrentShots() &gt; 1) {</span>
<span class="nc" id="L6750">                    return false;</span>
                }
<span class="nc bnc" id="L6752" title="All 2 branches missed.">                if (atype == null) {</span>
<span class="nc" id="L6753">                    break;</span>
                }
<span class="nc bnc" id="L6755" title="All 2 branches missed.">                switch (atype.getAmmoType()) {</span>
                    case AmmoType.T_SRM_STREAK:
                    case AmmoType.T_LRM_STREAK:
                    case AmmoType.T_LRM:
                    case AmmoType.T_LRM_IMP:
                    case AmmoType.T_LRM_TORPEDO:
                    case AmmoType.T_SRM:
                    case AmmoType.T_SRM_IMP:
                    case AmmoType.T_SRM_TORPEDO:
                    case AmmoType.T_MRM:
                    case AmmoType.T_NARC:
                    case AmmoType.T_INARC:
                    case AmmoType.T_AMS:
                    case AmmoType.T_ARROW_IV:
                    case AmmoType.T_LONG_TOM:
                    case AmmoType.T_SNIPER:
                    case AmmoType.T_THUMPER:
                    case AmmoType.T_SRM_ADVANCED:
                    case AmmoType.T_LRM_TORPEDO_COMBO:
                    case AmmoType.T_ATM:
                    case AmmoType.T_IATM:
                    case AmmoType.T_MML:
                    case AmmoType.T_EXLRM:
                    case AmmoType.T_NLRM:
                    case AmmoType.T_TBOLT_5:
                    case AmmoType.T_TBOLT_10:
                    case AmmoType.T_TBOLT_15:
                    case AmmoType.T_TBOLT_20:
                    case AmmoType.T_PXLRM:
                    case AmmoType.T_HSRM:
                    case AmmoType.T_MRM_STREAK:
                    case AmmoType.T_HAG:
                    case AmmoType.T_ROCKET_LAUNCHER:
<span class="nc" id="L6788">                        return false;</span>
                }
<span class="nc bnc" id="L6790" title="All 2 branches missed.">                if (((atype.getAmmoType() == AmmoType.T_AC_LBX_THB)</span>
<span class="nc bnc" id="L6791" title="All 2 branches missed.">                     || (atype.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L6792" title="All 2 branches missed.">                     || (atype.getAmmoType() == AmmoType.T_SBGAUSS))</span>
<span class="nc bnc" id="L6793" title="All 2 branches missed.">                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_CLUSTER)) {</span>
<span class="nc" id="L6794">                    return false;</span>
                }
                // Flak Ammo can't make aimed shots
<span class="nc bnc" id="L6797" title="All 2 branches missed.">                if (((atype.getAmmoType() == AmmoType.T_AC)</span>
<span class="nc bnc" id="L6798" title="All 2 branches missed.">                     || (atype.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L6799" title="All 2 branches missed.">                     || (atype.getAmmoType() == AmmoType.T_AC_ULTRA_THB))</span>
<span class="nc bnc" id="L6800" title="All 2 branches missed.">                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_FLAK)) {</span>
<span class="nc" id="L6801">                    return false;</span>
                }

                break;
            case (IAimingModes.AIM_MODE_TARG_COMP):
<span class="nc bnc" id="L6806" title="All 2 branches missed.">                if (!wtype.hasFlag(WeaponType.F_DIRECT_FIRE)</span>
<span class="nc bnc" id="L6807" title="All 4 branches missed.">                    || wtype.hasFlag(WeaponType.F_PULSE)</span>
                    || (wtype instanceof HAGWeapon)) {
<span class="nc" id="L6809">                    return false;</span>
                }
<span class="nc bnc" id="L6811" title="All 2 branches missed.">                if (weapon.getCurrentShots() &gt; 1) {</span>
<span class="nc" id="L6812">                    return false;</span>
                }

<span class="nc bnc" id="L6815" title="All 2 branches missed.">                if ((atype != null)</span>
<span class="nc bnc" id="L6816" title="All 2 branches missed.">                    &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC_LBX_THB)</span>
<span class="nc bnc" id="L6817" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L6818" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_SBGAUSS))</span>
<span class="nc bnc" id="L6819" title="All 2 branches missed.">                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_CLUSTER)) {</span>
<span class="nc" id="L6820">                    return false;</span>
                }

                // Flak Ammo can't make aimed shots
<span class="nc bnc" id="L6824" title="All 2 branches missed.">                if ((atype != null)</span>
<span class="nc bnc" id="L6825" title="All 2 branches missed.">                    &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC)</span>
<span class="nc bnc" id="L6826" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L6827" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_AC_ULTRA_THB))</span>
<span class="nc bnc" id="L6828" title="All 2 branches missed.">                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_FLAK)) {</span>
<span class="nc" id="L6829">                    return false;</span>
                }
                break;
        }
<span class="nc" id="L6833">        return true;</span>
    }

    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
    public static int getTotalGunnerNeeds(Entity entity) {
<span class="nc bnc" id="L6838" title="All 4 branches missed.">        if (entity instanceof SmallCraft || entity instanceof Jumpship) {</span>
<span class="nc" id="L6839">            int nStandardW = 0;</span>
<span class="nc" id="L6840">            int nCapitalW = 0;</span>
<span class="nc bnc" id="L6841" title="All 2 branches missed.">            for (Mounted m : entity.getTotalWeaponList()) {</span>
<span class="nc" id="L6842">                EquipmentType type = m.getType();</span>
<span class="nc bnc" id="L6843" title="All 2 branches missed.">                if (type instanceof BayWeapon) {</span>
<span class="nc" id="L6844">                    continue;</span>
                }
<span class="nc bnc" id="L6846" title="All 2 branches missed.">                if (type instanceof WeaponType) {</span>
<span class="nc bnc" id="L6847" title="All 2 branches missed.">                    if (((WeaponType) type).isCapital()) {</span>
<span class="nc" id="L6848">                        nCapitalW++;</span>
                    } else {
<span class="nc" id="L6850">                        nStandardW++;</span>
                    }
                }
<span class="nc" id="L6853">            }</span>
<span class="nc" id="L6854">            return nCapitalW + (int) Math.ceil(nStandardW / 6.0);</span>
<span class="nc bnc" id="L6855" title="All 2 branches missed.">        } else if (entity.isSupportVehicle()) {</span>
<span class="nc" id="L6856">            return getSupportVehicleGunnerNeeds(entity);</span>
<span class="nc bnc" id="L6857" title="All 2 branches missed.">        } else if (entity instanceof Tank) {</span>
<span class="nc" id="L6858">            return (getFullCrewSize(entity) - 1);</span>
<span class="nc bnc" id="L6859" title="All 2 branches missed.">        } else if (entity instanceof Infantry) {</span>
<span class="nc" id="L6860">            return getFullCrewSize(entity);</span>
<span class="nc bnc" id="L6861" title="All 2 branches missed.">        } else if (entity.getCrew().getCrewType().getGunnerPos() &gt; 0) {</span>
            //Tripod, QuadVee, or dual cockpit
<span class="nc" id="L6863">            return 1;</span>
        }
<span class="nc" id="L6865">        return 0;</span>
    }

    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
    public static int getAeroCrewNeeds(Entity entity) {
<span class="nc bnc" id="L6870" title="All 2 branches missed.">        if (entity instanceof Dropship) {</span>
<span class="nc bnc" id="L6871" title="All 2 branches missed.">            if (((Dropship) entity).isMilitary()) {</span>
<span class="nc" id="L6872">                return 4 + (int) Math.ceil(entity.getWeight() / 5000.0);</span>
            } else {
<span class="nc" id="L6874">                return 3 + (int) Math.ceil(entity.getWeight() / 5000.0);</span>
            }
<span class="nc bnc" id="L6876" title="All 2 branches missed.">        } else if (entity instanceof SmallCraft) {</span>
<span class="nc" id="L6877">            return getTotalDriverNeeds(entity);</span>
<span class="nc bnc" id="L6878" title="All 4 branches missed.">        } else if (entity instanceof Warship || entity instanceof SpaceStation) {</span>
<span class="nc" id="L6879">            return 45 + (int) Math.ceil(entity.getWeight() / 5000.0);</span>
<span class="nc bnc" id="L6880" title="All 2 branches missed.">        } else if (entity instanceof Jumpship) {</span>
<span class="nc" id="L6881">            return 6 + (int) Math.ceil(entity.getWeight() / 20000.0);</span>
        }
<span class="nc" id="L6883">        return 0;</span>
    }

    /**
     * Calculates the base crew requirements for support vehicles.
     *
     * @param entity The support vehicle
     * @return       The minimum base crew
     */
    public static int getSVBaseCrewNeeds(Entity entity) {
<span class="nc bnc" id="L6893" title="All 4 branches missed.">        if (entity.isTrailer() &amp;&amp; (entity.getEngine().getEngineType() == Engine.NONE)) {</span>
<span class="nc" id="L6894">            return 0;</span>
        }
<span class="nc bnc" id="L6896" title="All 2 branches missed.">        final boolean naval = entity.getMovementMode().equals(EntityMovementMode.NAVAL)</span>
<span class="nc bnc" id="L6897" title="All 2 branches missed.">                || entity.getMovementMode().equals(EntityMovementMode.HYDROFOIL)</span>
<span class="nc bnc" id="L6898" title="All 2 branches missed.">                || entity.getMovementMode().equals(EntityMovementMode.SUBMARINE);</span>
        int crew;
<span class="nc bnc" id="L6900" title="All 2 branches missed.">        if (entity.getWeightClass() == EntityWeightClass.WEIGHT_SMALL_SUPPORT) {</span>
<span class="nc" id="L6901">            crew = 1;</span>
<span class="nc bnc" id="L6902" title="All 2 branches missed.">        } else if (entity.getWeightClass() == EntityWeightClass.WEIGHT_MEDIUM_SUPPORT) {</span>
<span class="nc bnc" id="L6903" title="All 4 branches missed.">            if (naval || entity.getMovementMode().equals(EntityMovementMode.AIRSHIP)) {</span>
<span class="nc" id="L6904">                crew = 4;</span>
            } else {
<span class="nc" id="L6906">                crew = 2;</span>
            }
        } else {
<span class="nc" id="L6909">            crew = 3;</span>
<span class="nc bnc" id="L6910" title="All 2 branches missed.">            if (naval) {</span>
<span class="nc" id="L6911">                crew += (int) Math.ceil(entity.getWeight() / 5000);</span>
<span class="nc bnc" id="L6912" title="All 2 branches missed.">            } else if (entity.getMovementMode().equals(EntityMovementMode.AIRSHIP)) {</span>
<span class="nc" id="L6913">                crew += (int) Math.ceil(entity.getWeight() / 500);</span>
            }
        }
<span class="nc" id="L6916">        return crew;</span>
    }

    /**
     * Calculates number of gunners required for a support vehicle. See TM, 131.
     *
     * @param entity The support vehicle
     * @return       The number of gunners required.
     */
    public static int getSupportVehicleGunnerNeeds(Entity entity) {
<span class="nc" id="L6926">        final boolean advFireCon = entity.hasMisc(MiscType.F_ADVANCED_FIRECONTROL);</span>
<span class="nc bnc" id="L6927" title="All 4 branches missed.">        final boolean basicFireCon = !advFireCon &amp;&amp; entity.hasMisc(MiscType.F_BASIC_FIRECONTROL);</span>
<span class="nc bnc" id="L6928" title="All 2 branches missed.">        if (entity.getWeightClass() == EntityWeightClass.WEIGHT_SMALL_SUPPORT) {</span>
<span class="nc bnc" id="L6929" title="All 4 branches missed.">            if (!advFireCon &amp;&amp; !basicFireCon) {</span>
                // No fire control requires one gunner per weapon.
<span class="nc" id="L6931">                return entity.getWeaponList().size();</span>
            } else {
                // Otherwise we require one gunner per facing, with turrets and pintle mounts counting
                // as separate facings
<span class="nc" id="L6935">                Set&lt;Integer&gt; facings = new HashSet&lt;&gt;();</span>
<span class="nc" id="L6936">                int pintles = 0;</span>
<span class="nc bnc" id="L6937" title="All 2 branches missed.">                for (Mounted m : entity.getWeaponList()) {</span>
<span class="nc bnc" id="L6938" title="All 2 branches missed.">                    if (m.isPintleTurretMounted()) {</span>
<span class="nc" id="L6939">                        pintles++;</span>
                    } else {
<span class="nc" id="L6941">                        facings.add(m.getLocation());</span>
                    }
<span class="nc" id="L6943">                }</span>
<span class="nc bnc" id="L6944" title="All 2 branches missed.">                if (advFireCon) {</span>
                    // Advanced fire control lets the driver count as a gunner, so one fewer dedicated gunners is needed.
<span class="nc" id="L6946">                    return Math.max(0, pintles + facings.size() - 1);</span>
                } else {
<span class="nc" id="L6948">                    return pintles + facings.size();</span>
                }
            }
        } else {
            // Medium and large support vehicle gunner requirements are based on weapon tonnage
<span class="nc bnc" id="L6953" title="All 2 branches missed.">            double tonnage = entity.getWeaponList().stream().filter(m -&gt; !m.getType().hasFlag(WeaponType.F_AMS))</span>
<span class="nc" id="L6954">                    .mapToDouble(m -&gt; m.getTonnage()).sum();</span>
<span class="nc bnc" id="L6955" title="All 2 branches missed.">            if (advFireCon) {</span>
<span class="nc bnc" id="L6956" title="All 2 branches missed.">                if (entity.getStructuralTechRating() == ITechnology.RATING_F) {</span>
<span class="nc" id="L6957">                    return (int) Math.ceil(tonnage / 6.0);</span>
<span class="nc bnc" id="L6958" title="All 2 branches missed.">                } else if (entity.getStructuralTechRating() == ITechnology.RATING_E) {</span>
<span class="nc" id="L6959">                    return (int) Math.ceil(tonnage / 5.0);</span>
                }
<span class="nc" id="L6961">                return (int) Math.ceil(tonnage / 4.0);</span>
<span class="nc bnc" id="L6962" title="All 2 branches missed.">            } else if (basicFireCon) {</span>
<span class="nc" id="L6963">                return (int) Math.ceil(tonnage / 3.0);</span>
            } else {
<span class="nc" id="L6965">                return (int) Math.ceil(tonnage / 2.0);</span>
            }
        }
    }

    /**
     * Calculates addiontal crew required by support vehicles and advanced aerospace vessels
     * for certain misc equipment.
     *
     * @param entity The unit
     * @return       The number of additional crew required
     */
    public static int getAdditionalNonGunner(Entity entity) {
<span class="nc" id="L6978">        int crew = 0;</span>
<span class="nc bnc" id="L6979" title="All 2 branches missed.">        for (Mounted m : entity.getMisc()) {</span>
<span class="nc bnc" id="L6980" title="All 2 branches missed.">            if (m.getType().hasFlag(MiscType.F_COMMUNICATIONS)) {</span>
<span class="nc" id="L6981">                crew += (int) m.getTonnage();</span>
<span class="nc bnc" id="L6982" title="All 2 branches missed.">            } else if (m.getType().hasFlag(MiscType.F_FIELD_KITCHEN)) {</span>
<span class="nc" id="L6983">                crew += 3;</span>
<span class="nc bnc" id="L6984" title="All 2 branches missed.">            } else if (m.getType().hasFlag(MiscType.F_MOBILE_FIELD_BASE)) {</span>
<span class="nc" id="L6985">                crew += 5;</span>
<span class="nc bnc" id="L6986" title="All 2 branches missed.">            } else if (m.getType().hasFlag(MiscType.F_MASH)) {</span>
<span class="nc" id="L6987">                crew += 5 * (int) m.getSize();</span>
            }
<span class="nc" id="L6989">        }</span>
<span class="nc" id="L6990">        return crew;</span>
    }

    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
    public static int getFullCrewSize(Entity entity) {
<span class="nc bnc" id="L6995" title="All 2 branches missed.">        if (entity.isSupportVehicle()) {</span>
<span class="nc" id="L6996">            int crew = getSVBaseCrewNeeds(entity) + getSupportVehicleGunnerNeeds(entity)</span>
<span class="nc" id="L6997">                    + getAdditionalNonGunner(entity);</span>
<span class="nc bnc" id="L6998" title="All 2 branches missed.">            if (crew &lt; 4) {</span>
<span class="nc" id="L6999">                return crew;</span>
            }
<span class="nc" id="L7001">            return crew + (int) Math.ceil(crew / 6.0);</span>
<span class="nc bnc" id="L7002" title="All 2 branches missed.">        } else if (entity instanceof Tank) {</span>
<span class="nc" id="L7003">            return (int) Math.ceil(entity.getWeight() / 15.0) + ((Tank) entity).getExtraCrewSeats();</span>
<span class="nc bnc" id="L7004" title="All 2 branches missed.">        } else if (entity instanceof BattleArmor) {</span>
<span class="nc" id="L7005">            int ntroopers = 0;</span>
<span class="nc bnc" id="L7006" title="All 2 branches missed.">            for (int trooper = 1; trooper &lt; entity.locations(); trooper++) {</span>
                //less than zero means the suit is destroyed
<span class="nc bnc" id="L7008" title="All 2 branches missed.">                if (entity.getInternal(trooper) &gt;= 0) {</span>
                    //Also, if any modular equipment is missing, then we will consider this
                    //unit to be inoperable and will not allow it to load soldiers. This is because
                    //we have no mechanism in MM to handle BA where some suits have the equipment
                    //and others do not
<span class="nc" id="L7013">                    boolean useSuit = true;</span>
<span class="nc bnc" id="L7014" title="All 2 branches missed.">                    for(Mounted m : entity.getEquipment()) {</span>
<span class="nc bnc" id="L7015" title="All 2 branches missed.">                        if(m.isMissingForTrooper(trooper)) {</span>
<span class="nc" id="L7016">                            useSuit = false;</span>
<span class="nc" id="L7017">                            break;</span>
                        }
<span class="nc" id="L7019">                    }</span>
<span class="nc bnc" id="L7020" title="All 2 branches missed.">                    if(useSuit) {</span>
<span class="nc" id="L7021">                        ntroopers++;</span>
                    }
                }
            }
<span class="nc" id="L7025">            return ntroopers;</span>
<span class="nc bnc" id="L7026" title="All 2 branches missed.">        } else if (entity instanceof Infantry) {</span>
<span class="nc" id="L7027">            return ((Infantry) entity).getSquadN() * ((Infantry) entity).getSquadSize();</span>
<span class="nc bnc" id="L7028" title="All 4 branches missed.">        } else if (entity instanceof Jumpship || entity instanceof SmallCraft) {</span>
<span class="nc" id="L7029">            return getAeroCrewNeeds(entity) + getTotalGunnerNeeds(entity);</span>
        } else {
<span class="nc" id="L7031">            return 1;</span>
        }
    }

    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
    public static int getTotalDriverNeeds(Entity entity) {
        //Fix for MHQ Bug #3. Space stations have as much need for pilots as jumpships do.
<span class="nc bnc" id="L7038" title="All 2 branches missed.">        if (entity instanceof SpaceStation) {</span>
<span class="nc" id="L7039">            return 2;</span>
        }
<span class="nc bnc" id="L7041" title="All 4 branches missed.">        if (entity instanceof SmallCraft || entity instanceof Jumpship) {</span>
            //its not at all clear how many pilots dropships and jumpships
            //should have, but the old BattleSpace book suggests they should
            //be able to get by with 2. For warships, lets go with 2 per shift
            // so 6.
<span class="nc bnc" id="L7046" title="All 2 branches missed.">            if (entity instanceof Warship) {</span>
<span class="nc" id="L7047">                return 6;</span>
            }
<span class="nc bnc" id="L7049" title="All 2 branches missed.">            if (entity instanceof SmallCraft) {</span>
<span class="nc" id="L7050">                return 3;</span>
            }
<span class="nc" id="L7052">            return 2;</span>
        }
<span class="nc bnc" id="L7054" title="All 2 branches missed.">        if (entity.getCrew().getCrewType() == CrewType.COMMAND_CONSOLE) {</span>
<span class="nc" id="L7055">            return 2;</span>
        }
<span class="nc bnc" id="L7057" title="All 8 branches missed.">        if (entity instanceof Mech || entity instanceof Tank || entity instanceof Aero || entity instanceof Protomech) {</span>
            //only one driver please
<span class="nc" id="L7059">            return 1;</span>
<span class="nc bnc" id="L7060" title="All 2 branches missed.">        } else if (entity instanceof Infantry) {</span>
<span class="nc" id="L7061">            return getFullCrewSize(entity);</span>
        }
<span class="nc" id="L7063">        return 0;</span>
    }
    
    /**
     * Should we treat this entity, in its current state, as if it is a spheroid unit
     * flying in atmosphere?
     */
    public static boolean useSpheroidAtmosphere(IGame game, Entity en) {
<span class="nc bnc" id="L7071" title="All 2 branches missed.">        if (!en.isAero()) {</span>
<span class="nc" id="L7072">            return false;</span>
        }
        // are we in space?
<span class="nc bnc" id="L7075" title="All 2 branches missed.">        if (game.getBoard().inSpace()) {</span>
<span class="nc" id="L7076">            return false;</span>
        }
        // aerodyne's will operate like spheroids in vacuum
<span class="nc bnc" id="L7079" title="All 2 branches missed.">        if (!((IAero) en).isSpheroid()</span>
<span class="nc bnc" id="L7080" title="All 2 branches missed.">                &amp;&amp; !game.getPlanetaryConditions().isVacuum()) {</span>
<span class="nc" id="L7081">            return false;</span>
        }
        // are we in atmosphere?
<span class="nc" id="L7084">        return en.isAirborne();</span>
    }

} // End public class Compute
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>