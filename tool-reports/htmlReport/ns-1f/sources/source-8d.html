


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > QuadMech</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">megamek.common</a>
</div>

<h1>Coverage Summary for Class: QuadMech (megamek.common)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">QuadMech</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (10/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6%
  </span>
  <span class="absValue">
    (30/502)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11,3%
  </span>
  <span class="absValue">
    (53/468)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * MegaMek -
&nbsp; *  Copyright (C) 2000-2002
&nbsp; *    Ben Mazur (bmazur@sev.org)
&nbsp; *    Cord Awtry (kipsta@bs-interactive.com)
&nbsp; *
&nbsp; *  This program is free software; you can redistribute it and/or modify it
&nbsp; *  under the terms of the GNU General Public License as published by the Free
&nbsp; *  Software Foundation; either version 2 of the License, or (at your option)
&nbsp; *  any later version.
&nbsp; *
&nbsp; *  This program is distributed in the hope that it will be useful, but
&nbsp; *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
&nbsp; *  for more details.
&nbsp; */
&nbsp;package megamek.common;
&nbsp;
&nbsp;import java.io.PrintWriter;
&nbsp;
&nbsp;import megamek.common.options.OptionsConstants;
&nbsp;import megamek.common.preference.PreferenceManager;
&nbsp;
&nbsp;public class QuadMech extends Mech {
&nbsp;    /**
&nbsp;     *
&nbsp;     */
&nbsp;    private static final long serialVersionUID = 7183093787457804717L;
&nbsp;
<b class="fc">&nbsp;    private static final String[] LOCATION_NAMES = { &quot;Head&quot;, &quot;Center Torso&quot;, &quot;Right Torso&quot;, &quot;Left Torso&quot;, &quot;Front Right Leg&quot;, &quot;Front Left Leg&quot;, &quot;Rear Right Leg&quot;, &quot;Rear Left Leg&quot; };</b>
&nbsp;
<b class="fc">&nbsp;    private static final String[] LOCATION_ABBRS = { &quot;HD&quot;, &quot;CT&quot;, &quot;RT&quot;, &quot;LT&quot;, &quot;FRL&quot;, &quot;FLL&quot;, &quot;RRL&quot;, &quot;RLL&quot; };</b>
&nbsp;
<b class="fc">&nbsp;    private static final int[] NUM_OF_SLOTS = { 6, 12, 12, 12, 6, 6, 6, 6 };</b>
&nbsp;
&nbsp;    public QuadMech(String inGyroType, String inCockpitType) {
<b class="fc">&nbsp;        this(Mech.getGyroTypeForString(inGyroType), Mech.getCockpitTypeForString(inCockpitType));</b>
&nbsp;    }
&nbsp;
&nbsp;    public QuadMech() {
<b class="nc">&nbsp;        this(Mech.GYRO_STANDARD, Mech.COCKPIT_STANDARD);</b>
&nbsp;    }
&nbsp;
&nbsp;    public QuadMech(int inGyroType, int inCockpitType) {
<b class="fc">&nbsp;        super(inGyroType, inCockpitType);</b>
&nbsp;
<b class="fc">&nbsp;        movementMode = EntityMovementMode.QUAD;</b>
<b class="fc">&nbsp;        originalMovementMode = EntityMovementMode.QUAD;</b>
&nbsp;
<b class="fc">&nbsp;        setCritical(LOC_RARM, 0, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, ACTUATOR_HIP));</b>
<b class="fc">&nbsp;        setCritical(LOC_RARM, 1, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, ACTUATOR_UPPER_LEG));</b>
<b class="fc">&nbsp;        setCritical(LOC_RARM, 2, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, ACTUATOR_LOWER_LEG));</b>
<b class="fc">&nbsp;        setCritical(LOC_RARM, 3, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, ACTUATOR_FOOT));</b>
&nbsp;
<b class="fc">&nbsp;        setCritical(LOC_LARM, 0, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, ACTUATOR_HIP));</b>
<b class="fc">&nbsp;        setCritical(LOC_LARM, 1, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, ACTUATOR_UPPER_LEG));</b>
<b class="fc">&nbsp;        setCritical(LOC_LARM, 2, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, ACTUATOR_LOWER_LEG));</b>
<b class="fc">&nbsp;        setCritical(LOC_LARM, 3, new CriticalSlot(CriticalSlot.TYPE_SYSTEM, ACTUATOR_FOOT));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the Mech cannot stand up any longer.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean cannotStandUpFromHullDown() {
<b class="nc">&nbsp;        int i = 0;</b>
<b class="nc">&nbsp;        if (isLocationBad(LOC_LARM)) {</b>
<b class="nc">&nbsp;            i++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isLocationBad(LOC_RARM)) {</b>
<b class="nc">&nbsp;            i++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isLocationBad(LOC_LLEG)) {</b>
<b class="nc">&nbsp;            i++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isLocationBad(LOC_RLEG)) {</b>
<b class="nc">&nbsp;            i++;</b>
&nbsp;        }
<b class="nc">&nbsp;        return i &gt;= 3;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getWalkMP(boolean gravity, boolean ignoreheat, boolean ignoremodulararmor) {
<b class="fc">&nbsp;        int wmp = getOriginalWalkMP();</b>
&nbsp;
<b class="fc">&nbsp;        int legsDestroyed = 0;</b>
<b class="fc">&nbsp;        int hipHits = 0;</b>
<b class="fc">&nbsp;        int actuatorHits = 0;</b>
&nbsp;
&nbsp;        //A Mech using tracks has its movement reduced by 25% per leg or track destroyed.
<b class="pc">&nbsp;        if (movementMode == EntityMovementMode.TRACKED) {</b>
<b class="nc">&nbsp;            for (Mounted m : getMisc()) {</b>
<b class="nc">&nbsp;                if (m.getType().hasFlag(MiscType.F_TRACKS)) {</b>
<b class="nc">&nbsp;                    if (m.isHit() || isLocationBad(m.getLocation())) {</b>
<b class="nc">&nbsp;                        legsDestroyed++;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            wmp = (wmp * (4 - legsDestroyed)) / 4;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            for (int i = 0; i &lt; locations(); i++) {</b>
<b class="fc">&nbsp;                if (locationIsLeg(i)) {</b>
<b class="pc">&nbsp;                    if (!isLocationBad(i)) {</b>
<b class="pc">&nbsp;                        if (legHasHipCrit(i)) {</b>
<b class="nc">&nbsp;                            hipHits++;</b>
<b class="nc">&nbsp;                            if ((game == null) || !game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_LEG_DAMAGE)) {</b>
<b class="nc">&nbsp;                                continue;</b>
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        actuatorHits += countLegActuatorCrits(i);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        legsDestroyed++;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            // leg damage effects
<b class="pc">&nbsp;            if (legsDestroyed &gt; 0) {</b>
<b class="nc">&nbsp;                if (legsDestroyed == 1) {</b>
<b class="nc">&nbsp;                    wmp--;</b>
<b class="nc">&nbsp;                } else if (legsDestroyed == 2) {</b>
<b class="nc">&nbsp;                    wmp = 1;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    wmp = 0;</b>
&nbsp;                }
&nbsp;            }        
<b class="pc">&nbsp;            if (wmp &gt; 0) {</b>
<b class="pc">&nbsp;                if (hipHits &gt; 0) {</b>
<b class="nc">&nbsp;                    if ((game != null) &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_LEG_DAMAGE)) {</b>
<b class="nc">&nbsp;                        wmp = wmp - (2 * hipHits);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        for (int i = 0; i &lt; hipHits; i++) {</b>
<b class="nc">&nbsp;                            wmp = (int) Math.ceil(wmp / 2.0);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                wmp -= actuatorHits;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if (!ignoremodulararmor &amp;&amp; hasModularArmor() ) {</b>
<b class="nc">&nbsp;            wmp--;</b>
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if (!ignoreheat) {</b>
&nbsp;            // factor in heat
<b class="pc">&nbsp;            if ((game != null) &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_HEAT)) {</b>
<b class="nc">&nbsp;                if (heat &lt; 30) {</b>
<b class="nc">&nbsp;                    wmp -= (heat / 5);</b>
<b class="nc">&nbsp;                } else if (heat &gt;= 49) {</b>
<b class="nc">&nbsp;                    wmp -= 9;</b>
<b class="nc">&nbsp;                } else if (heat &gt;= 43) {</b>
<b class="nc">&nbsp;                    wmp -= 8;</b>
<b class="nc">&nbsp;                } else if (heat &gt;= 37) {</b>
<b class="nc">&nbsp;                    wmp -= 7;</b>
<b class="nc">&nbsp;                } else if (heat &gt;= 31) {</b>
<b class="nc">&nbsp;                    wmp -= 6;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    wmp -= 5;</b>
&nbsp;                }
&nbsp;            } else {
<b class="fc">&nbsp;                wmp -= (heat / 5);</b>
&nbsp;            }
&nbsp;            // TSM negates some heat but has no benefit for &#39;Mechs using tracks or QuadVees in vehicle mode.
<b class="pc">&nbsp;            if ((heat &gt;= 9) &amp;&amp; hasTSM() &amp;&amp; legsDestroyed &lt; 2</b>
&nbsp;                    &amp;&amp; movementMode != EntityMovementMode.TRACKED
&nbsp;                    &amp;&amp; movementMode != EntityMovementMode.WHEELED) {
<b class="nc">&nbsp;                wmp += 2;</b>
&nbsp;            }
&nbsp;        }
<b class="pc">&nbsp;        if (null != game) {</b>
<b class="nc">&nbsp;            int weatherMod = game.getPlanetaryConditions().getMovementMods(this);</b>
<b class="nc">&nbsp;            if (weatherMod != 0) {</b>
<b class="nc">&nbsp;                wmp = Math.max(wmp + weatherMod, 0);</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // gravity
<b class="pc">&nbsp;        if (gravity) {</b>
<b class="fc">&nbsp;            wmp = applyGravityEffectsOnMP(wmp);</b>
&nbsp;        }
&nbsp;        // For sanity sake...
<b class="fc">&nbsp;        wmp = Math.max(0, wmp);</b>
<b class="fc">&nbsp;        return wmp;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this mech&#39;s running/flank mp modified for leg loss &amp; stuff.
&nbsp;     */
&nbsp;
&nbsp;    @Override
&nbsp;    public int getRunMP(boolean gravity, boolean ignoreheat, boolean ignoremodulararmor) {
<b class="pc">&nbsp;        if (countBadLegs() &lt;= 1</b>
<b class="nc">&nbsp;                || (this instanceof QuadVee &amp;&amp; getConversionMode() == QuadVee.CONV_MODE_VEHICLE</b>
&nbsp;                &amp;&amp; !convertingNow)) {
<b class="fc">&nbsp;            return super.getRunMP(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;        }
<b class="nc">&nbsp;        return getWalkMP(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns run MP without considering MASC modified for leg loss &amp; stuff.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getRunMPwithoutMASC(boolean gravity, boolean ignoreheat, boolean ignoremodulararmor) {
<b class="nc">&nbsp;        if (countBadLegs() &lt;= 1</b>
<b class="nc">&nbsp;                || (this instanceof QuadVee &amp;&amp; getConversionMode() == QuadVee.CONV_MODE_VEHICLE</b>
&nbsp;                &amp;&amp; !convertingNow)) {
<b class="nc">&nbsp;            return super.getRunMPwithoutMASC(gravity, ignoreheat, ignoremodulararmor);</b>
&nbsp;        }
<b class="nc">&nbsp;        return getWalkMP(gravity, ignoreheat);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canChangeSecondaryFacing() {
<b class="nc">&nbsp;    	return hasQuirk(OptionsConstants.QUIRK_POS_EXT_TWIST) &amp;&amp; !isProne();</b>
&nbsp;    }
&nbsp;    
&nbsp;	@Override
&nbsp;	public boolean isValidSecondaryFacing(int dir) {
<b class="nc">&nbsp;		int rotate = dir - getFacing();</b>
<b class="nc">&nbsp;		if (canChangeSecondaryFacing()) {</b>
<b class="nc">&nbsp;			return (rotate &lt;= 1) || (rotate == 5);</b>
&nbsp;		} else
<b class="nc">&nbsp;			return rotate == 0;</b>
&nbsp;	}	 
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true is the location is a leg
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean locationIsLeg(int loc) {
<b class="fc">&nbsp;        return ((loc == Mech.LOC_RLEG) || (loc == Mech.LOC_LLEG) || (loc == Mech.LOC_RARM) || (loc == Mech.LOC_LARM));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the Compute.ARC that the weapon fires into.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getWeaponArc(int wn) {
<b class="nc">&nbsp;        final Mounted mounted = getEquipment(wn);</b>
&nbsp;
&nbsp;        // B-Pods need to be special-cased, the have 360 firing arc
<b class="nc">&nbsp;        if ((mounted.getType() instanceof WeaponType) &amp;&amp;</b>
<b class="nc">&nbsp;                mounted.getType().hasFlag(WeaponType.F_B_POD)) {</b>
<b class="nc">&nbsp;            return Compute.ARC_360;</b>
&nbsp;        }
&nbsp;        // VGLs base arc on their facing
<b class="nc">&nbsp;        if (mounted.getType().hasFlag(WeaponType.F_VGL)) {</b>
<b class="nc">&nbsp;            return Compute.firingArcFromVGLFacing(mounted.getFacing());</b>
&nbsp;        }
&nbsp;        // rear mounted?
<b class="nc">&nbsp;        if (mounted.isRearMounted()) {</b>
<b class="nc">&nbsp;            return Compute.ARC_REAR;</b>
&nbsp;        }
&nbsp;        // front mounted
<b class="nc">&nbsp;        switch (mounted.getLocation()) {</b>
&nbsp;        case LOC_HEAD:
&nbsp;        case LOC_CT:
&nbsp;        case LOC_RT:
&nbsp;        case LOC_LT:
&nbsp;        case LOC_RLEG:
&nbsp;        case LOC_LLEG:
&nbsp;        case LOC_LARM:
&nbsp;        case LOC_RARM:
<b class="nc">&nbsp;            return Compute.ARC_FORWARD;</b>
&nbsp;        default:
<b class="nc">&nbsp;            return Compute.ARC_360;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the internal structure for the mech.
&nbsp;     *
&nbsp;     * @param head
&nbsp;     *            head
&nbsp;     * @param ct
&nbsp;     *            center torso
&nbsp;     * @param t
&nbsp;     *            right/left torso
&nbsp;     * @param arm
&nbsp;     *            right/left arm
&nbsp;     * @param leg
&nbsp;     *            right/left leg
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void setInternal(int head, int ct, int t, int arm, int leg) {
<b class="fc">&nbsp;        initializeInternal(head, LOC_HEAD);</b>
<b class="fc">&nbsp;        initializeInternal(ct, LOC_CT);</b>
<b class="fc">&nbsp;        initializeInternal(t, LOC_RT);</b>
<b class="fc">&nbsp;        initializeInternal(t, LOC_LT);</b>
<b class="fc">&nbsp;        initializeInternal(leg, LOC_RARM);</b>
<b class="fc">&nbsp;        initializeInternal(leg, LOC_LARM);</b>
<b class="fc">&nbsp;        initializeInternal(leg, LOC_RLEG);</b>
<b class="fc">&nbsp;        initializeInternal(leg, LOC_LLEG);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true is the entity needs a roll to stand up
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean needsRollToStand() {
<b class="nc">&nbsp;        if (countBadLegs() == 0) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;    
&nbsp;    public PilotingRollData addQuadPilotingBonus(PilotingRollData roll, int destroyedLegs) {
<b class="nc">&nbsp;        if (destroyedLegs == 0) {</b>
<b class="nc">&nbsp;            roll.addModifier(-2, &quot;Quad bonus&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return roll;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add in any piloting skill mods
&nbsp;     */
&nbsp;    @Override
&nbsp;    public PilotingRollData addEntityBonuses(PilotingRollData roll) {
<b class="nc">&nbsp;        int[] locsToCheck = new int[4];</b>
<b class="nc">&nbsp;        int destroyedLegs = 0;</b>
&nbsp;
<b class="nc">&nbsp;        locsToCheck = new int[4];</b>
<b class="nc">&nbsp;        locsToCheck[0] = Mech.LOC_RLEG;</b>
<b class="nc">&nbsp;        locsToCheck[1] = Mech.LOC_LLEG;</b>
<b class="nc">&nbsp;        locsToCheck[2] = Mech.LOC_RARM;</b>
<b class="nc">&nbsp;        locsToCheck[3] = Mech.LOC_LARM;</b>
&nbsp;
<b class="nc">&nbsp;        destroyedLegs = countBadLegs();</b>
&nbsp;
&nbsp;        // QuadVees lose the bonus when converting.
<b class="nc">&nbsp;        if (destroyedLegs == 0 &amp;&amp; !convertingNow) {</b>
<b class="nc">&nbsp;            roll.addModifier(-2, &quot;Quad bonus&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hasAbility(OptionsConstants.PILOT_ANIMAL_MIMIC)) {</b>
<b class="nc">&nbsp;            roll.addModifier(-1, &quot;Animal Mimicry&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hasFunctionalLegAES()) {</b>
<b class="nc">&nbsp;            roll.addModifier(-2, &quot;AES bonus&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean destroyedLegCounted = false;</b>
<b class="nc">&nbsp;        for (int loc : locsToCheck) {</b>
<b class="nc">&nbsp;            if (isLocationBad(loc)) {</b>
&nbsp;                // a quad with 2 destroyed legs acts like a biped with one leg
&nbsp;                // destroyed, so add the +5 only once
&nbsp;                // 3 or more destroyed legs are being taken care in
&nbsp;                // getBasePiloting
<b class="nc">&nbsp;                if ((destroyedLegs == 2) &amp;&amp; !destroyedLegCounted) {</b>
<b class="nc">&nbsp;                    roll.addModifier(5, &quot;2 legs destroyed&quot;);</b>
<b class="nc">&nbsp;                    destroyedLegCounted = true;</b>
&nbsp;                }
&nbsp;            } else {
&nbsp;                // check for damaged hip actuators
<b class="nc">&nbsp;                if (getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_HIP, loc) &gt; 0) {</b>
<b class="nc">&nbsp;                    roll.addModifier(2, getLocationName(loc) + &quot; Hip Actuator destroyed&quot;);</b>
<b class="nc">&nbsp;                    if (!game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_LEG_DAMAGE)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                // upper leg actuators?
<b class="nc">&nbsp;                if (getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_UPPER_LEG, loc) &gt; 0) {</b>
<b class="nc">&nbsp;                    roll.addModifier(1, getLocationName(loc) + &quot; Upper Leg Actuator destroyed&quot;);</b>
&nbsp;                }
&nbsp;                // lower leg actuators?
<b class="nc">&nbsp;                if (getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_LOWER_LEG, loc) &gt; 0) {</b>
<b class="nc">&nbsp;                    roll.addModifier(1, getLocationName(loc) + &quot; Lower Leg Actuator destroyed&quot;);</b>
&nbsp;                }
&nbsp;                // foot actuators?
<b class="nc">&nbsp;                if (getBadCriticals(CriticalSlot.TYPE_SYSTEM, Mech.ACTUATOR_FOOT, loc) &gt; 0) {</b>
<b class="nc">&nbsp;                    roll.addModifier(1, getLocationName(loc) + &quot; Foot Actuator destroyed&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return super.addEntityBonuses(roll);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of slot counts for all locations
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected int[] getNoOfSlots() {
<b class="fc">&nbsp;        return NUM_OF_SLOTS;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of names for all locations
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String[] getLocationNames() {
<b class="nc">&nbsp;        return LOCATION_NAMES;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a vector of abbreviations for all locations
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String[] getLocationAbbrs() {
<b class="nc">&nbsp;        return LOCATION_ABBRS;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static int restrictScore(int location) {
<b class="nc">&nbsp;        switch (location) {</b>
&nbsp;        case Mech.LOC_RT:
&nbsp;        case Mech.LOC_LT:
<b class="nc">&nbsp;            return 1;</b>
&nbsp;        case Mech.LOC_CT:
<b class="nc">&nbsp;            return 2;</b>
&nbsp;        default:
<b class="nc">&nbsp;            return 3;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected double getArmActuatorCost() {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected double getLegActuatorCost() {
<b class="nc">&nbsp;        return (weight * 150 * 4) + (weight * 80 * 4) + (weight * 120 * 4);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public HitData rollHitLocation(int table, int side, int aimedLocation, int aimingMode, int cover) {
<b class="nc">&nbsp;        int roll = -1;</b>
&nbsp;
<b class="nc">&nbsp;        if ((aimedLocation != LOC_NONE) &amp;&amp; (aimingMode != IAimingModes.AIM_MODE_NONE)) {</b>
<b class="nc">&nbsp;            roll = Compute.d6(2);</b>
&nbsp;
<b class="nc">&nbsp;            if ((5 &lt; roll) &amp;&amp; (roll &lt; 9)) {</b>
<b class="nc">&nbsp;                return new HitData(aimedLocation, side == ToHitData.SIDE_REAR, true);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_ADVANCED_MECH_HIT_LOCATIONS)) {</b>
<b class="nc">&nbsp;            if ((table == ToHitData.HIT_NORMAL) || (table == ToHitData.HIT_PARTIAL_COVER)) {</b>
<b class="nc">&nbsp;                roll = Compute.d6(2);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    PrintWriter pw = PreferenceManager.getClientPreferences().getMekHitLocLog();</b>
<b class="nc">&nbsp;                    if (pw != null) {</b>
<b class="nc">&nbsp;                        pw.print(table);</b>
<b class="nc">&nbsp;                        pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                        pw.print(side);</b>
<b class="nc">&nbsp;                        pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                        pw.println(roll);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (Throwable thrown) {</b>
<b class="nc">&nbsp;                    thrown.printStackTrace();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (side == ToHitData.SIDE_FRONT) {</b>
&nbsp;                    // normal front hits
<b class="nc">&nbsp;                    switch (roll) {</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        if ((getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_TAC))</b>
<b class="nc">&nbsp;                                &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_NO_TAC)) {</b>
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                            result.setUndoneLocation(tac(table, side, Mech.LOC_CT, cover, false));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return tac(table, side, Mech.LOC_CT, cover, false);</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                    case 4:
&nbsp;                    case 5:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LARM);</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LT);</b>
&nbsp;                    case 7:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CT);</b>
&nbsp;                    case 8:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RT);</b>
&nbsp;                    case 9:
&nbsp;                    case 10:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RARM);</b>
&nbsp;                    case 11:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RLEG);</b>
&nbsp;                    case 12:
<b class="nc">&nbsp;                        if ((getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_HEADHIT))) {</b>
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side, aimedLocation, cover, aimingMode);</b>
<b class="nc">&nbsp;                            result.setUndoneLocation(new HitData(Mech.LOC_HEAD));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_HEAD);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (side == ToHitData.SIDE_REAR) {</b>
<b class="nc">&nbsp;                    switch (roll) {</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        if ((getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_TAC))</b>
<b class="nc">&nbsp;                                &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_NO_TAC)) {</b>
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                            result.setUndoneLocation(tac(table, side, Mech.LOC_CT, cover, true));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return tac(table, side, Mech.LOC_CT, cover, true);</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LARM, true);</b>
&nbsp;                    case 4:
&nbsp;                    case 5:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LLEG, true);</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LT, true);</b>
&nbsp;                    case 7:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CT, true);</b>
&nbsp;                    case 8:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RT, true);</b>
&nbsp;                    case 9:
&nbsp;                    case 10:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RLEG, true);</b>
&nbsp;                    case 11:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RARM, true);</b>
&nbsp;                    case 12:
<b class="nc">&nbsp;                        if ((getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_HEADHIT))) {</b>
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                            result.setUndoneLocation(new HitData(Mech.LOC_HEAD, true));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_HEAD, true);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (side == ToHitData.SIDE_LEFT) {</b>
<b class="nc">&nbsp;                    switch (roll) {</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        if ((getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_TAC))</b>
<b class="nc">&nbsp;                                &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_NO_TAC)) {</b>
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                            result.setUndoneLocation(tac(table, side, Mech.LOC_LT, cover, false));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return tac(table, side, Mech.LOC_LT, cover, false);</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RARM);</b>
&nbsp;                    case 4:
&nbsp;                    case 5:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LARM);</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RT);</b>
&nbsp;                    case 7:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LT);</b>
&nbsp;                    case 8:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CT);</b>
&nbsp;                    case 9:
&nbsp;                    case 10:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                    case 11:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RLEG);</b>
&nbsp;                    case 12:
<b class="nc">&nbsp;                        if ((getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_HEADHIT))) {</b>
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                            result.setUndoneLocation(new HitData(Mech.LOC_HEAD));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_HEAD);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (side == ToHitData.SIDE_RIGHT) {</b>
<b class="nc">&nbsp;                    switch (roll) {</b>
&nbsp;                    case 2:
<b class="nc">&nbsp;                        if ((getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_TAC))</b>
<b class="nc">&nbsp;                                &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_NO_TAC)) {</b>
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                            result.setUndoneLocation(tac(table, side, Mech.LOC_RT, cover, false));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return tac(table, side, Mech.LOC_RT, cover, false);</b>
&nbsp;                    case 3:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LARM);</b>
&nbsp;                    case 4:
&nbsp;                    case 5:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RARM);</b>
&nbsp;                    case 6:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_CT);</b>
&nbsp;                    case 7:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RT);</b>
&nbsp;                    case 8:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LT);</b>
&nbsp;                    case 9:
&nbsp;                    case 10:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_RLEG);</b>
&nbsp;                    case 11:
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                    case 12:
<b class="nc">&nbsp;                        if ((getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                                &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_HEADHIT))) {</b>
<b class="nc">&nbsp;                            getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                            HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                            result.setUndoneLocation(new HitData(Mech.LOC_HEAD));</b>
<b class="nc">&nbsp;                            return result;</b>
&nbsp;                        } // if
<b class="nc">&nbsp;                        return new HitData(Mech.LOC_HEAD);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (table == ToHitData.HIT_PUNCH) {</b>
<b class="nc">&nbsp;            roll = Compute.d6();</b>
&nbsp;            try {
<b class="nc">&nbsp;                PrintWriter pw = PreferenceManager.getClientPreferences().getMekHitLocLog();</b>
<b class="nc">&nbsp;                if (pw != null) {</b>
<b class="nc">&nbsp;                    pw.print(table);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.print(side);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.println(roll);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Throwable thrown) {</b>
<b class="nc">&nbsp;                thrown.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (side == ToHitData.SIDE_FRONT) {</b>
<b class="nc">&nbsp;                switch (roll) {</b>
&nbsp;                case 1:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LARM);</b>
&nbsp;                case 2:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LT);</b>
&nbsp;                case 3:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_CT);</b>
&nbsp;                case 4:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RT);</b>
&nbsp;                case 5:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RARM);</b>
&nbsp;                case 6:
<b class="nc">&nbsp;                    if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_HEADHIT)) {</b>
<b class="nc">&nbsp;                        getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                        HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                        result.setUndoneLocation(new HitData(Mech.LOC_HEAD, true));</b>
<b class="nc">&nbsp;                        return result;</b>
&nbsp;                    } // if
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_HEAD, true);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (side == ToHitData.SIDE_REAR) {</b>
<b class="nc">&nbsp;                switch (roll) {</b>
&nbsp;                case 1:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LLEG, true);</b>
&nbsp;                case 2:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LT, true);</b>
&nbsp;                case 3:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_CT, true);</b>
&nbsp;                case 4:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RT, true);</b>
&nbsp;                case 5:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RLEG, true);</b>
&nbsp;                case 6:
<b class="nc">&nbsp;                    if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_HEADHIT)) {</b>
<b class="nc">&nbsp;                        getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                        HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                        result.setUndoneLocation(new HitData(Mech.LOC_HEAD, true));</b>
<b class="nc">&nbsp;                        return result;</b>
&nbsp;                    } // if
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_HEAD, true);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (side == ToHitData.SIDE_LEFT) {</b>
<b class="nc">&nbsp;                switch (roll) {</b>
&nbsp;                case 1:
&nbsp;                case 2:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LT);</b>
&nbsp;                case 3:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_CT);</b>
&nbsp;                case 4:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LARM);</b>
&nbsp;                case 5:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                case 6:
<b class="nc">&nbsp;                    if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_HEADHIT)) {</b>
<b class="nc">&nbsp;                        getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                        HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                        result.setUndoneLocation(new HitData(Mech.LOC_HEAD, true));</b>
<b class="nc">&nbsp;                        return result;</b>
&nbsp;                    } // if
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_HEAD);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (side == ToHitData.SIDE_RIGHT) {</b>
<b class="nc">&nbsp;                switch (roll) {</b>
&nbsp;                case 1:
&nbsp;                case 2:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RT);</b>
&nbsp;                case 3:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_CT);</b>
&nbsp;                case 4:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RARM);</b>
&nbsp;                case 5:
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RLEG);</b>
&nbsp;                case 6:
<b class="nc">&nbsp;                    if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                            &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_HEADHIT)) {</b>
<b class="nc">&nbsp;                        getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                        HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                        result.setUndoneLocation(new HitData(Mech.LOC_HEAD, true));</b>
<b class="nc">&nbsp;                        return result;</b>
&nbsp;                    } // if
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_HEAD);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } else if (table == ToHitData.HIT_KICK) {</b>
<b class="nc">&nbsp;            roll = Compute.d6(1);</b>
&nbsp;            try {
<b class="nc">&nbsp;                PrintWriter pw = PreferenceManager.getClientPreferences().getMekHitLocLog();</b>
<b class="nc">&nbsp;                if (pw != null) {</b>
<b class="nc">&nbsp;                    pw.print(table);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.print(side);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.println(roll);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Throwable thrown) {</b>
<b class="nc">&nbsp;                thrown.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            boolean left = (roll &lt;= 3);</b>
<b class="nc">&nbsp;            if (side == ToHitData.SIDE_FRONT) {</b>
<b class="nc">&nbsp;                if (left) {</b>
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LARM);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new HitData(Mech.LOC_RARM);</b>
<b class="nc">&nbsp;            } else if (side == ToHitData.SIDE_REAR) {</b>
<b class="nc">&nbsp;                if (left) {</b>
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new HitData(Mech.LOC_RLEG);</b>
<b class="nc">&nbsp;            } else if (side == ToHitData.SIDE_LEFT) {</b>
<b class="nc">&nbsp;                if (left) {</b>
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_LLEG);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new HitData(Mech.LOC_LARM);</b>
<b class="nc">&nbsp;            } else if (side == ToHitData.SIDE_RIGHT) {</b>
<b class="nc">&nbsp;                if (left) {</b>
<b class="nc">&nbsp;                    return new HitData(Mech.LOC_RARM);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new HitData(Mech.LOC_RLEG);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if ((table == ToHitData.HIT_SWARM) || (table == ToHitData.HIT_SWARM_CONVENTIONAL)) {</b>
&nbsp;            int effects;
<b class="nc">&nbsp;            if (table == ToHitData.HIT_SWARM_CONVENTIONAL) {</b>
<b class="nc">&nbsp;                effects = HitData.EFFECT_NONE;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                effects = HitData.EFFECT_CRITICAL;</b>
&nbsp;            }
<b class="nc">&nbsp;            roll = Compute.d6(2);</b>
&nbsp;            try {
<b class="nc">&nbsp;                PrintWriter pw = PreferenceManager.getClientPreferences().getMekHitLocLog();</b>
<b class="nc">&nbsp;                if (pw != null) {</b>
<b class="nc">&nbsp;                    pw.print(table);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.print(side);</b>
<b class="nc">&nbsp;                    pw.print(&quot;\t&quot;);</b>
<b class="nc">&nbsp;                    pw.println(roll);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Throwable thrown) {</b>
<b class="nc">&nbsp;                thrown.printStackTrace();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            // Swarm attack locations.
<b class="nc">&nbsp;            switch (roll) {</b>
&nbsp;            case 2:
<b class="nc">&nbsp;                if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                        &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_HEADHIT)) {</b>
<b class="nc">&nbsp;                    getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                    HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                    result.setUndoneLocation(new HitData(Mech.LOC_HEAD, false, effects));</b>
<b class="nc">&nbsp;                    return result;</b>
&nbsp;                } // if
<b class="nc">&nbsp;                return new HitData(Mech.LOC_HEAD, false, effects);</b>
&nbsp;            case 3:
<b class="nc">&nbsp;                return new HitData(Mech.LOC_RT, false, effects);</b>
&nbsp;            case 4:
<b class="nc">&nbsp;                return new HitData(Mech.LOC_CT, true, effects);</b>
&nbsp;            case 5:
<b class="nc">&nbsp;                return new HitData(Mech.LOC_RT, true, effects);</b>
&nbsp;            case 6:
<b class="nc">&nbsp;                return new HitData(Mech.LOC_RT, false, effects);</b>
&nbsp;            case 7:
<b class="nc">&nbsp;                return new HitData(Mech.LOC_CT, false, effects);</b>
&nbsp;            case 8:
<b class="nc">&nbsp;                return new HitData(Mech.LOC_LT, false, effects);</b>
&nbsp;            case 9:
<b class="nc">&nbsp;                return new HitData(Mech.LOC_LT, true, effects);</b>
&nbsp;            case 10:
<b class="nc">&nbsp;                return new HitData(Mech.LOC_CT, true, effects);</b>
&nbsp;            case 11:
<b class="nc">&nbsp;                return new HitData(Mech.LOC_LT, false, effects);</b>
&nbsp;            case 12:
<b class="nc">&nbsp;                if (getCrew().hasEdgeRemaining()</b>
<b class="nc">&nbsp;                        &amp;&amp; getCrew().getOptions().booleanOption(OptionsConstants.EDGE_WHEN_HEADHIT)) {</b>
<b class="nc">&nbsp;                    getCrew().decreaseEdge();</b>
<b class="nc">&nbsp;                    HitData result = rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
<b class="nc">&nbsp;                    result.setUndoneLocation(new HitData(Mech.LOC_HEAD, false, effects));</b>
<b class="nc">&nbsp;                    return result;</b>
&nbsp;                } // if
<b class="nc">&nbsp;                return new HitData(Mech.LOC_HEAD, false, effects);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return super.rollHitLocation(table, side, aimedLocation, aimingMode, cover);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean removePartialCoverHits(int location, int cover, int side) {
&nbsp;        // treat front legs like legs not arms.
&nbsp;        
&nbsp;        // Handle upper cover specially, as treating it as a bitmask will lead
&nbsp;        //  to every location being covered
<b class="nc">&nbsp;        if (cover  == LosEffects.COVER_UPPER) {</b>
<b class="nc">&nbsp;            if ((location == LOC_LLEG) || (location == LOC_RLEG)</b>
&nbsp;                    || (location == LOC_LARM) || (location == LOC_RARM)) {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        
&nbsp;        // left and right cover are from attacker&#39;s POV.
&nbsp;        // if hitting front arc, need to swap them
<b class="nc">&nbsp;        if (side == ToHitData.SIDE_FRONT) {</b>
<b class="nc">&nbsp;            if (((cover &amp; LosEffects.COVER_LOWRIGHT) != 0) &amp;&amp;</b>
&nbsp;                    ((location == Mech.LOC_LARM) ||
&nbsp;                     (location == Mech.LOC_LLEG))) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (((cover &amp; LosEffects.COVER_LOWLEFT) != 0) &amp;&amp;</b>
&nbsp;                    ((location == Mech.LOC_RARM) ||
&nbsp;                     (location == Mech.LOC_RLEG))) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (((cover &amp; LosEffects.COVER_RIGHT) != 0) &amp;&amp;</b>
&nbsp;                    ((location == Mech.LOC_LARM) ||
&nbsp;                     (location == Mech.LOC_LT) ||
&nbsp;                     (location == Mech.LOC_LLEG))) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (((cover &amp; LosEffects.COVER_LEFT) != 0) &amp;&amp;</b>
&nbsp;                    ((location == Mech.LOC_RARM) ||
&nbsp;                     (location == Mech.LOC_RT) ||
&nbsp;                     (location == Mech.LOC_RLEG))) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            if (((cover &amp; LosEffects.COVER_LOWLEFT) != 0) &amp;&amp;</b>
&nbsp;                    ((location == Mech.LOC_LARM) ||
&nbsp;                     (location == Mech.LOC_LLEG))) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (((cover &amp; LosEffects.COVER_LOWRIGHT) != 0) &amp;&amp;</b>
&nbsp;                    ((location == Mech.LOC_RARM) ||
&nbsp;                     (location == Mech.LOC_RLEG))) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (((cover &amp; LosEffects.COVER_LEFT) != 0) &amp;&amp;</b>
&nbsp;                    ((location == Mech.LOC_LARM) ||
&nbsp;                     (location == Mech.LOC_LT) ||
&nbsp;                     (location == Mech.LOC_LLEG))) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (((cover &amp; LosEffects.COVER_RIGHT) != 0) &amp;&amp;</b>
&nbsp;                    ((location == Mech.LOC_RARM) ||
&nbsp;                     (location == Mech.LOC_RT) ||
&nbsp;                     (location == Mech.LOC_RLEG))) {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks for functional AES in all legs
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasFunctionalLegAES() {
<b class="nc">&nbsp;        boolean frontRightLeg = false;</b>
<b class="nc">&nbsp;        boolean frontLeftLeg = false;</b>
<b class="nc">&nbsp;        boolean rearRightLeg = false;</b>
<b class="nc">&nbsp;        boolean rearLeftLeg = false;</b>
&nbsp;
<b class="nc">&nbsp;        for (Mounted mounted : getMisc()) {</b>
<b class="nc">&nbsp;            if ((mounted.getLocation() == Mech.LOC_LLEG) || (mounted.getLocation() == Mech.LOC_RLEG) || (mounted.getLocation() == Mech.LOC_LARM) || (mounted.getLocation() == Mech.LOC_RARM)) {</b>
<b class="nc">&nbsp;                if (((MiscType) mounted.getType()).hasFlag(MiscType.F_ACTUATOR_ENHANCEMENT_SYSTEM) &amp;&amp; !mounted.isDestroyed() &amp;&amp; !mounted.isBreached() &amp;&amp; !mounted.isMissing()) {</b>
<b class="nc">&nbsp;                    if (mounted.getLocation() == Mech.LOC_LLEG) {</b>
<b class="nc">&nbsp;                        rearLeftLeg = true;</b>
<b class="nc">&nbsp;                    } else if (mounted.getLocation() == Mech.LOC_RLEG) {</b>
<b class="nc">&nbsp;                        rearRightLeg = true;</b>
<b class="nc">&nbsp;                    } else if (mounted.getLocation() == Mech.LOC_RARM) {</b>
<b class="nc">&nbsp;                        frontRightLeg = true;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        frontLeftLeg = true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                }// AES is destroyed their for it cannot be used.
<b class="nc">&nbsp;                else if (((MiscType) mounted.getType()).hasFlag(MiscType.F_ACTUATOR_ENHANCEMENT_SYSTEM)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return frontLeftLeg &amp;&amp; frontRightLeg &amp;&amp; rearRightLeg &amp;&amp; rearLeftLeg;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canGoHullDown() {
&nbsp;        // check the option
<b class="nc">&nbsp;        boolean retVal = game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_HULL_DOWN);</b>
<b class="nc">&nbsp;        if (!retVal) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        //check the locations
<b class="nc">&nbsp;        int locations[] = {Mech.LOC_RARM, Mech.LOC_LARM, Mech.LOC_LLEG, Mech.LOC_RLEG};</b>
<b class="nc">&nbsp;        int badLocs = 0;</b>
<b class="nc">&nbsp;        for ( int loc = locations.length -1; loc &gt;= 0; loc-- ) {</b>
<b class="nc">&nbsp;            if ( isLocationBad(locations[loc]) || isLocationDoomed(locations[loc])) {</b>
<b class="nc">&nbsp;                badLocs++;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (!(badLocs &lt;2)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        //check the Gyro
<b class="nc">&nbsp;        return !isGyroDestroyed();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Is the passed in location an arm?
&nbsp;     * @param loc
&nbsp;     * @return
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isArm(int loc) {
&nbsp;        // quads don&#39;t have arms
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean hasMPReducingHardenedArmor() {
<b class="pc">&nbsp;        return (armorType[LOC_LLEG] == EquipmentType.T_ARMOR_HARDENED)</b>
&nbsp;            || (armorType[LOC_RLEG] == EquipmentType.T_ARMOR_HARDENED)
&nbsp;            || (armorType[LOC_LARM] == EquipmentType.T_ARMOR_HARDENED)
&nbsp;            || (armorType[LOC_RARM] == EquipmentType.T_ARMOR_HARDENED);
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long getEntityType(){
<b class="fc">&nbsp;        return Entity.ETYPE_MECH | Entity.ETYPE_QUAD_MECH;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * quad mechs can&#39;t have claws
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean hasClaw(int location) {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:57</div>
</div>
</body>
</html>
