


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > DataHandler</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">javax.activation</a>
</div>

<h1>Coverage Summary for Class: DataHandler (javax.activation)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DataHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/72)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/149)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.
&nbsp; *
&nbsp; * This program and the accompanying materials are made available under the
&nbsp; * terms of the Eclipse Distribution License v. 1.0, which is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; */
&nbsp;
&nbsp;package javax.activation;
&nbsp;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.OutputStream;
&nbsp;import java.io.PipedInputStream;
&nbsp;import java.io.PipedOutputStream;
&nbsp;import java.io.OutputStreamWriter;
&nbsp;import java.net.URL;
&nbsp;import java.awt.datatransfer.Transferable;
&nbsp;import java.awt.datatransfer.DataFlavor;
&nbsp;import java.awt.datatransfer.UnsupportedFlavorException;
&nbsp;
&nbsp;/**
&nbsp; * The DataHandler class provides a consistent interface to data
&nbsp; * available in many different sources and formats.
&nbsp; * It manages simple stream to string conversions and related operations
&nbsp; * using DataContentHandlers.
&nbsp; * It provides access to commands that can operate on the data.
&nbsp; * The commands are found using a CommandMap. &lt;p&gt;
&nbsp; *
&nbsp; * &lt;b&gt;DataHandler and the Transferable Interface&lt;/b&gt;&lt;p&gt;
&nbsp; * DataHandler implements the Transferable interface so that data can
&nbsp; * be used in AWT data transfer operations, such as cut and paste and
&nbsp; * drag and drop. The implementation of the Transferable interface
&nbsp; * relies on the availability of an installed DataContentHandler
&nbsp; * object corresponding to the MIME type of the data represented in
&nbsp; * the specific instance of the DataHandler.&lt;p&gt;
&nbsp; *
&nbsp; * &lt;b&gt;DataHandler and CommandMaps&lt;/b&gt;&lt;p&gt;
&nbsp; * The DataHandler keeps track of the current CommandMap that it uses to
&nbsp; * service requests for commands (&lt;code&gt;getCommand&lt;/code&gt;,
&nbsp; * &lt;code&gt;getAllCommands&lt;/code&gt;, &lt;code&gt;getPreferredCommands&lt;/code&gt;).
&nbsp; * Each instance of a DataHandler may have a CommandMap associated with
&nbsp; * it using the &lt;code&gt;setCommandMap&lt;/code&gt; method.  If a CommandMap was
&nbsp; * not set, DataHandler calls the &lt;code&gt;getDefaultCommandMap&lt;/code&gt;
&nbsp; * method in CommandMap and uses the value it returns. See
&nbsp; * &lt;i&gt;CommandMap&lt;/i&gt; for more information. &lt;p&gt;
&nbsp; *
&nbsp; * &lt;b&gt;DataHandler and URLs&lt;/b&gt;&lt;p&gt;
&nbsp; * The current DataHandler implementation creates a private
&nbsp; * instance of URLDataSource when it is constructed with a URL.
&nbsp; *
&nbsp; * @see javax.activation.CommandMap
&nbsp; * @see javax.activation.DataContentHandler
&nbsp; * @see javax.activation.DataSource
&nbsp; * @see javax.activation.URLDataSource
&nbsp; */
&nbsp;
<b class="nc">&nbsp;public class DataHandler implements Transferable {</b>
&nbsp;
&nbsp;    // Use the datasource to indicate whether we were started via the
&nbsp;    // DataSource constructor or the object constructor.
<b class="nc">&nbsp;    private DataSource dataSource = null;</b>
<b class="nc">&nbsp;    private DataSource objDataSource = null;</b>
&nbsp;
&nbsp;    // The Object and mimetype from the constructor (if passed in).
&nbsp;    // object remains null if it was instantiated with a
&nbsp;    // DataSource.
<b class="nc">&nbsp;    private Object object = null;</b>
<b class="nc">&nbsp;    private String objectMimeType = null;</b>
&nbsp;
&nbsp;    // Keep track of the CommandMap
<b class="nc">&nbsp;    private CommandMap currentCommandMap = null;</b>
&nbsp;
&nbsp;    // our transfer flavors
<b class="nc">&nbsp;    private static final DataFlavor emptyFlavors[] = new DataFlavor[0];</b>
<b class="nc">&nbsp;    private DataFlavor transferFlavors[] = emptyFlavors;</b>
&nbsp;
&nbsp;    // our DataContentHandler
<b class="nc">&nbsp;    private DataContentHandler dataContentHandler = null;</b>
<b class="nc">&nbsp;    private DataContentHandler factoryDCH = null;</b>
&nbsp;
&nbsp;    // our DataContentHandlerFactory
<b class="nc">&nbsp;    private static DataContentHandlerFactory factory = null;</b>
<b class="nc">&nbsp;    private DataContentHandlerFactory oldFactory = null;</b>
&nbsp;    // the short representation of the ContentType (sans params)
<b class="nc">&nbsp;    private String shortType = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Create a &lt;code&gt;DataHandler&lt;/code&gt; instance referencing the
&nbsp;     * specified DataSource.  The data exists in a byte stream form.
&nbsp;     * The DataSource will provide an InputStream to access the data.
&nbsp;     *
&nbsp;     * @param ds	the DataSource
&nbsp;     */
<b class="nc">&nbsp;    public DataHandler(DataSource ds) {</b>
&nbsp;	// save a reference to the incoming DS
<b class="nc">&nbsp;	dataSource = ds;</b>
<b class="nc">&nbsp;	oldFactory = factory; // keep track of the factory</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a &lt;code&gt;DataHandler&lt;/code&gt; instance representing an object
&nbsp;     * of this MIME type.  This constructor is
&nbsp;     * used when the application already has an in-memory representation
&nbsp;     * of the data in the form of a Java Object.
&nbsp;     *
&nbsp;     * @param obj	the Java Object
&nbsp;     * @param mimeType	the MIME type of the object
&nbsp;     */
<b class="nc">&nbsp;    public DataHandler(Object obj, String mimeType) {</b>
<b class="nc">&nbsp;	object = obj;</b>
<b class="nc">&nbsp;	objectMimeType = mimeType;</b>
<b class="nc">&nbsp;	oldFactory = factory; // keep track of the factory</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a &lt;code&gt;DataHandler&lt;/code&gt; instance referencing a URL.
&nbsp;     * The DataHandler internally creates a &lt;code&gt;URLDataSource&lt;/code&gt;
&nbsp;     * instance to represent the URL.
&nbsp;     *
&nbsp;     * @param url	a URL object
&nbsp;     */
<b class="nc">&nbsp;    public DataHandler(URL url) {</b>
<b class="nc">&nbsp;	dataSource = new URLDataSource(url);</b>
<b class="nc">&nbsp;	oldFactory = factory; // keep track of the factory</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the CommandMap for this instance of DataHandler.
&nbsp;     */
&nbsp;    private synchronized CommandMap getCommandMap() {
<b class="nc">&nbsp;	if (currentCommandMap != null)</b>
<b class="nc">&nbsp;	    return currentCommandMap;</b>
&nbsp;	else
<b class="nc">&nbsp;	    return CommandMap.getDefaultCommandMap();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the DataSource associated with this instance
&nbsp;     * of DataHandler.
&nbsp;     * &lt;p&gt;
&nbsp;     * For DataHandlers that have been instantiated with a DataSource,
&nbsp;     * this method returns the DataSource that was used to create the
&nbsp;     * DataHandler object. In other cases the DataHandler
&nbsp;     * constructs a DataSource from the data used to construct
&nbsp;     * the DataHandler. DataSources created for DataHandlers &lt;b&gt;not&lt;/b&gt;
&nbsp;     * instantiated with a DataSource are cached for performance
&nbsp;     * reasons.
&nbsp;     *
&nbsp;     * @return	a valid DataSource object for this DataHandler
&nbsp;     */
&nbsp;    public DataSource getDataSource() {
<b class="nc">&nbsp;	if (dataSource == null) {</b>
&nbsp;	    // create one on the fly
<b class="nc">&nbsp;	    if (objDataSource == null)</b>
<b class="nc">&nbsp;		objDataSource = new DataHandlerDataSource(this);</b>
<b class="nc">&nbsp;	    return objDataSource;</b>
&nbsp;	}
<b class="nc">&nbsp;	return dataSource;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the name of the data object. If this DataHandler
&nbsp;     * was created with a DataSource, this method calls through
&nbsp;     * to the &lt;code&gt;DataSource.getName&lt;/code&gt; method, otherwise it
&nbsp;     * returns &lt;i&gt;null&lt;/i&gt;.
&nbsp;     *
&nbsp;     * @return	the name of the object
&nbsp;     */
&nbsp;    public String getName() {
<b class="nc">&nbsp;	if (dataSource != null)</b>
<b class="nc">&nbsp;	    return dataSource.getName();</b>
&nbsp;	else
<b class="nc">&nbsp;	    return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the MIME type of this object as retrieved from
&nbsp;     * the source object. Note that this is the &lt;i&gt;full&lt;/i&gt;
&nbsp;     * type with parameters.
&nbsp;     *
&nbsp;     * @return	the MIME type
&nbsp;     */
&nbsp;    public String getContentType() {
<b class="nc">&nbsp;	if (dataSource != null) // data source case</b>
<b class="nc">&nbsp;	    return dataSource.getContentType();</b>
&nbsp;	else
<b class="nc">&nbsp;	    return objectMimeType; // obj/type case</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the InputStream for this object. &lt;p&gt;
&nbsp;     *
&nbsp;     * For DataHandlers instantiated with a DataSource, the DataHandler
&nbsp;     * calls the &lt;code&gt;DataSource.getInputStream&lt;/code&gt; method and
&nbsp;     * returns the result to the caller.
&nbsp;     * &lt;p&gt;
&nbsp;     * For DataHandlers instantiated with an Object, the DataHandler
&nbsp;     * first attempts to find a DataContentHandler for the Object. If
&nbsp;     * the DataHandler can not find a DataContentHandler for this MIME
&nbsp;     * type, it throws an UnsupportedDataTypeException.  If it is
&nbsp;     * successful, it creates a pipe and a thread.  The thread uses the
&nbsp;     * DataContentHandler&#39;s &lt;code&gt;writeTo&lt;/code&gt; method to write the
&nbsp;     * stream data into one end of the pipe.  The other end of the pipe
&nbsp;     * is returned to the caller.  Because a thread is created to copy
&nbsp;     * the data, IOExceptions that may occur during the copy can not be
&nbsp;     * propagated back to the caller. The result is an empty stream.&lt;p&gt;
&nbsp;     *
&nbsp;     * @return	the InputStream representing this data
&nbsp;     * @exception IOException	if an I/O error occurs
&nbsp;     *
&nbsp;     * @see javax.activation.DataContentHandler#writeTo
&nbsp;     * @see javax.activation.UnsupportedDataTypeException
&nbsp;     */
&nbsp;    public InputStream getInputStream() throws IOException {
<b class="nc">&nbsp;	InputStream ins = null;</b>
&nbsp;
<b class="nc">&nbsp;	if (dataSource != null) {</b>
<b class="nc">&nbsp;	    ins = dataSource.getInputStream();</b>
&nbsp;	} else {
<b class="nc">&nbsp;	    DataContentHandler dch = getDataContentHandler();</b>
&nbsp;	    // we won&#39;t even try if we can&#39;t get a dch
<b class="nc">&nbsp;	    if (dch == null)</b>
<b class="nc">&nbsp;		throw new UnsupportedDataTypeException(</b>
<b class="nc">&nbsp;				&quot;no DCH for MIME type &quot; + getBaseType());</b>
&nbsp;
<b class="nc">&nbsp;	    if (dch instanceof ObjectDataContentHandler) {</b>
<b class="nc">&nbsp;		if (((ObjectDataContentHandler)dch).getDCH() == null)</b>
<b class="nc">&nbsp;		    throw new UnsupportedDataTypeException(</b>
<b class="nc">&nbsp;				&quot;no object DCH for MIME type &quot; + getBaseType());</b>
&nbsp;	    }
&nbsp;	    // there is none but the default^^^^^^^^^^^^^^^^
<b class="nc">&nbsp;	    final DataContentHandler fdch = dch;</b>
&nbsp;
&nbsp;	    // from bill s.
&nbsp;	    // ce n&#39;est pas une pipe!
&nbsp;	    //
&nbsp;	    // NOTE: This block of code needs to throw exceptions, but
&nbsp;	    // can&#39;t because it is in another thread!!! ARG!
&nbsp;	    //
<b class="nc">&nbsp;	    final PipedOutputStream pos = new PipedOutputStream();</b>
<b class="nc">&nbsp;	    PipedInputStream pin = new PipedInputStream(pos);</b>
<b class="nc">&nbsp;	    new Thread(</b>
&nbsp;		       new Runnable() {
&nbsp;		public void run() {
&nbsp;		    try {
&nbsp;			fdch.writeTo(object, objectMimeType, pos);
&nbsp;		    } catch (IOException e) {
&nbsp;
&nbsp;		    } finally {
&nbsp;			try {
&nbsp;			    pos.close();
&nbsp;			} catch (IOException ie) { }
&nbsp;		    }
&nbsp;		}
&nbsp;	    },
<b class="nc">&nbsp;		      &quot;DataHandler.getInputStream&quot;).start();</b>
<b class="nc">&nbsp;	    ins = pin;</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	return ins;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Write the data to an &lt;code&gt;OutputStream&lt;/code&gt;.&lt;p&gt;
&nbsp;     *
&nbsp;     * If the DataHandler was created with a DataSource, writeTo
&nbsp;     * retrieves the InputStream and copies the bytes from the
&nbsp;     * InputStream to the OutputStream passed in.
&nbsp;     * &lt;p&gt;
&nbsp;     * If the DataHandler was created with an object, writeTo
&nbsp;     * retrieves the DataContentHandler for the object&#39;s type.
&nbsp;     * If the DataContentHandler was found, it calls the
&nbsp;     * &lt;code&gt;writeTo&lt;/code&gt; method on the &lt;code&gt;DataContentHandler&lt;/code&gt;.
&nbsp;     *
&nbsp;     * @param os	the OutputStream to write to
&nbsp;     * @exception IOException	if an I/O error occurs
&nbsp;     */
&nbsp;    public void writeTo(OutputStream os) throws IOException {
&nbsp;	// for the DataSource case
<b class="nc">&nbsp;	if (dataSource != null) {</b>
<b class="nc">&nbsp;	    InputStream is = null;</b>
<b class="nc">&nbsp;	    byte data[] = new byte[8*1024];</b>
&nbsp;	    int bytes_read;
&nbsp;
<b class="nc">&nbsp;	    is = dataSource.getInputStream();</b>
&nbsp;
&nbsp;	    try {
<b class="nc">&nbsp;		while ((bytes_read = is.read(data)) &gt; 0) {</b>
<b class="nc">&nbsp;		    os.write(data, 0, bytes_read);</b>
&nbsp;		}
&nbsp;	    } finally {
<b class="nc">&nbsp;		is.close();</b>
<b class="nc">&nbsp;		is = null;</b>
<b class="nc">&nbsp;	    }</b>
<b class="nc">&nbsp;	} else { // for the Object case</b>
<b class="nc">&nbsp;	    DataContentHandler dch = getDataContentHandler();</b>
<b class="nc">&nbsp;	    dch.writeTo(object, objectMimeType, os);</b>
&nbsp;	}
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get an OutputStream for this DataHandler to allow overwriting
&nbsp;     * the underlying data.
&nbsp;     * If the DataHandler was created with a DataSource, the
&nbsp;     * DataSource&#39;s &lt;code&gt;getOutputStream&lt;/code&gt; method is called.
&nbsp;     * Otherwise, &lt;code&gt;null&lt;/code&gt; is returned.
&nbsp;     *
&nbsp;     * @return the OutputStream
&nbsp;     * @exception	IOException	for failures creating the OutputStream
&nbsp;     *
&nbsp;     * @see javax.activation.DataSource#getOutputStream
&nbsp;     * @see javax.activation.URLDataSource
&nbsp;     */
&nbsp;    public OutputStream getOutputStream() throws IOException {
<b class="nc">&nbsp;	if (dataSource != null)</b>
<b class="nc">&nbsp;	    return dataSource.getOutputStream();</b>
&nbsp;	else
<b class="nc">&nbsp;	    return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the DataFlavors in which this data is available. &lt;p&gt;
&nbsp;     *
&nbsp;     * Returns an array of DataFlavor objects indicating the flavors
&nbsp;     * the data can be provided in. The array is usually ordered
&nbsp;     * according to preference for providing the data, from most
&nbsp;     * richly descriptive to least richly descriptive.&lt;p&gt;
&nbsp;     *
&nbsp;     * The DataHandler attempts to find a DataContentHandler that
&nbsp;     * corresponds to the MIME type of the data. If one is located,
&nbsp;     * the DataHandler calls the DataContentHandler&#39;s
&nbsp;     * &lt;code&gt;getTransferDataFlavors&lt;/code&gt; method. &lt;p&gt;
&nbsp;     *
&nbsp;     * If a DataContentHandler can &lt;i&gt;not&lt;/i&gt; be located, and if the
&nbsp;     * DataHandler was created with a DataSource (or URL), one
&nbsp;     * DataFlavor is returned that represents this object&#39;s MIME type
&nbsp;     * and the &lt;code&gt;java.io.InputStream&lt;/code&gt; class.  If the
&nbsp;     * DataHandler was created with an object and a MIME type,
&nbsp;     * getTransferDataFlavors returns one DataFlavor that represents
&nbsp;     * this object&#39;s MIME type and the object&#39;s class.
&nbsp;     *
&nbsp;     * @return	an array of data flavors in which this data can be transferred
&nbsp;     * @see javax.activation.DataContentHandler#getTransferDataFlavors
&nbsp;     */
&nbsp;    public synchronized DataFlavor[] getTransferDataFlavors() {
<b class="nc">&nbsp;	if (factory != oldFactory) // if the factory has changed, clear cache</b>
<b class="nc">&nbsp;	    transferFlavors = emptyFlavors;</b>
&nbsp;
&nbsp;	// if it&#39;s not set, set it...
<b class="nc">&nbsp;	if (transferFlavors == emptyFlavors)</b>
<b class="nc">&nbsp;	    transferFlavors = getDataContentHandler().getTransferDataFlavors();</b>
<b class="nc">&nbsp;	if (transferFlavors == emptyFlavors)</b>
<b class="nc">&nbsp;	    return transferFlavors;	// no need to clone an empty array</b>
&nbsp;	else
<b class="nc">&nbsp;	    return transferFlavors.clone();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether the specified data flavor is supported
&nbsp;     * for this object.&lt;p&gt;
&nbsp;     *
&nbsp;     * This method iterates through the DataFlavors returned from
&nbsp;     * &lt;code&gt;getTransferDataFlavors&lt;/code&gt;, comparing each with
&nbsp;     * the specified flavor.
&nbsp;     *
&nbsp;     * @param flavor	the requested flavor for the data
&nbsp;     * @return		true if the data flavor is supported
&nbsp;     * @see javax.activation.DataHandler#getTransferDataFlavors
&nbsp;     */
&nbsp;    public boolean isDataFlavorSupported(DataFlavor flavor) {
<b class="nc">&nbsp;	DataFlavor[] lFlavors = getTransferDataFlavors();</b>
&nbsp;
<b class="nc">&nbsp;	for (int i = 0; i &lt; lFlavors.length; i++) {</b>
<b class="nc">&nbsp;	    if (lFlavors[i].equals(flavor))</b>
<b class="nc">&nbsp;		return true;</b>
&nbsp;	}
<b class="nc">&nbsp;	return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an object that represents the data to be
&nbsp;     * transferred. The class of the object returned is defined by the
&nbsp;     * representation class of the data flavor.&lt;p&gt;
&nbsp;     *
&nbsp;     * &lt;b&gt;For DataHandler&#39;s created with DataSources or URLs:&lt;/b&gt;&lt;p&gt;
&nbsp;     *
&nbsp;     * The DataHandler attempts to locate a DataContentHandler
&nbsp;     * for this MIME type. If one is found, the passed in DataFlavor
&nbsp;     * and the type of the data are passed to its &lt;code&gt;getTransferData&lt;/code&gt;
&nbsp;     * method. If the DataHandler fails to locate a DataContentHandler
&nbsp;     * and the flavor specifies this object&#39;s MIME type and the
&nbsp;     * &lt;code&gt;java.io.InputStream&lt;/code&gt; class, this object&#39;s InputStream
&nbsp;     * is returned.
&nbsp;     * Otherwise it throws an UnsupportedFlavorException. &lt;p&gt;
&nbsp;     *
&nbsp;     * &lt;b&gt;For DataHandler&#39;s created with Objects:&lt;/b&gt;&lt;p&gt;
&nbsp;     *
&nbsp;     * The DataHandler attempts to locate a DataContentHandler
&nbsp;     * for this MIME type. If one is found, the passed in DataFlavor
&nbsp;     * and the type of the data are passed to its getTransferData
&nbsp;     * method. If the DataHandler fails to locate a DataContentHandler
&nbsp;     * and the flavor specifies this object&#39;s MIME type and its class,
&nbsp;     * this DataHandler&#39;s referenced object is returned.  
&nbsp;     * Otherwise it throws an UnsupportedFlavorException.
&nbsp;     *
&nbsp;     * @param flavor	the requested flavor for the data
&nbsp;     * @return		the object
&nbsp;     * @exception UnsupportedFlavorException	if the data could not be
&nbsp;     *			converted to the requested flavor
&nbsp;     * @exception IOException	if an I/O error occurs
&nbsp;     * @see javax.activation.ActivationDataFlavor
&nbsp;     */
&nbsp;    public Object getTransferData(DataFlavor flavor)
&nbsp;				throws UnsupportedFlavorException, IOException {
<b class="nc">&nbsp;	return getDataContentHandler().getTransferData(flavor, dataSource);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the CommandMap for use by this DataHandler.
&nbsp;     * Setting it to &lt;code&gt;null&lt;/code&gt; causes the CommandMap to revert
&nbsp;     * to the CommandMap returned by the
&nbsp;     * &lt;code&gt;CommandMap.getDefaultCommandMap&lt;/code&gt; method.
&nbsp;     * Changing the CommandMap, or setting it to &lt;code&gt;null&lt;/code&gt;,
&nbsp;     * clears out any data cached from the previous CommandMap.
&nbsp;     *
&nbsp;     * @param commandMap	the CommandMap to use in this DataHandler
&nbsp;     *
&nbsp;     * @see javax.activation.CommandMap#setDefaultCommandMap
&nbsp;     */
&nbsp;    public synchronized void setCommandMap(CommandMap commandMap) {
<b class="nc">&nbsp;	if (commandMap != currentCommandMap || commandMap == null) {</b>
&nbsp;	    // clear cached values...
<b class="nc">&nbsp;	    transferFlavors = emptyFlavors;</b>
<b class="nc">&nbsp;	    dataContentHandler = null;</b>
&nbsp;
<b class="nc">&nbsp;	    currentCommandMap = commandMap;</b>
&nbsp;	}
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the &lt;i&gt;preferred&lt;/i&gt; commands for this type of data.
&nbsp;     * This method calls the &lt;code&gt;getPreferredCommands&lt;/code&gt; method
&nbsp;     * in the CommandMap associated with this instance of DataHandler.
&nbsp;     * This method returns an array that represents a subset of
&nbsp;     * available commands. In cases where multiple commands for the
&nbsp;     * MIME type represented by this DataHandler are present, the
&nbsp;     * installed CommandMap chooses the appropriate commands.
&nbsp;     *
&nbsp;     * @return	the CommandInfo objects representing the preferred commands
&nbsp;     *
&nbsp;     * @see javax.activation.CommandMap#getPreferredCommands
&nbsp;     */
&nbsp;    public CommandInfo[] getPreferredCommands() {
<b class="nc">&nbsp;	if (dataSource != null)</b>
<b class="nc">&nbsp;	    return getCommandMap().getPreferredCommands(getBaseType(),</b>
&nbsp;							dataSource);
&nbsp;	else
<b class="nc">&nbsp;	    return getCommandMap().getPreferredCommands(getBaseType());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return all the commands for this type of data.
&nbsp;     * This method returns an array containing all commands
&nbsp;     * for the type of data represented by this DataHandler. The
&nbsp;     * MIME type for the underlying data represented by this DataHandler
&nbsp;     * is used to call through to the &lt;code&gt;getAllCommands&lt;/code&gt; method
&nbsp;     * of the CommandMap associated with this DataHandler.
&nbsp;     *
&nbsp;     * @return	the CommandInfo objects representing all the commands
&nbsp;     *
&nbsp;     * @see javax.activation.CommandMap#getAllCommands
&nbsp;     */
&nbsp;    public CommandInfo[] getAllCommands() {
<b class="nc">&nbsp;	if (dataSource != null)</b>
<b class="nc">&nbsp;	    return getCommandMap().getAllCommands(getBaseType(), dataSource);</b>
&nbsp;	else
<b class="nc">&nbsp;	    return getCommandMap().getAllCommands(getBaseType());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the command &lt;i&gt;cmdName&lt;/i&gt;. Use the search semantics as
&nbsp;     * defined by the CommandMap installed in this DataHandler. The
&nbsp;     * MIME type for the underlying data represented by this DataHandler
&nbsp;     * is used to call through to the &lt;code&gt;getCommand&lt;/code&gt; method
&nbsp;     * of the CommandMap associated with this DataHandler.
&nbsp;     *
&nbsp;     * @param cmdName	the command name
&nbsp;     * @return	the CommandInfo corresponding to the command
&nbsp;     *
&nbsp;     * @see javax.activation.CommandMap#getCommand
&nbsp;     */
&nbsp;    public CommandInfo getCommand(String cmdName) {
<b class="nc">&nbsp;	if (dataSource != null)</b>
<b class="nc">&nbsp;	    return getCommandMap().getCommand(getBaseType(), cmdName,</b>
&nbsp;								dataSource);
&nbsp;	else
<b class="nc">&nbsp;	    return getCommandMap().getCommand(getBaseType(), cmdName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the data in its preferred Object form. &lt;p&gt;
&nbsp;     *
&nbsp;     * If the DataHandler was instantiated with an object, return
&nbsp;     * the object. &lt;p&gt;
&nbsp;     *
&nbsp;     * If the DataHandler was instantiated with a DataSource,
&nbsp;     * this method uses a DataContentHandler to return the content
&nbsp;     * object for the data represented by this DataHandler. If no
&nbsp;     * &lt;code&gt;DataContentHandler&lt;/code&gt; can be found for the
&nbsp;     * the type of this data, the DataHandler returns an
&nbsp;     * InputStream for the data.
&nbsp;     *
&nbsp;     * @return the content.
&nbsp;     * @exception IOException if an IOException occurs during
&nbsp;     *                              this operation.
&nbsp;     */
&nbsp;    public Object getContent() throws IOException {
<b class="nc">&nbsp;	if (object != null)</b>
<b class="nc">&nbsp;	    return object;</b>
&nbsp;	else
<b class="nc">&nbsp;	    return getDataContentHandler().getContent(getDataSource());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A convenience method that takes a CommandInfo object
&nbsp;     * and instantiates the corresponding command, usually
&nbsp;     * a JavaBean component.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method calls the CommandInfo&#39;s &lt;code&gt;getCommandObject&lt;/code&gt;
&nbsp;     * method with the &lt;code&gt;ClassLoader&lt;/code&gt; used to load
&nbsp;     * the &lt;code&gt;javax.activation.DataHandler&lt;/code&gt; class itself.
&nbsp;     *
&nbsp;     * @param cmdinfo	the CommandInfo corresponding to a command
&nbsp;     * @return	the instantiated command object
&nbsp;     */
&nbsp;    public Object getBean(CommandInfo cmdinfo) {
<b class="nc">&nbsp;	Object bean = null;</b>
&nbsp;
&nbsp;	try {
&nbsp;	    // make the bean
<b class="nc">&nbsp;	    ClassLoader cld = null;</b>
&nbsp;	    // First try the &quot;application&#39;s&quot; class loader.
<b class="nc">&nbsp;	    cld = SecuritySupport.getContextClassLoader();</b>
<b class="nc">&nbsp;	    if (cld == null)</b>
<b class="nc">&nbsp;		cld = this.getClass().getClassLoader();</b>
<b class="nc">&nbsp;	    bean = cmdinfo.getCommandObject(this, cld);</b>
<b class="nc">&nbsp;	} catch (IOException e) {</b>
<b class="nc">&nbsp;	} catch (ClassNotFoundException e) { }</b>
&nbsp;
<b class="nc">&nbsp;	return bean;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the DataContentHandler for this DataHandler: &lt;p&gt;
&nbsp;     *
&nbsp;     * If a DataContentHandlerFactory is set, use it.
&nbsp;     * Otherwise look for an object to serve DCH in the
&nbsp;     * following order: &lt;p&gt;
&nbsp;     *
&nbsp;     * 1) if a factory is set, use it &lt;p&gt;
&nbsp;     * 2) if a CommandMap is set, use it &lt;p&gt;
&nbsp;     * 3) use the default CommandMap &lt;p&gt;
&nbsp;     *
&nbsp;     * In any case, wrap the real DataContentHandler with one of our own
&nbsp;     * to handle any missing cases, fill in defaults, and to ensure that
&nbsp;     * we always have a non-null DataContentHandler.
&nbsp;     *
&nbsp;     * @return	the requested DataContentHandler
&nbsp;     */
&nbsp;    private synchronized DataContentHandler getDataContentHandler() {
&nbsp;
&nbsp;	// make sure the factory didn&#39;t change
<b class="nc">&nbsp;	if (factory != oldFactory) {</b>
<b class="nc">&nbsp;	    oldFactory = factory;</b>
<b class="nc">&nbsp;	    factoryDCH = null;</b>
<b class="nc">&nbsp;	    dataContentHandler = null;</b>
<b class="nc">&nbsp;	    transferFlavors = emptyFlavors;</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp; 	if (dataContentHandler != null)</b>
<b class="nc">&nbsp; 	    return dataContentHandler;</b>
&nbsp;
<b class="nc">&nbsp;	String simpleMT = getBaseType();</b>
&nbsp;
<b class="nc">&nbsp;	if (factoryDCH == null &amp;&amp; factory != null)</b>
<b class="nc">&nbsp;	    factoryDCH = factory.createDataContentHandler(simpleMT);</b>
&nbsp;
<b class="nc">&nbsp; 	if (factoryDCH != null)</b>
<b class="nc">&nbsp; 	    dataContentHandler = factoryDCH;</b>
&nbsp;
<b class="nc">&nbsp;	if (dataContentHandler == null) {</b>
<b class="nc">&nbsp;	    if (dataSource != null)</b>
<b class="nc">&nbsp;		dataContentHandler = getCommandMap().</b>
<b class="nc">&nbsp;				createDataContentHandler(simpleMT, dataSource);</b>
&nbsp;	    else
<b class="nc">&nbsp;		dataContentHandler = getCommandMap().</b>
<b class="nc">&nbsp;				createDataContentHandler(simpleMT);</b>
&nbsp;	}
&nbsp;
&nbsp;	// getDataContentHandler always uses these &#39;wrapper&#39; handlers
&nbsp;	// to make sure it returns SOMETHING meaningful...
<b class="nc">&nbsp;	if (dataSource != null)</b>
<b class="nc">&nbsp;	    dataContentHandler = new DataSourceDataContentHandler(</b>
&nbsp;						      dataContentHandler,
&nbsp;						      dataSource);
&nbsp;	else
<b class="nc">&nbsp;	    dataContentHandler = new ObjectDataContentHandler(</b>
&nbsp;						      dataContentHandler,
&nbsp;						      object,
&nbsp;						      objectMimeType);
<b class="nc">&nbsp;	return dataContentHandler;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Use the MimeType class to extract the MIME type/subtype,
&nbsp;     * ignoring the parameters.  The type is cached.
&nbsp;     */
&nbsp;    private synchronized String getBaseType() {
<b class="nc">&nbsp;	if (shortType == null) {</b>
<b class="nc">&nbsp;	    String ct = getContentType();</b>
&nbsp;	    try {
<b class="nc">&nbsp;		MimeType mt = new MimeType(ct);</b>
<b class="nc">&nbsp;		shortType = mt.getBaseType();</b>
<b class="nc">&nbsp;	    } catch (MimeTypeParseException e) {</b>
<b class="nc">&nbsp;		shortType = ct;</b>
<b class="nc">&nbsp;	    }</b>
&nbsp;	}
<b class="nc">&nbsp;	return shortType;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the DataContentHandlerFactory.  The DataContentHandlerFactory
&nbsp;     * is called first to find DataContentHandlers.
&nbsp;     * The DataContentHandlerFactory can only be set once.
&nbsp;     * &lt;p&gt;
&nbsp;     * If the DataContentHandlerFactory has already been set,
&nbsp;     * this method throws an Error.
&nbsp;     *
&nbsp;     * @param newFactory	the DataContentHandlerFactory
&nbsp;     * @exception Error	if the factory has already been defined.
&nbsp;     *
&nbsp;     * @see javax.activation.DataContentHandlerFactory
&nbsp;     */
&nbsp;    public static synchronized void setDataContentHandlerFactory(
&nbsp;					 DataContentHandlerFactory newFactory) {
<b class="nc">&nbsp;	if (factory != null)</b>
<b class="nc">&nbsp;	    throw new Error(&quot;DataContentHandlerFactory already defined&quot;);</b>
&nbsp;
<b class="nc">&nbsp;	SecurityManager security = System.getSecurityManager();</b>
<b class="nc">&nbsp;	if (security != null) {</b>
&nbsp;	    try {
&nbsp;		// if it&#39;s ok with the SecurityManager, it&#39;s ok with me...
<b class="nc">&nbsp;		security.checkSetFactory();</b>
<b class="nc">&nbsp;	    } catch (SecurityException ex) {</b>
&nbsp;		// otherwise, we also allow it if this code and the
&nbsp;		// factory come from the same class loader (e.g.,
&nbsp;		// the JAF classes were loaded with the applet classes).
<b class="nc">&nbsp;		if (DataHandler.class.getClassLoader() !=</b>
<b class="nc">&nbsp;			newFactory.getClass().getClassLoader())</b>
<b class="nc">&nbsp;		    throw ex;</b>
<b class="nc">&nbsp;	    }</b>
&nbsp;	}
<b class="nc">&nbsp;	factory = newFactory;</b>
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;/**
&nbsp; * The DataHanderDataSource class implements the
&nbsp; * DataSource interface when the DataHandler is constructed
&nbsp; * with an Object and a mimeType string.
&nbsp; */
&nbsp;class DataHandlerDataSource implements DataSource {
&nbsp;    DataHandler dataHandler = null;
&nbsp;
&nbsp;    /**
&nbsp;     * The constructor.
&nbsp;     */
&nbsp;    public DataHandlerDataSource(DataHandler dh) {
&nbsp;	this.dataHandler = dh;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an &lt;code&gt;InputStream&lt;/code&gt; representing this object.
&nbsp;     * @return	the &lt;code&gt;InputStream&lt;/code&gt;
&nbsp;     */
&nbsp;    public InputStream getInputStream() throws IOException {
&nbsp;	return dataHandler.getInputStream();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the &lt;code&gt;OutputStream&lt;/code&gt; for this object.
&nbsp;     * @return	the &lt;code&gt;OutputStream&lt;/code&gt;
&nbsp;     */
&nbsp;    public OutputStream getOutputStream() throws IOException {
&nbsp;	return dataHandler.getOutputStream();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the MIME type of the data represented by this object.
&nbsp;     * @return	the MIME type
&nbsp;     */
&nbsp;    public String getContentType() {
&nbsp;	return dataHandler.getContentType();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the name of this object.
&nbsp;     * @return	the name of this object
&nbsp;     */
&nbsp;    public String getName() {
&nbsp;	return dataHandler.getName(); // what else would it be?
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;/*
&nbsp; * DataSourceDataContentHandler
&nbsp; *
&nbsp; * This is a &lt;i&gt;private&lt;/i&gt; DataContentHandler that wraps the real
&nbsp; * DataContentHandler in the case where the DataHandler was instantiated
&nbsp; * with a DataSource.
&nbsp; */
&nbsp;class DataSourceDataContentHandler implements DataContentHandler {
&nbsp;    private DataSource ds = null;
&nbsp;    private DataFlavor transferFlavors[] = null;
&nbsp;    private DataContentHandler dch = null;
&nbsp;
&nbsp;    /**
&nbsp;     * The constructor.
&nbsp;     */
&nbsp;    public DataSourceDataContentHandler(DataContentHandler dch, DataSource ds) {
&nbsp;	this.ds = ds;
&nbsp;	this.dch = dch;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the DataFlavors for this &lt;code&gt;DataContentHandler&lt;/code&gt;.
&nbsp;     * @return	the DataFlavors
&nbsp;     */
&nbsp;    public DataFlavor[] getTransferDataFlavors() {
&nbsp;
&nbsp;	if (transferFlavors == null) {
&nbsp;	    if (dch != null) { // is there a dch?
&nbsp;		transferFlavors = dch.getTransferDataFlavors();
&nbsp;	    } else {
&nbsp;		transferFlavors = new DataFlavor[1];
&nbsp;		transferFlavors[0] =
&nbsp;		    new ActivationDataFlavor(ds.getContentType(),
&nbsp;					     ds.getContentType());
&nbsp;	    }
&nbsp;	}
&nbsp;	return transferFlavors;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the Transfer Data of type DataFlavor from InputStream.
&nbsp;     * @param df	the DataFlavor
&nbsp;     * @param ds	the DataSource
&nbsp;     * @return		the constructed Object
&nbsp;     */
&nbsp;    public Object getTransferData(DataFlavor df, DataSource ds) throws
&nbsp;				UnsupportedFlavorException, IOException {
&nbsp;
&nbsp;	if (dch != null)
&nbsp;	    return dch.getTransferData(df, ds);
&nbsp;	else if (df.equals(getTransferDataFlavors()[0])) // only have one now
&nbsp;	    return ds.getInputStream();
&nbsp;	else
&nbsp;	    throw new UnsupportedFlavorException(df);
&nbsp;    }
&nbsp;
&nbsp;    public Object getContent(DataSource ds) throws IOException {
&nbsp;
&nbsp;	if (dch != null)
&nbsp;	    return dch.getContent(ds);
&nbsp;	else
&nbsp;	    return ds.getInputStream();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Write the object to the output stream.
&nbsp;     */
&nbsp;    public void writeTo(Object obj, String mimeType, OutputStream os)
&nbsp;						throws IOException {
&nbsp;	if (dch != null)
&nbsp;	    dch.writeTo(obj, mimeType, os);
&nbsp;	else
&nbsp;	    throw new UnsupportedDataTypeException(
&nbsp;			&quot;no DCH for content type &quot; + ds.getContentType());
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;/*
&nbsp; * ObjectDataContentHandler
&nbsp; *
&nbsp; * This is a &lt;i&gt;private&lt;/i&gt; DataContentHandler that wraps the real
&nbsp; * DataContentHandler in the case where the DataHandler was instantiated
&nbsp; * with an object.
&nbsp; */
&nbsp;class ObjectDataContentHandler implements DataContentHandler {
&nbsp;    private DataFlavor transferFlavors[] = null;
&nbsp;    private Object obj;
&nbsp;    private String mimeType;
&nbsp;    private DataContentHandler dch = null;
&nbsp;
&nbsp;    /**
&nbsp;     * The constructor.
&nbsp;     */
&nbsp;    public ObjectDataContentHandler(DataContentHandler dch,
&nbsp;				    Object obj, String mimeType) {
&nbsp;	this.obj = obj;
&nbsp;	this.mimeType = mimeType;
&nbsp;	this.dch = dch;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the DataContentHandler for this object.
&nbsp;     * Used only by the DataHandler class.
&nbsp;     */
&nbsp;    public DataContentHandler getDCH() {
&nbsp;	return dch;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the DataFlavors for this &lt;code&gt;DataContentHandler&lt;/code&gt;.
&nbsp;     * @return	the DataFlavors
&nbsp;     */
&nbsp;    public synchronized DataFlavor[] getTransferDataFlavors() {
&nbsp;	if (transferFlavors == null) {
&nbsp;	    if (dch != null) {
&nbsp;		transferFlavors = dch.getTransferDataFlavors();
&nbsp;	    } else {
&nbsp;		transferFlavors = new DataFlavor[1];
&nbsp;		transferFlavors[0] = new ActivationDataFlavor(obj.getClass(),
&nbsp;					     mimeType, mimeType);
&nbsp;	    }
&nbsp;	}
&nbsp;	return transferFlavors;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the Transfer Data of type DataFlavor from InputStream.
&nbsp;     * @param df	the DataFlavor
&nbsp;     * @param ds	the DataSource
&nbsp;     * @return		the constructed Object
&nbsp;     */
&nbsp;    public Object getTransferData(DataFlavor df, DataSource ds)
&nbsp;				throws UnsupportedFlavorException, IOException {
&nbsp;
&nbsp;	if (dch != null)
&nbsp;	    return dch.getTransferData(df, ds);
&nbsp;	else if (df.equals(getTransferDataFlavors()[0])) // only have one now
&nbsp;	    return obj;
&nbsp;	else
&nbsp;	    throw new UnsupportedFlavorException(df);
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public Object getContent(DataSource ds) {
&nbsp;	return obj;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Write the object to the output stream.
&nbsp;     */
&nbsp;    public void writeTo(Object obj, String mimeType, OutputStream os)
&nbsp;						throws IOException {
&nbsp;	if (dch != null)
&nbsp;	    dch.writeTo(obj, mimeType, os);
&nbsp;	else if (obj instanceof byte[])
&nbsp;	    os.write((byte[])obj);
&nbsp;	else if (obj instanceof String) {
&nbsp;	    OutputStreamWriter osw = new OutputStreamWriter(os);
&nbsp;	    osw.write((String)obj);
&nbsp;	    osw.flush();
&nbsp;	} else
&nbsp;	    throw new UnsupportedDataTypeException(
&nbsp;				&quot;no object DCH for MIME type &quot; + this.mimeType);
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
