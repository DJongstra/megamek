


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Unmarshaller</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">javax.xml.bind</a>
</div>

<h1>Coverage Summary for Class: Unmarshaller (javax.xml.bind)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
</tr>
<tr>
  <td class="name">Unmarshaller</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (c) 2003, 2018 Oracle and/or its affiliates. All rights reserved.
&nbsp; *
&nbsp; * This program and the accompanying materials are made available under the
&nbsp; * terms of the Eclipse Distribution License v. 1.0, which is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; */
&nbsp;
&nbsp;package javax.xml.bind;
&nbsp;
&nbsp;import javax.xml.bind.annotation.adapters.XmlAdapter;
&nbsp;import javax.xml.bind.attachment.AttachmentUnmarshaller;
&nbsp;import javax.xml.validation.Schema;
&nbsp;import java.io.Reader;
&nbsp;
&nbsp;/**
&nbsp; * The {@code Unmarshaller} class governs the process of deserializing XML
&nbsp; * data into newly created Java content trees, optionally validating the XML 
&nbsp; * data as it is unmarshalled.  It provides an overloading of unmarshal methods
&nbsp; * for many different input kinds.
&nbsp; *    
&nbsp; * &lt;p&gt;
&nbsp; * Unmarshalling from a File:
&nbsp; * &lt;blockquote&gt;
&nbsp; *    &lt;pre&gt;
&nbsp; *       JAXBContext jc = JAXBContext.newInstance( &quot;com.acme.foo&quot; );
&nbsp; *       Unmarshaller u = jc.createUnmarshaller();
&nbsp; *       Object o = u.unmarshal( new File( &quot;nosferatu.xml&quot; ) );
&nbsp; *    &lt;/pre&gt;
&nbsp; * &lt;/blockquote&gt;
&nbsp; *
&nbsp; *  
&nbsp; * &lt;p&gt;
&nbsp; * Unmarshalling from an InputStream:
&nbsp; * &lt;blockquote&gt;
&nbsp; *    &lt;pre&gt;
&nbsp; *       InputStream is = new FileInputStream( &quot;nosferatu.xml&quot; );
&nbsp; *       JAXBContext jc = JAXBContext.newInstance( &quot;com.acme.foo&quot; );
&nbsp; *       Unmarshaller u = jc.createUnmarshaller();
&nbsp; *       Object o = u.unmarshal( is );
&nbsp; *    &lt;/pre&gt;
&nbsp; * &lt;/blockquote&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Unmarshalling from a URL:
&nbsp; * &lt;blockquote&gt;
&nbsp; *    &lt;pre&gt;
&nbsp; *       JAXBContext jc = JAXBContext.newInstance( &quot;com.acme.foo&quot; );
&nbsp; *       Unmarshaller u = jc.createUnmarshaller();
&nbsp; *       URL url = new URL( &quot;http://beaker.east/nosferatu.xml&quot; );
&nbsp; *       Object o = u.unmarshal( url );
&nbsp; *    &lt;/pre&gt;
&nbsp; * &lt;/blockquote&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Unmarshalling from a StringBuffer using a 
&nbsp; * {@code javax.xml.transform.stream.StreamSource}:
&nbsp; * &lt;blockquote&gt;
&nbsp; *    &lt;pre&gt;{@code
&nbsp; *       JAXBContext jc = JAXBContext.newInstance( &quot;com.acme.foo&quot; );
&nbsp; *       Unmarshaller u = jc.createUnmarshaller();
&nbsp; *       StringBuffer xmlStr = new StringBuffer( &quot;&lt;?xml version=&quot;1.0&quot;?&gt;...&quot; );
&nbsp; *       Object o = u.unmarshal( new StreamSource( new StringReader( xmlStr.toString() ) ) );
&nbsp; *    }&lt;/pre&gt;
&nbsp; * &lt;/blockquote&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Unmarshalling from a {@code org.w3c.dom.Node}:
&nbsp; * &lt;blockquote&gt;
&nbsp; *    &lt;pre&gt;
&nbsp; *       JAXBContext jc = JAXBContext.newInstance( &quot;com.acme.foo&quot; );
&nbsp; *       Unmarshaller u = jc.createUnmarshaller();
&nbsp; * 
&nbsp; *       DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
&nbsp; *       dbf.setNamespaceAware(true);
&nbsp; *       DocumentBuilder db = dbf.newDocumentBuilder();
&nbsp; *       Document doc = db.parse(new File( &quot;nosferatu.xml&quot;));
&nbsp;
&nbsp; *       Object o = u.unmarshal( doc );
&nbsp; *    &lt;/pre&gt;
&nbsp; * &lt;/blockquote&gt;
&nbsp; * 
&nbsp; * &lt;p&gt;
&nbsp; * Unmarshalling from a {@code javax.xml.transform.sax.SAXSource} using a
&nbsp; * client specified validating SAX2.0 parser:
&nbsp; * &lt;blockquote&gt;
&nbsp; *    &lt;pre&gt;
&nbsp; *       // configure a validating SAX2.0 parser (Xerces2)
&nbsp; *       static final String JAXP_SCHEMA_LANGUAGE =
&nbsp; *           &quot;http://java.sun.com/xml/jaxp/properties/schemaLanguage&quot;;
&nbsp; *       static final String JAXP_SCHEMA_LOCATION =
&nbsp; *           &quot;http://java.sun.com/xml/jaxp/properties/schemaSource&quot;;
&nbsp; *       static final String W3C_XML_SCHEMA =
&nbsp; *           &quot;http://www.w3.org/2001/XMLSchema&quot;;
&nbsp; *
&nbsp; *       System.setProperty( &quot;javax.xml.parsers.SAXParserFactory&quot;,
&nbsp; *                           &quot;org.apache.xerces.jaxp.SAXParserFactoryImpl&quot; );
&nbsp; *
&nbsp; *       SAXParserFactory spf = SAXParserFactory.newInstance();
&nbsp; *       spf.setNamespaceAware(true);
&nbsp; *       spf.setValidating(true);
&nbsp; *       SAXParser saxParser = spf.newSAXParser();
&nbsp; *       
&nbsp; *       try {
&nbsp; *           saxParser.setProperty(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA);
&nbsp; *           saxParser.setProperty(JAXP_SCHEMA_LOCATION, &quot;http://....&quot;);
&nbsp; *       } catch (SAXNotRecognizedException x) {
&nbsp; *           // exception handling omitted
&nbsp; *       }
&nbsp; *
&nbsp; *       XMLReader xmlReader = saxParser.getXMLReader();
&nbsp; *       SAXSource source = 
&nbsp; *           new SAXSource( xmlReader, new InputSource( &quot;http://...&quot; ) );
&nbsp; *
&nbsp; *       // Setup JAXB to unmarshal
&nbsp; *       JAXBContext jc = JAXBContext.newInstance( &quot;com.acme.foo&quot; );
&nbsp; *       Unmarshaller u = jc.createUnmarshaller();
&nbsp; *       ValidationEventCollector vec = new ValidationEventCollector();
&nbsp; *       u.setEventHandler( vec );
&nbsp; *       
&nbsp; *       // turn off the JAXB provider&#39;s default validation mechanism to 
&nbsp; *       // avoid duplicate validation
&nbsp; *       u.setValidating( false )
&nbsp; *
&nbsp; *       // unmarshal
&nbsp; *       Object o = u.unmarshal( source );
&nbsp; *
&nbsp; *       // check for events
&nbsp; *       if( vec.hasEvents() ) {
&nbsp; *          // iterate over events
&nbsp; *       }
&nbsp; *    &lt;/pre&gt;
&nbsp; * &lt;/blockquote&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Unmarshalling from a StAX XMLStreamReader:
&nbsp; * &lt;blockquote&gt;
&nbsp; *    &lt;pre&gt;
&nbsp; *       JAXBContext jc = JAXBContext.newInstance( &quot;com.acme.foo&quot; );
&nbsp; *       Unmarshaller u = jc.createUnmarshaller();
&nbsp; * 
&nbsp; *       javax.xml.stream.XMLStreamReader xmlStreamReader = 
&nbsp; *           javax.xml.stream.XMLInputFactory().newInstance().createXMLStreamReader( ... );
&nbsp; * 
&nbsp; *       Object o = u.unmarshal( xmlStreamReader );
&nbsp; *    &lt;/pre&gt;
&nbsp; * &lt;/blockquote&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Unmarshalling from a StAX XMLEventReader:
&nbsp; * &lt;blockquote&gt;
&nbsp; *    &lt;pre&gt;
&nbsp; *       JAXBContext jc = JAXBContext.newInstance( &quot;com.acme.foo&quot; );
&nbsp; *       Unmarshaller u = jc.createUnmarshaller();
&nbsp; * 
&nbsp; *       javax.xml.stream.XMLEventReader xmlEventReader = 
&nbsp; *           javax.xml.stream.XMLInputFactory().newInstance().createXMLEventReader( ... );
&nbsp; * 
&nbsp; *       Object o = u.unmarshal( xmlEventReader );
&nbsp; *    &lt;/pre&gt;
&nbsp; * &lt;/blockquote&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * &lt;a name=&quot;unmarshalEx&quot;&gt;&lt;/a&gt;
&nbsp; * &lt;b&gt;Unmarshalling XML Data&lt;/b&gt;&lt;br&gt;
&nbsp; * &lt;blockquote&gt;
&nbsp; * Unmarshalling can deserialize XML data that represents either an entire XML document 
&nbsp; * or a subtree of an XML document. Typically, it is sufficient to use the
&nbsp; * unmarshalling methods described by  
&nbsp; * &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalGlobal&quot;&gt;Unmarshal root element that is declared globally&lt;/a&gt;.
&nbsp; * These unmarshal methods utilize {@link JAXBContext}&#39;s mapping of global XML element
&nbsp; * declarations and type definitions to JAXB mapped classes to initiate the 
&nbsp; * unmarshalling of the root element of  XML data.  When the {@link JAXBContext}&#39;s 
&nbsp; * mappings are not sufficient to unmarshal the root element of XML data, 
&nbsp; * the application can assist the unmarshalling process by using the 
&nbsp; * &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalByDeclaredType&quot;&gt;unmarshal by declaredType methods&lt;/a&gt;.
&nbsp; * These methods are useful for unmarshalling XML data where
&nbsp; * the root element corresponds to a local element declaration in the schema.
&nbsp; * &lt;/blockquote&gt;
&nbsp; * 
&nbsp; * &lt;blockquote&gt;
&nbsp; * An unmarshal method never returns null. If the unmarshal process is unable to unmarshal
&nbsp; * the root of XML content to a JAXB mapped object, a fatal error is reported that
&nbsp; * terminates processing by throwing JAXBException.
&nbsp; * &lt;/blockquote&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * &lt;a name=&quot;unmarshalGlobal&quot;&gt;&lt;/a&gt;
&nbsp; * &lt;b&gt;Unmarshal a root element that is globally declared&lt;/b&gt;&lt;br&gt;
&nbsp; * &lt;blockquote&gt;
&nbsp; * The unmarshal methods that do not have an {@code declaredType} parameter use
&nbsp; * {@link JAXBContext} to unmarshal the root element of an XML data. The {@link JAXBContext} 
&nbsp; * instance is the one that was used to create this {@code Unmarshaller}. The {@link JAXBContext}
&nbsp; * instance maintains a mapping of globally declared XML element and type definition names to 
&nbsp; * JAXB mapped classes. The unmarshal method checks if {@link JAXBContext} has a mapping
&nbsp; * from the root element&#39;s XML name and/or {@code @xsi:type} to a JAXB mapped class.  If it does, it umarshalls the
&nbsp; * XML data using the appropriate JAXB mapped class. Note that when the root element name is unknown and the root
&nbsp; * element has an {@code @xsi:type}, the XML data is unmarshalled
&nbsp; * using that JAXB mapped class as the value of a {@link JAXBElement}.
&nbsp; * When the {@link JAXBContext} object does not have a mapping for the root element&#39;s name
&nbsp; * nor its {@code @xsi:type}, if it exists,
&nbsp; * then the unmarshal operation will abort immediately by throwing a {@link UnmarshalException 
&nbsp; * UnmarshalException}. This exception scenario can be worked around by using the unmarshal by 
&nbsp; * declaredType methods described in the next subsection.
&nbsp; * &lt;/blockquote&gt;
&nbsp; * 
&nbsp; * &lt;p&gt;
&nbsp; * &lt;a name=&quot;unmarshalByDeclaredType&quot;&gt;&lt;/a&gt;
&nbsp; * &lt;b&gt;Unmarshal by Declared Type&lt;/b&gt;&lt;br&gt;
&nbsp; * &lt;blockquote&gt;
&nbsp; * The unmarshal methods with a {@code declaredType} parameter enable an
&nbsp; * application to deserialize a root element of XML data, even when
&nbsp; * there is no mapping in {@link JAXBContext} of the root element&#39;s XML name.
&nbsp; * The unmarshaller unmarshals the root element using the application provided
&nbsp; * mapping specified as the {@code declaredType} parameter.
&nbsp; * Note that even when the root element&#39;s element name is mapped by {@link JAXBContext}, 
&nbsp; * the {@code declaredType} parameter overrides that mapping for
&nbsp; * deserializing the root element when using these unmarshal methods. 
&nbsp; * Additionally, when the root element of XML data has an {@code xsi:type} attribute and
&nbsp; * that attribute&#39;s value references a type definition that is mapped 
&nbsp; * to a JAXB mapped class by {@link JAXBContext}, that the root 
&nbsp; * element&#39;s {@code xsi:type} attribute takes
&nbsp; * precedence over the unmarshal methods {@code declaredType} parameter.
&nbsp; * These methods always return a {@code JAXBElement&lt;declaredType&gt;}
&nbsp; * instance. The table below shows how the properties of the returned JAXBElement 
&nbsp; * instance are set.
&nbsp; *
&nbsp; * &lt;a name=&quot;unmarshalDeclaredTypeReturn&quot;&gt;&lt;/a&gt;
&nbsp; *   &lt;table class=&quot;striped&quot;&gt;
&nbsp; *   &lt;caption&gt;Unmarshal By Declared Type returned JAXBElement&lt;/caption&gt;
&nbsp; *   &lt;thead&gt;
&nbsp; *     &lt;tr&gt;
&nbsp; *       &lt;th scope=&quot;col&quot;&gt;JAXBElement Property&lt;/th&gt;
&nbsp; *       &lt;th scope=&quot;col&quot;&gt;Value&lt;/th&gt;
&nbsp; *       &lt;/tr&gt;
&nbsp; *     &lt;tr&gt;
&nbsp; *       &lt;th scope=&quot;col&quot;&gt;name&lt;/th&gt;
&nbsp; *       &lt;th scope=&quot;col&quot;&gt;{@code xml element name}&lt;/th&gt;
&nbsp; *     &lt;/tr&gt;
&nbsp; *   &lt;/thead&gt;
&nbsp; *   &lt;tbody&gt;
&nbsp; *     &lt;tr&gt;
&nbsp; *       &lt;th scope=&quot;row&quot;&gt;value&lt;/th&gt;
&nbsp; *       &lt;td&gt;{@code instanceof declaredType}&lt;/td&gt;
&nbsp; *     &lt;/tr&gt;
&nbsp; *     &lt;tr&gt;
&nbsp; *       &lt;th scope=&quot;row&quot;&gt;declaredType&lt;/th&gt;
&nbsp; *       &lt;td&gt;unmarshal method {@code declaredType} parameter&lt;/td&gt;
&nbsp; *     &lt;/tr&gt;
&nbsp; *     &lt;tr&gt;
&nbsp; *       &lt;th scope=&quot;row&quot;&gt;scope&lt;/th&gt;
&nbsp; *       &lt;td&gt;{@code null} &lt;i&gt;(actual scope is unknown)&lt;/i&gt;&lt;/td&gt;
&nbsp; *     &lt;/tr&gt;
&nbsp; *   &lt;/tbody&gt;
&nbsp; *  &lt;/table&gt;
&nbsp; * &lt;/blockquote&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * The following is an example of 
&nbsp; * &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalByDeclaredType&quot;&gt;unmarshal by declaredType method&lt;/a&gt;.
&nbsp; * &lt;p&gt;
&nbsp; * Unmarshal by declaredType from a {@code org.w3c.dom.Node}:
&nbsp; * &lt;blockquote&gt;
&nbsp; *    &lt;pre&gt;{@code 
&nbsp; *       Schema fragment for example
&nbsp; *       &lt;xs:schema&gt;
&nbsp; *          &lt;xs:complexType name=&quot;FooType&quot;&gt;...&lt;\xs:complexType&gt;
&nbsp; *          &lt;!-- global element declaration &quot;PurchaseOrder&quot; --&gt;
&nbsp; *          &lt;xs:element name=&quot;PurchaseOrder&quot;&gt;
&nbsp; *              &lt;xs:complexType&gt;
&nbsp; *                 &lt;xs:sequence&gt;
&nbsp; *                    &lt;!-- local element declaration &quot;foo&quot; --&gt;
&nbsp; *                    &lt;xs:element name=&quot;foo&quot; type=&quot;FooType&quot;/&gt;
&nbsp; *                    ...
&nbsp; *                 &lt;/xs:sequence&gt;
&nbsp; *              &lt;/xs:complexType&gt;
&nbsp; *          &lt;/xs:element&gt;
&nbsp; *       &lt;/xs:schema&gt;
&nbsp; *
&nbsp; *       JAXBContext jc = JAXBContext.newInstance( &quot;com.acme.foo&quot; );
&nbsp; *       Unmarshaller u = jc.createUnmarshaller();
&nbsp; * 
&nbsp; *       DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
&nbsp; *       dbf.setNamespaceAware(true);
&nbsp; *       DocumentBuilder db = dbf.newDocumentBuilder();
&nbsp; *       Document doc = db.parse(new File( &quot;nosferatu.xml&quot;));
&nbsp; *       Element  fooSubtree = ...; // traverse DOM till reach xml element foo, constrained by a 
&nbsp; *                                  // local element declaration in schema.
&nbsp; * 
&nbsp; *       // FooType is the JAXB mapping of the type of local element declaration foo.
&nbsp; *       JAXBElement&lt;FooType&gt; foo = u.unmarshal( fooSubtree, FooType.class);
&nbsp; *    }&lt;/pre&gt;
&nbsp; * &lt;/blockquote&gt;
&nbsp; * 
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Support for SAX2.0 Compliant Parsers&lt;/b&gt;&lt;br&gt;
&nbsp; * &lt;blockquote&gt;
&nbsp; * A client application has the ability to select the SAX2.0 compliant parser
&nbsp; * of their choice.  If a SAX parser is not selected, then the JAXB Provider&#39;s
&nbsp; * default parser will be used.  Even though the JAXB Provider&#39;s default parser
&nbsp; * is not required to be SAX2.0 compliant, all providers are required to allow
&nbsp; * a client application to specify their own SAX2.0 parser.  Some providers may
&nbsp; * require the client application to specify the SAX2.0 parser at schema compile
&nbsp; * time. See {@link #unmarshal(javax.xml.transform.Source) unmarshal(Source)} 
&nbsp; * for more detail.
&nbsp; * &lt;/blockquote&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Validation and Well-Formedness&lt;/b&gt;&lt;br&gt;
&nbsp; * &lt;blockquote&gt;
&nbsp; * &lt;p&gt;
&nbsp; * A client application can enable or disable JAXP 1.3 validation
&nbsp; * mechanism via the {@code setSchema(javax.xml.validation.Schema)} API.
&nbsp; * Sophisticated clients can specify their own validating SAX 2.0 compliant 
&nbsp; * parser and bypass the JAXP 1.3 validation mechanism using the 
&nbsp; * {@link #unmarshal(javax.xml.transform.Source) unmarshal(Source)}  API.
&nbsp; * 
&nbsp; * &lt;p&gt;
&nbsp; * Since unmarshalling invalid XML content is defined in JAXB 2.0, 
&nbsp; * the Unmarshaller default validation event handler was made more lenient
&nbsp; * than in JAXB 1.0.  When schema-derived code generated
&nbsp; * by JAXB 1.0 binding compiler is registered with {@link JAXBContext}, 
&nbsp; * the default unmarshal validation handler is 
&nbsp; * {@link javax.xml.bind.helpers.DefaultValidationEventHandler} and it
&nbsp; * terminates the marshal  operation after encountering either a fatal error or an error. 
&nbsp; * For a JAXB 2.0 client application, there is no explicitly defined default
&nbsp; * validation handler and the default event handling only 
&nbsp; * terminates the unmarshal operation after encountering a fatal error.
&nbsp; * 
&nbsp; * &lt;/blockquote&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * &lt;a name=&quot;supportedProps&quot;&gt;&lt;/a&gt;
&nbsp; * &lt;b&gt;Supported Properties&lt;/b&gt;&lt;br&gt;
&nbsp; * &lt;blockquote&gt;
&nbsp; * &lt;p&gt;
&nbsp; * There currently are not any properties required to be supported by all 
&nbsp; * JAXB Providers on Unmarshaller.  However, some providers may support 
&nbsp; * their own set of provider specific properties.
&nbsp; * &lt;/blockquote&gt;
&nbsp; * 
&nbsp; * &lt;p&gt;
&nbsp; * &lt;a name=&quot;unmarshalEventCallback&quot;&gt;&lt;/a&gt;
&nbsp; * &lt;b&gt;Unmarshal Event Callbacks&lt;/b&gt;&lt;br&gt;
&nbsp; * &lt;blockquote&gt;
&nbsp; * The {@link Unmarshaller} provides two styles of callback mechanisms
&nbsp; * that allow application specific processing during key points in the
&nbsp; * unmarshalling process.  In &#39;class defined&#39; event callbacks, application
&nbsp; * specific code placed in JAXB mapped classes is triggered during
&nbsp; * unmarshalling.  &#39;External listeners&#39; allow for centralized processing
&nbsp; * of unmarshal events in one callback method rather than by type event callbacks.
&nbsp; * &lt;p&gt;
&nbsp; * &#39;Class defined&#39; event callback methods allow any JAXB mapped class to specify 
&nbsp; * its own specific callback methods by defining methods with the following method signature:
&nbsp; * &lt;blockquote&gt;
&nbsp; * &lt;pre&gt;
&nbsp; *   // This method is called immediately after the object is created and before the unmarshalling of this 
&nbsp; *   // object begins. The callback provides an opportunity to initialize JavaBean properties prior to unmarshalling.
&nbsp; *   void beforeUnmarshal(Unmarshaller, Object parent);
&nbsp; * 
&nbsp; *   //This method is called after all the properties (except IDREF) are unmarshalled for this object, 
&nbsp; *   //but before this object is set to the parent object.
&nbsp; *   void afterUnmarshal(Unmarshaller, Object parent);
&nbsp; * &lt;/pre&gt;
&nbsp; * &lt;/blockquote&gt;
&nbsp; * The class defined callback methods should be used when the callback method requires
&nbsp; * access to non-public methods and/or fields of the class. 
&nbsp; * &lt;p&gt;
&nbsp; * The external listener callback mechanism enables the registration of a {@link Listener} 
&nbsp; * instance with an {@link Unmarshaller#setListener(Listener)}. The external listener receives all callback events, 
&nbsp; * allowing for more centralized processing than per class defined callback methods.  The external listener 
&nbsp; * receives events when unmarshalling process is marshalling to a JAXB element or to JAXB mapped class.
&nbsp; * &lt;p&gt;
&nbsp; * The &#39;class defined&#39; and external listener event callback methods are independent of each other,
&nbsp; * both can be called for one event.  The invocation ordering when both listener callback methods exist is
&nbsp; * defined in {@link Listener#beforeUnmarshal(Object, Object)} and {@link Listener#afterUnmarshal(Object, Object)}. 
&nbsp;* &lt;p&gt;
&nbsp; * An event callback method throwing an exception terminates the current unmarshal process.
&nbsp; * 
&nbsp; * &lt;/blockquote&gt;
&nbsp; * 
&nbsp; * @author &lt;ul&gt;&lt;li&gt;Ryan Shoemaker, Sun Microsystems, Inc.&lt;/li&gt;&lt;li&gt;Kohsuke Kawaguchi, Sun Microsystems, Inc.&lt;/li&gt;&lt;li&gt;Joe Fialli, Sun Microsystems, Inc.&lt;/li&gt;&lt;/ul&gt;
&nbsp; * @see JAXBContext
&nbsp; * @see Marshaller
&nbsp; * @see Validator
&nbsp; * @since 1.6, JAXB 1.0
&nbsp; */
&nbsp;public interface Unmarshaller {
&nbsp;    
&nbsp;    /**
&nbsp;     * Unmarshal XML data from the specified file and return the resulting
&nbsp;     * content tree.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Implements &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalGlobal&quot;&gt;Unmarshal Global Root Element&lt;/a&gt;.
&nbsp;     * 
&nbsp;     * @param f the file to unmarshal XML data from
&nbsp;     * @return the newly created root object of the java content tree 
&nbsp;     *
&nbsp;     * @throws JAXBException 
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If the file parameter is null
&nbsp;     */
&nbsp;    public Object unmarshal( java.io.File f ) throws JAXBException;
&nbsp;    
&nbsp;    /**
&nbsp;     * Unmarshal XML data from the specified InputStream and return the 
&nbsp;     * resulting content tree.  Validation event location information may
&nbsp;     * be incomplete when using this form of the unmarshal API.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Implements &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalGlobal&quot;&gt;Unmarshal Global Root Element&lt;/a&gt;.
&nbsp;     * 
&nbsp;     * @param is the InputStream to unmarshal XML data from
&nbsp;     * @return the newly created root object of the java content tree 
&nbsp;     *
&nbsp;     * @throws JAXBException 
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If the InputStream parameter is null
&nbsp;     */
&nbsp;    public Object unmarshal( java.io.InputStream is ) throws JAXBException;
&nbsp;
&nbsp;    /**
&nbsp;     * Unmarshal XML data from the specified Reader and return the
&nbsp;     * resulting content tree.  Validation event location information may
&nbsp;     * be incomplete when using this form of the unmarshal API,
&nbsp;     * because a Reader does not provide the system ID.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Implements &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalGlobal&quot;&gt;Unmarshal Global Root Element&lt;/a&gt;.
&nbsp;     * 
&nbsp;     * @param reader the Reader to unmarshal XML data from
&nbsp;     * @return the newly created root object of the java content tree
&nbsp;     *
&nbsp;     * @throws JAXBException
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If the InputStream parameter is null
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public Object unmarshal( Reader reader ) throws JAXBException;
&nbsp;
&nbsp;    /**
&nbsp;     * Unmarshal XML data from the specified URL and return the resulting
&nbsp;     * content tree.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Implements &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalGlobal&quot;&gt;Unmarshal Global Root Element&lt;/a&gt;.
&nbsp;     *
&nbsp;     * @param url the url to unmarshal XML data from
&nbsp;     * @return the newly created root object of the java content tree 
&nbsp;     *
&nbsp;     * @throws JAXBException 
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If the URL parameter is null
&nbsp;     */
&nbsp;    public Object unmarshal( java.net.URL url ) throws JAXBException;
&nbsp;    
&nbsp;    /**
&nbsp;     * Unmarshal XML data from the specified SAX InputSource and return the
&nbsp;     * resulting content tree.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Implements &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalGlobal&quot;&gt;Unmarshal Global Root Element&lt;/a&gt;.
&nbsp;     *
&nbsp;     * @param source the input source to unmarshal XML data from
&nbsp;     * @return the newly created root object of the java content tree 
&nbsp;     *
&nbsp;     * @throws JAXBException 
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If the InputSource parameter is null
&nbsp;     */
&nbsp;    public Object unmarshal( org.xml.sax.InputSource source ) throws JAXBException;
&nbsp;    
&nbsp;    /**
&nbsp;     * Unmarshal global XML data from the specified DOM tree and return the resulting
&nbsp;     * content tree.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Implements &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalGlobal&quot;&gt;Unmarshal Global Root Element&lt;/a&gt;.
&nbsp;     *
&nbsp;     * @param node
&nbsp;     *      the document/element to unmarshal XML data from.
&nbsp;     *      The caller must support at least Document and Element.
&nbsp;     * @return the newly created root object of the java content tree 
&nbsp;     *
&nbsp;     * @throws JAXBException 
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If the Node parameter is null
&nbsp;     * @see #unmarshal(org.w3c.dom.Node, Class)
&nbsp;     */
&nbsp;    public Object unmarshal( org.w3c.dom.Node node ) throws JAXBException;
&nbsp;
&nbsp;    /**
&nbsp;     * Unmarshal XML data by JAXB mapped {@code declaredType}
&nbsp;     * and return the resulting content tree.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Implements &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalByDeclaredType&quot;&gt;Unmarshal by Declared Type&lt;/a&gt;
&nbsp;     *
&nbsp;     * @param node
&nbsp;     *      the document/element to unmarshal XML data from.
&nbsp;     *      The caller must support at least Document and Element.
&nbsp;     * @param declaredType
&nbsp;     *      appropriate JAXB mapped class to hold {@code node}&#39;s XML data.
&nbsp;     * 
&nbsp;     * @return &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalDeclaredTypeReturn&quot;&gt;JAXB Element&lt;/a&gt; representation of {@code node}
&nbsp;     * 
&nbsp;     * @throws JAXBException 
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If any parameter is null
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public &lt;T&gt; JAXBElement&lt;T&gt; unmarshal( org.w3c.dom.Node node, Class&lt;T&gt; declaredType ) throws JAXBException;
&nbsp;    
&nbsp;    /**
&nbsp;     * Unmarshal XML data from the specified XML Source and return the 
&nbsp;     * resulting content tree.  
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Implements &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalGlobal&quot;&gt;Unmarshal Global Root Element&lt;/a&gt;.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;a name=&quot;saxParserPlugable&quot;&gt;&lt;/a&gt;
&nbsp;     * &lt;b&gt;SAX 2.0 Parser Pluggability&lt;/b&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * A client application can choose not to use the default parser mechanism
&nbsp;     * supplied with their JAXB provider.  Any SAX 2.0 compliant parser can be
&nbsp;     * substituted for the JAXB provider&#39;s default mechanism.  To do so, the
&nbsp;     * client application must properly configure a {@code SAXSource} containing
&nbsp;     * an {@code XMLReader} implemented by the SAX 2.0 parser provider.  If the
&nbsp;     * {@code XMLReader} has an {@code org.xml.sax.ErrorHandler} registered
&nbsp;     * on it, it will be replaced by the JAXB Provider so that validation errors
&nbsp;     * can be reported via the {@code ValidationEventHandler} mechanism of
&nbsp;     * JAXB.  If the {@code SAXSource} does not contain an {@code XMLReader},
&nbsp;     * then the JAXB provider&#39;s default parser mechanism will be used.
&nbsp;     * &lt;p&gt;
&nbsp;     * This parser replacement mechanism can also be used to replace the JAXB
&nbsp;     * provider&#39;s unmarshal-time validation engine.  The client application 
&nbsp;     * must properly configure their SAX 2.0 compliant parser to perform
&nbsp;     * validation (as shown in the example above).  Any {@code SAXParserExceptions}
&nbsp;     * encountered by the parser during the unmarshal operation will be
&nbsp;     * processed by the JAXB provider and converted into JAXB 
&nbsp;     * {@code ValidationEvent} objects which will be reported back to the
&nbsp;     * client via the {@code ValidationEventHandler} registered with the
&nbsp;     * {@code Unmarshaller}.  &lt;i&gt;Note:&lt;/i&gt; specifying a substitute validating
&nbsp;     * SAX 2.0 parser for unmarshalling does not necessarily replace the 
&nbsp;     * validation engine used by the JAXB provider for performing on-demand 
&nbsp;     * validation.
&nbsp;     * &lt;p&gt;
&nbsp;     * The only way for a client application to specify an alternate parser
&nbsp;     * mechanism to be used during unmarshal is via the 
&nbsp;     * {@code unmarshal(SAXSource)} API.  All other forms of the unmarshal
&nbsp;     * method (File, URL, Node, etc) will use the JAXB provider&#39;s default 
&nbsp;     * parser and validator mechanisms.
&nbsp;     *
&nbsp;     * @param source the XML Source to unmarshal XML data from (providers are
&nbsp;     *        only required to support SAXSource, DOMSource, and StreamSource)
&nbsp;     * @return the newly created root object of the java content tree
&nbsp;     *
&nbsp;     * @throws JAXBException 
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If the Source parameter is null
&nbsp;     * @see #unmarshal(javax.xml.transform.Source, Class)
&nbsp;     */
&nbsp;    public Object unmarshal( javax.xml.transform.Source source )
&nbsp;        throws JAXBException;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Unmarshal XML data from the specified XML Source by {@code declaredType} and return the
&nbsp;     * resulting content tree.  
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Implements &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalByDeclaredType&quot;&gt;Unmarshal by Declared Type&lt;/a&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#saxParserPlugable&quot;&gt;SAX 2.0 Parser Pluggability&lt;/a&gt;
&nbsp;     *
&nbsp;     * @param source the XML Source to unmarshal XML data from (providers are
&nbsp;     *        only required to support SAXSource, DOMSource, and StreamSource)
&nbsp;     * @param declaredType 
&nbsp;     *      appropriate JAXB mapped class to hold {@code source}&#39;s xml root element
&nbsp;     * @return Java content rooted by &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalDeclaredTypeReturn&quot;&gt;JAXB Element&lt;/a&gt;
&nbsp;     *
&nbsp;     * @throws JAXBException 
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If any parameter is null
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public &lt;T&gt; JAXBElement&lt;T&gt; unmarshal( javax.xml.transform.Source source, Class&lt;T&gt; declaredType )
&nbsp;        throws JAXBException;
&nbsp;    
&nbsp;    /**
&nbsp;     * Unmarshal XML data from the specified pull parser and return the
&nbsp;     * resulting content tree.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Implements &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalGlobal&quot;&gt;Unmarshal Global Root Element&lt;/a&gt;.
&nbsp;     * 
&nbsp;     * &lt;p&gt;
&nbsp;     * This method assumes that the parser is on a START_DOCUMENT or
&nbsp;     * START_ELEMENT event.  Unmarshalling will be done from this 
&nbsp;     * start event to the corresponding end event.  If this method 
&nbsp;     * returns successfully, the {@code reader} will be pointing at
&nbsp;     * the token right after the end event.
&nbsp;     * 
&nbsp;     * @param reader
&nbsp;     *      The parser to be read.
&nbsp;     * @return
&nbsp;     *      the newly created root object of the java content tree.
&nbsp;     *
&nbsp;     * @throws JAXBException 
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If the {@code reader} parameter is null
&nbsp;     * @throws IllegalStateException
&nbsp;     *      If {@code reader} is not pointing to a START_DOCUMENT or
&nbsp;     *      START_ELEMENT  event.
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     * @see #unmarshal(javax.xml.stream.XMLStreamReader, Class)
&nbsp;     */
&nbsp;    public Object unmarshal( javax.xml.stream.XMLStreamReader reader )
&nbsp;        throws JAXBException;
&nbsp;    
&nbsp;    /**
&nbsp;     * Unmarshal root element to JAXB mapped {@code declaredType}
&nbsp;     * and return the resulting content tree.
&nbsp;     * 
&nbsp;     * &lt;p&gt;
&nbsp;     * This method implements &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalByDeclaredType&quot;&gt;unmarshal by declaredType&lt;/a&gt;.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method assumes that the parser is on a START_DOCUMENT or
&nbsp;     * START_ELEMENT event. Unmarshalling will be done from this 
&nbsp;     * start event to the corresponding end event.  If this method 
&nbsp;     * returns successfully, the {@code reader} will be pointing at 
&nbsp;     * the token right after the end event.
&nbsp;     *
&nbsp;     * @param reader
&nbsp;     *      The parser to be read. 
&nbsp;     * @param declaredType
&nbsp;     *      appropriate JAXB mapped class to hold {@code reader}&#39;s START_ELEMENT XML data.
&nbsp;     * 
&nbsp;     * @return   content tree rooted by &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalDeclaredTypeReturn&quot;&gt;JAXB Element representation&lt;/a&gt;
&nbsp;     * 
&nbsp;     * @throws JAXBException 
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If any parameter is null
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public &lt;T&gt; JAXBElement&lt;T&gt; unmarshal( javax.xml.stream.XMLStreamReader reader, Class&lt;T&gt; declaredType ) throws JAXBException;
&nbsp;
&nbsp;    /**
&nbsp;     * Unmarshal XML data from the specified pull parser and return the
&nbsp;     * resulting content tree.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method is an &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalGlobal&quot;&gt;Unmarshal Global Root method&lt;/a&gt;.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method assumes that the parser is on a START_DOCUMENT or
&nbsp;     * START_ELEMENT event.  Unmarshalling will be done from this 
&nbsp;     * start event to the corresponding end event.  If this method 
&nbsp;     * returns successfully, the {@code reader} will be pointing at 
&nbsp;     * the token right after the end event. 
&nbsp;     * 
&nbsp;     * @param reader
&nbsp;     *      The parser to be read.
&nbsp;     * @return
&nbsp;     *      the newly created root object of the java content tree.
&nbsp;     *
&nbsp;     * @throws JAXBException 
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If the {@code reader} parameter is null
&nbsp;     * @throws IllegalStateException
&nbsp;     *      If {@code reader} is not pointing to a START_DOCUMENT or
&nbsp;     *      START_ELEMENT event.
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     * @see #unmarshal(javax.xml.stream.XMLEventReader, Class)
&nbsp;     */
&nbsp;    public Object unmarshal( javax.xml.stream.XMLEventReader reader )
&nbsp;        throws JAXBException;
&nbsp;    
&nbsp;    /**
&nbsp;     * Unmarshal root element to JAXB mapped {@code declaredType}
&nbsp;     * and return the resulting content tree.
&nbsp;     * 
&nbsp;     * &lt;p&gt;
&nbsp;     * This method implements &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalByDeclaredType&quot;&gt;unmarshal by declaredType&lt;/a&gt;.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method assumes that the parser is on a START_DOCUMENT or
&nbsp;     * START_ELEMENT event. Unmarshalling will be done from this 
&nbsp;     * start event to the corresponding end event.  If this method 
&nbsp;     * returns successfully, the {@code reader} will be pointing at 
&nbsp;     * the token right after the end event.
&nbsp;     *
&nbsp;     * @param reader
&nbsp;     *      The parser to be read. 
&nbsp;     * @param declaredType
&nbsp;     *      appropriate JAXB mapped class to hold {@code reader}&#39;s START_ELEMENT XML data.
&nbsp;     * 
&nbsp;     * @return   content tree rooted by &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalDeclaredTypeReturn&quot;&gt;JAXB Element representation&lt;/a&gt;
&nbsp;     * 
&nbsp;     * @throws JAXBException 
&nbsp;     *     If any unexpected errors occur while unmarshalling
&nbsp;     * @throws UnmarshalException
&nbsp;     *     If the {@link ValidationEventHandler ValidationEventHandler}
&nbsp;     *     returns false from its {@code handleEvent} method or the
&nbsp;     *     {@code Unmarshaller} is unable to perform the XML to Java
&nbsp;     *     binding.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#unmarshalEx&quot;&gt;Unmarshalling XML Data&lt;/a&gt;
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If any parameter is null
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public &lt;T&gt; JAXBElement&lt;T&gt; unmarshal( javax.xml.stream.XMLEventReader reader, Class&lt;T&gt; declaredType ) throws JAXBException;
&nbsp;
&nbsp;    /**
&nbsp;     * Get an unmarshaller handler object that can be used as a component in
&nbsp;     * an XML pipeline.
&nbsp;     * 
&nbsp;     * &lt;p&gt;
&nbsp;     * The JAXB Provider can return the same handler object for multiple 
&nbsp;     * invocations of this method. In other words, this method does not 
&nbsp;     * necessarily create a new instance of {@code UnmarshallerHandler}. If the
&nbsp;     * application needs to use more than one {@code UnmarshallerHandler}, it
&nbsp;     * should create more than one {@code Unmarshaller}.
&nbsp;     *
&nbsp;     * @return the unmarshaller handler object
&nbsp;     * @see UnmarshallerHandler
&nbsp;     */
&nbsp;    public UnmarshallerHandler getUnmarshallerHandler();
&nbsp;    
&nbsp;    /**
&nbsp;     * Specifies whether or not the default validation mechanism of the
&nbsp;     * {@code Unmarshaller} should validate during unmarshal operations.
&nbsp;     * By default, the {@code Unmarshaller} does not validate.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method may only be invoked before or after calling one of the
&nbsp;     * unmarshal methods.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method only controls the JAXB Provider&#39;s default unmarshal-time
&nbsp;     * validation mechanism - it has no impact on clients that specify their 
&nbsp;     * own validating SAX 2.0 compliant parser.  Clients that specify their
&nbsp;     * own unmarshal-time validation mechanism may wish to turn off the JAXB
&nbsp;     * Provider&#39;s default validation mechanism via this API to avoid &quot;double
&nbsp;     * validation&quot;.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method is deprecated as of JAXB 2.0 - please use the new
&nbsp;     * {@link #setSchema(javax.xml.validation.Schema)} API.
&nbsp;     *
&nbsp;     * @param validating true if the Unmarshaller should validate during 
&nbsp;     *        unmarshal, false otherwise
&nbsp;     * @throws JAXBException if an error occurred while enabling or disabling
&nbsp;     *         validation at unmarshal time
&nbsp;     * @throws UnsupportedOperationException could be thrown if this method is
&nbsp;     *         invoked on an Unmarshaller created from a JAXBContext referencing
&nbsp;     *         JAXB 2.0 mapped classes
&nbsp;     * @deprecated since JAXB2.0, please see {@link #setSchema(javax.xml.validation.Schema)}
&nbsp;     */
&nbsp;    public void setValidating( boolean validating ) 
&nbsp;        throws JAXBException;
&nbsp;    
&nbsp;    /**
&nbsp;     * Indicates whether or not the {@code Unmarshaller} is configured to
&nbsp;     * validate during unmarshal operations.
&nbsp;     * &lt;p&gt;
&nbsp;     * This API returns the state of the JAXB Provider&#39;s default unmarshal-time
&nbsp;     * validation mechanism. 
&nbsp;     * &lt;p&gt;
&nbsp;     * This method is deprecated as of JAXB 2.0 - please use the new
&nbsp;     * {@link #getSchema()} API.
&nbsp;     *
&nbsp;     * @return true if the Unmarshaller is configured to validate during 
&nbsp;     *         unmarshal operations, false otherwise
&nbsp;     * @throws JAXBException if an error occurs while retrieving the validating
&nbsp;     *         flag
&nbsp;     * @throws UnsupportedOperationException could be thrown if this method is
&nbsp;     *         invoked on an Unmarshaller created from a JAXBContext referencing
&nbsp;     *         JAXB 2.0 mapped classes
&nbsp;     * @deprecated since JAXB2.0, please see {@link #getSchema()}
&nbsp;     */
&nbsp;    public boolean isValidating() 
&nbsp;        throws JAXBException;
&nbsp;    
&nbsp;    /**
&nbsp;     * Allow an application to register a {@code ValidationEventHandler}.
&nbsp;     * &lt;p&gt;
&nbsp;     * The {@code ValidationEventHandler} will be called by the JAXB Provider
&nbsp;     * if any validation errors are encountered during calls to any of the 
&nbsp;     * unmarshal methods.  If the client application does not register a 
&nbsp;     * {@code ValidationEventHandler} before invoking the unmarshal methods,
&nbsp;     * then {@code ValidationEvents} will be handled by the default event
&nbsp;     * handler which will terminate the unmarshal operation after the first 
&nbsp;     * error or fatal error is encountered.
&nbsp;     * &lt;p&gt;
&nbsp;     * Calling this method with a null parameter will cause the Unmarshaller
&nbsp;     * to revert back to the default event handler.
&nbsp;     *
&nbsp;     * @param handler the validation event handler
&nbsp;     * @throws JAXBException if an error was encountered while setting the
&nbsp;     *         event handler
&nbsp;     */
&nbsp;    public void setEventHandler( ValidationEventHandler handler )
&nbsp;        throws JAXBException;
&nbsp;
&nbsp;    /**
&nbsp;     * Return the current event handler or the default event handler if one
&nbsp;     * hasn&#39;t been set.
&nbsp;     *
&nbsp;     * @return the current ValidationEventHandler or the default event handler
&nbsp;     *         if it hasn&#39;t been set
&nbsp;     * @throws JAXBException if an error was encountered while getting the 
&nbsp;     *         current event handler
&nbsp;     */
&nbsp;    public ValidationEventHandler getEventHandler()
&nbsp;        throws JAXBException;
&nbsp;
&nbsp;    /**
&nbsp;     * Set the particular property in the underlying implementation of 
&nbsp;     * {@code Unmarshaller}.  This method can only be used to set one of
&nbsp;     * the standard JAXB defined properties above or a provider specific
&nbsp;     * property.  Attempting to set an undefined property will result in
&nbsp;     * a PropertyException being thrown.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#supportedProps&quot;&gt;
&nbsp;     * Supported Properties&lt;/a&gt;.
&nbsp;     *
&nbsp;     * @param name the name of the property to be set. This value can either
&nbsp;     *              be specified using one of the constant fields or a user 
&nbsp;     *              supplied string.
&nbsp;     * @param value the value of the property to be set
&nbsp;     *
&nbsp;     * @throws PropertyException when there is an error processing the given
&nbsp;     *                            property or value
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If the name parameter is null
&nbsp;     */
&nbsp;    public void setProperty( String name, Object value ) 
&nbsp;        throws PropertyException;
&nbsp;    
&nbsp;    /**
&nbsp;     * Get the particular property in the underlying implementation of 
&nbsp;     * {@code Unmarshaller}.  This method can only be used to get one of
&nbsp;     * the standard JAXB defined properties above or a provider specific
&nbsp;     * property.  Attempting to get an undefined property will result in
&nbsp;     * a PropertyException being thrown.  See &lt;a href=&quot;{@docRoot}/javax/xml/bind/Unmarshaller.html#supportedProps&quot;&gt;
&nbsp;     * Supported Properties&lt;/a&gt;.
&nbsp;     *
&nbsp;     * @param name the name of the property to retrieve
&nbsp;     * @return the value of the requested property
&nbsp;     *
&nbsp;     * @throws PropertyException
&nbsp;     *      when there is an error retrieving the given property or value
&nbsp;     *      property name
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      If the name parameter is null
&nbsp;     */
&nbsp;    public Object getProperty( String name ) throws PropertyException;
&nbsp;
&nbsp;    /**
&nbsp;     * Specify the JAXP 1.3 {@link javax.xml.validation.Schema Schema}
&nbsp;     * object that should be used to validate subsequent unmarshal operations
&nbsp;     * against.  Passing null into this method will disable validation.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method replaces the deprecated {@link #setValidating(boolean) setValidating(boolean)}
&nbsp;     * API.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Initially this property is set to {@code null}.
&nbsp;     *
&nbsp;     * @param schema Schema object to validate unmarshal operations against or null to disable validation
&nbsp;     * @throws UnsupportedOperationException could be thrown if this method is
&nbsp;     *         invoked on an Unmarshaller created from a JAXBContext referencing
&nbsp;     *         JAXB 1.0 mapped classes
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public void setSchema( javax.xml.validation.Schema schema );
&nbsp;
&nbsp;    /**
&nbsp;     * Get the JAXP 1.3 {@link javax.xml.validation.Schema Schema} object
&nbsp;     * being used to perform unmarshal-time validation.  If there is no
&nbsp;     * Schema set on the unmarshaller, then this method will return null
&nbsp;     * indicating that unmarshal-time validation will not be performed.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method provides replacement functionality for the deprecated
&nbsp;     * {@link #isValidating()} API as well as access to the Schema object.
&nbsp;     * To determine if the Unmarshaller has validation enabled, simply
&nbsp;     * test the return type for null:
&nbsp;     * &lt;pre&gt;{@code
&nbsp;     *   boolean isValidating = u.getSchema()!=null;
&nbsp;     * }&lt;/pre&gt;
&nbsp;     * 
&nbsp;     * @return the Schema object being used to perform unmarshal-time
&nbsp;     *      validation or null if not present
&nbsp;     * @throws UnsupportedOperationException could be thrown if this method is
&nbsp;     *         invoked on an Unmarshaller created from a JAXBContext referencing
&nbsp;     *         JAXB 1.0 mapped classes
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public javax.xml.validation.Schema getSchema();
&nbsp;
&nbsp;    /**
&nbsp;     * Associates a configured instance of {@link XmlAdapter} with this unmarshaller.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This is a convenience method that invokes {@code setAdapter(adapter.getClass(),adapter);}.
&nbsp;     *
&nbsp;     * @see #setAdapter(Class,XmlAdapter)
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      if the adapter parameter is null.
&nbsp;     * @throws UnsupportedOperationException
&nbsp;     *      if invoked agains a JAXB 1.0 implementation.
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public void setAdapter( XmlAdapter adapter );
&nbsp;
&nbsp;    /**
&nbsp;     * Associates a configured instance of {@link XmlAdapter} with this unmarshaller.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Every unmarshaller internally maintains a
&nbsp;     * {@link java.util.Map}&amp;lt;{@link Class},{@link XmlAdapter}&amp;gt;,
&nbsp;     * which it uses for unmarshalling classes whose fields/methods are annotated
&nbsp;     * with {@link javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter}.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method allows applications to use a configured instance of {@link XmlAdapter}.
&nbsp;     * When an instance of an adapter is not given, an unmarshaller will create
&nbsp;     * one by invoking its default constructor.
&nbsp;     *
&nbsp;     * @param type
&nbsp;     *      The type of the adapter. The specified instance will be used when
&nbsp;     *      {@link javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter#value()}
&nbsp;     *      refers to this type.
&nbsp;     * @param adapter
&nbsp;     *      The instance of the adapter to be used. If null, it will un-register
&nbsp;     *      the current adapter set for this type.
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      if the type parameter is null.
&nbsp;     * @throws UnsupportedOperationException
&nbsp;     *      if invoked agains a JAXB 1.0 implementation.
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public &lt;A extends XmlAdapter&gt; void setAdapter( Class&lt;A&gt; type, A adapter );
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the adapter associated with the specified type.
&nbsp;     *
&nbsp;     * This is the reverse operation of the {@link #setAdapter} method.
&nbsp;     *
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      if the type parameter is null.
&nbsp;     * @throws UnsupportedOperationException
&nbsp;     *      if invoked agains a JAXB 1.0 implementation.
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public &lt;A extends XmlAdapter&gt; A getAdapter( Class&lt;A&gt; type );
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Associate a context that resolves cid&#39;s, content-id URIs, to
&nbsp;     * binary data passed as attachments.&lt;/p&gt;
&nbsp;     * &lt;p&gt;Unmarshal time validation, enabled via {@link #setSchema(Schema)},
&nbsp;     * must be supported even when unmarshaller is performing XOP processing.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @throws IllegalStateException if attempt to concurrently call this
&nbsp;     *                               method during a unmarshal operation.
&nbsp;     */
&nbsp;    void setAttachmentUnmarshaller(AttachmentUnmarshaller au);
&nbsp;
&nbsp;    AttachmentUnmarshaller getAttachmentUnmarshaller();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Register an instance of an implementation of this class with {@link Unmarshaller} to externally listen
&nbsp;     * for unmarshal events.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * This class enables pre and post processing of an instance of a JAXB mapped class
&nbsp;     * as XML data is unmarshalled into it. The event callbacks are called when unmarshalling
&nbsp;     * XML content into a JAXBElement instance or a JAXB mapped class that represents a complex type definition.
&nbsp;     * The event callbacks are not called when unmarshalling to an instance of a
&nbsp;     * Java datatype that represents a simple type definition.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * External listener is one of two different mechanisms for defining unmarshal event callbacks.
&nbsp;     * See &lt;a href=&quot;Unmarshaller.html#unmarshalEventCallback&quot;&gt;Unmarshal Event Callbacks&lt;/a&gt; for an overview.
&nbsp;     * &lt;/p&gt;
&nbsp;     * (@link #setListener(Listener)}
&nbsp;     * (@link #getListener()}
&nbsp;     *
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public static abstract class Listener {
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Callback method invoked before unmarshalling into {@code target}.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * This method is invoked immediately after {@code target} was created and
&nbsp;         * before the unmarshalling of this object begins. Note that
&nbsp;         * if the class of {@code target} defines its own {@code beforeUnmarshal} method,
&nbsp;         * the class specific callback method is invoked before this method is invoked.
&nbsp;         *
&nbsp;         * @param target non-null instance of JAXB mapped class prior to unmarshalling into it.
&nbsp;         * @param parent instance of JAXB mapped class that will eventually reference {@code target}.
&nbsp;         *               {@code null} when {@code target} is root element.
&nbsp;         */
&nbsp;        public void beforeUnmarshal(Object target, Object parent) {
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Callback method invoked after unmarshalling XML data into {@code target}.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * This method is invoked after all the properties (except IDREF)
&nbsp;         * are unmarshalled into {@code target},
&nbsp;         * but before {@code target} is set into its {@code parent} object.
&nbsp;         * Note that if the class of {@code target} defines its own {@code afterUnmarshal} method,
&nbsp;         * the class specific callback method is invoked before this method is invoked.
&nbsp;         *
&nbsp;         * @param target non-null instance of JAXB mapped class prior to unmarshalling into it.
&nbsp;         * @param parent instance of JAXB mapped class that will reference {@code target}.
&nbsp;         *               {@code null} when {@code target} is root element.
&nbsp;         */
&nbsp;        public void afterUnmarshal(Object target, Object parent) {
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Register unmarshal event callback {@link Listener} with this {@link Unmarshaller}.
&nbsp;     * 
&nbsp;     * &lt;p&gt;
&nbsp;     * There is only one Listener per Unmarshaller. Setting a Listener replaces the previous set Listener.
&nbsp;     * One can unregister current Listener by setting listener to {@code null}.
&nbsp;     * 
&nbsp;     * @param listener  provides unmarshal event callbacks for this {@link Unmarshaller}
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public void     setListener(Listener listener);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Return {@link Listener} registered with this {@link Unmarshaller}.
&nbsp;     *
&nbsp;     * @return registered {@link Listener} or {@code null}
&nbsp;     *         if no Listener is registered with this Unmarshaller.
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public Listener getListener();
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
