


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > DatatypeConverterImpl</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">javax.xml.bind</a>
</div>

<h1>Coverage Summary for Class: DatatypeConverterImpl (javax.xml.bind)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DatatypeConverterImpl</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7,8%
  </span>
  <span class="absValue">
    (6/77)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8,2%
  </span>
  <span class="absValue">
    (17/208)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11,9%
  </span>
  <span class="absValue">
    (38/319)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (c) 2007, 2018 Oracle and/or its affiliates. All rights reserved.
&nbsp; *
&nbsp; * This program and the accompanying materials are made available under the
&nbsp; * terms of the Eclipse Distribution License v. 1.0, which is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; */
&nbsp;
&nbsp;package javax.xml.bind;
&nbsp;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.math.BigInteger;
&nbsp;import java.util.Calendar;
&nbsp;import java.util.GregorianCalendar;
&nbsp;import java.util.TimeZone;
&nbsp;
&nbsp;import javax.xml.namespace.QName;
&nbsp;import javax.xml.namespace.NamespaceContext;
&nbsp;import javax.xml.datatype.DatatypeFactory;
&nbsp;import javax.xml.datatype.DatatypeConfigurationException;
&nbsp;
&nbsp;/**
&nbsp; * This class is the JAXB RI&#39;s default implementation of the
&nbsp; * {@link DatatypeConverterInterface}.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * When client applications specify the use of the static print/parse
&nbsp; * methods in {@link DatatypeConverter}, it will delegate
&nbsp; * to this class.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This class is responsible for whitespace normalization.
&nbsp; *
&nbsp; * @author &lt;ul&gt;&lt;li&gt;Ryan Shoemaker, Sun Microsystems, Inc.&lt;/li&gt;&lt;/ul&gt;
&nbsp; * @since JAXB 2.1
&nbsp; */
<b class="fc">&nbsp;final class DatatypeConverterImpl implements DatatypeConverterInterface {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * To avoid re-creating instances, we cache one instance.
&nbsp;     */
<b class="fc">&nbsp;    public static final DatatypeConverterInterface theInstance = new DatatypeConverterImpl();</b>
&nbsp;
<b class="fc">&nbsp;    protected DatatypeConverterImpl() {</b>
&nbsp;    }
&nbsp;
&nbsp;    public String parseString(String lexicalXSDString) {
<b class="nc">&nbsp;        return lexicalXSDString;</b>
&nbsp;    }
&nbsp;
&nbsp;    public BigInteger parseInteger(String lexicalXSDInteger) {
<b class="nc">&nbsp;        return _parseInteger(lexicalXSDInteger);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static BigInteger _parseInteger(CharSequence s) {
<b class="nc">&nbsp;        return new BigInteger(removeOptionalPlus(WhiteSpaceProcessor.trim(s)).toString());</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printInteger(BigInteger val) {
<b class="nc">&nbsp;        return _printInteger(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printInteger(BigInteger val) {
<b class="nc">&nbsp;        return val.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    public int parseInt(String s) {
<b class="nc">&nbsp;        return _parseInt(s);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Faster but less robust String-&gt;int conversion.
&nbsp;     *
&nbsp;     * Note that:
&nbsp;     * &lt;ol&gt;
&nbsp;     *  &lt;li&gt;XML Schema allows &#39;+&#39;, but {@link Integer#valueOf(String)} is not.
&nbsp;     *  &lt;li&gt;XML Schema allows leading and trailing (but not in-between) whitespaces.
&nbsp;     *      {@link Integer#valueOf(String)} doesn&#39;t allow any.
&nbsp;     * &lt;/ol&gt;
&nbsp;     */
&nbsp;    public static int _parseInt(CharSequence s) {
<b class="nc">&nbsp;        int len = s.length();</b>
<b class="nc">&nbsp;        int sign = 1;</b>
&nbsp;
<b class="nc">&nbsp;        int r = 0;</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; len; i++) {</b>
<b class="nc">&nbsp;            char ch = s.charAt(i);</b>
<b class="nc">&nbsp;            if (WhiteSpaceProcessor.isWhiteSpace(ch)) {</b>
&nbsp;                // skip whitespace
<b class="nc">&nbsp;            } else if (&#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;) {</b>
<b class="nc">&nbsp;                r = r * 10 + (ch - &#39;0&#39;);</b>
<b class="nc">&nbsp;            } else if (ch == &#39;-&#39;) {</b>
<b class="nc">&nbsp;                sign = -1;</b>
<b class="nc">&nbsp;            } else if (ch == &#39;+&#39;) {</b>
&nbsp;                // noop
&nbsp;            } else {
<b class="nc">&nbsp;                throw new NumberFormatException(&quot;Not a number: &quot; + s);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return r * sign;</b>
&nbsp;    }
&nbsp;
&nbsp;    public long parseLong(String lexicalXSLong) {
<b class="nc">&nbsp;        return _parseLong(lexicalXSLong);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static long _parseLong(CharSequence s) {
<b class="nc">&nbsp;        return Long.parseLong(removeOptionalPlus(WhiteSpaceProcessor.trim(s)).toString());</b>
&nbsp;    }
&nbsp;
&nbsp;    public short parseShort(String lexicalXSDShort) {
<b class="nc">&nbsp;        return _parseShort(lexicalXSDShort);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static short _parseShort(CharSequence s) {
<b class="nc">&nbsp;        return (short) _parseInt(s);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printShort(short val) {
<b class="nc">&nbsp;        return _printShort(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printShort(short val) {
<b class="nc">&nbsp;        return String.valueOf(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public BigDecimal parseDecimal(String content) {
<b class="nc">&nbsp;        return _parseDecimal(content);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static BigDecimal _parseDecimal(CharSequence content) {
<b class="nc">&nbsp;        content = WhiteSpaceProcessor.trim(content);</b>
&nbsp;
<b class="nc">&nbsp;        if (content.length() &lt;= 0) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return new BigDecimal(content.toString());</b>
&nbsp;
&nbsp;        // from purely XML Schema perspective,
&nbsp;        // this implementation has a problem, since
&nbsp;        // in xs:decimal &quot;1.0&quot; and &quot;1&quot; is equal whereas the above
&nbsp;        // code will return different values for those two forms.
&nbsp;        //
&nbsp;        // the code was originally using com.sun.msv.datatype.xsd.NumberType.load,
&nbsp;        // but a profiling showed that the process of normalizing &quot;1.0&quot; into &quot;1&quot;
&nbsp;        // could take non-trivial time.
&nbsp;        //
&nbsp;        // also, from the user&#39;s point of view, one might be surprised if
&nbsp;        // 1 (not 1.0) is returned from &quot;1.000&quot;
&nbsp;    }
&nbsp;
&nbsp;    public float parseFloat(String lexicalXSDFloat) {
<b class="nc">&nbsp;        return _parseFloat(lexicalXSDFloat);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static float _parseFloat(CharSequence _val) {
<b class="nc">&nbsp;        String s = WhiteSpaceProcessor.trim(_val).toString();</b>
&nbsp;        /* Incompatibilities of XML Schema&#39;s float &quot;xfloat&quot; and Java&#39;s float &quot;jfloat&quot;
&nbsp;
&nbsp;         * jfloat.valueOf ignores leading and trailing whitespaces,
&nbsp;        whereas this is not allowed in xfloat.
&nbsp;         * jfloat.valueOf allows &quot;float type suffix&quot; (f, F) to be
&nbsp;        appended after float literal (e.g., 1.52e-2f), whereare
&nbsp;        this is not the case of xfloat.
&nbsp;
&nbsp;        gray zone
&nbsp;        ---------
&nbsp;         * jfloat allows &quot;.523&quot;. And there is no clear statement that mentions
&nbsp;        this case in xfloat. Although probably this is allowed.
&nbsp;         *
&nbsp;         */
&nbsp;
<b class="nc">&nbsp;        if (s.equals(&quot;NaN&quot;)) {</b>
<b class="nc">&nbsp;            return Float.NaN;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (s.equals(&quot;INF&quot;)) {</b>
<b class="nc">&nbsp;            return Float.POSITIVE_INFINITY;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (s.equals(&quot;-INF&quot;)) {</b>
<b class="nc">&nbsp;            return Float.NEGATIVE_INFINITY;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (s.length() == 0</b>
<b class="nc">&nbsp;                || !isDigitOrPeriodOrSign(s.charAt(0))</b>
<b class="nc">&nbsp;                || !isDigitOrPeriodOrSign(s.charAt(s.length() - 1))) {</b>
<b class="nc">&nbsp;            throw new NumberFormatException();</b>
&nbsp;        }
&nbsp;
&nbsp;        // these screening process is necessary due to the wobble of Float.valueOf method
<b class="nc">&nbsp;        return Float.parseFloat(s);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printFloat(float v) {
<b class="nc">&nbsp;        return _printFloat(v);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printFloat(float v) {
<b class="nc">&nbsp;        if (Float.isNaN(v)) {</b>
<b class="nc">&nbsp;            return &quot;NaN&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (v == Float.POSITIVE_INFINITY) {</b>
<b class="nc">&nbsp;            return &quot;INF&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (v == Float.NEGATIVE_INFINITY) {</b>
<b class="nc">&nbsp;            return &quot;-INF&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return String.valueOf(v);</b>
&nbsp;    }
&nbsp;
&nbsp;    public double parseDouble(String lexicalXSDDouble) {
<b class="nc">&nbsp;        return _parseDouble(lexicalXSDDouble);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static double _parseDouble(CharSequence _val) {
<b class="nc">&nbsp;        String val = WhiteSpaceProcessor.trim(_val).toString();</b>
&nbsp;
<b class="nc">&nbsp;        if (val.equals(&quot;NaN&quot;)) {</b>
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (val.equals(&quot;INF&quot;)) {</b>
<b class="nc">&nbsp;            return Double.POSITIVE_INFINITY;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (val.equals(&quot;-INF&quot;)) {</b>
<b class="nc">&nbsp;            return Double.NEGATIVE_INFINITY;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (val.length() == 0</b>
<b class="nc">&nbsp;                || !isDigitOrPeriodOrSign(val.charAt(0))</b>
<b class="nc">&nbsp;                || !isDigitOrPeriodOrSign(val.charAt(val.length() - 1))) {</b>
<b class="nc">&nbsp;            throw new NumberFormatException(val);</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        // these screening process is necessary due to the wobble of Float.valueOf method
<b class="nc">&nbsp;        return Double.parseDouble(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean parseBoolean(String lexicalXSDBoolean) {
<b class="nc">&nbsp;        Boolean b = _parseBoolean(lexicalXSDBoolean);</b>
<b class="nc">&nbsp;        return (b == null) ? false : b.booleanValue();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Boolean _parseBoolean(CharSequence literal) {
<b class="nc">&nbsp;        if (literal == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int i = 0;</b>
<b class="nc">&nbsp;        int len = literal.length();</b>
&nbsp;        char ch;
<b class="nc">&nbsp;        boolean value = false;</b>
&nbsp;
<b class="nc">&nbsp;        if (literal.length() &lt;= 0) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        do {
<b class="nc">&nbsp;            ch = literal.charAt(i++);</b>
<b class="nc">&nbsp;        } while (WhiteSpaceProcessor.isWhiteSpace(ch) &amp;&amp; i &lt; len);</b>
&nbsp;
<b class="nc">&nbsp;        int strIndex = 0;</b>
&nbsp;
<b class="nc">&nbsp;        switch (ch) {</b>
&nbsp;            case &#39;1&#39;:
<b class="nc">&nbsp;                value = true;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case &#39;0&#39;:
<b class="nc">&nbsp;                value = false;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case &#39;t&#39;:
<b class="nc">&nbsp;                String strTrue = &quot;rue&quot;;</b>
&nbsp;                do {
<b class="nc">&nbsp;                    ch = literal.charAt(i++);</b>
<b class="nc">&nbsp;                } while ((strTrue.charAt(strIndex++) == ch) &amp;&amp; i &lt; len &amp;&amp; strIndex &lt; 3);</b>
&nbsp;
<b class="nc">&nbsp;                if (strIndex == 3) {</b>
<b class="nc">&nbsp;                    value = true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;//                    throw new IllegalArgumentException(&quot;String \&quot;&quot; + literal + &quot;\&quot; is not valid boolean value.&quot;);
&nbsp;
&nbsp;                break;
&nbsp;            case &#39;f&#39;:
<b class="nc">&nbsp;                String strFalse = &quot;alse&quot;;</b>
&nbsp;                do {
<b class="nc">&nbsp;                    ch = literal.charAt(i++);</b>
<b class="nc">&nbsp;                } while ((strFalse.charAt(strIndex++) == ch) &amp;&amp; i &lt; len &amp;&amp; strIndex &lt; 4);</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;                if (strIndex == 4) {</b>
<b class="nc">&nbsp;                    value = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;//                    throw new IllegalArgumentException(&quot;String \&quot;&quot; + literal + &quot;\&quot; is not valid boolean value.&quot;);
&nbsp;
&nbsp;                break;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (i &lt; len) {</b>
&nbsp;            do {
<b class="nc">&nbsp;                ch = literal.charAt(i++);</b>
<b class="nc">&nbsp;            } while (WhiteSpaceProcessor.isWhiteSpace(ch) &amp;&amp; i &lt; len);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (i == len) {</b>
<b class="nc">&nbsp;            return value;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;//            throw new IllegalArgumentException(&quot;String \&quot;&quot; + literal + &quot;\&quot; is not valid boolean value.&quot;);
&nbsp;    }
&nbsp;
&nbsp;    public String printBoolean(boolean val) {
<b class="nc">&nbsp;        return val ? &quot;true&quot; : &quot;false&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printBoolean(boolean val) {
<b class="nc">&nbsp;        return val ? &quot;true&quot; : &quot;false&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    public byte parseByte(String lexicalXSDByte) {
<b class="nc">&nbsp;        return _parseByte(lexicalXSDByte);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static byte _parseByte(CharSequence literal) {
<b class="nc">&nbsp;        return (byte) _parseInt(literal);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printByte(byte val) {
<b class="nc">&nbsp;        return _printByte(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printByte(byte val) {
<b class="nc">&nbsp;        return String.valueOf(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public QName parseQName(String lexicalXSDQName, NamespaceContext nsc) {
<b class="nc">&nbsp;        return _parseQName(lexicalXSDQName, nsc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return null if fails to convert.
&nbsp;     */
&nbsp;    public static QName _parseQName(CharSequence text, NamespaceContext nsc) {
<b class="nc">&nbsp;        int length = text.length();</b>
&nbsp;
&nbsp;        // trim whitespace
<b class="nc">&nbsp;        int start = 0;</b>
<b class="nc">&nbsp;        while (start &lt; length &amp;&amp; WhiteSpaceProcessor.isWhiteSpace(text.charAt(start))) {</b>
<b class="nc">&nbsp;            start++;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int end = length;</b>
<b class="nc">&nbsp;        while (end &gt; start &amp;&amp; WhiteSpaceProcessor.isWhiteSpace(text.charAt(end - 1))) {</b>
<b class="nc">&nbsp;            end--;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (end == start) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;input is empty&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        String uri;
&nbsp;        String localPart;
&nbsp;        String prefix;
&nbsp;
&nbsp;        // search &#39;:&#39;
<b class="nc">&nbsp;        int idx = start + 1;    // no point in searching the first char. that&#39;s not valid.</b>
<b class="nc">&nbsp;        while (idx &lt; end &amp;&amp; text.charAt(idx) != &#39;:&#39;) {</b>
<b class="nc">&nbsp;            idx++;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (idx == end) {</b>
<b class="nc">&nbsp;            uri = nsc.getNamespaceURI(&quot;&quot;);</b>
<b class="nc">&nbsp;            localPart = text.subSequence(start, end).toString();</b>
<b class="nc">&nbsp;            prefix = &quot;&quot;;</b>
&nbsp;        } else {
&nbsp;            // Prefix exists, check everything
<b class="nc">&nbsp;            prefix = text.subSequence(start, idx).toString();</b>
<b class="nc">&nbsp;            localPart = text.subSequence(idx + 1, end).toString();</b>
<b class="nc">&nbsp;            uri = nsc.getNamespaceURI(prefix);</b>
&nbsp;            // uri can never be null according to javadoc,
&nbsp;            // but some users reported that there are implementations that return null.
<b class="nc">&nbsp;            if (uri == null || uri.length() == 0) // crap. the NamespaceContext interface is broken.</b>
&nbsp;            // error: unbound prefix
&nbsp;            {
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;prefix &quot; + prefix + &quot; is not bound to a namespace&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return new QName(uri, localPart, prefix);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Calendar parseDateTime(String lexicalXSDDateTime) {
<b class="nc">&nbsp;        return _parseDateTime(lexicalXSDDateTime);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static GregorianCalendar _parseDateTime(CharSequence s) {
<b class="nc">&nbsp;        String val = WhiteSpaceProcessor.trim(s).toString();</b>
<b class="nc">&nbsp;        return datatypeFactory.newXMLGregorianCalendar(val).toGregorianCalendar();</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printDateTime(Calendar val) {
<b class="nc">&nbsp;        return _printDateTime(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printDateTime(Calendar val) {
<b class="nc">&nbsp;        return CalendarFormatter.doFormat(&quot;%Y-%M-%DT%h:%m:%s%z&quot;, val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public byte[] parseBase64Binary(String lexicalXSDBase64Binary) {
<b class="nc">&nbsp;        return _parseBase64Binary(lexicalXSDBase64Binary);</b>
&nbsp;    }
&nbsp;
&nbsp;    public byte[] parseHexBinary(String s) {
<b class="nc">&nbsp;        final int len = s.length();</b>
&nbsp;
&nbsp;        // &quot;111&quot; is not a valid hex encoding.
<b class="nc">&nbsp;        if (len % 2 != 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;hexBinary needs to be even-length: &quot; + s);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        byte[] out = new byte[len / 2];</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; len; i += 2) {</b>
<b class="nc">&nbsp;            int h = hexToBin(s.charAt(i));</b>
<b class="nc">&nbsp;            int l = hexToBin(s.charAt(i + 1));</b>
<b class="nc">&nbsp;            if (h == -1 || l == -1) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;contains illegal character for hexBinary: &quot; + s);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            out[i / 2] = (byte) (h * 16 + l);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return out;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int hexToBin(char ch) {
<b class="nc">&nbsp;        if (&#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;) {</b>
<b class="nc">&nbsp;            return ch - &#39;0&#39;;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (&#39;A&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;F&#39;) {</b>
<b class="nc">&nbsp;            return ch - &#39;A&#39; + 10;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (&#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;f&#39;) {</b>
<b class="nc">&nbsp;            return ch - &#39;a&#39; + 10;</b>
&nbsp;        }
<b class="nc">&nbsp;        return -1;</b>
&nbsp;    }
<b class="fc">&nbsp;    private static final char[] hexCode = &quot;0123456789ABCDEF&quot;.toCharArray();</b>
&nbsp;
&nbsp;    public String printHexBinary(byte[] data) {
<b class="nc">&nbsp;        StringBuilder r = new StringBuilder(data.length * 2);</b>
<b class="nc">&nbsp;        for (byte b : data) {</b>
<b class="nc">&nbsp;            r.append(hexCode[(b &gt;&gt; 4) &amp; 0xF]);</b>
<b class="nc">&nbsp;            r.append(hexCode[(b &amp; 0xF)]);</b>
&nbsp;        }
<b class="nc">&nbsp;        return r.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    public long parseUnsignedInt(String lexicalXSDUnsignedInt) {
<b class="nc">&nbsp;        return _parseLong(lexicalXSDUnsignedInt);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printUnsignedInt(long val) {
<b class="nc">&nbsp;        return _printLong(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int parseUnsignedShort(String lexicalXSDUnsignedShort) {
<b class="nc">&nbsp;        return _parseInt(lexicalXSDUnsignedShort);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Calendar parseTime(String lexicalXSDTime) {
<b class="nc">&nbsp;        return datatypeFactory.newXMLGregorianCalendar(lexicalXSDTime).toGregorianCalendar();</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printTime(Calendar val) {
<b class="nc">&nbsp;        return CalendarFormatter.doFormat(&quot;%h:%m:%s%z&quot;, val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Calendar parseDate(String lexicalXSDDate) {
<b class="nc">&nbsp;        return datatypeFactory.newXMLGregorianCalendar(lexicalXSDDate).toGregorianCalendar();</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printDate(Calendar val) {
<b class="nc">&nbsp;        return _printDate(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printDate(Calendar val) {
<b class="nc">&nbsp;        return CalendarFormatter.doFormat((new StringBuilder(&quot;%Y-%M-%D&quot;).append(&quot;%z&quot;)).toString(),val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String parseAnySimpleType(String lexicalXSDAnySimpleType) {
<b class="nc">&nbsp;        return lexicalXSDAnySimpleType;</b>
&nbsp;//        return (String)SimpleURType.theInstance._createValue( lexicalXSDAnySimpleType, null );
&nbsp;    }
&nbsp;
&nbsp;    public String printString(String val) {
&nbsp;//        return StringType.theInstance.convertToLexicalValue( val, null );
<b class="nc">&nbsp;        return val;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printInt(int val) {
<b class="nc">&nbsp;        return _printInt(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printInt(int val) {
<b class="nc">&nbsp;        return String.valueOf(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printLong(long val) {
<b class="nc">&nbsp;        return _printLong(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printLong(long val) {
<b class="nc">&nbsp;        return String.valueOf(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printDecimal(BigDecimal val) {
<b class="nc">&nbsp;        return _printDecimal(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printDecimal(BigDecimal val) {
<b class="nc">&nbsp;        return val.toPlainString();</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printDouble(double v) {
<b class="nc">&nbsp;        return _printDouble(v);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printDouble(double v) {
<b class="nc">&nbsp;        if (Double.isNaN(v)) {</b>
<b class="nc">&nbsp;            return &quot;NaN&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (v == Double.POSITIVE_INFINITY) {</b>
<b class="nc">&nbsp;            return &quot;INF&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (v == Double.NEGATIVE_INFINITY) {</b>
<b class="nc">&nbsp;            return &quot;-INF&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return String.valueOf(v);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printQName(QName val, NamespaceContext nsc) {
<b class="fc">&nbsp;        return _printQName(val, nsc);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printQName(QName val, NamespaceContext nsc) {
&nbsp;        // Double-check
&nbsp;        String qname;
<b class="fc">&nbsp;        String prefix = nsc.getPrefix(val.getNamespaceURI());</b>
<b class="fc">&nbsp;        String localPart = val.getLocalPart();</b>
&nbsp;
<b class="pc">&nbsp;        if (prefix == null || prefix.length() == 0) { // be defensive</b>
<b class="fc">&nbsp;            qname = localPart;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            qname = prefix + &#39;:&#39; + localPart;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return qname;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printBase64Binary(byte[] val) {
<b class="nc">&nbsp;        return _printBase64Binary(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printUnsignedShort(int val) {
<b class="nc">&nbsp;        return String.valueOf(val);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String printAnySimpleType(String val) {
<b class="nc">&nbsp;        return val;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Just return the string passed as a parameter but
&nbsp;     * installs an instance of this class as the DatatypeConverter
&nbsp;     * implementation. Used from static fixed value initializers.
&nbsp;     */
&nbsp;    public static String installHook(String s) {
<b class="nc">&nbsp;        DatatypeConverter.setDatatypeConverter(theInstance);</b>
<b class="nc">&nbsp;        return s;</b>
&nbsp;    }
&nbsp;// base64 decoder
<b class="fc">&nbsp;    private static final byte[] decodeMap = initDecodeMap();</b>
&nbsp;    private static final byte PADDING = 127;
&nbsp;
&nbsp;    private static byte[] initDecodeMap() {
<b class="fc">&nbsp;        byte[] map = new byte[128];</b>
&nbsp;        int i;
<b class="fc">&nbsp;        for (i = 0; i &lt; 128; i++) {</b>
<b class="fc">&nbsp;            map[i] = -1;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for (i = &#39;A&#39;; i &lt;= &#39;Z&#39;; i++) {</b>
<b class="fc">&nbsp;            map[i] = (byte) (i - &#39;A&#39;);</b>
&nbsp;        }
<b class="fc">&nbsp;        for (i = &#39;a&#39;; i &lt;= &#39;z&#39;; i++) {</b>
<b class="fc">&nbsp;            map[i] = (byte) (i - &#39;a&#39; + 26);</b>
&nbsp;        }
<b class="fc">&nbsp;        for (i = &#39;0&#39;; i &lt;= &#39;9&#39;; i++) {</b>
<b class="fc">&nbsp;            map[i] = (byte) (i - &#39;0&#39; + 52);</b>
&nbsp;        }
<b class="fc">&nbsp;        map[&#39;+&#39;] = 62;</b>
<b class="fc">&nbsp;        map[&#39;/&#39;] = 63;</b>
<b class="fc">&nbsp;        map[&#39;=&#39;] = PADDING;</b>
&nbsp;
<b class="fc">&nbsp;        return map;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * computes the length of binary data speculatively.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Our requirement is to create byte[] of the exact length to store the binary data.
&nbsp;     * If we do this in a straight-forward way, it takes two passes over the data.
&nbsp;     * Experiments show that this is a non-trivial overhead (35% or so is spent on
&nbsp;     * the first pass in calculating the length.)
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * So the approach here is that we compute the length speculatively, without looking
&nbsp;     * at the whole contents. The obtained speculative value is never less than the
&nbsp;     * actual length of the binary data, but it may be bigger. So if the speculation
&nbsp;     * goes wrong, we&#39;ll pay the cost of reallocation and buffer copying.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * If the base64 text is tightly packed with no indentation nor illegal char
&nbsp;     * (like what most web services produce), then the speculation of this method
&nbsp;     * will be correct, so we get the performance benefit.
&nbsp;     */
&nbsp;    private static int guessLength(String text) {
<b class="nc">&nbsp;        final int len = text.length();</b>
&nbsp;
&nbsp;        // compute the tail &#39;=&#39; chars
<b class="nc">&nbsp;        int j = len - 1;</b>
<b class="nc">&nbsp;        for (; j &gt;= 0; j--) {</b>
<b class="nc">&nbsp;            byte code = decodeMap[text.charAt(j)];</b>
<b class="nc">&nbsp;            if (code == PADDING) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (code == -1) // most likely this base64 text is indented. go with the upper bound</b>
&nbsp;            {
<b class="nc">&nbsp;                return text.length() / 4 * 3;</b>
&nbsp;            }
&nbsp;            break;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        j++;    // text.charAt(j) is now at some base64 char, so +1 to make it the size</b>
<b class="nc">&nbsp;        int padSize = len - j;</b>
<b class="nc">&nbsp;        if (padSize &gt; 2) // something is wrong with base64. be safe and go with the upper bound</b>
&nbsp;        {
<b class="nc">&nbsp;            return text.length() / 4 * 3;</b>
&nbsp;        }
&nbsp;
&nbsp;        // so far this base64 looks like it&#39;s unindented tightly packed base64.
&nbsp;        // take a chance and create an array with the expected size
<b class="nc">&nbsp;        return text.length() / 4 * 3 - padSize;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param text
&nbsp;     *      base64Binary data is likely to be long, and decoding requires
&nbsp;     *      each character to be accessed twice (once for counting length, another
&nbsp;     *      for decoding.)
&nbsp;     *
&nbsp;     *      A benchmark showed that taking {@link String} is faster, presumably
&nbsp;     *      because JIT can inline a lot of string access (with data of 1K chars, it was twice as fast)
&nbsp;     */
&nbsp;    public static byte[] _parseBase64Binary(String text) {
<b class="nc">&nbsp;        final int buflen = guessLength(text);</b>
<b class="nc">&nbsp;        final byte[] out = new byte[buflen];</b>
<b class="nc">&nbsp;        int o = 0;</b>
&nbsp;
<b class="nc">&nbsp;        final int len = text.length();</b>
&nbsp;        int i;
&nbsp;
<b class="nc">&nbsp;        final byte[] quadruplet = new byte[4];</b>
<b class="nc">&nbsp;        int q = 0;</b>
&nbsp;
&nbsp;        // convert each quadruplet to three bytes.
<b class="nc">&nbsp;        for (i = 0; i &lt; len; i++) {</b>
<b class="nc">&nbsp;            char ch = text.charAt(i);</b>
<b class="nc">&nbsp;            byte v = decodeMap[ch];</b>
&nbsp;
<b class="nc">&nbsp;            if (v != -1) {</b>
<b class="nc">&nbsp;                quadruplet[q++] = v;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (q == 4) {</b>
&nbsp;                // quadruplet is now filled.
<b class="nc">&nbsp;                out[o++] = (byte) ((quadruplet[0] &lt;&lt; 2) | (quadruplet[1] &gt;&gt; 4));</b>
<b class="nc">&nbsp;                if (quadruplet[2] != PADDING) {</b>
<b class="nc">&nbsp;                    out[o++] = (byte) ((quadruplet[1] &lt;&lt; 4) | (quadruplet[2] &gt;&gt; 2));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (quadruplet[3] != PADDING) {</b>
<b class="nc">&nbsp;                    out[o++] = (byte) ((quadruplet[2] &lt;&lt; 6) | (quadruplet[3]));</b>
&nbsp;                }
<b class="nc">&nbsp;                q = 0;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (buflen == o) // speculation worked out to be OK</b>
&nbsp;        {
<b class="nc">&nbsp;            return out;</b>
&nbsp;        }
&nbsp;
&nbsp;        // we overestimated, so need to create a new buffer
<b class="nc">&nbsp;        byte[] nb = new byte[o];</b>
<b class="nc">&nbsp;        System.arraycopy(out, 0, nb, 0, o);</b>
<b class="nc">&nbsp;        return nb;</b>
&nbsp;    }
<b class="fc">&nbsp;    private static final char[] encodeMap = initEncodeMap();</b>
&nbsp;
&nbsp;    private static char[] initEncodeMap() {
<b class="fc">&nbsp;        char[] map = new char[64];</b>
&nbsp;        int i;
<b class="fc">&nbsp;        for (i = 0; i &lt; 26; i++) {</b>
<b class="fc">&nbsp;            map[i] = (char) (&#39;A&#39; + i);</b>
&nbsp;        }
<b class="fc">&nbsp;        for (i = 26; i &lt; 52; i++) {</b>
<b class="fc">&nbsp;            map[i] = (char) (&#39;a&#39; + (i - 26));</b>
&nbsp;        }
<b class="fc">&nbsp;        for (i = 52; i &lt; 62; i++) {</b>
<b class="fc">&nbsp;            map[i] = (char) (&#39;0&#39; + (i - 52));</b>
&nbsp;        }
<b class="fc">&nbsp;        map[62] = &#39;+&#39;;</b>
<b class="fc">&nbsp;        map[63] = &#39;/&#39;;</b>
&nbsp;
<b class="fc">&nbsp;        return map;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static char encode(int i) {
<b class="nc">&nbsp;        return encodeMap[i &amp; 0x3F];</b>
&nbsp;    }
&nbsp;
&nbsp;    public static byte encodeByte(int i) {
<b class="nc">&nbsp;        return (byte) encodeMap[i &amp; 0x3F];</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printBase64Binary(byte[] input) {
<b class="nc">&nbsp;        return _printBase64Binary(input, 0, input.length);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String _printBase64Binary(byte[] input, int offset, int len) {
<b class="nc">&nbsp;        char[] buf = new char[((len + 2) / 3) * 4];</b>
<b class="nc">&nbsp;        int ptr = _printBase64Binary(input, offset, len, buf, 0);</b>
<b class="nc">&nbsp;        assert ptr == buf.length;</b>
<b class="nc">&nbsp;        return new String(buf);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Encodes a byte array into a char array by doing base64 encoding.
&nbsp;     *
&nbsp;     * The caller must supply a big enough buffer.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      the value of {@code ptr+((len+2)/3)*4}, which is the new offset
&nbsp;     *      in the output buffer where the further bytes should be placed.
&nbsp;     */
&nbsp;    public static int _printBase64Binary(byte[] input, int offset, int len, char[] buf, int ptr) {
&nbsp;        // encode elements until only 1 or 2 elements are left to encode
<b class="nc">&nbsp;        int remaining = len;</b>
&nbsp;        int i;
<b class="nc">&nbsp;        for (i = offset;remaining &gt;= 3; remaining -= 3, i += 3) {</b>
<b class="nc">&nbsp;            buf[ptr++] = encode(input[i] &gt;&gt; 2);</b>
<b class="nc">&nbsp;            buf[ptr++] = encode(</b>
&nbsp;                    ((input[i] &amp; 0x3) &lt;&lt; 4)
&nbsp;                    | ((input[i + 1] &gt;&gt; 4) &amp; 0xF));
<b class="nc">&nbsp;            buf[ptr++] = encode(</b>
&nbsp;                    ((input[i + 1] &amp; 0xF) &lt;&lt; 2)
&nbsp;                    | ((input[i + 2] &gt;&gt; 6) &amp; 0x3));
<b class="nc">&nbsp;            buf[ptr++] = encode(input[i + 2] &amp; 0x3F);</b>
&nbsp;        }
&nbsp;        // encode when exactly 1 element (left) to encode
<b class="nc">&nbsp;        if (remaining == 1) {</b>
<b class="nc">&nbsp;            buf[ptr++] = encode(input[i] &gt;&gt; 2);</b>
<b class="nc">&nbsp;            buf[ptr++] = encode(((input[i]) &amp; 0x3) &lt;&lt; 4);</b>
<b class="nc">&nbsp;            buf[ptr++] = &#39;=&#39;;</b>
<b class="nc">&nbsp;            buf[ptr++] = &#39;=&#39;;</b>
&nbsp;        }
&nbsp;        // encode when exactly 2 elements (left) to encode
<b class="nc">&nbsp;        if (remaining == 2) {</b>
<b class="nc">&nbsp;            buf[ptr++] = encode(input[i] &gt;&gt; 2);</b>
<b class="nc">&nbsp;            buf[ptr++] = encode(((input[i] &amp; 0x3) &lt;&lt; 4)</b>
&nbsp;                    | ((input[i + 1] &gt;&gt; 4) &amp; 0xF));
<b class="nc">&nbsp;            buf[ptr++] = encode((input[i + 1] &amp; 0xF) &lt;&lt; 2);</b>
<b class="nc">&nbsp;            buf[ptr++] = &#39;=&#39;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return ptr;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Encodes a byte array into another byte array by first doing base64 encoding
&nbsp;     * then encoding the result in ASCII.
&nbsp;     *
&nbsp;     * The caller must supply a big enough buffer.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      the value of {@code ptr+((len+2)/3)*4}, which is the new offset
&nbsp;     *      in the output buffer where the further bytes should be placed.
&nbsp;     */
&nbsp;    public static int _printBase64Binary(byte[] input, int offset, int len, byte[] out, int ptr) {
<b class="nc">&nbsp;        byte[] buf = out;</b>
<b class="nc">&nbsp;        int remaining = len;</b>
&nbsp;        int i;
<b class="nc">&nbsp;        for (i=offset; remaining &gt;= 3; remaining -= 3, i += 3 ) {</b>
<b class="nc">&nbsp;            buf[ptr++] = encodeByte(input[i]&gt;&gt;2);</b>
<b class="nc">&nbsp;            buf[ptr++] = encodeByte(</b>
&nbsp;                        ((input[i]&amp;0x3)&lt;&lt;4) |
&nbsp;                        ((input[i+1]&gt;&gt;4)&amp;0xF));
<b class="nc">&nbsp;            buf[ptr++] = encodeByte(</b>
&nbsp;                        ((input[i+1]&amp;0xF)&lt;&lt;2)|
&nbsp;                        ((input[i+2]&gt;&gt;6)&amp;0x3));
<b class="nc">&nbsp;            buf[ptr++] = encodeByte(input[i+2]&amp;0x3F);</b>
&nbsp;        }
&nbsp;        // encode when exactly 1 element (left) to encode
<b class="nc">&nbsp;        if (remaining == 1) {</b>
<b class="nc">&nbsp;            buf[ptr++] = encodeByte(input[i]&gt;&gt;2);</b>
<b class="nc">&nbsp;            buf[ptr++] = encodeByte(((input[i])&amp;0x3)&lt;&lt;4);</b>
<b class="nc">&nbsp;            buf[ptr++] = &#39;=&#39;;</b>
<b class="nc">&nbsp;            buf[ptr++] = &#39;=&#39;;</b>
&nbsp;        }
&nbsp;        // encode when exactly 2 elements (left) to encode
<b class="nc">&nbsp;        if (remaining == 2) {</b>
<b class="nc">&nbsp;            buf[ptr++] = encodeByte(input[i]&gt;&gt;2);</b>
<b class="nc">&nbsp;            buf[ptr++] = encodeByte(</b>
&nbsp;                        ((input[i]&amp;0x3)&lt;&lt;4) |
&nbsp;                        ((input[i+1]&gt;&gt;4)&amp;0xF));
<b class="nc">&nbsp;            buf[ptr++] = encodeByte((input[i+1]&amp;0xF)&lt;&lt;2);</b>
<b class="nc">&nbsp;            buf[ptr++] = &#39;=&#39;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return ptr;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static CharSequence removeOptionalPlus(CharSequence s) {
<b class="nc">&nbsp;        int len = s.length();</b>
&nbsp;
<b class="nc">&nbsp;        if (len &lt;= 1 || s.charAt(0) != &#39;+&#39;) {</b>
<b class="nc">&nbsp;            return s;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        s = s.subSequence(1, len);</b>
<b class="nc">&nbsp;        char ch = s.charAt(0);</b>
<b class="nc">&nbsp;        if (&#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;) {</b>
<b class="nc">&nbsp;            return s;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (&#39;.&#39; == ch) {</b>
<b class="nc">&nbsp;            return s;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new NumberFormatException();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isDigitOrPeriodOrSign(char ch) {
<b class="nc">&nbsp;        if (&#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (ch == &#39;+&#39; || ch == &#39;-&#39; || ch == &#39;.&#39;) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;    private static final DatatypeFactory datatypeFactory;
&nbsp;
&nbsp;    static {
&nbsp;        try {
<b class="fc">&nbsp;            datatypeFactory = DatatypeFactory.newInstance();</b>
<b class="nc">&nbsp;        } catch (DatatypeConfigurationException e) {</b>
<b class="nc">&nbsp;            throw new Error(e);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static final class CalendarFormatter {
&nbsp;
&nbsp;        public static String doFormat(String format, Calendar cal) throws IllegalArgumentException {
&nbsp;            int fidx = 0;
&nbsp;            int flen = format.length();
&nbsp;            StringBuilder buf = new StringBuilder();
&nbsp;
&nbsp;            while (fidx &lt; flen) {
&nbsp;                char fch = format.charAt(fidx++);
&nbsp;
&nbsp;                if (fch != &#39;%&#39;) {  // not a meta character
&nbsp;                    buf.append(fch);
&nbsp;                    continue;
&nbsp;                }
&nbsp;
&nbsp;                // seen meta character. we don&#39;t do error check against the format
&nbsp;                switch (format.charAt(fidx++)) {
&nbsp;                    case &#39;Y&#39;: // year
&nbsp;                        formatYear(cal, buf);
&nbsp;                        break;
&nbsp;
&nbsp;                    case &#39;M&#39;: // month
&nbsp;                        formatMonth(cal, buf);
&nbsp;                        break;
&nbsp;
&nbsp;                    case &#39;D&#39;: // days
&nbsp;                        formatDays(cal, buf);
&nbsp;                        break;
&nbsp;
&nbsp;                    case &#39;h&#39;: // hours
&nbsp;                        formatHours(cal, buf);
&nbsp;                        break;
&nbsp;
&nbsp;                    case &#39;m&#39;: // minutes
&nbsp;                        formatMinutes(cal, buf);
&nbsp;                        break;
&nbsp;
&nbsp;                    case &#39;s&#39;: // parse seconds.
&nbsp;                        formatSeconds(cal, buf);
&nbsp;                        break;
&nbsp;
&nbsp;                    case &#39;z&#39;: // time zone
&nbsp;                        formatTimeZone(cal, buf);
&nbsp;                        break;
&nbsp;
&nbsp;                    default:
&nbsp;                        // illegal meta character. impossible.
&nbsp;                        throw new InternalError();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return buf.toString();
&nbsp;        }
&nbsp;
&nbsp;        private static void formatYear(Calendar cal, StringBuilder buf) {
&nbsp;            int year = cal.get(Calendar.YEAR);
&nbsp;
&nbsp;            String s;
&nbsp;            if (year &lt;= 0) // negative value
&nbsp;            {
&nbsp;                s = Integer.toString(1 - year);
&nbsp;            } else // positive value
&nbsp;            {
&nbsp;                s = Integer.toString(year);
&nbsp;            }
&nbsp;
&nbsp;            while (s.length() &lt; 4) {
&nbsp;                s = &#39;0&#39; + s;
&nbsp;            }
&nbsp;            if (year &lt;= 0) {
&nbsp;                s = &#39;-&#39; + s;
&nbsp;            }
&nbsp;
&nbsp;            buf.append(s);
&nbsp;        }
&nbsp;
&nbsp;        private static void formatMonth(Calendar cal, StringBuilder buf) {
&nbsp;            formatTwoDigits(cal.get(Calendar.MONTH) + 1, buf);
&nbsp;        }
&nbsp;
&nbsp;        private static void formatDays(Calendar cal, StringBuilder buf) {
&nbsp;            formatTwoDigits(cal.get(Calendar.DAY_OF_MONTH), buf);
&nbsp;        }
&nbsp;
&nbsp;        private static void formatHours(Calendar cal, StringBuilder buf) {
&nbsp;            formatTwoDigits(cal.get(Calendar.HOUR_OF_DAY), buf);
&nbsp;        }
&nbsp;
&nbsp;        private static void formatMinutes(Calendar cal, StringBuilder buf) {
&nbsp;            formatTwoDigits(cal.get(Calendar.MINUTE), buf);
&nbsp;        }
&nbsp;
&nbsp;        private static void formatSeconds(Calendar cal, StringBuilder buf) {
&nbsp;            formatTwoDigits(cal.get(Calendar.SECOND), buf);
&nbsp;            if (cal.isSet(Calendar.MILLISECOND)) { // milliseconds
&nbsp;                int n = cal.get(Calendar.MILLISECOND);
&nbsp;                if (n != 0) {
&nbsp;                    String ms = Integer.toString(n);
&nbsp;                    while (ms.length() &lt; 3) {
&nbsp;                        ms = &#39;0&#39; + ms; // left 0 paddings.
&nbsp;                    }
&nbsp;                    buf.append(&#39;.&#39;);
&nbsp;                    buf.append(ms);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /** formats time zone specifier. */
&nbsp;        private static void formatTimeZone(Calendar cal, StringBuilder buf) {
&nbsp;            TimeZone tz = cal.getTimeZone();
&nbsp;
&nbsp;            if (tz == null) {
&nbsp;                return;
&nbsp;            }
&nbsp;
&nbsp;            // otherwise print out normally.
&nbsp;            int offset = tz.getOffset(cal.getTime().getTime());
&nbsp;
&nbsp;            if (offset == 0) {
&nbsp;                buf.append(&#39;Z&#39;);
&nbsp;                return;
&nbsp;            }
&nbsp;
&nbsp;            if (offset &gt;= 0) {
&nbsp;                buf.append(&#39;+&#39;);
&nbsp;            } else {
&nbsp;                buf.append(&#39;-&#39;);
&nbsp;                offset *= -1;
&nbsp;            }
&nbsp;
&nbsp;            offset /= 60 * 1000; // offset is in milli-seconds
&nbsp;
&nbsp;            formatTwoDigits(offset / 60, buf);
&nbsp;            buf.append(&#39;:&#39;);
&nbsp;            formatTwoDigits(offset % 60, buf);
&nbsp;        }
&nbsp;
&nbsp;        /** formats Integer into two-character-wide string. */
&nbsp;        private static void formatTwoDigits(int n, StringBuilder buf) {
&nbsp;            // n is always non-negative.
&nbsp;            if (n &lt; 10) {
&nbsp;                buf.append(&#39;0&#39;);
&nbsp;            }
&nbsp;            buf.append(n);
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
