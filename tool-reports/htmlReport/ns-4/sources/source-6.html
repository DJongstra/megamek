


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > JAXBContext</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">javax.xml.bind</a>
</div>

<h1>Coverage Summary for Class: JAXBContext (javax.xml.bind)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JAXBContext</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27,3%
  </span>
  <span class="absValue">
    (3/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (6/18)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (c) 2003, 2018 Oracle and/or its affiliates. All rights reserved.
&nbsp; *
&nbsp; * This program and the accompanying materials are made available under the
&nbsp; * terms of the Eclipse Distribution License v. 1.0, which is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; */
&nbsp;
&nbsp;package javax.xml.bind;
&nbsp;
&nbsp;import org.w3c.dom.Node;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Map;
&nbsp;import java.util.Properties;
&nbsp;
&nbsp;/**
&nbsp; * The {@code JAXBContext} class provides the client&#39;s entry point to the
&nbsp; * JAXB API. It provides an abstraction for managing the XML/Java binding
&nbsp; * information necessary to implement the JAXB binding framework operations:
&nbsp; * unmarshal, marshal and validate.
&nbsp; *
&nbsp; * &lt;p&gt;A client application normally obtains new instances of this class using
&nbsp; * one of these two styles for newInstance methods, although there are other
&nbsp; * specialized forms of the method available:
&nbsp; *
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;{@link #newInstance(String, ClassLoader) JAXBContext.newInstance( &quot;com.acme.foo:com.acme.bar&quot; )} &lt;br&gt;
&nbsp; * The JAXBContext instance is initialized from a list of colon
&nbsp; * separated Java package names. Each java package contains
&nbsp; * JAXB mapped classes, schema-derived classes and/or user annotated
&nbsp; * classes. Additionally, the java package may contain JAXB package annotations
&nbsp; * that must be processed. (see JLS, Section 7.4.1 &quot;Named Packages&quot;).
&nbsp; * &lt;/li&gt;
&nbsp; * &lt;li&gt;{@link #newInstance(Class...) JAXBContext.newInstance( com.acme.foo.Foo.class )} &lt;br&gt;
&nbsp; * The JAXBContext instance is initialized with class(es)
&nbsp; * passed as parameter(s) and classes that are statically reachable from
&nbsp; * these class(es). See {@link #newInstance(Class...)} for details.
&nbsp; * &lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;p&gt;&lt;i&gt;
&nbsp; * The following JAXB 1.0 requirement is only required for schema to
&nbsp; * java interface/implementation binding. It does not apply to JAXB annotated
&nbsp; * classes. JAXB Providers must generate a {@code jaxb.properties} file in
&nbsp; * each package containing schema derived classes.  The property file must
&nbsp; * contain a property named {@code javax.xml.bind.context.factory} whose
&nbsp; * value is the name of the class that implements the {@code createContext}
&nbsp; * APIs.&lt;/i&gt;
&nbsp; *
&nbsp; * &lt;p&gt;&lt;i&gt;
&nbsp; * The class supplied by the provider does not have to be assignable to
&nbsp; * {@code javax.xml.bind.JAXBContext}, it simply has to provide a class that
&nbsp; * implements the {@code createContext} APIs.&lt;/i&gt;
&nbsp; *
&nbsp; * &lt;p&gt;&lt;i&gt;
&nbsp; * In addition, the provider must call the
&nbsp; * {@link DatatypeConverter#setDatatypeConverter(DatatypeConverterInterface)
&nbsp; * DatatypeConverter.setDatatypeConverter} api prior to any client
&nbsp; * invocations of the marshal and unmarshal methods.  This is necessary to
&nbsp; * configure the datatype converter that will be used during these operations.&lt;/i&gt;
&nbsp; *
&nbsp; * &lt;a name=&quot;Unmarshalling&quot;&gt;&lt;/a&gt;
&nbsp; * &lt;h3&gt;Unmarshalling&lt;/h3&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The {@link Unmarshaller} class provides the client application the ability
&nbsp; * to convert XML data into a tree of Java content objects.
&nbsp; * The unmarshal method allows for
&nbsp; * any global XML element declared in the schema to be unmarshalled as
&nbsp; * the root of an instance document.
&nbsp; * Additionally, the unmarshal method allows for an unrecognized root element that
&nbsp; * has  an xsi:type attribute&#39;s value that references a type definition declared in
&nbsp; * the schema  to be unmarshalled as the root of an instance document.
&nbsp; * The {@code JAXBContext} object
&nbsp; * allows the merging of global elements and type definitions across a set of schemas (listed
&nbsp; * in the {@code contextPath}). Since each schema in the schema set can belong
&nbsp; * to distinct namespaces, the unification of schemas to an unmarshalling
&nbsp; * context must be namespace independent.  This means that a client
&nbsp; * application is able to unmarshal XML documents that are instances of
&nbsp; * any of the schemas listed in the {@code contextPath}.  For example:
&nbsp; *
&nbsp; * &lt;pre&gt;
&nbsp; *      JAXBContext jc = JAXBContext.newInstance( &quot;com.acme.foo:com.acme.bar&quot; );
&nbsp; *      Unmarshaller u = jc.createUnmarshaller();
&nbsp; *      FooObject fooObj = (FooObject)u.unmarshal( new File( &quot;foo.xml&quot; ) ); // ok
&nbsp; *      BarObject barObj = (BarObject)u.unmarshal( new File( &quot;bar.xml&quot; ) ); // ok
&nbsp; *      BazObject bazObj = (BazObject)u.unmarshal( new File( &quot;baz.xml&quot; ) ); // error, &quot;com.acme.baz&quot; not in contextPath
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * The client application may also generate Java content trees explicitly rather
&nbsp; * than unmarshalling existing XML data.  For all JAXB-annotated value classes,
&nbsp; * an application can create content using constructors.
&nbsp; * For schema-derived interface/implementation classes and for the
&nbsp; * creation of elements that are not bound to a JAXB-annotated
&nbsp; * class, an application needs to have access and knowledge about each of
&nbsp; * the schema derived {@code ObjectFactory} classes that exist in each of
&nbsp; * java packages contained in the {@code contextPath}.  For each schema
&nbsp; * derived java class, there is a static factory method that produces objects
&nbsp; * of that type.  For example,
&nbsp; * assume that after compiling a schema, you have a package {@code com.acme.foo}
&nbsp; * that contains a schema derived interface named {@code PurchaseOrder}.  In
&nbsp; * order to create objects of that type, the client application would use the
&nbsp; * factory method like this:
&nbsp; *
&nbsp; * &lt;pre&gt;
&nbsp; *       com.acme.foo.PurchaseOrder po =
&nbsp; *           com.acme.foo.ObjectFactory.createPurchaseOrder();
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Once the client application has an instance of the the schema derived object,
&nbsp; * it can use the mutator methods to set content on it.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * For more information on the generated {@code ObjectFactory} classes, see
&nbsp; * Section 4.2 &lt;i&gt;Java Package&lt;/i&gt; of the specification.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * &lt;i&gt;The provider must generate a class in each
&nbsp; * package that contains all of the necessary object factory methods for that
&nbsp; * package named ObjectFactory as well as the static
&nbsp; * {@code newInstance( javaContentInterface )} method&lt;/i&gt;
&nbsp; *
&nbsp; * &lt;h3&gt;Marshalling&lt;/h3&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The {@link Marshaller} class provides the client application the ability
&nbsp; * to convert a Java content tree back into XML data.  There is no difference
&nbsp; * between marshalling a content tree that is created manually using the factory
&nbsp; * methods and marshalling a content tree that is the result an {@code unmarshal}
&nbsp; * operation.  Clients can marshal a java content tree back to XML data
&nbsp; * to a {@code java.io.OutputStream} or a {@code java.io.Writer}.  The
&nbsp; * marshalling process can alternatively produce SAX2 event streams to a
&nbsp; * registered {@code ContentHandler} or produce a DOM Node object.
&nbsp; * Client applications have control over the output encoding as well as
&nbsp; * whether or not to marshal the XML data as a complete document or
&nbsp; * as a fragment.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Here is a simple example that unmarshals an XML document and then marshals
&nbsp; * it back out:
&nbsp; *
&nbsp; * &lt;pre&gt;
&nbsp; *        JAXBContext jc = JAXBContext.newInstance( &quot;com.acme.foo&quot; );
&nbsp; *
&nbsp; *        // unmarshal from foo.xml
&nbsp; *        Unmarshaller u = jc.createUnmarshaller();
&nbsp; *        FooObject fooObj = (FooObject)u.unmarshal( new File( &quot;foo.xml&quot; ) );
&nbsp; *
&nbsp; *        // marshal to System.out
&nbsp; *        Marshaller m = jc.createMarshaller();
&nbsp; *        m.marshal( fooObj, System.out );
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3&gt;Validation&lt;/h3&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Validation has been changed significantly since JAXB 1.0.  The {@link Validator}
&nbsp; * class has been deprecated and made optional.  This means that you are advised
&nbsp; * not to use this class and, in fact, it may not even be available depending on
&nbsp; * your JAXB provider.  JAXB 1.0 client applications that rely on {@code Validator}
&nbsp; * will still work properly when deployed with the JAXB 1.0 runtime system.
&nbsp; *
&nbsp; * In JAXB 2.0, the {@link Unmarshaller} has included convenince methods that expose
&nbsp; * the JAXP 1.3 {@link javax.xml.validation} framework.  Please refer to the
&nbsp; * {@link Unmarshaller#setSchema(javax.xml.validation.Schema)} API for more
&nbsp; * information.
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3&gt;JAXB Runtime Binding Framework Compatibility&lt;/h3&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The following JAXB 1.0 restriction only applies to binding schema to
&nbsp; * interfaces/implementation classes.
&nbsp; * Since this binding does not require a common runtime system, a JAXB
&nbsp; * client application must not attempt to mix runtime objects ({@code JAXBContext,
&nbsp; * Marshaller}, etc. ) from different providers.  This does not
&nbsp; * mean that the client application isn&#39;t portable, it simply means that a
&nbsp; * client has to use a runtime system provided by the same provider that was
&nbsp; * used to compile the schema.
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3&gt;Discovery of JAXB implementation&lt;/h3&gt;
&nbsp; * &lt;p&gt;
&nbsp; * To create an instance of {@link JAXBContext}, one of {@code JAXBContext.newInstance(...)} methods is invoked. After
&nbsp; * JAX-B implementation is discovered, call is delegated to appropriate provider&#39;s method {@code createContext(...)}
&nbsp; * passing parameters from the original call.
&nbsp; * &lt;p&gt;
&nbsp; * JAX-B implementation discovery happens each time {@code JAXBContext.newInstance} is invoked. If there is no user
&nbsp; * specific configuration provided, default JAX-B provider must be returned.
&nbsp; * &lt;p&gt;
&nbsp; * Implementation discovery consists of following steps:
&nbsp; *
&nbsp; * &lt;ol&gt;
&nbsp; *
&nbsp; * &lt;li&gt;
&nbsp; * Packages/classes explicitly passed in to the {@link #newInstance} method are processed in the order they are
&nbsp; * specified, until {@code jaxb.properties} file is looked up in its package, by using the associated classloader &amp;mdash;
&nbsp; * this is {@link Class#getClassLoader() the owner class loader} for a {@link Class} argument, and for a package
&nbsp; * the specified {@link ClassLoader}.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * If such a resource is discovered, it is {@link Properties#load(InputStream) loaded} as a property file, and
&nbsp; * the value of the {@link #JAXB_CONTEXT_FACTORY} key will be assumed to be the provider factory class. If no value
&nbsp; * found, {@code &quot;javax.xml.bind.context.factory&quot;} is used as a key for backwards compatibility reasons. This class is
&nbsp; * then loaded by the associated class loader discussed above.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This phase of the look up allows some packages to force the use of a certain JAXB implementation.
&nbsp; * (For example, perhaps the schema compiler has generated some vendor extension in the code.)
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This configuration method is deprecated.
&nbsp; *
&nbsp; * &lt;li&gt;
&nbsp; * If the system property {@link #JAXB_CONTEXT_FACTORY} exists, then its value is assumed to be the provider
&nbsp; * factory class. If no such property exists, properties {@code &quot;javax.xml.bind.context.factory&quot;} and
&nbsp; * {@code &quot;javax.xml.bind.JAXBContext&quot;} are checked too (in this order), for backwards compatibility reasons. This phase
&nbsp; * of the look up enables per-JVM override of the JAXB implementation.
&nbsp; *
&nbsp; * &lt;li&gt;
&nbsp; * Provider of {@link javax.xml.bind.JAXBContextFactory} is loaded using the service-provider loading
&nbsp; * facilities, defined by the {@link java.util.ServiceLoader} class, to attempt
&nbsp; * to locate and load an implementation of the service using the {@linkplain
&nbsp; * java.util.ServiceLoader#load(java.lang.Class) default loading mechanism}: the service-provider loading facility
&nbsp; * will use the {@linkplain java.lang.Thread#getContextClassLoader() current thread&#39;s context class loader}
&nbsp; * to attempt to load the context factory. If the context class loader is null, the
&nbsp; * {@linkplain ClassLoader#getSystemClassLoader() system class loader} will be used.
&nbsp; * &lt;br&gt;
&nbsp; * In case of {@link java.util.ServiceConfigurationError service
&nbsp; * configuration error} a {@link javax.xml.bind.JAXBException} will be thrown.
&nbsp; *
&nbsp; * &lt;li&gt;
&nbsp; * Look for resource {@code /META-INF/services/javax.xml.bind.JAXBContext} using provided class loader.
&nbsp; * Methods without class loader parameter use {@code Thread.currentThread().getContextClassLoader()}.
&nbsp; * If such a resource exists, its content is assumed to be the provider factory class.
&nbsp; *
&nbsp; * This configuration method is deprecated.
&nbsp; *
&nbsp; * &lt;li&gt;
&nbsp; * Finally, if all the steps above fail, then the rest of the look up is unspecified. That said,
&nbsp; * the recommended behavior is to simply look for some hard-coded platform default JAXB implementation.
&nbsp; * This phase of the look up is so that Java SE can have its own JAXB implementation as the last resort.
&nbsp; * &lt;/ol&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Once the provider factory class is discovered, context creation is delegated to one of its
&nbsp; * {@code createContext(...)} methods.
&nbsp; *
&nbsp; * For backward compatibility reasons, there are two ways how to implement provider factory class:
&nbsp; * &lt;ol&gt;
&nbsp; *     &lt;li&gt;the class is implementation of {@link javax.xml.bind.JAXBContextFactory}. It must also implement no-arg
&nbsp; *     constructor. If discovered in other step then 3, new instance using no-arg constructor is created first.
&nbsp; *     After that, appropriate instance method is invoked on this instance.
&nbsp; *     &lt;li&gt;the class is not implementation of interface above and then it is mandated to implement the following
&nbsp; *     static method signatures:
&nbsp; * &lt;pre&gt;
&nbsp; *
&nbsp; * public static JAXBContext createContext(
&nbsp; *                                      String contextPath,
&nbsp; *                                      ClassLoader classLoader,
&nbsp; *                                      Map&amp;lt;String,Object&amp;gt; properties ) throws JAXBException
&nbsp; *
&nbsp; * public static JAXBContext createContext(
&nbsp; *                                      Class[] classes,
&nbsp; *                                      Map&amp;lt;String,Object&amp;gt; properties ) throws JAXBException
&nbsp; * &lt;/pre&gt;
&nbsp; *      In this scenario, appropriate static method is used instead of instance method. This approach is incompatible
&nbsp; *      with {@link java.util.ServiceLoader} so it can&#39;t be used with step 3.
&nbsp; * &lt;/ol&gt;
&nbsp; * &lt;p&gt;
&nbsp; * There is no difference in behavior of given method {@code createContext(...)} regardless of whether it uses approach
&nbsp; * 1 (JAXBContextFactory) or 2 (no interface, static methods).
&nbsp; *
&nbsp; * @apiNote
&nbsp; * Service discovery method using resource {@code /META-INF/services/javax.xml.bind.JAXBContext} (described in step 4)
&nbsp; * is supported only to allow backwards compatibility, it is strongly recommended to migrate to standard
&nbsp; * {@link java.util.ServiceLoader} mechanism (described in step 3). The difference here is the resource name, which
&nbsp; * doesn&#39;t match service&#39;s type name.
&nbsp; * &lt;p&gt;
&nbsp; * Also using providers implementing interface {@link JAXBContextFactory} is preferred over using ones defining
&nbsp; * static methods, same as {@link JAXBContext#JAXB_CONTEXT_FACTORY} property is preferred over property
&nbsp; * {@code &quot;javax.xml.bind.context.factory&quot;}
&nbsp; *
&nbsp; * @implNote
&nbsp; * Within the last step, if Glassfish AS environment detected, its specific service loader is used to find factory class.
&nbsp; *
&nbsp; * @author &lt;ul&gt;&lt;li&gt;Ryan Shoemaker, Sun Microsystems, Inc.&lt;/li&gt;
&nbsp; *             &lt;li&gt;Kohsuke Kawaguchi, Sun Microsystems, Inc.&lt;/li&gt;
&nbsp; *             &lt;li&gt;Joe Fialli, Sun Microsystems, Inc.&lt;/li&gt;&lt;/ul&gt;
&nbsp; *
&nbsp; * @see Marshaller
&nbsp; * @see Unmarshaller
&nbsp; * @see &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-7.html#jls-7.4.1&quot;&gt;S 7.4.1 &quot;Named Packages&quot;
&nbsp; *      in Java Language Specification&lt;/a&gt;
&nbsp; *
&nbsp; * @since 1.6, JAXB 1.0
&nbsp; */
&nbsp;public abstract class JAXBContext {
&nbsp;
&nbsp;    /**
&nbsp;     * The name of the property that contains the name of the class capable
&nbsp;     * of creating new {@code JAXBContext} objects.
&nbsp;     */
&nbsp;    public static final String JAXB_CONTEXT_FACTORY = &quot;javax.xml.bind.JAXBContextFactory&quot;;
&nbsp;
<b class="fc">&nbsp;    protected JAXBContext() {</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Create a new instance of a {@code JAXBContext} class.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This is a convenience method to invoke the
&nbsp;     * {@link #newInstance(String,ClassLoader)} method with
&nbsp;     * the context class loader of the current thread.
&nbsp;     *
&nbsp;     * @throws JAXBException if an error was encountered while creating the
&nbsp;     *                       {@code JAXBContext} such as
&nbsp;     * &lt;ol&gt;
&nbsp;     *   &lt;li&gt;failure to locate either ObjectFactory.class or jaxb.index in the packages&lt;/li&gt;
&nbsp;     *   &lt;li&gt;an ambiguity among global elements contained in the contextPath&lt;/li&gt;
&nbsp;     *   &lt;li&gt;failure to locate a value for the context factory provider property&lt;/li&gt;
&nbsp;     *   &lt;li&gt;mixing schema derived packages from different providers on the same contextPath&lt;/li&gt;
&nbsp;     *   &lt;li&gt;packages are not open to {@code java.xml.bind} module&lt;/li&gt;
&nbsp;     * &lt;/ol&gt;
&nbsp;     */
&nbsp;    public static JAXBContext newInstance( String contextPath )
&nbsp;            throws JAXBException {
&nbsp;
&nbsp;        //return newInstance( contextPath, JAXBContext.class.getClassLoader() );
<b class="nc">&nbsp;        return newInstance( contextPath, getContextClassLoader());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a new instance of a {@code JAXBContext} class.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The client application must supply a context path which is a list of
&nbsp;     * colon (&#39;:&#39;, \u005Cu003A) separated java package names that contain
&nbsp;     * schema-derived classes and/or fully qualified JAXB-annotated classes.
&nbsp;     * Schema-derived
&nbsp;     * code is registered with the JAXBContext by the
&nbsp;     * ObjectFactory.class generated per package.
&nbsp;     * Alternatively than being listed in the context path, programmer
&nbsp;     * annotated JAXB mapped classes can be listed in a
&nbsp;     * {@code jaxb.index} resource file, format described below.
&nbsp;     * Note that a java package can contain both schema-derived classes and
&nbsp;     * user annotated JAXB classes. Additionally, the java package may
&nbsp;     * contain JAXB package annotations  that must be processed. (see JLS,
&nbsp;     * Section 7.4.1 &quot;Named Packages&quot;).
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Every package listed on the contextPath must meet &lt;b&gt;one or both&lt;/b&gt; of the
&nbsp;     * following conditions otherwise a {@code JAXBException} will be thrown:
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;ol&gt;
&nbsp;     *   &lt;li&gt;it must contain ObjectFactory.class&lt;/li&gt;
&nbsp;     *   &lt;li&gt;it must contain jaxb.index&lt;/li&gt;
&nbsp;     * &lt;/ol&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Format for jaxb.index&lt;/b&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * The file contains a newline-separated list of class names.
&nbsp;     * Space and tab characters, as well as blank
&nbsp;     * lines, are ignored. The comment character
&nbsp;     * is &#39;#&#39; (0x23); on each line all characters following the first comment
&nbsp;     * character are ignored. The file must be encoded in UTF-8. Classes that
&nbsp;     * are reachable, as defined in {@link #newInstance(Class...)}, from the
&nbsp;     * listed classes are also registered with JAXBContext.
&nbsp;     * &lt;p&gt;
&nbsp;     * Constraints on class name occuring in a {@code jaxb.index} file are:
&nbsp;     * &lt;ul&gt;
&nbsp;     *   &lt;li&gt;Must not end with &quot;.class&quot;.&lt;/li&gt;
&nbsp;     *   &lt;li&gt;Class names are resolved relative to package containing
&nbsp;     *       {@code jaxb.index} file. Only classes occuring directly in package
&nbsp;     *       containing {@code jaxb.index} file are allowed.&lt;/li&gt;
&nbsp;     *   &lt;li&gt;Fully qualified class names are not allowed.
&nbsp;     *       A qualified class name,relative to current package,
&nbsp;     *       is only allowed to specify a nested or inner class.&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * To maintain compatibility with JAXB 1.0 schema to java
&nbsp;     * interface/implementation binding, enabled by schema customization
&nbsp;     * {@code &lt;jaxb:globalBindings valueClass=&quot;false&quot;&gt;},
&nbsp;     * the JAXB provider will ensure that each package on the context path
&nbsp;     * has a {@code jaxb.properties} file which contains a value for the
&nbsp;     * {@code javax.xml.bind.context.factory} property and that all values
&nbsp;     * resolve to the same provider.  This requirement does not apply to
&nbsp;     * JAXB annotated classes.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * If there are any global XML element name collisions across the various
&nbsp;     * packages listed on the {@code contextPath}, a {@code JAXBException}
&nbsp;     * will be thrown.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Mixing generated interface/impl bindings from multiple JAXB Providers
&nbsp;     * in the same context path may result in a {@code JAXBException}
&nbsp;     * being thrown.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The steps involved in discovering the JAXB implementation is discussed in the class javadoc.
&nbsp;     *
&nbsp;     * @param contextPath
&nbsp;     *      List of java package names that contain schema
&nbsp;     *      derived class and/or java to schema (JAXB-annotated)
&nbsp;     *      mapped classes.
&nbsp;     *      Packages in {@code contextPath} that are in named modules must be
&nbsp;     *      {@linkplain java.lang.Module#isOpen open} to at least the {@code java.xml.bind} module.
&nbsp;     * @param classLoader
&nbsp;     *      This class loader will be used to locate the implementation
&nbsp;     *      classes.
&nbsp;     *
&nbsp;     * @return a new instance of a {@code JAXBContext}
&nbsp;     * @throws JAXBException if an error was encountered while creating the
&nbsp;     *                       {@code JAXBContext} such as
&nbsp;     * &lt;ol&gt;
&nbsp;     *   &lt;li&gt;failure to locate either ObjectFactory.class or jaxb.index in the packages&lt;/li&gt;
&nbsp;     *   &lt;li&gt;an ambiguity among global elements contained in the contextPath&lt;/li&gt;
&nbsp;     *   &lt;li&gt;failure to locate a value for the context factory provider property&lt;/li&gt;
&nbsp;     *   &lt;li&gt;mixing schema derived packages from different providers on the same contextPath&lt;/li&gt;
&nbsp;     *   &lt;li&gt;packages are not open to {@code java.xml.bind} module&lt;/li&gt;
&nbsp;     * &lt;/ol&gt;
&nbsp;     */
&nbsp;    public static JAXBContext newInstance( String contextPath, ClassLoader classLoader ) throws JAXBException {
&nbsp;
<b class="nc">&nbsp;        return newInstance(contextPath,classLoader,Collections.&lt;String,Object&gt;emptyMap());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a new instance of a {@code JAXBContext} class.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This is mostly the same as {@link JAXBContext#newInstance(String, ClassLoader)},
&nbsp;     * but this version allows you to pass in provider-specific properties to configure
&nbsp;     * the instantiation of {@link JAXBContext}.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The interpretation of properties is up to implementations. Implementations must
&nbsp;     * throw {@code JAXBException} if it finds properties that it doesn&#39;t understand.
&nbsp;     *
&nbsp;     * @param contextPath
&nbsp;     *      List of java package names that contain schema
&nbsp;     *      derived class and/or java to schema (JAXB-annotated)
&nbsp;     *      mapped classes.
&nbsp;     *      Packages in {@code contextPath} that are in named modules must be
&nbsp;     *      {@linkplain java.lang.Module#isOpen open} to at least the {@code java.xml.bind} module.
&nbsp;     * @param classLoader
&nbsp;     *      This class loader will be used to locate the implementation classes.
&nbsp;     * @param properties
&nbsp;     *      provider-specific properties. Can be null, which means the same thing as passing
&nbsp;     *      in an empty map.
&nbsp;     *
&nbsp;     * @return a new instance of a {@code JAXBContext}
&nbsp;     * @throws JAXBException if an error was encountered while creating the
&nbsp;     *                       {@code JAXBContext} such as
&nbsp;     * &lt;ol&gt;
&nbsp;     *   &lt;li&gt;failure to locate either ObjectFactory.class or jaxb.index in the packages&lt;/li&gt;
&nbsp;     *   &lt;li&gt;an ambiguity among global elements contained in the contextPath&lt;/li&gt;
&nbsp;     *   &lt;li&gt;failure to locate a value for the context factory provider property&lt;/li&gt;
&nbsp;     *   &lt;li&gt;mixing schema derived packages from different providers on the same contextPath&lt;/li&gt;
&nbsp;     *   &lt;li&gt;packages are not open to {@code java.xml.bind} module&lt;/li&gt;
&nbsp;     * &lt;/ol&gt;
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public static JAXBContext newInstance( String contextPath,
&nbsp;                                           ClassLoader classLoader,
&nbsp;                                           Map&lt;String,?&gt;  properties  ) throws JAXBException {
&nbsp;
<b class="nc">&nbsp;        return ContextFinder.find(</b>
&nbsp;                        /* The default property name according to the JAXB spec */
&nbsp;                JAXB_CONTEXT_FACTORY,
&nbsp;
&nbsp;                        /* the context path supplied by the client app */
&nbsp;                contextPath,
&nbsp;
&nbsp;                        /* class loader to be used */
&nbsp;                classLoader,
&nbsp;                properties );
&nbsp;    }
&nbsp;
&nbsp;// TODO: resurrect this once we introduce external annotations
&nbsp;//    /**
&nbsp;//     * Create a new instance of a {@code JAXBContext} class.
&nbsp;//     *
&nbsp;//     * &lt;p&gt;
&nbsp;//     * The client application must supply a list of classes that the new
&nbsp;//     * context object needs to recognize.
&nbsp;//     *
&nbsp;//     * Not only the new context will recognize all the classes specified,
&nbsp;//     * but it will also recognize any classes that are directly/indirectly
&nbsp;//     * referenced statically from the specified classes.
&nbsp;//     *
&nbsp;//     * For example, in the following Java code, if you do
&nbsp;//     * {@code newInstance(Foo.class)}, the newly created {@link JAXBContext}
&nbsp;//     * will recognize both {@code Foo} and {@code Bar}, but not {@code Zot}:
&nbsp;//     * &lt;pre&gt;
&nbsp;//     * class Foo {
&nbsp;//     *      Bar b;
&nbsp;//     * }
&nbsp;//     * class Bar { int x; }
&nbsp;//     * class Zot extends Bar { int y; }
&nbsp;//     * &lt;/pre&gt;
&nbsp;//     *
&nbsp;//     * Therefore, a typical client application only needs to specify the
&nbsp;//     * top-level classes, but it needs to be careful.
&nbsp;//     *
&nbsp;//     * TODO: if we are to define other mechanisms, refer to them.
&nbsp;//     *
&nbsp;//     * @param externalBindings
&nbsp;//     *      list of external binding files. Can be null or empty if none is used.
&nbsp;//     *      when specified, those files determine how the classes are bound.
&nbsp;//     *
&nbsp;//     * @param classesToBeBound
&nbsp;//     *      list of java classes to be recognized by the new {@link JAXBContext}.
&nbsp;//     *      Can be empty, in which case a {@link JAXBContext} that only knows about
&nbsp;//     *      spec-defined classes will be returned.
&nbsp;//     *
&nbsp;//     * @return
&nbsp;//     *      A new instance of a {@code JAXBContext}.
&nbsp;//     *
&nbsp;//     * @throws JAXBException
&nbsp;//     *      if an error was encountered while creating the
&nbsp;//     *      {@code JAXBContext}, such as (but not limited to):
&nbsp;//     * &lt;ol&gt;
&nbsp;//     *  &lt;li&gt;No JAXB implementation was discovered
&nbsp;//     *  &lt;li&gt;Classes use JAXB annotations incorrectly
&nbsp;//     *  &lt;li&gt;Classes have colliding annotations (i.e., two classes with the same type name)
&nbsp;//     *  &lt;li&gt;Specified external bindings are incorrect
&nbsp;//     *  &lt;li&gt;The JAXB implementation was unable to locate
&nbsp;//     *      provider-specific out-of-band information (such as additional
&nbsp;//     *      files generated at the development time.)
&nbsp;//     * &lt;/ol&gt;
&nbsp;//     *
&nbsp;//     * @throws IllegalArgumentException
&nbsp;//     *      if the parameter contains {@code null} (i.e., {@code newInstance(null);})
&nbsp;//     *
&nbsp;//     * @since JAXB 2.0
&nbsp;//     */
&nbsp;//    public static JAXBContext newInstance( Source[] externalBindings, Class... classesToBeBound )
&nbsp;//        throws JAXBException {
&nbsp;//
&nbsp;//        // empty class list is not an error, because the context will still include
&nbsp;//        // spec-specified classes like String and Integer.
&nbsp;//        // if(classesToBeBound.length==0)
&nbsp;//        //    throw new IllegalArgumentException();
&nbsp;//
&nbsp;//        // but it is an error to have nulls in it.
&nbsp;//        for( int i=classesToBeBound.length-1; i&gt;=0; i-- )
&nbsp;//            if(classesToBeBound[i]==null)
&nbsp;//                throw new IllegalArgumentException();
&nbsp;//
&nbsp;//        return ContextFinder.find(externalBindings,classesToBeBound);
&nbsp;//    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a new instance of a {@code JAXBContext} class.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The client application must supply a list of classes that the new
&nbsp;     * context object needs to recognize.
&nbsp;     *
&nbsp;     * Not only the new context will recognize all the classes specified,
&nbsp;     * but it will also recognize any classes that are directly/indirectly
&nbsp;     * referenced statically from the specified classes. Subclasses of
&nbsp;     * referenced classes nor {@code @XmlTransient} referenced classes
&nbsp;     * are not registered with JAXBContext.
&nbsp;     *
&nbsp;     * For example, in the following Java code, if you do
&nbsp;     * {@code newInstance(Foo.class)}, the newly created {@link JAXBContext}
&nbsp;     * will recognize both {@code Foo} and {@code Bar}, but not {@code Zot} or {@code FooBar}:
&nbsp;     * &lt;pre&gt;
&nbsp;     * class Foo {
&nbsp;     *      &amp;#64;XmlTransient FooBar c;
&nbsp;     *      Bar b;
&nbsp;     * }
&nbsp;     * class Bar { int x; }
&nbsp;     * class Zot extends Bar { int y; }
&nbsp;     * class FooBar { }
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * Therefore, a typical client application only needs to specify the
&nbsp;     * top-level classes, but it needs to be careful.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Note that for each java package registered with JAXBContext,
&nbsp;     * when the optional package annotations exist, they must be processed.
&nbsp;     * (see JLS, Section 7.4.1 &quot;Named Packages&quot;).
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The steps involved in discovering the JAXB implementation is discussed in the class javadoc.
&nbsp;     *
&nbsp;     * @param classesToBeBound
&nbsp;     *      List of java classes to be recognized by the new {@link JAXBContext}.
&nbsp;     *      Classes in {@code classesToBeBound} that are in named modules must be in a package
&nbsp;     *      that is {@linkplain java.lang.Module#isOpen open} to at least the {@code java.xml.bind} module.
&nbsp;     *      Can be empty, in which case a {@link JAXBContext} that only knows about
&nbsp;     *      spec-defined classes will be returned.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      A new instance of a {@code JAXBContext}.
&nbsp;     *
&nbsp;     * @throws JAXBException
&nbsp;     *      if an error was encountered while creating the
&nbsp;     *      {@code JAXBContext}, such as (but not limited to):
&nbsp;     * &lt;ol&gt;
&nbsp;     *  &lt;li&gt;No JAXB implementation was discovered
&nbsp;     *  &lt;li&gt;Classes use JAXB annotations incorrectly
&nbsp;     *  &lt;li&gt;Classes have colliding annotations (i.e., two classes with the same type name)
&nbsp;     *  &lt;li&gt;The JAXB implementation was unable to locate
&nbsp;     *      provider-specific out-of-band information (such as additional
&nbsp;     *      files generated at the development time.)
&nbsp;     *  &lt;li&gt;{@code classesToBeBound} are not open to {@code java.xml.bind} module
&nbsp;     * &lt;/ol&gt;
&nbsp;     *
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      if the parameter contains {@code null} (i.e., {@code newInstance(null);})
&nbsp;     *
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public static JAXBContext newInstance( Class&lt;?&gt; ... classesToBeBound )
&nbsp;            throws JAXBException {
&nbsp;
<b class="fc">&nbsp;        return newInstance(classesToBeBound,Collections.&lt;String,Object&gt;emptyMap());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a new instance of a {@code JAXBContext} class.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * An overloading of {@link JAXBContext#newInstance(Class...)}
&nbsp;     * to configure &#39;properties&#39; for this instantiation of {@link JAXBContext}.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The interpretation of properties is up to implementations. Implementations must
&nbsp;     * throw {@code JAXBException} if it finds properties that it doesn&#39;t understand.
&nbsp;     *
&nbsp;     * @param classesToBeBound
&nbsp;     *      List of java classes to be recognized by the new {@link JAXBContext}.
&nbsp;     *      Classes in {@code classesToBeBound} that are in named modules must be in a package
&nbsp;     *      that is {@linkplain java.lang.Module#isOpen open} to at least the {@code java.xml.bind} module.
&nbsp;     *      Can be empty, in which case a {@link JAXBContext} that only knows about
&nbsp;     *      spec-defined classes will be returned.
&nbsp;     * @param properties
&nbsp;     *      provider-specific properties. Can be null, which means the same thing as passing
&nbsp;     *      in an empty map.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      A new instance of a {@code JAXBContext}.
&nbsp;     *
&nbsp;     * @throws JAXBException
&nbsp;     *      if an error was encountered while creating the
&nbsp;     *      {@code JAXBContext}, such as (but not limited to):
&nbsp;     * &lt;ol&gt;
&nbsp;     *  &lt;li&gt;No JAXB implementation was discovered
&nbsp;     *  &lt;li&gt;Classes use JAXB annotations incorrectly
&nbsp;     *  &lt;li&gt;Classes have colliding annotations (i.e., two classes with the same type name)
&nbsp;     *  &lt;li&gt;The JAXB implementation was unable to locate
&nbsp;     *      provider-specific out-of-band information (such as additional
&nbsp;     *      files generated at the development time.)
&nbsp;     *  &lt;li&gt;{@code classesToBeBound} are not open to {@code java.xml.bind} module
&nbsp;     * &lt;/ol&gt;
&nbsp;     *
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      if the parameter contains {@code null} (i.e., {@code newInstance(null,someMap);})
&nbsp;     *
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public static JAXBContext newInstance( Class&lt;?&gt;[] classesToBeBound, Map&lt;String,?&gt; properties )
&nbsp;            throws JAXBException {
&nbsp;
<b class="pc">&nbsp;        if (classesToBeBound == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException();</b>
&nbsp;        }
&nbsp;
&nbsp;        // but it is an error to have nulls in it.
<b class="fc">&nbsp;        for (int i = classesToBeBound.length - 1; i &gt;= 0; i--) {</b>
<b class="pc">&nbsp;            if (classesToBeBound[i] == null) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return ContextFinder.find(classesToBeBound,properties);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create an {@code Unmarshaller} object that can be used to convert XML
&nbsp;     * data into a java content tree.
&nbsp;     *
&nbsp;     * @return an {@code Unmarshaller} object
&nbsp;     *
&nbsp;     * @throws JAXBException if an error was encountered while creating the
&nbsp;     *                       {@code Unmarshaller} object
&nbsp;     */
&nbsp;    public abstract Unmarshaller createUnmarshaller() throws JAXBException;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Create a {@code Marshaller} object that can be used to convert a
&nbsp;     * java content tree into XML data.
&nbsp;     *
&nbsp;     * @return a {@code Marshaller} object
&nbsp;     *
&nbsp;     * @throws JAXBException if an error was encountered while creating the
&nbsp;     *                       {@code Marshaller} object
&nbsp;     */
&nbsp;    public abstract Marshaller createMarshaller() throws JAXBException;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * {@link Validator} has been made optional and deprecated in JAXB 2.0.  Please
&nbsp;     * refer to the javadoc for {@link Validator} for more detail.
&nbsp;     * &lt;p&gt;
&nbsp;     * Create a {@code Validator} object that can be used to validate a
&nbsp;     * java content tree against its source schema.
&nbsp;     *
&nbsp;     * @return a {@code Validator} object
&nbsp;     *
&nbsp;     * @throws JAXBException if an error was encountered while creating the
&nbsp;     *                       {@code Validator} object
&nbsp;     * @deprecated since JAXB2.0
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public abstract Validator createValidator() throws JAXBException;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@code Binder} object that can be used for
&nbsp;     * associative/in-place unmarshalling/marshalling.
&nbsp;     *
&nbsp;     * @param domType select the DOM API to use by passing in its DOM Node class.
&nbsp;     *
&nbsp;     * @return always a new valid {@code Binder} object.
&nbsp;     *
&nbsp;     * @throws UnsupportedOperationException
&nbsp;     *      if DOM API corresponding to {@code domType} is not supported by
&nbsp;     *      the implementation.
&nbsp;     *
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public &lt;T&gt; Binder&lt;T&gt; createBinder(Class&lt;T&gt; domType) {
&nbsp;        // to make JAXB 1.0 implementations work, this method must not be
&nbsp;        // abstract
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@code Binder} for W3C DOM.
&nbsp;     *
&nbsp;     * @return always a new valid {@code Binder} object.
&nbsp;     *
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public Binder&lt;Node&gt; createBinder() {
<b class="nc">&nbsp;        return createBinder(Node.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@code JAXBIntrospector} object that can be used to
&nbsp;     * introspect JAXB objects.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      always return a non-null valid {@code JAXBIntrospector} object.
&nbsp;     *
&nbsp;     * @throws UnsupportedOperationException
&nbsp;     *      Calling this method on JAXB 1.0 implementations will throw
&nbsp;     *      an UnsupportedOperationException.
&nbsp;     *
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public JAXBIntrospector createJAXBIntrospector() {
&nbsp;        // to make JAXB 1.0 implementations work, this method must not be
&nbsp;        // abstract
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generates the schema documents for this context.
&nbsp;     *
&nbsp;     * @param outputResolver
&nbsp;     *      this object controls the output to which schemas
&nbsp;     *      will be sent.
&nbsp;     *
&nbsp;     * @throws IOException
&nbsp;     *      if {@link SchemaOutputResolver} throws an {@link IOException}.
&nbsp;     *
&nbsp;     * @throws UnsupportedOperationException
&nbsp;     *      Calling this method on JAXB 1.0 implementations will throw
&nbsp;     *      an UnsupportedOperationException.
&nbsp;     *
&nbsp;     * @since 1.6, JAXB 2.0
&nbsp;     */
&nbsp;    public void generateSchema(SchemaOutputResolver outputResolver) throws IOException  {
&nbsp;        // to make JAXB 1.0 implementations work, this method must not be
&nbsp;        // abstract
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static ClassLoader getContextClassLoader() {
<b class="nc">&nbsp;        if (System.getSecurityManager() == null) {</b>
<b class="nc">&nbsp;            return Thread.currentThread().getContextClassLoader();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return java.security.AccessController.doPrivileged(</b>
&nbsp;                    new java.security.PrivilegedAction&lt;ClassLoader&gt;() {
&nbsp;                        public ClassLoader run() {
&nbsp;                            return Thread.currentThread().getContextClassLoader();
&nbsp;                        }
&nbsp;                    });
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
