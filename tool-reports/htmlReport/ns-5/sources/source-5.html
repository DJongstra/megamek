


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > XmlType</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">javax.xml.bind.annotation</a>
</div>

<h1>Coverage Summary for Class: XmlType (javax.xml.bind.annotation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">XmlType$DEFAULT</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (c) 2004, 2018 Oracle and/or its affiliates. All rights reserved.
&nbsp; *
&nbsp; * This program and the accompanying materials are made available under the
&nbsp; * terms of the Eclipse Distribution License v. 1.0, which is available at
&nbsp; * http://www.eclipse.org/org/documents/edl-v10.php.
&nbsp; *
&nbsp; * SPDX-License-Identifier: BSD-3-Clause
&nbsp; */
&nbsp;
&nbsp;package javax.xml.bind.annotation;
&nbsp;
&nbsp;import static java.lang.annotation.ElementType.TYPE;
&nbsp;import java.lang.annotation.Retention;
&nbsp;import static java.lang.annotation.RetentionPolicy.RUNTIME;
&nbsp;import java.lang.annotation.Target;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * Maps a class or an enum type to a XML Schema type.
&nbsp; *
&nbsp; * &lt;p&gt;&lt;b&gt;Usage&lt;/b&gt;&lt;/p&gt;
&nbsp; * &lt;p&gt; The {@code @XmlType} annnotation can be used with the following program
&nbsp; * elements:
&nbsp; * &lt;ul&gt;
&nbsp; *   &lt;li&gt; a top level class &lt;/li&gt;
&nbsp; *   &lt;li&gt; an enum type &lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;p&gt;See &quot;Package Specification&quot; in javax.xml.bind.package javadoc for
&nbsp; * additional common information.&lt;/p&gt;
&nbsp; *
&nbsp; * &lt;h3&gt; Mapping a Class &lt;/h3&gt; 
&nbsp; * &lt;p&gt;
&nbsp; * A class maps to a XML Schema type. A class is a data container for
&nbsp; * values represented by properties and fields. A schema type is a
&nbsp; * data container for values represented by schema components within a
&nbsp; * schema type&#39;s content model (e.g. model groups, attributes etc).
&nbsp; * &lt;p&gt; To be mapped, a class must either have a public no-arg
&nbsp; * constructor or a static no-arg factory method. The static factory
&nbsp; * method can be specified in {@code factoryMethod()} and
&nbsp; * {@code factoryClass()} annotation elements. The static factory
&nbsp; * method or the no-arg constructor is used during unmarshalling to
&nbsp; * create an instance of this class. If both are present, the static
&nbsp; * factory method overrides the no-arg constructor.
&nbsp; * &lt;p&gt;
&nbsp; * A class maps to either a XML Schema complex type or a XML Schema simple
&nbsp; * type. The XML Schema type is derived based on the 
&nbsp; * mapping of JavaBean properties and fields contained within the
&nbsp; * class. The schema type to which the class is mapped can either be
&nbsp; * named or anonymous. A class can be mapped to an anonymous schema
&nbsp; * type by annotating the class with {@code @XmlType(name=&quot;&quot;)}.
&nbsp; * &lt;p&gt;
&nbsp; * Either a global element, local element or a local attribute can be
&nbsp; * associated with an anonymous type as follows:
&nbsp; * &lt;ul&gt;
&nbsp; *   &lt;li&gt;&lt;b&gt;global element: &lt;/b&gt; A global element of an anonymous
&nbsp; *      type can be derived by annotating the class with @{@link
&nbsp; *      XmlRootElement}. See Example 3 below. &lt;/li&gt; 
&nbsp; *
&nbsp; *   &lt;li&gt;&lt;b&gt;local element: &lt;/b&gt; A JavaBean property that references
&nbsp; *      a class annotated with @XmlType(name=&quot;&quot;) and is mapped to the
&nbsp; *      element associated with the anonymous type. See Example 4
&nbsp; *      below.&lt;/li&gt; 
&nbsp; *
&nbsp; *   &lt;li&gt;&lt;b&gt;attribute: &lt;/b&gt; A JavaBean property that references
&nbsp; *      a class annotated with @XmlType(name=&quot;&quot;) and is mapped to the
&nbsp; *      attribute associated with the anonymous type. See Example 5 below. &lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * &lt;b&gt; Mapping to XML Schema Complex Type &lt;/b&gt;
&nbsp; * &lt;ul&gt;
&nbsp; *   &lt;li&gt;If class is annotated with {@code @XmlType(name=&quot;&quot;) }, it
&nbsp; *   is mapped to an anonymous type otherwise, the class name maps
&nbsp; *   to a complex type name. The {@code XmlName()} annotation element
&nbsp; *   can be used to customize the name.&lt;/li&gt;  
&nbsp; *
&nbsp; *   &lt;li&gt; Properties and fields that are mapped to elements are mapped to a
&nbsp; *   content model within a complex type. The annotation element
&nbsp; *   {@code propOrder()} can be used to customize the content model to be
&nbsp; *   {@code xs:all} or {@code xs:sequence}.  It is used for specifying
&nbsp; *   the order of XML elements in {@code xs:sequence}. &lt;/li&gt;
&nbsp; *
&nbsp; *   &lt;li&gt; Properties and fields can be mapped to attributes within the
&nbsp; *        complex type.  &lt;/li&gt;
&nbsp; *
&nbsp; *   &lt;li&gt; The targetnamespace of the XML Schema type can be customized
&nbsp; *        using the annotation element {@code namespace()}. &lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt; Mapping class to XML Schema simple type &lt;/b&gt;
&nbsp; * &lt;p&gt;
&nbsp; * A class can be mapped to a XML Schema simple type using the
&nbsp; * {@code @XmlValue} annotation. For additional details and examples,
&nbsp; * see @{@link XmlValue} annotation type.
&nbsp; * &lt;p&gt;
&nbsp; * The following table shows the mapping of the class to a XML Schema
&nbsp; * complex type or simple type. The notational symbols used in the table are:
&nbsp; * &lt;ul&gt;
&nbsp; *   &lt;li&gt; {@literal -&gt;}    : represents a mapping &lt;/li&gt;
&nbsp; *   &lt;li&gt; [x]+  : one or more occurrences of x &lt;/li&gt;
&nbsp; *   &lt;li&gt; [ {@code @XmlValue} property ]: JavaBean property annotated with
&nbsp; *         {@code @XmlValue}&lt;/li&gt;
&nbsp; *   &lt;li&gt; X     : don&#39;t care
&nbsp; * &lt;/ul&gt;
&nbsp; * &lt;blockquote&gt;
&nbsp; *   &lt;table class=&quot;striped&quot; summary=&quot;Mapping class to XML Schema simple type&quot;&gt;
&nbsp; *     &lt;thead&gt;
&nbsp; *       &lt;tr&gt;
&nbsp; *         &lt;th scope=&quot;col&quot;&gt;Target&lt;/th&gt;
&nbsp; *         &lt;th scope=&quot;col&quot;&gt;propOrder&lt;/th&gt;
&nbsp; *         &lt;th scope=&quot;col&quot;&gt;ClassBody&lt;/th&gt;
&nbsp; *         &lt;th scope=&quot;col&quot;&gt;ComplexType&lt;/th&gt;
&nbsp; *         &lt;th scope=&quot;col&quot;&gt;SimpleType&lt;/th&gt;
&nbsp; *       &lt;/tr&gt;
&nbsp; *     &lt;/thead&gt;
&nbsp; * 
&nbsp; *     &lt;tbody&gt;
&nbsp; *       &lt;tr&gt;
&nbsp; *         &lt;td&gt;Class&lt;/td&gt;
&nbsp; *         &lt;td&gt;{}&lt;/td&gt;
&nbsp; *         &lt;th scope=&quot;row&quot;&gt;[property]+ {@literal -&gt;} elements&lt;/th&gt;
&nbsp; *         &lt;td&gt;complexcontent&lt;br&gt;xs:all&lt;/td&gt;
&nbsp; *         &lt;td&gt; &lt;/td&gt;
&nbsp; *       &lt;/tr&gt;
&nbsp; * 
&nbsp; *       &lt;tr&gt;
&nbsp; *         &lt;td&gt;Class&lt;/td&gt;
&nbsp; *         &lt;td&gt;non empty&lt;/td&gt;
&nbsp; *         &lt;th scope=&quot;row&quot;&gt;[property]+ {@literal -&gt;} elements&lt;/th&gt;
&nbsp; *         &lt;td&gt;complexcontent&lt;br&gt;xs:sequence&lt;/td&gt;
&nbsp; *         &lt;td&gt; &lt;/td&gt;
&nbsp; *       &lt;/tr&gt;
&nbsp; * 
&nbsp; *       &lt;tr&gt;
&nbsp; *         &lt;td&gt;Class&lt;/td&gt;
&nbsp; *         &lt;td&gt;X&lt;/td&gt;
&nbsp; *         &lt;th scope=&quot;row&quot;&gt;no property {@literal -&gt;} element&lt;/th&gt;
&nbsp; *         &lt;td&gt;complexcontent&lt;br&gt;empty sequence&lt;/td&gt;
&nbsp; *         &lt;td&gt; &lt;/td&gt;
&nbsp; *       &lt;/tr&gt;
&nbsp; * 
&nbsp; *       &lt;tr&gt;
&nbsp; *         &lt;td&gt;Class&lt;/td&gt;
&nbsp; *         &lt;td&gt;X&lt;/td&gt;
&nbsp; *         &lt;th scope=&quot;row&quot;&gt;1 [{@code @XmlValue} property] {@literal &amp;&amp;} &lt;br&gt; [property]+ {@literal -&gt;} attributes&lt;/th&gt;
&nbsp; *         &lt;td&gt;simplecontent&lt;/td&gt;
&nbsp; *         &lt;td&gt; &lt;/td&gt;
&nbsp; *       &lt;/tr&gt;
&nbsp; * 
&nbsp; *       &lt;tr&gt;
&nbsp; *         &lt;td&gt;Class&lt;/td&gt;
&nbsp; *         &lt;td&gt;X&lt;/td&gt;
&nbsp; *         &lt;th scope=&quot;row&quot;&gt;1 [{@code @XmlValue} property] {@literal &amp;&amp;} &lt;br&gt; no properties {@literal -&gt;} attribute&lt;/th&gt;
&nbsp; *         &lt;td&gt; &lt;/td&gt;
&nbsp; *         &lt;td&gt;simpletype&lt;/td&gt;
&nbsp; *       &lt;/tr&gt;
&nbsp; *     &lt;/tbody&gt;
&nbsp; *   &lt;/table&gt;
&nbsp; * &lt;/blockquote&gt;
&nbsp; * 
&nbsp; * &lt;h3&gt; Mapping an enum type &lt;/h3&gt;
&nbsp; * 
&nbsp; * An enum type maps to a XML schema simple type with enumeration
&nbsp; * facets. The following annotation elements are ignored since they
&nbsp; * are not meaningful: {@code propOrder()} , {@code factoryMethod()} ,
&nbsp; * {@code factoryClass()} .
&nbsp; *
&nbsp; *  &lt;h3&gt; Usage with other annotations &lt;/h3&gt;
&nbsp; * &lt;p&gt; This annotation can be used with the following annotations: 
&nbsp; * {@link XmlRootElement}, {@link XmlAccessorOrder}, {@link XmlAccessorType},
&nbsp; * {@link XmlEnum}. However, {@link
&nbsp; * XmlAccessorOrder} and {@link XmlAccessorType} are ignored when this
&nbsp; * annotation is used on an enum type.
&nbsp; * 
&nbsp; * &lt;p&gt; &lt;b&gt; Example 1: &lt;/b&gt; Map a class to a complex type with
&nbsp; *   xs:sequence with a customized ordering of JavaBean properties. 
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * &lt;pre&gt;
&nbsp; *   &amp;#64;XmlType(propOrder={&quot;street&quot;, &quot;city&quot; , &quot;state&quot;, &quot;zip&quot;, &quot;name&quot; })
&nbsp; *   public class USAddress {
&nbsp; *     String getName() {..};
&nbsp; *     void setName(String) {..};
&nbsp; * 
&nbsp; *     String getStreet() {..};
&nbsp; *     void setStreet(String) {..};
&nbsp; *
&nbsp; *     String getCity() {..}; 
&nbsp; *     void setCity(String) {..};
&nbsp; * 
&nbsp; *     String getState() {..};
&nbsp; *     void setState(String) {..};
&nbsp; *
&nbsp; *     java.math.BigDecimal getZip() {..};
&nbsp; *     void setZip(java.math.BigDecimal) {..};
&nbsp; *   }
&nbsp; * {@code
&nbsp; * 
&nbsp; *   &lt;!-- XML Schema mapping for USAddress --&gt;
&nbsp; *   &lt;xs:complexType name=&quot;USAddress&quot;&gt;
&nbsp; *     &lt;xs:sequence&gt;
&nbsp; *       &lt;xs:element name=&quot;street&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *       &lt;xs:element name=&quot;city&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *       &lt;xs:element name=&quot;state&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *       &lt;xs:element name=&quot;zip&quot; type=&quot;xs:decimal&quot;/&gt;
&nbsp; *       &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *     &lt;/xs:all&gt;
&nbsp; *   &lt;/xs:complexType&gt;
&nbsp; * }&lt;/pre&gt;
&nbsp; * &lt;p&gt; &lt;b&gt; Example 2: &lt;/b&gt; Map a class to a complex type with
&nbsp; *     xs:all &lt;/p&gt;
&nbsp; * &lt;pre&gt;
&nbsp; * &amp;#64;XmlType(propOrder={})
&nbsp; * public class USAddress { ...}
&nbsp; * {@code
&nbsp; * 
&nbsp; * &lt;!-- XML Schema mapping for USAddress --&gt;
&nbsp; * &lt;xs:complexType name=&quot;USAddress&quot;&gt;
&nbsp; *   &lt;xs:all&gt;
&nbsp; *     &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *     &lt;xs:element name=&quot;street&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *     &lt;xs:element name=&quot;city&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *     &lt;xs:element name=&quot;state&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *     &lt;xs:element name=&quot;zip&quot; type=&quot;xs:decimal&quot;/&gt;
&nbsp; *   &lt;/xs:sequence&gt;
&nbsp; * &lt;/xs:complexType&gt;
&nbsp; *}&lt;/pre&gt;
&nbsp; * &lt;p&gt; &lt;b&gt; Example 3: &lt;/b&gt; Map a class to a global element with an
&nbsp; * anonymous type. 
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;pre&gt;
&nbsp; *   &amp;#64;XmlRootElement
&nbsp; *   &amp;#64;XmlType(name=&quot;&quot;)
&nbsp; *   public class USAddress { ...}
&nbsp; * {@code
&nbsp; * 
&nbsp; *   &lt;!-- XML Schema mapping for USAddress --&gt;
&nbsp; *   &lt;xs:element name=&quot;USAddress&quot;&gt;
&nbsp; *     &lt;xs:complexType&gt;
&nbsp; *       &lt;xs:sequence&gt;
&nbsp; *         &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *         &lt;xs:element name=&quot;street&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *         &lt;xs:element name=&quot;city&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *         &lt;xs:element name=&quot;state&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *         &lt;xs:element name=&quot;zip&quot; type=&quot;xs:decimal&quot;/&gt;
&nbsp; *       &lt;/xs:sequence&gt;
&nbsp; *     &lt;/xs:complexType&gt;
&nbsp; *   &lt;/xs:element&gt;
&nbsp; * }&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt; &lt;b&gt; Example 4: &lt;/b&gt; Map a property to a local element with
&nbsp; * anonymous type.
&nbsp; * &lt;pre&gt;
&nbsp; *   //Example: Code fragment
&nbsp; *   public class Invoice {
&nbsp; *       USAddress addr;
&nbsp; *           ...
&nbsp; *       }
&nbsp; *
&nbsp; *   &amp;#64;XmlType(name=&quot;&quot;)
&nbsp; *   public class USAddress { ... }
&nbsp; *   } 
&nbsp; * {@code
&nbsp; * 
&nbsp; *   &lt;!-- XML Schema mapping for USAddress --&gt;
&nbsp; *   &lt;xs:complexType name=&quot;Invoice&quot;&gt;
&nbsp; *     &lt;xs:sequence&gt;
&nbsp; *       &lt;xs:element name=&quot;addr&quot;&gt;
&nbsp; *         &lt;xs:complexType&gt;
&nbsp; *           &lt;xs:element name=&quot;name&quot;, type=&quot;xs:string&quot;/&gt;
&nbsp; *           &lt;xs:element name=&quot;city&quot;, type=&quot;xs:string&quot;/&gt;
&nbsp; *           &lt;xs:element name=&quot;city&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *           &lt;xs:element name=&quot;state&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *           &lt;xs:element name=&quot;zip&quot; type=&quot;xs:decimal&quot;/&gt;
&nbsp; *         &lt;/xs:complexType&gt;
&nbsp; *       ...
&nbsp; *     &lt;/xs:sequence&gt;
&nbsp; *   &lt;/xs:complexType&gt;
&nbsp; * }&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt; &lt;b&gt; Example 5: &lt;/b&gt; Map a property to an attribute with
&nbsp; * anonymous type.
&nbsp; * 
&nbsp; * &lt;pre&gt;
&nbsp; *
&nbsp; *     //Example: Code fragment
&nbsp; *     public class Item {
&nbsp; *         public String name;
&nbsp; *         &amp;#64;XmlAttribute 
&nbsp; *         public USPrice price;
&nbsp; *     }
&nbsp; *    
&nbsp; *     // map class to anonymous simple type. 
&nbsp; *     &amp;#64;XmlType(name=&quot;&quot;)
&nbsp; *     public class USPrice { 
&nbsp; *         &amp;#64;XmlValue
&nbsp; *         public java.math.BigDecimal price;
&nbsp; *     }
&nbsp; * {@code
&nbsp; * 
&nbsp; *     &lt;!-- Example: XML Schema fragment --&gt;
&nbsp; *     &lt;xs:complexType name=&quot;Item&quot;&gt;
&nbsp; *       &lt;xs:sequence&gt;
&nbsp; *         &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;
&nbsp; *         &lt;xs:attribute name=&quot;price&quot;&gt;
&nbsp; *           &lt;xs:simpleType&gt;
&nbsp; *             &lt;xs:restriction base=&quot;xs:decimal&quot;/&gt;
&nbsp; *           &lt;/xs:simpleType&gt;
&nbsp; *         &lt;/xs:attribute&gt;
&nbsp; *       &lt;/xs:sequence&gt;
&nbsp; *     &lt;/xs:complexType&gt;
&nbsp; * }&lt;/pre&gt;
&nbsp; *
&nbsp; *  &lt;p&gt; &lt;b&gt; Example 6: &lt;/b&gt; Define a factoryClass and factoryMethod
&nbsp; *
&nbsp; * &lt;pre&gt; 
&nbsp; *      &amp;#64;XmlType(name=&quot;USAddressType&quot;, factoryClass=USAddressFactory.class,
&nbsp; *      factoryMethod=&quot;getUSAddress&quot;)
&nbsp; *      public class USAddress {
&nbsp; *
&nbsp; *          private String city;
&nbsp; *          private String name;
&nbsp; *          private String state;
&nbsp; *          private String street;
&nbsp; *          private int    zip;
&nbsp; *
&nbsp; *      public USAddress(String name, String street, String city, 
&nbsp; *          String state, int zip) {
&nbsp; *          this.name = name;
&nbsp; *          this.street = street;
&nbsp; *          this.city = city;
&nbsp; *          this.state = state;
&nbsp; *          this.zip = zip;
&nbsp; *      }
&nbsp; *  }
&nbsp; *
&nbsp; *  public class USAddressFactory {
&nbsp; *      public static USAddress getUSAddress(){
&nbsp; *       return new USAddress(&quot;Mark Baker&quot;, &quot;23 Elm St&quot;, 
&nbsp; *          &quot;Dayton&quot;, &quot;OH&quot;, 90952);
&nbsp; *  }
&nbsp; *
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; *  &lt;p&gt; &lt;b&gt; Example 7: &lt;/b&gt; Define factoryMethod and use the default factoryClass
&nbsp; * 
&nbsp; * &lt;pre&gt;
&nbsp; *      &amp;#64;XmlType(name=&quot;USAddressType&quot;, factoryMethod=&quot;getNewInstance&quot;)
&nbsp; *      public class USAddress {
&nbsp; *
&nbsp; *          private String city;
&nbsp; *          private String name;
&nbsp; *          private String state;
&nbsp; *          private String street;
&nbsp; *          private int    zip;
&nbsp; *
&nbsp; *          private USAddress() {}
&nbsp; *
&nbsp; *          public static USAddress getNewInstance(){
&nbsp; *              return new USAddress();
&nbsp; *          }
&nbsp; *      }
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * @author Sekhar Vajjhala, Sun Microsystems, Inc.
&nbsp; * @see XmlElement
&nbsp; * @see XmlAttribute
&nbsp; * @see XmlValue
&nbsp; * @see XmlSchema
&nbsp; * @since 1.6, JAXB 2.0
&nbsp; */
&nbsp;
&nbsp;@Retention(RUNTIME) @Target({TYPE})
&nbsp;public @interface XmlType {
&nbsp;    /**
&nbsp;     * Name of the XML Schema type which the class is mapped.
&nbsp;     */
&nbsp;    String name() default &quot;##default&quot; ;
&nbsp; 
&nbsp;    /**
&nbsp;     * Specifies the order for XML Schema elements when class is
&nbsp;     * mapped to a XML Schema complex type.
&nbsp;     * 
&nbsp;     * &lt;p&gt; Refer to the table for how the propOrder affects the
&nbsp;     * mapping of class &lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;p&gt; The propOrder is a list of names of JavaBean properties in
&nbsp;     *     the class. Each name in the list is the name of a Java
&nbsp;     *     identifier of the JavaBean property. The order in which
&nbsp;     *     JavaBean properties are listed is the order of XML Schema
&nbsp;     *     elements to which the JavaBean properties are mapped. &lt;/p&gt;
&nbsp;     * &lt;p&gt; All of the JavaBean properties being mapped to XML Schema elements
&nbsp;     *     must be listed. 
&nbsp;     * &lt;p&gt; A JavaBean property or field listed in propOrder must not
&nbsp;     *     be transient or annotated with {@code @XmlTransient}.
&nbsp;     * &lt;p&gt; The default ordering of JavaBean properties is determined
&nbsp;     *     by @{@link XmlAccessorOrder}. 
&nbsp;     */
&nbsp;    String[] propOrder() default {&quot;&quot;};
&nbsp;
&nbsp;    /**
&nbsp;     * Name of the target namespace of the XML Schema type. By
&nbsp;     * default, this is the target namespace to which the package
&nbsp;     * containing the class is mapped.
&nbsp;     */
&nbsp;    String namespace() default &quot;##default&quot; ;
&nbsp;   
&nbsp;    /**
&nbsp;     * Class containing a no-arg factory method for creating an
&nbsp;     * instance of this class. The default is this class.
&nbsp;     * 
&nbsp;     * &lt;p&gt;If {@code factoryClass} is DEFAULT.class and
&nbsp;     * {@code factoryMethod} is &quot;&quot;, then there is no static factory
&nbsp;     * method.
&nbsp;     * 
&nbsp;     * &lt;p&gt;If {@code factoryClass} is DEFAULT.class and
&nbsp;     * {@code factoryMethod} is not &quot;&quot;, then 
&nbsp;     * {@code factoryMethod} is the name of a static factory method
&nbsp;     * in this class. 
&nbsp;     *
&nbsp;     * &lt;p&gt;If {@code factoryClass} is not DEFAULT.class, then
&nbsp;     * {@code factoryMethod} must not be &quot;&quot; and must be the name of
&nbsp;     * a static factory method specified in {@code factoryClass}.
&nbsp;     */
&nbsp;    Class factoryClass() default DEFAULT.class;
&nbsp;
&nbsp;    /**
&nbsp;     * Used in {@link XmlType#factoryClass()} to
&nbsp;     * signal that either factory mehod is not used or
&nbsp;     * that it&#39;s in the class with this {@link XmlType} itself. 
&nbsp;     */
<b class="nc">&nbsp;    static final class DEFAULT {}</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Name of a no-arg factory method in the class specified in
&nbsp;     * {@code factoryClass} factoryClass().
&nbsp;     * 
&nbsp;     */
&nbsp;    String factoryMethod() default &quot;&quot;;
&nbsp;}
&nbsp;
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
