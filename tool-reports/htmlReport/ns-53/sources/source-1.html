


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > AnnotationDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.annotation</a>
</div>

<h1>Coverage Summary for Class: AnnotationDescription (net.bytebuddy.description.annotation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AnnotationDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AnnotationDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    44,4%
  </span>
  <span class="absValue">
    (4/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    15%
  </span>
  <span class="absValue">
    (3/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26,3%
  </span>
  <span class="absValue">
    (10/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$AbstractBase$ForPrepared</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation</td>
<td class="coverageStat">
  <span class="percent">
    88,9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (16/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38,7%
  </span>
  <span class="absValue">
    (24/62)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$Loadable</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    71,4%
  </span>
  <span class="absValue">
    (15/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31,7%
  </span>
  <span class="absValue">
    (19/60)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    35,2%
  </span>
  <span class="absValue">
    (37/105)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.description.annotation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.utility.privilege.SetAccessibleAction;
&nbsp;
&nbsp;import java.lang.annotation.*;
&nbsp;import java.lang.reflect.InvocationHandler;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Proxy;
&nbsp;import java.security.AccessController;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.named;
&nbsp;
&nbsp;/**
&nbsp; * An annotation description describes {@link java.lang.annotation.Annotation} meta data of a class without this class
&nbsp; * being required to be loaded. All values of an annotation are therefore represented in unloaded state:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;{@link java.lang.Class} instances are represented as {@link TypeDescription}s.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link java.lang.Enum} instances are represented as
&nbsp; * {@link net.bytebuddy.description.enumeration.EnumerationDescription}s.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link java.lang.annotation.Annotation}s are described as
&nbsp; * {@link AnnotationDescription}s.&lt;/li&gt;
&nbsp; * &lt;li&gt;All primitive types are represented as their wrapper types.&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * An annotation can however be loaded in order to access unwrapped values. This will cause a loading of the classes
&nbsp; * of these values.
&nbsp; */
&nbsp;public interface AnnotationDescription {
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates a nonexistent annotation in a type-safe manner.
&nbsp;     */
<b class="fc">&nbsp;    AnnotationDescription.Loadable&lt;?&gt; UNDEFINED = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the value of this annotation.
&nbsp;     *
&nbsp;     * @param property The property being accessed.
&nbsp;     * @return The value for the supplied property.
&nbsp;     */
&nbsp;    AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a description of the annotation type of this annotation.
&nbsp;     *
&nbsp;     * @return A description of the annotation type of this annotation.
&nbsp;     */
&nbsp;    TypeDescription getAnnotationType();
&nbsp;
&nbsp;    /**
&nbsp;     * Links this annotation description to a given annotation type such that it can be loaded. This does not cause
&nbsp;     * the values of this annotation to be loaded.
&nbsp;     *
&nbsp;     * @param annotationType The loaded annotation type of this annotation description.
&nbsp;     * @param &lt;T&gt;            The type of the annotation.
&nbsp;     * @return A loadable version of this annotation description.
&nbsp;     */
&nbsp;    &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this annotation&#39;s retention policy.
&nbsp;     *
&nbsp;     * @return This annotation&#39;s retention policy.
&nbsp;     */
&nbsp;    RetentionPolicy getRetention();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a set of all {@link ElementType}s that can declare this annotation.
&nbsp;     *
&nbsp;     * @return A set of all element types that can declare this annotation.
&nbsp;     */
&nbsp;    Set&lt;ElementType&gt; getElementTypes();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this annotation is inherited.
&nbsp;     *
&nbsp;     * @return {@code true} if this annotation is inherited.
&nbsp;     * @see Inherited
&nbsp;     */
&nbsp;    boolean isInherited();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this annotation is documented.
&nbsp;     *
&nbsp;     * @return {@code true} if this annotation is documented.
&nbsp;     * @see Documented
&nbsp;     */
&nbsp;    boolean isDocumented();
&nbsp;
&nbsp;    /**
&nbsp;     * An annotation description that is linked to a given loaded annotation type which allows its representation
&nbsp;     * as a fully loaded instance.
&nbsp;     *
&nbsp;     * @param &lt;S&gt; The annotation type.
&nbsp;     */
&nbsp;    interface Loadable&lt;S extends Annotation&gt; extends AnnotationDescription {
&nbsp;
&nbsp;        /**
&nbsp;         * Loads this annotation description. This causes all classes referenced by the annotation value to be loaded.
&nbsp;         * Without specifying a class loader, the annotation&#39;s class loader which was used to prepare this instance
&nbsp;         * is used.
&nbsp;         *
&nbsp;         * @return A loaded version of this annotation description.
&nbsp;         * @throws java.lang.ClassNotFoundException If any linked classes of the annotation cannot be loaded.
&nbsp;         */
&nbsp;        S load() throws ClassNotFoundException;
&nbsp;
&nbsp;        /**
&nbsp;         * Loads this annotation description. This causes all classes referenced by the annotation value to be loaded.
&nbsp;         * Without specifying a class loader, the annotation&#39;s class loader which was used to prepare this instance
&nbsp;         * is used. Any {@link java.lang.ClassNotFoundException} is wrapped in an {@link java.lang.IllegalStateException}.
&nbsp;         *
&nbsp;         * @return A loaded version of this annotation description.
&nbsp;         */
&nbsp;        S loadSilent();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An {@link java.lang.reflect.InvocationHandler} for implementing annotations.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the handled annotation.
&nbsp;     */
&nbsp;    class AnnotationInvocationHandler&lt;T extends Annotation&gt; implements InvocationHandler {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the {@link Object#hashCode()} method.
&nbsp;         */
&nbsp;        private static final String HASH_CODE = &quot;hashCode&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the {@link Object#equals(Object)} method.
&nbsp;         */
&nbsp;        private static final String EQUALS = &quot;equals&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the {@link Object#toString()} method.
&nbsp;         */
&nbsp;        private static final String TO_STRING = &quot;toString&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * An empty array that can be used to indicate no arguments to avoid an allocation on a reflective call.
&nbsp;         */
&nbsp;        private static final Object[] NO_ARGUMENTS = new Object[0];
&nbsp;
&nbsp;        /**
&nbsp;         * The loaded annotation type.
&nbsp;         */
&nbsp;        private final Class&lt;? extends Annotation&gt; annotationType;
&nbsp;
&nbsp;        /**
&nbsp;         * A sorted list of values of this annotation.
&nbsp;         */
&nbsp;        private final LinkedHashMap&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; values;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new invocation handler.
&nbsp;         *
&nbsp;         * @param annotationType The loaded annotation type.
&nbsp;         * @param values         A sorted list of values of this annotation.
&nbsp;         */
&nbsp;        protected AnnotationInvocationHandler(Class&lt;T&gt; annotationType, LinkedHashMap&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; values) {
&nbsp;            this.annotationType = annotationType;
&nbsp;            this.values = values;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a proxy instance for the supplied annotation type and values.
&nbsp;         *
&nbsp;         * @param classLoader    The class loader that should be used for loading the annotation&#39;s values.
&nbsp;         * @param annotationType The annotation&#39;s type.
&nbsp;         * @param values         The values that the annotation contains.
&nbsp;         * @param &lt;S&gt;            The type of the handled annotation.
&nbsp;         * @return A proxy for the annotation type and values.
&nbsp;         * @throws ClassNotFoundException If the class of an instance that is contained by this annotation could not be found.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public static &lt;S extends Annotation&gt; S of(ClassLoader classLoader,
&nbsp;                                                  Class&lt;S&gt; annotationType,
&nbsp;                                                  Map&lt;String, ? extends AnnotationValue&lt;?, ?&gt;&gt; values) throws ClassNotFoundException {
&nbsp;            LinkedHashMap&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; loadedValues = new LinkedHashMap&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt;();
&nbsp;            for (Method method : annotationType.getDeclaredMethods()) {
&nbsp;                AnnotationValue&lt;?, ?&gt; annotationValue = values.get(method.getName());
&nbsp;                loadedValues.put(method, (annotationValue == null
&nbsp;                        ? defaultValueOf(method)
&nbsp;                        : annotationValue).load(classLoader));
&nbsp;            }
&nbsp;            return (S) Proxy.newProxyInstance(classLoader, new Class&lt;?&gt;[]{annotationType}, new AnnotationInvocationHandler&lt;S&gt;(annotationType, loadedValues));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a default value for the given method.
&nbsp;         *
&nbsp;         * @param method The method from which to attempt the extraction of a default value.
&nbsp;         * @return A default value representation.
&nbsp;         */
&nbsp;        private static AnnotationValue&lt;?, ?&gt; defaultValueOf(Method method) {
&nbsp;            Object defaultValue = method.getDefaultValue();
&nbsp;            return defaultValue == null
&nbsp;                    ? MissingValue.of(method)
&nbsp;                    : AnnotationDescription.ForLoadedAnnotation.asValue(defaultValue, method.getReturnType());
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves any primitive type to its wrapper type.
&nbsp;         *
&nbsp;         * @param type The type to resolve.
&nbsp;         * @return The resolved type.
&nbsp;         */
&nbsp;        private static Class&lt;?&gt; asWrapper(Class&lt;?&gt; type) {
&nbsp;            if (type.isPrimitive()) {
&nbsp;                if (type == boolean.class) {
&nbsp;                    return Boolean.class;
&nbsp;                } else if (type == byte.class) {
&nbsp;                    return Byte.class;
&nbsp;                } else if (type == short.class) {
&nbsp;                    return Short.class;
&nbsp;                } else if (type == char.class) {
&nbsp;                    return Character.class;
&nbsp;                } else if (type == int.class) {
&nbsp;                    return Integer.class;
&nbsp;                } else if (type == long.class) {
&nbsp;                    return Long.class;
&nbsp;                } else if (type == float.class) {
&nbsp;                    return Float.class;
&nbsp;                } else if (type == double.class) {
&nbsp;                    return Double.class;
&nbsp;                }
&nbsp;            }
&nbsp;            return type;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object invoke(Object proxy, Method method, Object[] argument) {
&nbsp;            if (method.getDeclaringClass() != annotationType) {
&nbsp;                if (method.getName().equals(HASH_CODE)) {
&nbsp;                    return hashCodeRepresentation();
&nbsp;                } else if (method.getName().equals(EQUALS) &amp;&amp; method.getParameterTypes().length == 1) {
&nbsp;                    return equalsRepresentation(proxy, argument[0]);
&nbsp;                } else if (method.getName().equals(TO_STRING)) {
&nbsp;                    return toStringRepresentation();
&nbsp;                } else /* if (method.getName().equals(&quot;annotationType&quot;)) */ {
&nbsp;                    return annotationType;
&nbsp;                }
&nbsp;            }
&nbsp;            Object value = values.get(method).resolve();
&nbsp;            if (!asWrapper(method.getReturnType()).isAssignableFrom(value.getClass())) {
&nbsp;                throw new AnnotationTypeMismatchException(method, value.getClass().toString());
&nbsp;            }
&nbsp;            return value;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the string representation of the represented annotation.
&nbsp;         *
&nbsp;         * @return The string representation of the represented annotation.
&nbsp;         */
&nbsp;        protected String toStringRepresentation() {
&nbsp;            StringBuilder toString = new StringBuilder();
&nbsp;            toString.append(&#39;@&#39;);
&nbsp;            toString.append(annotationType.getName());
&nbsp;            toString.append(&#39;(&#39;);
&nbsp;            boolean firstMember = true;
&nbsp;            for (Map.Entry&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; entry : values.entrySet()) {
&nbsp;                if (!entry.getValue().getState().isDefined()) {
&nbsp;                    continue;
&nbsp;                }
&nbsp;                if (firstMember) {
&nbsp;                    firstMember = false;
&nbsp;                } else {
&nbsp;                    toString.append(&quot;, &quot;);
&nbsp;                }
&nbsp;                toString.append(entry.getKey().getName())
&nbsp;                        .append(&#39;=&#39;)
&nbsp;                        .append(entry.getValue().toString());
&nbsp;            }
&nbsp;            toString.append(&#39;)&#39;);
&nbsp;            return toString.toString();
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the hash code of the represented annotation.
&nbsp;         *
&nbsp;         * @return The hash code of the represented annotation.
&nbsp;         */
&nbsp;        private int hashCodeRepresentation() {
&nbsp;            int hashCode = 0;
&nbsp;            for (Map.Entry&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; entry : values.entrySet()) {
&nbsp;                if (!entry.getValue().getState().isDefined()) {
&nbsp;                    continue;
&nbsp;                }
&nbsp;                hashCode += (127 * entry.getKey().getName().hashCode()) ^ entry.getValue().hashCode();
&nbsp;            }
&nbsp;            return hashCode;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if another instance is equal to this instance.
&nbsp;         *
&nbsp;         * @param self  The annotation proxy instance.
&nbsp;         * @param other The instance to be examined for equality to the represented instance.
&nbsp;         * @return {@code true} if the given instance is equal to the represented instance.
&nbsp;         */
&nbsp;        private boolean equalsRepresentation(Object self, Object other) {
&nbsp;            if (self == other) {
&nbsp;                return true;
&nbsp;            } else if (!annotationType.isInstance(other)) {
&nbsp;                return false;
&nbsp;            } else if (Proxy.isProxyClass(other.getClass())) {
&nbsp;                InvocationHandler invocationHandler = Proxy.getInvocationHandler(other);
&nbsp;                if (invocationHandler instanceof AnnotationInvocationHandler) {
&nbsp;                    return invocationHandler.equals(this);
&nbsp;                }
&nbsp;            }
&nbsp;            try {
&nbsp;                for (Map.Entry&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; entry : values.entrySet()) {
&nbsp;                    try {
&nbsp;                        if (!entry.getValue().represents(entry.getKey().invoke(other, NO_ARGUMENTS))) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    } catch (RuntimeException exception) {
&nbsp;                        return false; // Incomplete annotations are not equal to one another.
&nbsp;                    }
&nbsp;                }
&nbsp;                return true;
&nbsp;            } catch (InvocationTargetException ignored) {
&nbsp;                return false;
&nbsp;            } catch (IllegalAccessException exception) {
&nbsp;                throw new IllegalStateException(&quot;Could not access annotation property&quot;, exception);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof AnnotationInvocationHandler)) {
&nbsp;                return false;
&nbsp;            }
&nbsp;            AnnotationInvocationHandler that = (AnnotationInvocationHandler) other;
&nbsp;            if (!annotationType.equals(that.annotationType)) {
&nbsp;                return false;
&nbsp;            }
&nbsp;            for (Map.Entry&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; entry : values.entrySet()) {
&nbsp;                if (!entry.getValue().equals(that.values.get(entry.getKey()))) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;            return true;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
&nbsp;            int result = annotationType.hashCode();
&nbsp;            result = 31 * result + values.hashCode();
&nbsp;            for (Map.Entry&lt;Method, ?&gt; entry : values.entrySet()) {
&nbsp;                result = 31 * result + entry.getValue().hashCode();
&nbsp;            }
&nbsp;            return result;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a missing annotation property which is not represented by a default value.
&nbsp;         */
&nbsp;        protected static class MissingValue extends AnnotationValue.Loaded.AbstractBase&lt;Void&gt; implements AnnotationValue&lt;Void, Void&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The annotation type.
&nbsp;             */
&nbsp;            private final Class&lt;? extends Annotation&gt; annotationType;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the property without an annotation value.
&nbsp;             */
&nbsp;            private final String property;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new representation for a missing annotation property.
&nbsp;             *
&nbsp;             * @param annotationType The annotation type.
&nbsp;             * @param property       The name of the property without an annotation value.
&nbsp;             */
&nbsp;            protected MissingValue(Class&lt;? extends Annotation&gt; annotationType, String property) {
&nbsp;                this.annotationType = annotationType;
&nbsp;                this.property = property;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a missing value for the supplied annotation property.
&nbsp;             *
&nbsp;             * @param method A method representing an annotation property.
&nbsp;             * @return An annotation value for a missing property.
&nbsp;             */
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            protected static AnnotationValue&lt;?, ?&gt; of(Method method) {
&nbsp;                return new MissingValue((Class&lt;? extends Annotation&gt;) method.getDeclaringClass(), method.getName());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public State getState() {
&nbsp;                return State.UNDEFINED;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(Object value) {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Loaded&lt;Void&gt; load(ClassLoader classLoader) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Loaded&lt;Void&gt; loadSilent(ClassLoader classLoader) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Void resolve() {
&nbsp;                throw new IncompleteAnnotationException(annotationType, property);
&nbsp;            }
&nbsp;
&nbsp;            /* does intentionally not implement hashCode, equals and toString */
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An adapter implementation of an annotation.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase implements AnnotationDescription {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * An array containing all element types that are a legal annotation target when such a target
&nbsp;         * is not specified explicitly.
&nbsp;         */
<b class="fc">&nbsp;        private static final ElementType[] DEFAULT_TARGET = new ElementType[]{ElementType.ANNOTATION_TYPE,</b>
&nbsp;                ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.METHOD,
&nbsp;                ElementType.PACKAGE, ElementType.PARAMETER, ElementType.TYPE};
&nbsp;
&nbsp;        @Override
&nbsp;        public RetentionPolicy getRetention() {
<b class="fc">&nbsp;            AnnotationDescription.Loadable&lt;Retention&gt; retention = getAnnotationType().getDeclaredAnnotations().ofType(Retention.class);</b>
<b class="pc">&nbsp;            return retention == null</b>
&nbsp;                    ? RetentionPolicy.CLASS
<b class="fc">&nbsp;                    : retention.loadSilent().value();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Set&lt;ElementType&gt; getElementTypes() {
<b class="nc">&nbsp;            AnnotationDescription.Loadable&lt;Target&gt; target = getAnnotationType().getDeclaredAnnotations().ofType(Target.class);</b>
<b class="nc">&nbsp;            return new HashSet&lt;ElementType&gt;(Arrays.asList(target == null</b>
&nbsp;                    ? DEFAULT_TARGET
<b class="nc">&nbsp;                    : target.loadSilent().value()));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isInherited() {
<b class="nc">&nbsp;            return getAnnotationType().getDeclaredAnnotations().isAnnotationPresent(Inherited.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isDocumented() {
<b class="nc">&nbsp;            return getAnnotationType().getDeclaredAnnotations().isAnnotationPresent(Documented.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
<b class="nc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (!(other instanceof AnnotationDescription)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            AnnotationDescription annotationDescription = ((AnnotationDescription) other);</b>
<b class="nc">&nbsp;            TypeDescription annotationType = getAnnotationType();</b>
<b class="nc">&nbsp;            if (!annotationDescription.getAnnotationType().equals(annotationType)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (MethodDescription.InDefinedShape methodDescription : annotationType.getDeclaredMethods()) {</b>
<b class="nc">&nbsp;                if (!getValue(methodDescription).equals(annotationDescription.getValue(methodDescription))) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            int hashCode = 0;</b>
<b class="fc">&nbsp;            for (MethodDescription.InDefinedShape methodDescription : getAnnotationType().getDeclaredMethods()) {</b>
<b class="fc">&nbsp;                hashCode += 31 * getValue(methodDescription).hashCode();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return hashCode;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            TypeDescription annotationType = getAnnotationType();</b>
<b class="nc">&nbsp;            StringBuilder toString = new StringBuilder().append(&#39;@&#39;).append(annotationType.getName()).append(&#39;(&#39;);</b>
<b class="nc">&nbsp;            boolean firstMember = true;</b>
<b class="nc">&nbsp;            for (MethodDescription.InDefinedShape methodDescription : annotationType.getDeclaredMethods()) {</b>
<b class="nc">&nbsp;                if (firstMember) {</b>
<b class="nc">&nbsp;                    firstMember = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toString.append(&quot;, &quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                toString.append(methodDescription.getName()).append(&#39;=&#39;).append(getValue(methodDescription));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return toString.append(&#39;)&#39;).toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract implementation of a loadable annotation description.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; The annotation type this instance was prepared for.
&nbsp;         */
<b class="fc">&nbsp;        public abstract static class ForPrepared&lt;S extends Annotation&gt; extends AbstractBase implements Loadable&lt;S&gt; {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public S loadSilent() {
&nbsp;                try {
<b class="fc">&nbsp;                    return load();</b>
<b class="nc">&nbsp;                } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Could not load annotation type or referenced type&quot;, exception);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A description of an already loaded annotation.
&nbsp;     *
&nbsp;     * @param &lt;S&gt; The type of the annotation.
&nbsp;     */
&nbsp;    class ForLoadedAnnotation&lt;S extends Annotation&gt; extends AbstractBase.ForPrepared&lt;S&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The represented annotation value.
&nbsp;         */
&nbsp;        private final S annotation;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotation&#39;s loaded type which might be loaded by a different class loader than the value&#39;s
&nbsp;         * annotation type but must be structurally equal to it.
&nbsp;         */
&nbsp;        private final Class&lt;S&gt; annotationType;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new annotation description for a loaded annotation.
&nbsp;         *
&nbsp;         * @param annotation The annotation to represent.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        protected ForLoadedAnnotation(S annotation) {
<b class="fc">&nbsp;            this(annotation, (Class&lt;S&gt;) annotation.annotationType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new annotation description for a loaded annotation.
&nbsp;         *
&nbsp;         * @param annotation     The annotation to represent.
&nbsp;         * @param annotationType The annotation&#39;s loaded type which might be loaded by a different class loader than the value&#39;s
&nbsp;         *                       annotation type but must be structurally equal to it.
&nbsp;         */
<b class="fc">&nbsp;        private ForLoadedAnnotation(S annotation, Class&lt;S&gt; annotationType) {</b>
<b class="fc">&nbsp;            this.annotation = annotation;</b>
<b class="fc">&nbsp;            this.annotationType = annotationType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a description of the given annotation.
&nbsp;         *
&nbsp;         * @param annotation The annotation to be described.
&nbsp;         * @param &lt;U&gt;        The type of the annotation.
&nbsp;         * @return A description of the given annotation.
&nbsp;         */
&nbsp;        public static &lt;U extends Annotation&gt; Loadable&lt;U&gt; of(U annotation) {
<b class="fc">&nbsp;            return new ForLoadedAnnotation&lt;U&gt;(annotation);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public S load() throws ClassNotFoundException {
<b class="pc">&nbsp;            return annotationType == annotation.annotationType()</b>
&nbsp;                    ? annotation
<b class="nc">&nbsp;                    : AnnotationInvocationHandler.of(annotationType.getClassLoader(), annotationType, asValue(annotation));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Extracts the annotation values of an annotation into a property map.
&nbsp;         *
&nbsp;         * @param annotation The annotation to convert.
&nbsp;         * @return A mapping of property names to their annotation value.
&nbsp;         */
&nbsp;        private static Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; asValue(Annotation annotation) {
<b class="nc">&nbsp;            Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; annotationValues = new HashMap&lt;String, AnnotationValue&lt;?, ?&gt;&gt;();</b>
<b class="nc">&nbsp;            for (Method property : annotation.annotationType().getDeclaredMethods()) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    annotationValues.put(property.getName(), asValue(property.invoke(annotation), property.getReturnType()));</b>
<b class="nc">&nbsp;                } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot read &quot; + property, exception.getCause());</b>
<b class="nc">&nbsp;                } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot access &quot; + property, exception);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            return annotationValues;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Transforms an annotation property to an annotation value.
&nbsp;         *
&nbsp;         * @param type  The annotation&#39;s type.
&nbsp;         * @param value The annotations value.
&nbsp;         * @return An annotation value representation.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public static AnnotationValue&lt;?, ?&gt; asValue(Object value, Class&lt;?&gt; type) {
&nbsp;            // Because enums can implement annotation interfaces, the enum property needs to be checked first.
<b class="fc">&nbsp;            if (Enum.class.isAssignableFrom(type)) {</b>
<b class="fc">&nbsp;                return AnnotationValue.ForEnumerationDescription.&lt;Enum&gt;of(new EnumerationDescription.ForLoadedEnumeration((Enum) value));</b>
<b class="pc">&nbsp;            } else if (Enum[].class.isAssignableFrom(type)) {</b>
<b class="nc">&nbsp;                Enum&lt;?&gt;[] element = (Enum&lt;?&gt;[]) value;</b>
<b class="nc">&nbsp;                EnumerationDescription[] enumerationDescription = new EnumerationDescription[element.length];</b>
<b class="nc">&nbsp;                int index = 0;</b>
<b class="nc">&nbsp;                for (Enum&lt;?&gt; anElement : element) {</b>
<b class="nc">&nbsp;                    enumerationDescription[index++] = new EnumerationDescription.ForLoadedEnumeration(anElement);</b>
&nbsp;                }
<b class="nc">&nbsp;                return AnnotationValue.ForDescriptionArray.&lt;Enum&gt;of(TypeDescription.ForLoadedType.of(type.getComponentType()), enumerationDescription);</b>
<b class="pc">&nbsp;            } else if (Annotation.class.isAssignableFrom(type)) {</b>
<b class="nc">&nbsp;                return AnnotationValue.ForAnnotationDescription.&lt;Annotation&gt;of(TypeDescription.ForLoadedType.of(type), asValue((Annotation) value));</b>
<b class="pc">&nbsp;            } else if (Annotation[].class.isAssignableFrom(type)) {</b>
<b class="nc">&nbsp;                Annotation[] element = (Annotation[]) value;</b>
<b class="nc">&nbsp;                AnnotationDescription[] annotationDescription = new AnnotationDescription[element.length];</b>
<b class="nc">&nbsp;                int index = 0;</b>
<b class="nc">&nbsp;                for (Annotation anElement : element) {</b>
<b class="nc">&nbsp;                    annotationDescription[index++] = new AnnotationDescription.Latent(TypeDescription.ForLoadedType.of(type.getComponentType()), asValue(anElement));</b>
&nbsp;                }
<b class="nc">&nbsp;                return AnnotationValue.ForDescriptionArray.of(TypeDescription.ForLoadedType.of(type.getComponentType()), annotationDescription);</b>
<b class="fc">&nbsp;            } else if (Class.class.isAssignableFrom(type)) {</b>
<b class="fc">&nbsp;                return AnnotationValue.ForTypeDescription.&lt;Class&gt;of(TypeDescription.ForLoadedType.of((Class&lt;?&gt;) value));</b>
<b class="pc">&nbsp;            } else if (Class[].class.isAssignableFrom(type)) {</b>
<b class="nc">&nbsp;                Class&lt;?&gt;[] element = (Class&lt;?&gt;[]) value;</b>
<b class="nc">&nbsp;                TypeDescription[] typeDescription = new TypeDescription[element.length];</b>
<b class="nc">&nbsp;                int index = 0;</b>
<b class="nc">&nbsp;                for (Class&lt;?&gt; anElement : element) {</b>
<b class="nc">&nbsp;                    typeDescription[index++] = TypeDescription.ForLoadedType.of(anElement);</b>
&nbsp;                }
<b class="nc">&nbsp;                return AnnotationValue.ForDescriptionArray.of(typeDescription);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return AnnotationValue.ForConstant.of(value);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;        @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should always be wrapped for clarity&quot;)
&nbsp;        public AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property) {
<b class="pc">&nbsp;            if (!property.getDeclaringType().represents(annotation.annotationType())) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(property + &quot; does not represent &quot; + annotation.annotationType());</b>
&nbsp;            }
&nbsp;            try {
<b class="fc">&nbsp;                boolean accessible = property.getDeclaringType().isPublic(); // method is required to be public</b>
<b class="pc">&nbsp;                Method method = property instanceof MethodDescription.ForLoadedMethod</b>
<b class="fc">&nbsp;                        ? ((MethodDescription.ForLoadedMethod) property).getLoadedMethod()</b>
&nbsp;                        : null;
<b class="pc">&nbsp;                if (method == null || method.getDeclaringClass() != annotation.annotationType() || (!accessible &amp;&amp; !method.isAccessible())) {</b>
<b class="nc">&nbsp;                    method = annotation.annotationType().getMethod(property.getName());</b>
<b class="nc">&nbsp;                    if (!accessible) {</b>
<b class="nc">&nbsp;                        AccessController.doPrivileged(new SetAccessibleAction&lt;Method&gt;(method));</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return asValue(method.invoke(annotation), method.getReturnType());</b>
<b class="nc">&nbsp;            } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Error reading annotation property &quot; + property, exception.getCause());</b>
<b class="nc">&nbsp;            } catch (Exception exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot access annotation property &quot; + property, exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType) {
<b class="pc">&nbsp;            if (!annotation.annotationType().getName().equals(annotationType.getName())) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(annotationType + &quot; does not represent &quot; + annotation.annotationType());</b>
&nbsp;            }
<b class="pc">&nbsp;            return annotationType == annotation.annotationType()</b>
&nbsp;                    ? (Loadable&lt;T&gt;) this
&nbsp;                    : new ForLoadedAnnotation&lt;T&gt;((T) annotation, annotationType);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getAnnotationType() {
<b class="fc">&nbsp;            return TypeDescription.ForLoadedType.of(annotation.annotationType());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A latent description of an annotation value that is defined explicitly.
&nbsp;     */
&nbsp;    class Latent extends AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The type of the annotation.
&nbsp;         */
&nbsp;        private final TypeDescription annotationType;
&nbsp;
&nbsp;        /**
&nbsp;         * The values of the annotation mapped by their property name.
&nbsp;         */
&nbsp;        private final Map&lt;String, ? extends AnnotationValue&lt;?, ?&gt;&gt; annotationValues;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent annotation description.
&nbsp;         *
&nbsp;         * @param annotationType   The type of the annotation.
&nbsp;         * @param annotationValues The values of the annotation mapped by their property name.
&nbsp;         */
&nbsp;        protected Latent(TypeDescription annotationType, Map&lt;String, ? extends AnnotationValue&lt;?, ?&gt;&gt; annotationValues) {
&nbsp;            this.annotationType = annotationType;
&nbsp;            this.annotationValues = annotationValues;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property) {
&nbsp;            AnnotationValue&lt;?, ?&gt; value = annotationValues.get(property.getName());
&nbsp;            if (value != null) {
&nbsp;                return value;
&nbsp;            }
&nbsp;            AnnotationValue&lt;?, ?&gt; defaultValue = property.getDefaultValue();
&nbsp;            if (defaultValue != null) {
&nbsp;                return defaultValue;
&nbsp;            }
&nbsp;            throw new IllegalArgumentException(&quot;No value defined for: &quot; + property);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getAnnotationType() {
&nbsp;            return annotationType;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType) {
&nbsp;            if (!this.annotationType.represents(annotationType)) {
&nbsp;                throw new IllegalArgumentException(annotationType + &quot; does not represent &quot; + this.annotationType);
&nbsp;            }
&nbsp;            return new Loadable&lt;T&gt;(annotationType);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A loadable annotation description of a latent annotation description.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; The annotation type.
&nbsp;         */
&nbsp;        protected class Loadable&lt;S extends Annotation&gt; extends AbstractBase.ForPrepared&lt;S&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The annotation type.
&nbsp;             */
&nbsp;            private final Class&lt;S&gt; annotationType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a loadable version of a latent annotation description.
&nbsp;             *
&nbsp;             * @param annotationType The annotation type.
&nbsp;             */
&nbsp;            protected Loadable(Class&lt;S&gt; annotationType) {
&nbsp;                this.annotationType = annotationType;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public S load() throws ClassNotFoundException {
&nbsp;                return AnnotationDescription.AnnotationInvocationHandler.of(annotationType.getClassLoader(), annotationType, annotationValues);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property) {
&nbsp;                return Latent.this.getValue(property);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription getAnnotationType() {
&nbsp;                return TypeDescription.ForLoadedType.of(annotationType);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType) {
&nbsp;                return Latent.this.prepare(annotationType);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A builder for pragmatically creating {@link net.bytebuddy.description.annotation.AnnotationDescription}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Builder {
&nbsp;
&nbsp;        /**
&nbsp;         * The annotation type.
&nbsp;         */
&nbsp;        private final TypeDescription annotationType;
&nbsp;
&nbsp;        /**
&nbsp;         * A mapping of annotation properties to their annotation values.
&nbsp;         */
&nbsp;        private final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; annotationValues;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a builder for an annotation description.
&nbsp;         *
&nbsp;         * @param annotationType   The annotation type.
&nbsp;         * @param annotationValues A mapping of annotation properties to their annotation values.
&nbsp;         */
&nbsp;        protected Builder(TypeDescription annotationType, Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; annotationValues) {
&nbsp;            this.annotationType = annotationType;
&nbsp;            this.annotationValues = annotationValues;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a builder for creating an annotation of the given type.
&nbsp;         *
&nbsp;         * @param annotationType The annotation type.
&nbsp;         * @return A builder for creating an annotation of the given type.
&nbsp;         */
&nbsp;        public static Builder ofType(Class&lt;? extends Annotation&gt; annotationType) {
&nbsp;            return ofType(TypeDescription.ForLoadedType.of(annotationType));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a builder for creating an annotation of the given type.
&nbsp;         *
&nbsp;         * @param annotationType A description of the annotation type.
&nbsp;         * @return A builder for creating an annotation of the given type.
&nbsp;         */
&nbsp;        public static Builder ofType(TypeDescription annotationType) {
&nbsp;            if (!annotationType.isAnnotation()) {
&nbsp;                throw new IllegalArgumentException(&quot;Not an annotation type: &quot; + annotationType);
&nbsp;            }
&nbsp;            return new Builder(annotationType, Collections.&lt;String, AnnotationValue&lt;?, ?&gt;&gt;emptyMap());
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional, given property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    An explicit description of the annotation value.
&nbsp;         * @return A builder with the additional, given property.
&nbsp;         */
&nbsp;        public Builder define(String property, AnnotationValue&lt;?, ?&gt; value) {
&nbsp;            MethodList&lt;?&gt; methodDescriptions = annotationType.getDeclaredMethods().filter(named(property));
&nbsp;            if (methodDescriptions.isEmpty()) {
&nbsp;                throw new IllegalArgumentException(annotationType + &quot; does not define a property named &quot; + property);
&nbsp;            } else if (!methodDescriptions.getOnly().getReturnType().asErasure().isAnnotationValue(value.resolve())) {
&nbsp;                throw new IllegalArgumentException(value + &quot; cannot be assigned to &quot; + property);
&nbsp;            }
&nbsp;            Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; annotationValues = new HashMap&lt;String, AnnotationValue&lt;?, ?&gt;&gt;();
&nbsp;            annotationValues.putAll(this.annotationValues);
&nbsp;            if (annotationValues.put(methodDescriptions.getOnly().getName(), value) != null) {
&nbsp;                throw new IllegalArgumentException(&quot;Property already defined: &quot; + property);
&nbsp;            }
&nbsp;            return new Builder(annotationType, annotationValues);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional enumeration property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The enumeration value to define.
&nbsp;         * @return A builder with the additional enumeration property.
&nbsp;         */
&nbsp;        public Builder define(String property, Enum&lt;?&gt; value) {
&nbsp;            return define(property, new EnumerationDescription.ForLoadedEnumeration(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional enumeration property.
&nbsp;         *
&nbsp;         * @param property        The name of the property to define.
&nbsp;         * @param enumerationType The type of the enumeration.
&nbsp;         * @param value           The enumeration value to define.
&nbsp;         * @return A builder with the additional enumeration property.
&nbsp;         */
&nbsp;        public Builder define(String property, TypeDescription enumerationType, String value) {
&nbsp;            return define(property, new EnumerationDescription.Latent(enumerationType, value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional enumeration property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    A description of the enumeration value to define.
&nbsp;         * @return A builder with the additional enumeration property.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public Builder define(String property, EnumerationDescription value) {
&nbsp;            return define(property, AnnotationValue.ForEnumerationDescription.&lt;Enum&gt;of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional annotation property.
&nbsp;         *
&nbsp;         * @param property   The name of the property to define.
&nbsp;         * @param annotation The annotation value to define.
&nbsp;         * @return A builder with the additional annotation property.
&nbsp;         */
&nbsp;        public Builder define(String property, Annotation annotation) {
&nbsp;            return define(property, new ForLoadedAnnotation&lt;Annotation&gt;(annotation));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional annotation property.
&nbsp;         *
&nbsp;         * @param property              The name of the property to define.
&nbsp;         * @param annotationDescription A description of the annotation value to define.
&nbsp;         * @return A builder with the additional annotation property.
&nbsp;         */
&nbsp;        public Builder define(String property, AnnotationDescription annotationDescription) {
&nbsp;            return define(property, new AnnotationValue.ForAnnotationDescription&lt;Annotation&gt;(annotationDescription));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional class property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param type     The class value to define.
&nbsp;         * @return A builder with the additional class property.
&nbsp;         */
&nbsp;        public Builder define(String property, Class&lt;?&gt; type) {
&nbsp;            return define(property, TypeDescription.ForLoadedType.of(type));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional class property.
&nbsp;         *
&nbsp;         * @param property        The name of the property to define.
&nbsp;         * @param typeDescription A description of the type to define as a property value.
&nbsp;         * @return A builder with the additional class property.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public Builder define(String property, TypeDescription typeDescription) {
&nbsp;            return define(property, AnnotationValue.ForTypeDescription.&lt;Class&gt;of(typeDescription));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional enumeration array property.
&nbsp;         *
&nbsp;         * @param property        The name of the property to define.
&nbsp;         * @param enumerationType The type of the enumeration, i.e. the component type of the enumeration array.
&nbsp;         * @param value           The enumeration values to be contained by the array.
&nbsp;         * @param &lt;T&gt;             The enumeration type.
&nbsp;         * @return A builder with the additional class property.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public &lt;T extends Enum&lt;?&gt;&gt; Builder defineEnumerationArray(String property, Class&lt;T&gt; enumerationType, T... value) {
&nbsp;            EnumerationDescription[] enumerationDescription = new EnumerationDescription[value.length];
&nbsp;            int index = 0;
&nbsp;            for (T aValue : value) {
&nbsp;                enumerationDescription[index++] = new EnumerationDescription.ForLoadedEnumeration(aValue);
&nbsp;            }
&nbsp;            return defineEnumerationArray(property, TypeDescription.ForLoadedType.of(enumerationType), enumerationDescription);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional enumeration array property.
&nbsp;         *
&nbsp;         * @param property        The name of the property to define.
&nbsp;         * @param enumerationType The type of the enumerations, i.e. is the component type of the enumeration array.
&nbsp;         * @param value           The enumeration values to be contained by the array.
&nbsp;         * @return A builder with the additional enumeration property.
&nbsp;         */
&nbsp;        public Builder defineEnumerationArray(String property, TypeDescription enumerationType, String... value) {
&nbsp;            if (!enumerationType.isEnum()) {
&nbsp;                throw new IllegalArgumentException(&quot;Not an enumeration type: &quot; + enumerationType);
&nbsp;            }
&nbsp;            EnumerationDescription[] enumerationDescription = new EnumerationDescription[value.length];
&nbsp;            for (int i = 0; i &lt; value.length; i++) {
&nbsp;                enumerationDescription[i] = new EnumerationDescription.Latent(enumerationType, value[i]);
&nbsp;            }
&nbsp;            return defineEnumerationArray(property, enumerationType, enumerationDescription);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional enumeration array property.
&nbsp;         *
&nbsp;         * @param property        The name of the property to define.
&nbsp;         * @param enumerationType The type of the enumerations, i.e. the component type of the enumeration array.
&nbsp;         * @param value           Descriptions of the enumerations to be contained by the array.
&nbsp;         * @return A builder with the additional enumeration property.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public Builder defineEnumerationArray(String property, TypeDescription enumerationType, EnumerationDescription... value) {
&nbsp;            return define(property, AnnotationValue.ForDescriptionArray.&lt;Enum&gt;of(enumerationType, value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional annotation array property.
&nbsp;         *
&nbsp;         * @param property       The name of the property to define.
&nbsp;         * @param annotationType The type of the annotations, i.e. the component type of the enumeration array.
&nbsp;         * @param annotation     The annotation values to be contained by the array.
&nbsp;         * @param &lt;T&gt;            The annotation type.
&nbsp;         * @return A builder with the additional annotation property.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public &lt;T extends Annotation&gt; Builder defineAnnotationArray(String property, Class&lt;T&gt; annotationType, T... annotation) {
&nbsp;            return defineAnnotationArray(property,
&nbsp;                    TypeDescription.ForLoadedType.of(annotationType),
&nbsp;                    new AnnotationList.ForLoadedAnnotations(annotation).toArray(new AnnotationDescription[annotation.length]));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional annotation array property.
&nbsp;         *
&nbsp;         * @param property              The name of the property to define.
&nbsp;         * @param annotationType        The type of the annotations, i.e. the component type of the enumeration array.
&nbsp;         * @param annotationDescription Descriptions of the annotation values to be contained by the array.
&nbsp;         * @return A builder with the additional annotation property.
&nbsp;         */
&nbsp;        public Builder defineAnnotationArray(String property, TypeDescription annotationType, AnnotationDescription... annotationDescription) {
&nbsp;            return define(property, AnnotationValue.ForDescriptionArray.of(annotationType, annotationDescription));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional type array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param type     The types that should be contained by the array.
&nbsp;         * @return A builder with the additional type array property.
&nbsp;         */
&nbsp;        public Builder defineTypeArray(String property, Class&lt;?&gt;... type) {
&nbsp;            return defineTypeArray(property, new TypeList.ForLoadedTypes(type).toArray(new TypeDescription[type.length]));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional type array property.
&nbsp;         *
&nbsp;         * @param property        The name of the property to define.
&nbsp;         * @param typeDescription Descriptions of the types that should be contained by the array.
&nbsp;         * @return A builder with the additional type array property.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public Builder defineTypeArray(String property, TypeDescription... typeDescription) {
&nbsp;            return define(property, AnnotationValue.ForDescriptionArray.of(typeDescription));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code boolean} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code boolean} value to define for the property.
&nbsp;         * @return A builder with the additional {@code boolean} property.
&nbsp;         */
&nbsp;        public Builder define(String property, boolean value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code byte} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code byte} value to define for the property.
&nbsp;         * @return A builder with the additional {@code byte} property.
&nbsp;         */
&nbsp;        public Builder define(String property, byte value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code char} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code char} value to define for the property.
&nbsp;         * @return A builder with the additional {@code char} property.
&nbsp;         */
&nbsp;        public Builder define(String property, char value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code short} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code short} value to define for the property.
&nbsp;         * @return A builder with the additional {@code short} property.
&nbsp;         */
&nbsp;        public Builder define(String property, short value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code int} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code int} value to define for the property.
&nbsp;         * @return A builder with the additional {@code int} property.
&nbsp;         */
&nbsp;        public Builder define(String property, int value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code long} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code long} value to define for the property.
&nbsp;         * @return A builder with the additional {@code long} property.
&nbsp;         */
&nbsp;        public Builder define(String property, long value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code float} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code float} value to define for the property.
&nbsp;         * @return A builder with the additional {@code float} property.
&nbsp;         */
&nbsp;        public Builder define(String property, float value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code double} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code double} value to define for the property.
&nbsp;         * @return A builder with the additional {@code double} property.
&nbsp;         */
&nbsp;        public Builder define(String property, double value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@link java.lang.String} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@link java.lang.String} value to define for the property.
&nbsp;         * @return A builder with the additional {@link java.lang.String} property.
&nbsp;         */
&nbsp;        public Builder define(String property, String value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code boolean} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code boolean} values to define for the property.
&nbsp;         * @return A builder with the additional {@code boolean} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, boolean... value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code byte} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code byte} values to define for the property.
&nbsp;         * @return A builder with the additional {@code byte} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, byte... value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code char} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code char} values to define for the property.
&nbsp;         * @return A builder with the additional {@code char} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, char... value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code short} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code short} values to define for the property.
&nbsp;         * @return A builder with the additional {@code short} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, short... value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code int} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code int} values to define for the property.
&nbsp;         * @return A builder with the additional {@code int} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, int... value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code long} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code long} values to define for the property.
&nbsp;         * @return A builder with the additional {@code long} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, long... value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code float} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code float} values to define for the property.
&nbsp;         * @return A builder with the additional {@code float} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, float... value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code double} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code double} values to define for the property.
&nbsp;         * @return A builder with the additional {@code double} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, double... value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@link java.lang.String} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@link java.lang.String} array value to define for the property.
&nbsp;         * @return A builder with the additional {@link java.lang.String} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, String... value) {
&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation description for the values that were defined for this builder.
&nbsp;         *
&nbsp;         * @return An appropriate annotation description.
&nbsp;         */
&nbsp;        public AnnotationDescription build() {
&nbsp;            for (MethodDescription methodDescription : annotationType.getDeclaredMethods()) {
&nbsp;                if (annotationValues.get(methodDescription.getName()) == null &amp;&amp; methodDescription.getDefaultValue() == null) {
&nbsp;                    throw new IllegalStateException(&quot;No value or default value defined for &quot; + methodDescription.getName());
&nbsp;                }
&nbsp;            }
&nbsp;            return new Latent(annotationType, annotationValues);
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
