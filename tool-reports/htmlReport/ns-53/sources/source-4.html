


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > AnnotationValue</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.annotation</a>
</div>

<h1>Coverage Summary for Class: AnnotationValue (net.bytebuddy.description.annotation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AnnotationValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AnnotationValue$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant</td>
<td class="coverageStat">
  <span class="percent">
    28%
  </span>
  <span class="absValue">
    (7/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26,2%
  </span>
  <span class="absValue">
    (11/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31,7%
  </span>
  <span class="absValue">
    (20/63)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84,6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$4</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$5</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$6</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$7</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$8</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$9</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForEnumerationDescription</td>
<td class="coverageStat">
  <span class="percent">
    42,9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    44,4%
  </span>
  <span class="absValue">
    (4/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForTypeDescription</td>
<td class="coverageStat">
  <span class="percent">
    57,1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62,5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$Loaded</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    43,9%
  </span>
  <span class="absValue">
    (29/66)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20,4%
  </span>
  <span class="absValue">
    (11/54)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    44,4%
  </span>
  <span class="absValue">
    (52/117)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.description.annotation;
&nbsp;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.Array;
&nbsp;import java.util.*;
&nbsp;
&nbsp;/**
&nbsp; * Representation of an unloaded annotation value where all values represent either:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;Primitive values (as their wrappers), {@link String}s or arrays of primitive types or strings.&lt;/li&gt;
&nbsp; * &lt;li&gt;A {@link TypeDescription} or an array of such a descriptions.&lt;/li&gt;
&nbsp; * &lt;li&gt;An {@link EnumerationDescription} or an array of such a description.&lt;/li&gt;
&nbsp; * &lt;li&gt;An {@link AnnotationDescription} or an array of such a description.&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * The represented values are not necessarily resolvable, i.e. can contain non-available types, unknown enumeration
&nbsp; * constants or inconsistent annotations.
&nbsp; *
&nbsp; * @param &lt;T&gt; The represented value&#39;s unloaded type.
&nbsp; * @param &lt;S&gt; The represented value&#39;s  loaded type.
&nbsp; */
&nbsp;public interface AnnotationValue&lt;T, S&gt; {
&nbsp;
&nbsp;    /**
&nbsp;     * An undefined annotation value.
&nbsp;     */
<b class="fc">&nbsp;    AnnotationValue&lt;?, ?&gt; UNDEFINED = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves the unloaded value of this annotation.
&nbsp;     *
&nbsp;     * @return The unloaded value of this annotation.
&nbsp;     */
&nbsp;    T resolve();
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves the unloaded value of this annotation.
&nbsp;     *
&nbsp;     * @param type The annotation value&#39;s unloaded type.
&nbsp;     * @param &lt;W&gt;  The annotation value&#39;s unloaded type.
&nbsp;     * @return The unloaded value of this annotation.
&nbsp;     */
&nbsp;    &lt;W&gt; W resolve(Class&lt;? extends W&gt; type);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the loaded value of this annotation.
&nbsp;     *
&nbsp;     * @param classLoader The class loader for loading this value.
&nbsp;     * @return The loaded value of this annotation.
&nbsp;     * @throws ClassNotFoundException If a type that represents a loaded value cannot be found.
&nbsp;     */
&nbsp;    Loaded&lt;S&gt; load(ClassLoader classLoader) throws ClassNotFoundException;
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the loaded value of this annotation without throwing a checked exception.
&nbsp;     *
&nbsp;     * @param classLoader The class loader for loading this value.
&nbsp;     * @return The loaded value of this annotation.
&nbsp;     */
&nbsp;    Loaded&lt;S&gt; loadSilent(ClassLoader classLoader);
&nbsp;
&nbsp;    /**
&nbsp;     * A rendering dispatcher is responsible for resolving annotation values to {@link String} representations.
&nbsp;     */
&nbsp;    enum RenderingDispatcher {
&nbsp;
&nbsp;        /**
&nbsp;         * A rendering dispatcher for any VM previous to Java 9.
&nbsp;         */
&nbsp;        LEGACY_VM(&#39;[&#39;, &#39;]&#39;) {
&nbsp;            @Override
&nbsp;            public String toSourceString(char value) {
&nbsp;                return Character.toString(value);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(long value) {
&nbsp;                return Long.toString(value);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(float value) {
&nbsp;                return Float.toString(value);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(double value) {
&nbsp;                return Double.toString(value);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(String value) {
&nbsp;                return value;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(TypeDescription value) {
&nbsp;                return value.toString();
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A rendering dispatcher for Java 9 onward.
&nbsp;         */
&nbsp;        JAVA_9_CAPABLE_VM(&#39;{&#39;, &#39;}&#39;) {
&nbsp;            @Override
&nbsp;            public String toSourceString(char value) {
&nbsp;                StringBuilder stringBuilder = new StringBuilder().append(&#39;\&#39;&#39;);
&nbsp;                if (value == &#39;\&#39;&#39;) {
&nbsp;                    stringBuilder.append(&quot;\\\&#39;&quot;);
&nbsp;                } else {
&nbsp;                    stringBuilder.append(value);
&nbsp;                }
&nbsp;                return stringBuilder.append(&#39;\&#39;&#39;).toString();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(long value) {
&nbsp;                return Math.abs(value) &lt;= Integer.MAX_VALUE
&nbsp;                        ? String.valueOf(value)
&nbsp;                        : value + &quot;L&quot;;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(float value) {
&nbsp;                return Math.abs(value) &lt;= Float.MAX_VALUE // Float.isFinite(value)
&nbsp;                        ? Float.toString(value) + &quot;f&quot;
&nbsp;                        : (Float.isInfinite(value) ? (value &lt; 0.0f ? &quot;-1.0f/0.0f&quot; : &quot;1.0f/0.0f&quot;) : &quot;0.0f/0.0f&quot;);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(double value) {
&nbsp;                return Math.abs(value) &lt;= Double.MAX_VALUE // Double.isFinite(value)
&nbsp;                        ? Double.toString(value)
&nbsp;                        : (Double.isInfinite(value) ? (value &lt; 0.0d ? &quot;-1.0/0.0&quot; : &quot;1.0/0.0&quot;) : &quot;0.0/0.0&quot;);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(String value) {
&nbsp;                return &quot;\&quot;&quot; + (value.indexOf(&#39;&quot;&#39;) == -1
&nbsp;                        ? value
&nbsp;                        : value.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)) + &quot;\&quot;&quot;;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(TypeDescription value) {
&nbsp;                return value.getActualName() + &quot;.class&quot;;
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * The rendering dispatcher for the current VM.
&nbsp;         */
&nbsp;        public static final RenderingDispatcher CURRENT = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V6).isAtLeast(ClassFileVersion.JAVA_V9)
&nbsp;                ? JAVA_9_CAPABLE_VM
&nbsp;                : LEGACY_VM;
&nbsp;
&nbsp;        /**
&nbsp;         * The opening brace of an array {@link String} representation.
&nbsp;         */
&nbsp;        private final char openingBrace;
&nbsp;
&nbsp;        /**
&nbsp;         * The closing brace of an array {@link String} representation.
&nbsp;         */
&nbsp;        private final char closingBrace;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new rendering dispatcher.
&nbsp;         *
&nbsp;         * @param openingBrace The opening brace of an array {@link String} representation.
&nbsp;         * @param closingBrace The closing brace of an array {@link String} representation.
&nbsp;         */
&nbsp;        RenderingDispatcher(char openingBrace, char closingBrace) {
&nbsp;            this.openingBrace = openingBrace;
&nbsp;            this.closingBrace = closingBrace;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code boolean} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code boolean} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public String toSourceString(boolean value) {
&nbsp;            return Boolean.toString(value);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code boolean} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code boolean} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public String toSourceString(byte value) {
&nbsp;            return Byte.toString(value);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code short} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code short} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public String toSourceString(short value) {
&nbsp;            return Short.toString(value);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code char} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code char} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public abstract String toSourceString(char value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code int} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code int} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public String toSourceString(int value) {
&nbsp;            return Integer.toString(value);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code long} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code long} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public abstract String toSourceString(long value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code float} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code float} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public abstract String toSourceString(float value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code double} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code double} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public abstract String toSourceString(double value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@link String} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@link String} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public abstract String toSourceString(String value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@link TypeDescription} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@link TypeDescription} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public abstract String toSourceString(TypeDescription value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied list elements as a {@link String}.
&nbsp;         *
&nbsp;         * @param values The elements to render where each element is represented by its {@link Object#toString()} representation.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public String toSourceString(List&lt;?&gt; values) {
&nbsp;            StringBuilder stringBuilder = new StringBuilder().append(openingBrace);
&nbsp;            boolean first = true;
&nbsp;            for (Object value : values) {
&nbsp;                if (first) {
&nbsp;                    first = false;
&nbsp;                } else {
&nbsp;                    stringBuilder.append(&quot;, &quot;);
&nbsp;                }
&nbsp;                stringBuilder.append(value);
&nbsp;            }
&nbsp;            return stringBuilder.append(closingBrace).toString();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A loaded variant of an {@link AnnotationValue}. While
&nbsp;     * implementations of this value are required to be processed successfully by a
&nbsp;     * {@link java.lang.ClassLoader} they might still be unresolved. Typical errors on loading an annotation
&nbsp;     * value are:
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;{@link java.lang.annotation.IncompleteAnnotationException}: An annotation does not define a value
&nbsp;     * even though no default value for a property is provided.&lt;/li&gt;
&nbsp;     * &lt;li&gt;{@link java.lang.EnumConstantNotPresentException}: An annotation defines an unknown value for
&nbsp;     * a known enumeration.&lt;/li&gt;
&nbsp;     * &lt;li&gt;{@link java.lang.annotation.AnnotationTypeMismatchException}: An annotation property is not
&nbsp;     * of the expected type.&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * Implementations of this interface must implement methods for {@link Object#hashCode()} and
&nbsp;     * {@link Object#toString()} that resemble those used for the annotation values of an actual
&nbsp;     * {@link java.lang.annotation.Annotation} implementation. Also, instances must implement
&nbsp;     * {@link java.lang.Object#equals(Object)} to return {@code true} for other instances of
&nbsp;     * this interface that represent the same annotation value.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The represented value&#39;s type.
&nbsp;     */
&nbsp;    interface Loaded&lt;U&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the state of the represented loaded annotation value.
&nbsp;         *
&nbsp;         * @return The state represented by this instance.
&nbsp;         */
&nbsp;        State getState();
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the value to the actual value of an annotation. Calling this method might throw a runtime
&nbsp;         * exception if this value is either not defined or not resolved.
&nbsp;         *
&nbsp;         * @return The actual annotation value represented by this instance.
&nbsp;         */
&nbsp;        U resolve();
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the value to the actual value of an annotation. Calling this method might throw a runtime
&nbsp;         * exception if this value is either not defined or not resolved.
&nbsp;         *
&nbsp;         * @param type The value&#39;s loaded type.
&nbsp;         * @param &lt;V&gt;  The value&#39;s loaded type.
&nbsp;         * @return The actual annotation value represented by this instance.
&nbsp;         */
&nbsp;        &lt;V&gt; V resolve(Class&lt;? extends V&gt; type);
&nbsp;
&nbsp;        /**
&nbsp;         * Verifies if this loaded value represents the supplied loaded value.
&nbsp;         *
&nbsp;         * @param value A loaded annotation value.
&nbsp;         * @return {@code true} if the supplied annotation value is represented by this annotation value.
&nbsp;         */
&nbsp;        boolean represents(Object value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the state of a {@link Loaded} annotation property.
&nbsp;         */
&nbsp;        enum State {
&nbsp;
&nbsp;            /**
&nbsp;             * An undefined annotation value describes an annotation property which is missing such that
&nbsp;             * an {@link java.lang.annotation.IncompleteAnnotationException} would be thrown.
&nbsp;             */
&nbsp;            UNDEFINED,
&nbsp;
&nbsp;            /**
&nbsp;             * An unresolved annotation value describes an annotation property which does not represent a
&nbsp;             * valid value but an exceptional state.
&nbsp;             */
&nbsp;            UNRESOLVED,
&nbsp;
&nbsp;            /**
&nbsp;             * A resolved annotation value describes an annotation property with an actual value.
&nbsp;             */
&nbsp;            RESOLVED;
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if the related annotation value is defined, i.e. either represents
&nbsp;             * an actual value or an exceptional state.
&nbsp;             *
&nbsp;             * @return {@code true} if the related annotation value is defined.
&nbsp;             */
&nbsp;            public boolean isDefined() {
&nbsp;                return this != UNDEFINED;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if the related annotation value is resolved, i.e. represents an actual
&nbsp;             * value.
&nbsp;             *
&nbsp;             * @return {@code true} if the related annotation value is resolved.
&nbsp;             */
&nbsp;            public boolean isResolved() {
&nbsp;                return this == RESOLVED;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a loaded annotation value.
&nbsp;         *
&nbsp;         * @param &lt;W&gt; The represented loaded type.
&nbsp;         */
&nbsp;        abstract class AbstractBase&lt;W&gt; implements Loaded&lt;W&gt; {
&nbsp;
&nbsp;            @Override
&nbsp;            public &lt;X&gt; X resolve(Class&lt;? extends X&gt; type) {
&nbsp;                return type.cast(resolve());
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract base implementation of an unloaded annotation value.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The represented unloaded type.
&nbsp;     * @param &lt;V&gt; The represented loaded type.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase&lt;U, V&gt; implements AnnotationValue&lt;U, V&gt; {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public &lt;W&gt; W resolve(Class&lt;? extends W&gt; type) {
<b class="fc">&nbsp;            return type.cast(resolve());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Loaded&lt;V&gt; loadSilent(ClassLoader classLoader) {
&nbsp;            try {
<b class="nc">&nbsp;                return load(classLoader);</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot load &quot; + this, exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a primitive value, a {@link java.lang.String} or an array of the latter types.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The type where primitive values are represented by their boxed type.
&nbsp;     */
&nbsp;    class ForConstant&lt;U&gt; extends AbstractBase&lt;U, U&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The represented value.
&nbsp;         */
&nbsp;        private final U value;
&nbsp;
&nbsp;        /**
&nbsp;         * The property delegate for the value&#39;s type.
&nbsp;         */
&nbsp;        private final PropertyDelegate propertyDelegate;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new constant annotation value.
&nbsp;         *
&nbsp;         * @param value            The represented value.
&nbsp;         * @param propertyDelegate The property delegate for the value&#39;s type.
&nbsp;         */
<b class="fc">&nbsp;        protected ForConstant(U value, PropertyDelegate propertyDelegate) {</b>
<b class="fc">&nbsp;            this.value = value;</b>
<b class="fc">&nbsp;            this.propertyDelegate = propertyDelegate;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code boolean} value.
&nbsp;         *
&nbsp;         * @param value The {@code boolean} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Boolean, Boolean&gt; of(boolean value) {
<b class="fc">&nbsp;            return new ForConstant&lt;Boolean&gt;(value, PropertyDelegate.ForNonArrayType.BOOLEAN);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code byte} value.
&nbsp;         *
&nbsp;         * @param value The {@code byte} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Byte, Byte&gt; of(byte value) {
<b class="nc">&nbsp;            return new ForConstant&lt;Byte&gt;(value, PropertyDelegate.ForNonArrayType.BYTE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code short} value.
&nbsp;         *
&nbsp;         * @param value The {@code short} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Short, Short&gt; of(short value) {
<b class="nc">&nbsp;            return new ForConstant&lt;Short&gt;(value, PropertyDelegate.ForNonArrayType.SHORT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code char} value.
&nbsp;         *
&nbsp;         * @param value The {@code char} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Character, Character&gt; of(char value) {
<b class="nc">&nbsp;            return new ForConstant&lt;Character&gt;(value, PropertyDelegate.ForNonArrayType.CHARACTER);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code int} value.
&nbsp;         *
&nbsp;         * @param value The {@code int} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Integer, Integer&gt; of(int value) {
<b class="fc">&nbsp;            return new ForConstant&lt;Integer&gt;(value, PropertyDelegate.ForNonArrayType.INTEGER);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code long} value.
&nbsp;         *
&nbsp;         * @param value The {@code long} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Long, Long&gt; of(long value) {
<b class="nc">&nbsp;            return new ForConstant&lt;Long&gt;(value, PropertyDelegate.ForNonArrayType.LONG);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code float} value.
&nbsp;         *
&nbsp;         * @param value The {@code float} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Float, Float&gt; of(float value) {
<b class="nc">&nbsp;            return new ForConstant&lt;Float&gt;(value, PropertyDelegate.ForNonArrayType.FLOAT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code double} value.
&nbsp;         *
&nbsp;         * @param value The {@code double} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Double, Double&gt; of(double value) {
<b class="nc">&nbsp;            return new ForConstant&lt;Double&gt;(value, PropertyDelegate.ForNonArrayType.DOUBLE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@link String} value.
&nbsp;         *
&nbsp;         * @param value The {@link String} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;String, String&gt; of(String value) {
<b class="fc">&nbsp;            return new ForConstant&lt;String&gt;(value, PropertyDelegate.ForNonArrayType.STRING);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code boolean[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code boolean[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;boolean[], boolean[]&gt; of(boolean... value) {
<b class="nc">&nbsp;            return new ForConstant&lt;boolean[]&gt;(value, PropertyDelegate.ForArrayType.BOOLEAN);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code byte[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code byte[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;byte[], byte[]&gt; of(byte... value) {
<b class="nc">&nbsp;            return new ForConstant&lt;byte[]&gt;(value, PropertyDelegate.ForArrayType.BYTE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code short[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code short[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;short[], short[]&gt; of(short... value) {
<b class="nc">&nbsp;            return new ForConstant&lt;short[]&gt;(value, PropertyDelegate.ForArrayType.SHORT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code char[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code char[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;char[], char[]&gt; of(char... value) {
<b class="nc">&nbsp;            return new ForConstant&lt;char[]&gt;(value, PropertyDelegate.ForArrayType.CHARACTER);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code int[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code int[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;int[], int[]&gt; of(int... value) {
<b class="nc">&nbsp;            return new ForConstant&lt;int[]&gt;(value, PropertyDelegate.ForArrayType.INTEGER);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code long[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code long[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;long[], long[]&gt; of(long... value) {
<b class="nc">&nbsp;            return new ForConstant&lt;long[]&gt;(value, PropertyDelegate.ForArrayType.LONG);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code float[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code float[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;float[], float[]&gt; of(float... value) {
<b class="nc">&nbsp;            return new ForConstant&lt;float[]&gt;(value, PropertyDelegate.ForArrayType.FLOAT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code double[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code double[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;double[], double[]&gt; of(double... value) {
<b class="nc">&nbsp;            return new ForConstant&lt;double[]&gt;(value, PropertyDelegate.ForArrayType.DOUBLE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code String[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code String[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;String[], String[]&gt; of(String... value) {
<b class="nc">&nbsp;            return new ForConstant&lt;String[]&gt;(value, PropertyDelegate.ForArrayType.STRING);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for any constant value, i.e any primitive (wrapper) type,
&nbsp;         * any primitive array type or any {@link String} value or array. If no constant annotation
&nbsp;         * type is provided, a runtime exception is thrown.
&nbsp;         *
&nbsp;         * @param value The value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;?, ?&gt; of(Object value) {
<b class="fc">&nbsp;            if (value instanceof Boolean) {</b>
<b class="fc">&nbsp;                return of(((Boolean) value).booleanValue());</b>
<b class="pc">&nbsp;            } else if (value instanceof Byte) {</b>
<b class="nc">&nbsp;                return of(((Byte) value).byteValue());</b>
<b class="pc">&nbsp;            } else if (value instanceof Short) {</b>
<b class="nc">&nbsp;                return of(((Short) value).shortValue());</b>
<b class="pc">&nbsp;            } else if (value instanceof Character) {</b>
<b class="nc">&nbsp;                return of(((Character) value).charValue());</b>
<b class="fc">&nbsp;            } else if (value instanceof Integer) {</b>
<b class="fc">&nbsp;                return of(((Integer) value).intValue());</b>
<b class="pc">&nbsp;            } else if (value instanceof Long) {</b>
<b class="nc">&nbsp;                return of(((Long) value).longValue());</b>
<b class="pc">&nbsp;            } else if (value instanceof Float) {</b>
<b class="nc">&nbsp;                return of(((Float) value).floatValue());</b>
<b class="pc">&nbsp;            } else if (value instanceof Double) {</b>
<b class="nc">&nbsp;                return of(((Double) value).doubleValue());</b>
<b class="pc">&nbsp;            } else if (value instanceof String) {</b>
<b class="fc">&nbsp;                return of((String) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof boolean[]) {</b>
<b class="nc">&nbsp;                return of((boolean[]) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof byte[]) {</b>
<b class="nc">&nbsp;                return of((byte[]) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof short[]) {</b>
<b class="nc">&nbsp;                return of((short[]) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof char[]) {</b>
<b class="nc">&nbsp;                return of((char[]) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof int[]) {</b>
<b class="nc">&nbsp;                return of((int[]) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof long[]) {</b>
<b class="nc">&nbsp;                return of((long[]) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof float[]) {</b>
<b class="nc">&nbsp;                return of((float[]) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof double[]) {</b>
<b class="nc">&nbsp;                return of((double[]) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof String[]) {</b>
<b class="nc">&nbsp;                return of((String[]) value);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not a constant annotation value: &quot; + value);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public U resolve() {
<b class="fc">&nbsp;            return value;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationValue.Loaded&lt;U&gt; load(ClassLoader classLoader) {
<b class="nc">&nbsp;            return new Loaded&lt;U&gt;(value, propertyDelegate);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
<b class="nc">&nbsp;            return this == other || other instanceof AnnotationValue&lt;?, ?&gt; &amp;&amp; propertyDelegate.equals(value, ((AnnotationValue&lt;?, ?&gt;) other).resolve());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return propertyDelegate.hashCode(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return propertyDelegate.toString(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A property delegate for a constant annotation value.
&nbsp;         */
&nbsp;        protected interface PropertyDelegate {
&nbsp;
&nbsp;            /**
&nbsp;             * Copies the provided value, if it is not immutable.
&nbsp;             *
&nbsp;             * @param value The value to copy.
&nbsp;             * @param &lt;S&gt;   The value&#39;s type.
&nbsp;             * @return A copy of the provided instance or the provided value, if it is immutable.
&nbsp;             */
&nbsp;            &lt;S&gt; S copy(S value);
&nbsp;
&nbsp;            /**
&nbsp;             * Computes the value&#39;s hash code.
&nbsp;             *
&nbsp;             * @param value The value for which to compute the hash code.
&nbsp;             * @return The hash code of the provided value.
&nbsp;             */
&nbsp;            int hashCode(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if another value is equal to a constant annotation value.
&nbsp;             *
&nbsp;             * @param self  The value that is represented as a constant annotation value.
&nbsp;             * @param other Any other value for which to determine equality.
&nbsp;             * @return {@code true} if the provided value is equal to the represented value.
&nbsp;             */
&nbsp;            boolean equals(Object self, Object other);
&nbsp;
&nbsp;            /**
&nbsp;             * Renders the supplied value as a {@link String}.
&nbsp;             *
&nbsp;             * @param value The value to render.
&nbsp;             * @return An appropriate {@link String} representation of the provided value.
&nbsp;             */
&nbsp;            String toString(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * A property delegate for a non-array type.
&nbsp;             */
<b class="fc">&nbsp;            enum ForNonArrayType implements PropertyDelegate {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code boolean} value.
&nbsp;                 */
<b class="fc">&nbsp;                BOOLEAN {</b>
&nbsp;                    @Override
&nbsp;                    public String toString(Object value) {
<b class="nc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Boolean) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code byte} value.
&nbsp;                 */
<b class="fc">&nbsp;                BYTE {</b>
&nbsp;                    @Override
&nbsp;                    public String toString(Object value) {
<b class="nc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Byte) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code short} value.
&nbsp;                 */
<b class="fc">&nbsp;                SHORT {</b>
&nbsp;                    @Override
&nbsp;                    public String toString(Object value) {
<b class="nc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Short) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code char} value.
&nbsp;                 */
<b class="fc">&nbsp;                CHARACTER {</b>
&nbsp;                    @Override
&nbsp;                    public String toString(Object value) {
<b class="nc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Character) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code int} value.
&nbsp;                 */
<b class="fc">&nbsp;                INTEGER {</b>
&nbsp;                    @Override
&nbsp;                    public String toString(Object value) {
<b class="nc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Integer) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code long} value.
&nbsp;                 */
<b class="fc">&nbsp;                LONG {</b>
&nbsp;                    @Override
&nbsp;                    public String toString(Object value) {
<b class="nc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Long) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code float} value.
&nbsp;                 */
<b class="fc">&nbsp;                FLOAT {</b>
&nbsp;                    @Override
&nbsp;                    public String toString(Object value) {
<b class="nc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Float) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code double} value.
&nbsp;                 */
<b class="fc">&nbsp;                DOUBLE {</b>
&nbsp;                    @Override
&nbsp;                    public String toString(Object value) {
<b class="nc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Double) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@link String} value.
&nbsp;                 */
<b class="fc">&nbsp;                STRING {</b>
&nbsp;                    @Override
&nbsp;                    public String toString(Object value) {
<b class="nc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((String) value);</b>
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                @Override
&nbsp;                public &lt;S&gt; S copy(S value) {
<b class="nc">&nbsp;                    return value;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int hashCode(Object value) {
<b class="fc">&nbsp;                    return value.hashCode();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean equals(Object self, Object other) {
<b class="nc">&nbsp;                    return self.equals(other);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A property delegate for an array type of a constant value.
&nbsp;             */
&nbsp;            enum ForArrayType implements PropertyDelegate {
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code boolean[]} value.
&nbsp;                 */
&nbsp;                BOOLEAN {
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((boolean[]) value).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((boolean[]) value);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof boolean[] &amp;&amp; Arrays.equals((boolean[]) self, (boolean[]) other);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return ForNonArrayType.BOOLEAN.toString(Array.getBoolean(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code byte[]} value.
&nbsp;                 */
&nbsp;                BYTE {
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((byte[]) value).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((byte[]) value);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof byte[] &amp;&amp; Arrays.equals((byte[]) self, (byte[]) other);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return ForNonArrayType.BYTE.toString(Array.getByte(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code short[]} value.
&nbsp;                 */
&nbsp;                SHORT {
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((short[]) value).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((short[]) value);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof short[] &amp;&amp; Arrays.equals((short[]) self, (short[]) other);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return ForNonArrayType.SHORT.toString(Array.getShort(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code char[]} value.
&nbsp;                 */
&nbsp;                CHARACTER {
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((char[]) value).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((char[]) value);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof char[] &amp;&amp; Arrays.equals((char[]) self, (char[]) other);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return ForNonArrayType.CHARACTER.toString(Array.getChar(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code int[]} value.
&nbsp;                 */
&nbsp;                INTEGER {
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((int[]) value).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((int[]) value);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof int[] &amp;&amp; Arrays.equals((int[]) self, (int[]) other);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return ForNonArrayType.INTEGER.toString(Array.getInt(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code long[]} value.
&nbsp;                 */
&nbsp;                LONG {
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((long[]) value).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((long[]) value);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof long[] &amp;&amp; Arrays.equals((long[]) self, (long[]) other);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return ForNonArrayType.LONG.toString(Array.getLong(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code float[]} value.
&nbsp;                 */
&nbsp;                FLOAT {
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((float[]) value).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((float[]) value);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof float[] &amp;&amp; Arrays.equals((float[]) self, (float[]) other);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return ForNonArrayType.FLOAT.toString(Array.getFloat(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code double[]} value.
&nbsp;                 */
&nbsp;                DOUBLE {
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((double[]) value).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((double[]) value);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof double[] &amp;&amp; Arrays.equals((double[]) self, (double[]) other);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return ForNonArrayType.DOUBLE.toString(Array.getDouble(array, index));
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code String[]} value.
&nbsp;                 */
&nbsp;                STRING {
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
&nbsp;                        return ((String[]) value).clone();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int hashCode(Object value) {
&nbsp;                        return Arrays.hashCode((String[]) value);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean equals(Object self, Object other) {
&nbsp;                        return other instanceof String[] &amp;&amp; Arrays.equals((String[]) self, (String[]) other);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
&nbsp;                        return ForNonArrayType.STRING.toString(Array.get(array, index));
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                @Override
&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                public &lt;S&gt; S copy(S value) {
&nbsp;                    return (S) doCopy(value);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a copy of the provided array.
&nbsp;                 *
&nbsp;                 * @param value The array to copy.
&nbsp;                 * @return A shallow copy of the provided array.
&nbsp;                 */
&nbsp;                protected abstract Object doCopy(Object value);
&nbsp;
&nbsp;                @Override
&nbsp;                public String toString(Object value) {
&nbsp;                    List&lt;String&gt; elements = new ArrayList&lt;String&gt;(Array.getLength(value));
&nbsp;                    for (int index = 0; index &lt; Array.getLength(value); index++) {
&nbsp;                        elements.add(toString(value, index));
&nbsp;                    }
&nbsp;                    return RenderingDispatcher.CURRENT.toSourceString(elements);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Renders the array element at the specified index.
&nbsp;                 *
&nbsp;                 * @param array The array for which an element should be rendered.
&nbsp;                 * @param index The index of the array element to render.
&nbsp;                 * @return A {@link String} representation of the array element at the supplied index.
&nbsp;                 */
&nbsp;                protected abstract String toString(Object array, int index);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a trivial loaded value.
&nbsp;         *
&nbsp;         * @param &lt;V&gt; The annotation properties type.
&nbsp;         */
&nbsp;        protected static class Loaded&lt;V&gt; extends AnnotationValue.Loaded.AbstractBase&lt;V&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented value.
&nbsp;             */
&nbsp;            private final V value;
&nbsp;
&nbsp;            /**
&nbsp;             * The property delegate for the value&#39;s type.
&nbsp;             */
&nbsp;            private final PropertyDelegate propertyDelegate;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new loaded representation of a constant value.
&nbsp;             *
&nbsp;             * @param value            The represented value.
&nbsp;             * @param propertyDelegate The property delegate for the value&#39;s type.
&nbsp;             */
&nbsp;            protected Loaded(V value, PropertyDelegate propertyDelegate) {
&nbsp;                this.value = value;
&nbsp;                this.propertyDelegate = propertyDelegate;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public State getState() {
&nbsp;                return State.RESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public V resolve() {
&nbsp;                return propertyDelegate.copy(value);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(Object value) {
&nbsp;                return propertyDelegate.equals(this.value, value);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
&nbsp;                return propertyDelegate.hashCode(value);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof AnnotationValue.Loaded&lt;?&gt;)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;                AnnotationValue.Loaded&lt;?&gt; annotationValue = (AnnotationValue.Loaded&lt;?&gt;) other;
&nbsp;                return annotationValue.getState().isResolved() &amp;&amp; propertyDelegate.equals(value, annotationValue.resolve());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
&nbsp;                return propertyDelegate.toString(value);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A description of an {@link java.lang.annotation.Annotation} as a value of another annotation.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The type of the annotation.
&nbsp;     */
&nbsp;    class ForAnnotationDescription&lt;U extends Annotation&gt; extends AbstractBase&lt;AnnotationDescription, U&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The annotation description that this value represents.
&nbsp;         */
&nbsp;        private final AnnotationDescription annotationDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new annotation value for a given annotation description.
&nbsp;         *
&nbsp;         * @param annotationDescription The annotation description that this value represents.
&nbsp;         */
&nbsp;        public ForAnnotationDescription(AnnotationDescription annotationDescription) {
&nbsp;            this.annotationDescription = annotationDescription;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value instance for describing the given annotation type and values.
&nbsp;         *
&nbsp;         * @param annotationType   The annotation type.
&nbsp;         * @param annotationValues The values of the annotation.
&nbsp;         * @param &lt;V&gt;              The type of the annotation.
&nbsp;         * @return An annotation value representing the given annotation.
&nbsp;         */
&nbsp;        public static &lt;V extends Annotation&gt; AnnotationValue&lt;AnnotationDescription, V&gt; of(TypeDescription annotationType,
&nbsp;                                                                                          Map&lt;String, ? extends AnnotationValue&lt;?, ?&gt;&gt; annotationValues) {
&nbsp;            return new ForAnnotationDescription&lt;V&gt;(new AnnotationDescription.Latent(annotationType, annotationValues));
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationDescription resolve() {
&nbsp;            return annotationDescription;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationValue.Loaded&lt;U&gt; load(ClassLoader classLoader) throws ClassNotFoundException {
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            Class&lt;U&gt; annotationType = (Class&lt;U&gt;) Class.forName(annotationDescription.getAnnotationType().getName(), false, classLoader);
&nbsp;            return new Loaded&lt;U&gt;(annotationDescription.prepare(annotationType).load());
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
&nbsp;            return this == other || other instanceof AnnotationValue&lt;?, ?&gt; &amp;&amp; annotationDescription.equals(((AnnotationValue&lt;?, ?&gt;) other).resolve());
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
&nbsp;            return annotationDescription.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
&nbsp;            return annotationDescription.toString();
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A loaded version of the described annotation.
&nbsp;         *
&nbsp;         * @param &lt;V&gt; The annotation type.
&nbsp;         */
&nbsp;        public static class Loaded&lt;V extends Annotation&gt; extends AnnotationValue.Loaded.AbstractBase&lt;V&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The loaded version of the represented annotation.
&nbsp;             */
&nbsp;            private final V annotation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a representation of a loaded annotation.
&nbsp;             *
&nbsp;             * @param annotation The represented annotation.
&nbsp;             */
&nbsp;            public Loaded(V annotation) {
&nbsp;                this.annotation = annotation;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public State getState() {
&nbsp;                return State.RESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public V resolve() {
&nbsp;                return annotation;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(Object value) {
&nbsp;                return annotation.equals(value);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof AnnotationValue.Loaded&lt;?&gt;)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;                AnnotationValue.Loaded&lt;?&gt; annotationValue = (AnnotationValue.Loaded&lt;?&gt;) other;
&nbsp;                return annotationValue.getState().isResolved() &amp;&amp; annotation.equals(annotationValue.resolve());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
&nbsp;                return annotation.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
&nbsp;                return annotation.toString();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Represents an annotation value which was attempted to ba loaded by a type that does not represent
&nbsp;         * an annotation value.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: Neither of {@link Object#hashCode()}, {@link Object#toString()} and
&nbsp;         * {@link java.lang.Object#equals(Object)} are implemented specifically what resembles the way
&nbsp;         * such exceptional states are represented in the Open JDK&#39;s annotation implementations.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        public static class IncompatibleRuntimeType extends AnnotationValue.Loaded.AbstractBase&lt;Annotation&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The incompatible runtime type which is not an annotation type.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt; incompatibleType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new representation for an annotation with an incompatible runtime type.
&nbsp;             *
&nbsp;             * @param incompatibleType The incompatible runtime type which is not an annotation type.
&nbsp;             */
&nbsp;            public IncompatibleRuntimeType(Class&lt;?&gt; incompatibleType) {
&nbsp;                this.incompatibleType = incompatibleType;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public State getState() {
&nbsp;                return State.UNRESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Annotation resolve() {
&nbsp;                throw new IncompatibleClassChangeError(&quot;Not an annotation type: &quot; + incompatibleType.toString());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(Object value) {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            /* does intentionally not implement hashCode, equals and toString */
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A description of an {@link java.lang.Enum} as a value of an annotation.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The type of the enumeration.
&nbsp;     */
&nbsp;    class ForEnumerationDescription&lt;U extends Enum&lt;U&gt;&gt; extends AbstractBase&lt;EnumerationDescription, U&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The enumeration that is represented.
&nbsp;         */
&nbsp;        private final EnumerationDescription enumerationDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new description of an annotation value for a given enumeration.
&nbsp;         *
&nbsp;         * @param enumerationDescription The enumeration that is to be represented.
&nbsp;         */
<b class="fc">&nbsp;        protected ForEnumerationDescription(EnumerationDescription enumerationDescription) {</b>
<b class="fc">&nbsp;            this.enumerationDescription = enumerationDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new annotation value for the given enumeration description.
&nbsp;         *
&nbsp;         * @param value The value to represent.
&nbsp;         * @param &lt;V&gt;   The type of the represented enumeration.
&nbsp;         * @return An annotation value that describes the given enumeration.
&nbsp;         */
&nbsp;        public static &lt;V extends Enum&lt;V&gt;&gt; AnnotationValue&lt;EnumerationDescription, V&gt; of(EnumerationDescription value) {
<b class="fc">&nbsp;            return new ForEnumerationDescription&lt;V&gt;(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EnumerationDescription resolve() {
<b class="nc">&nbsp;            return enumerationDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationValue.Loaded&lt;U&gt; load(ClassLoader classLoader) throws ClassNotFoundException {
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;            Class&lt;U&gt; enumerationType = (Class&lt;U&gt;) Class.forName(enumerationDescription.getEnumerationType().getName(), false, classLoader);</b>
<b class="nc">&nbsp;            return new Loaded&lt;U&gt;(enumerationDescription.load(enumerationType));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
<b class="nc">&nbsp;            return this == other || other instanceof AnnotationValue&lt;?, ?&gt; &amp;&amp; enumerationDescription.equals(((AnnotationValue&lt;?, ?&gt;) other).resolve());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return enumerationDescription.hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return enumerationDescription.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A loaded representation of an enumeration value.
&nbsp;         *
&nbsp;         * @param &lt;V&gt; The type of the represented enumeration.
&nbsp;         */
&nbsp;        public static class Loaded&lt;V extends Enum&lt;V&gt;&gt; extends AnnotationValue.Loaded.AbstractBase&lt;V&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented enumeration.
&nbsp;             */
&nbsp;            private final V enumeration;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a loaded version of an enumeration description.
&nbsp;             *
&nbsp;             * @param enumeration The represented enumeration.
&nbsp;             */
&nbsp;            public Loaded(V enumeration) {
&nbsp;                this.enumeration = enumeration;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public State getState() {
&nbsp;                return State.RESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public V resolve() {
&nbsp;                return enumeration;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(Object value) {
&nbsp;                return enumeration.equals(value);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof AnnotationValue.Loaded&lt;?&gt;)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;                AnnotationValue.Loaded&lt;?&gt; annotationValue = (AnnotationValue.Loaded&lt;?&gt;) other;
&nbsp;                return annotationValue.getState().isResolved() &amp;&amp; enumeration.equals(annotationValue.resolve());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
&nbsp;                return enumeration.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
&nbsp;                return enumeration.toString();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Represents an annotation&#39;s enumeration value for a constant that does not exist for the runtime
&nbsp;         * enumeration type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: Neither of {@link Object#hashCode()}, {@link Object#toString()} and
&nbsp;         * {@link java.lang.Object#equals(Object)} are implemented specifically what resembles the way
&nbsp;         * such exceptional states are represented in the Open JDK&#39;s annotation implementations.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        public static class UnknownRuntimeEnumeration extends AnnotationValue.Loaded.AbstractBase&lt;Enum&lt;?&gt;&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The loaded enumeration type.
&nbsp;             */
&nbsp;            private final Class&lt;? extends Enum&lt;?&gt;&gt; enumType;
&nbsp;
&nbsp;            /**
&nbsp;             * The value for which no enumeration constant exists at runtime.
&nbsp;             */
&nbsp;            private final String value;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new representation for an unknown enumeration constant of an annotation.
&nbsp;             *
&nbsp;             * @param enumType The loaded enumeration type.
&nbsp;             * @param value    The value for which no enumeration constant exists at runtime.
&nbsp;             */
&nbsp;            public UnknownRuntimeEnumeration(Class&lt;? extends Enum&lt;?&gt;&gt; enumType, String value) {
&nbsp;                this.enumType = enumType;
&nbsp;                this.value = value;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public State getState() {
&nbsp;                return State.UNRESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Enum&lt;?&gt; resolve() {
&nbsp;                throw new EnumConstantNotPresentException(enumType, value);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(Object value) {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            /* hashCode, equals and toString are intentionally not implemented */
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Represents an annotation&#39;s enumeration value for a runtime type that is not an enumeration type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: Neither of {@link Object#hashCode()}, {@link Object#toString()} and
&nbsp;         * {@link java.lang.Object#equals(Object)} are implemented specifically what resembles the way
&nbsp;         * such exceptional states are represented in the Open JDK&#39;s annotation implementations.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        public static class IncompatibleRuntimeType extends AnnotationValue.Loaded.AbstractBase&lt;Enum&lt;?&gt;&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The runtime type which is not an enumeration type.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt; type;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new representation for an incompatible runtime type.
&nbsp;             *
&nbsp;             * @param type The runtime type which is not an enumeration type.
&nbsp;             */
&nbsp;            public IncompatibleRuntimeType(Class&lt;?&gt; type) {
&nbsp;                this.type = type;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public State getState() {
&nbsp;                return State.UNRESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Enum&lt;?&gt; resolve() {
&nbsp;                throw new IncompatibleClassChangeError(&quot;Not an enumeration type: &quot; + type.toString());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(Object value) {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            /* hashCode, equals and toString are intentionally not implemented */
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A description of a {@link java.lang.Class} as a value of an annotation.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The type of the {@link java.lang.Class} that is described.
&nbsp;     */
&nbsp;    class ForTypeDescription&lt;U extends Class&lt;U&gt;&gt; extends AbstractBase&lt;TypeDescription, U&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates to a class loading process that class initializers are not required to be executed when loading a type.
&nbsp;         */
&nbsp;        private static final boolean NO_INITIALIZATION = false;
&nbsp;
&nbsp;        /**
&nbsp;         * A description of the represented type.
&nbsp;         */
&nbsp;        private final TypeDescription typeDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new annotation value that represents a type.
&nbsp;         *
&nbsp;         * @param typeDescription The represented type.
&nbsp;         */
<b class="fc">&nbsp;        protected ForTypeDescription(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;            this.typeDescription = typeDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for representing the given type.
&nbsp;         *
&nbsp;         * @param typeDescription The type to represent.
&nbsp;         * @param &lt;V&gt;             The represented type.
&nbsp;         * @return An annotation value that represents the given type.
&nbsp;         */
&nbsp;        public static &lt;V extends Class&lt;V&gt;&gt; AnnotationValue&lt;TypeDescription, V&gt; of(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return new ForTypeDescription&lt;V&gt;(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription resolve() {
<b class="fc">&nbsp;            return typeDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public AnnotationValue.Loaded&lt;U&gt; load(ClassLoader classLoader) throws ClassNotFoundException {
<b class="nc">&nbsp;            return new Loaded&lt;U&gt;((U) Class.forName(typeDescription.getName(), NO_INITIALIZATION, classLoader));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
<b class="nc">&nbsp;            return this == other || other instanceof AnnotationValue&lt;?, ?&gt; &amp;&amp; typeDescription.equals(((AnnotationValue&lt;?, ?&gt;) other).resolve());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return typeDescription.hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return RenderingDispatcher.CURRENT.toSourceString(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A loaded annotation value for a given type.
&nbsp;         *
&nbsp;         * @param &lt;U&gt; The represented type.
&nbsp;         */
&nbsp;        protected static class Loaded&lt;U extends Class&lt;U&gt;&gt; extends AnnotationValue.Loaded.AbstractBase&lt;U&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented type.
&nbsp;             */
&nbsp;            private final U type;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new loaded annotation value for a given type.
&nbsp;             *
&nbsp;             * @param type The represented type.
&nbsp;             */
&nbsp;            public Loaded(U type) {
&nbsp;                this.type = type;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public State getState() {
&nbsp;                return State.RESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public U resolve() {
&nbsp;                return type;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(Object value) {
&nbsp;                return type.equals(value);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof AnnotationValue.Loaded&lt;?&gt;)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;                AnnotationValue.Loaded&lt;?&gt; annotationValue = (AnnotationValue.Loaded&lt;?&gt;) other;
&nbsp;                return annotationValue.getState().isResolved() &amp;&amp; type.equals(annotationValue.resolve());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
&nbsp;                return type.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
&nbsp;                return RenderingDispatcher.CURRENT.toSourceString(TypeDescription.ForLoadedType.of(type));
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Describes a complex array that is the value of an annotation. Complex arrays are arrays that might trigger the loading
&nbsp;     * of user-defined types, i.e. {@link java.lang.Class}, {@link java.lang.annotation.Annotation} and {@link java.lang.Enum}
&nbsp;     * instances.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The component type of the annotation&#39;s value when it is not loaded.
&nbsp;     * @param &lt;V&gt; The component type of the annotation&#39;s value when it is loaded.
&nbsp;     */
&nbsp;    class ForDescriptionArray&lt;U, V&gt; extends AbstractBase&lt;U[], V[]&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The component type for arrays containing unloaded versions of the annotation array&#39;s values.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; unloadedComponentType;
&nbsp;
&nbsp;        /**
&nbsp;         * A description of the component type when it is loaded.
&nbsp;         */
&nbsp;        private final TypeDescription componentType;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of values of the array elements.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new complex array.
&nbsp;         *
&nbsp;         * @param unloadedComponentType The component type for arrays containing unloaded versions of the annotation array&#39;s values.
&nbsp;         * @param componentType         A description of the component type when it is loaded.
&nbsp;         * @param values                A list of values of the array elements.
&nbsp;         */
&nbsp;        protected ForDescriptionArray(Class&lt;?&gt; unloadedComponentType,
&nbsp;                                      TypeDescription componentType,
&nbsp;                                      List&lt;? extends AnnotationValue&lt;?, ?&gt;&gt; values) {
&nbsp;            this.unloadedComponentType = unloadedComponentType;
&nbsp;            this.componentType = componentType;
&nbsp;            this.values = values;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new complex array of enumeration descriptions.
&nbsp;         *
&nbsp;         * @param enumerationType        A description of the type of the enumeration.
&nbsp;         * @param enumerationDescription An array of enumeration descriptions.
&nbsp;         * @param &lt;W&gt;                    The type of the enumeration.
&nbsp;         * @return A description of the array of enumeration values.
&nbsp;         */
&nbsp;        public static &lt;W extends Enum&lt;W&gt;&gt; AnnotationValue&lt;EnumerationDescription[], W[]&gt; of(TypeDescription enumerationType,
&nbsp;                                                                                            EnumerationDescription[] enumerationDescription) {
&nbsp;            List&lt;AnnotationValue&lt;EnumerationDescription, W&gt;&gt; values = new ArrayList&lt;AnnotationValue&lt;EnumerationDescription, W&gt;&gt;(enumerationDescription.length);
&nbsp;            for (EnumerationDescription value : enumerationDescription) {
&nbsp;                if (!value.getEnumerationType().equals(enumerationType)) {
&nbsp;                    throw new IllegalArgumentException(value + &quot; is not of &quot; + enumerationType);
&nbsp;                }
&nbsp;                values.add(ForEnumerationDescription.&lt;W&gt;of(value));
&nbsp;            }
&nbsp;            return new ForDescriptionArray&lt;EnumerationDescription, W&gt;(EnumerationDescription.class, enumerationType, values);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new complex array of annotation descriptions.
&nbsp;         *
&nbsp;         * @param annotationType        A description of the type of the annotation.
&nbsp;         * @param annotationDescription An array of annotation descriptions.
&nbsp;         * @param &lt;W&gt;                   The type of the annotation.
&nbsp;         * @return A description of the array of enumeration values.
&nbsp;         */
&nbsp;        public static &lt;W extends Annotation&gt; AnnotationValue&lt;AnnotationDescription[], W[]&gt; of(TypeDescription annotationType,
&nbsp;                                                                                              AnnotationDescription[] annotationDescription) {
&nbsp;            List&lt;AnnotationValue&lt;AnnotationDescription, W&gt;&gt; values = new ArrayList&lt;AnnotationValue&lt;AnnotationDescription, W&gt;&gt;(annotationDescription.length);
&nbsp;            for (AnnotationDescription value : annotationDescription) {
&nbsp;                if (!value.getAnnotationType().equals(annotationType)) {
&nbsp;                    throw new IllegalArgumentException(value + &quot; is not of &quot; + annotationType);
&nbsp;                }
&nbsp;                values.add(new ForAnnotationDescription&lt;W&gt;(value));
&nbsp;            }
&nbsp;            return new ForDescriptionArray&lt;AnnotationDescription, W&gt;(AnnotationDescription.class, annotationType, values);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new complex array of annotation descriptions.
&nbsp;         *
&nbsp;         * @param typeDescription A description of the types contained in the array.
&nbsp;         * @return A description of the array of enumeration values.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public static AnnotationValue&lt;TypeDescription[], Class&lt;?&gt;[]&gt; of(TypeDescription[] typeDescription) {
&nbsp;            List&lt;AnnotationValue&lt;TypeDescription, Class&lt;?&gt;&gt;&gt; values = new ArrayList&lt;AnnotationValue&lt;TypeDescription, Class&lt;?&gt;&gt;&gt;(typeDescription.length);
&nbsp;            for (TypeDescription value : typeDescription) {
&nbsp;                values.add((AnnotationValue) ForTypeDescription.&lt;Class&gt;of(value));
&nbsp;            }
&nbsp;            return new ForDescriptionArray&lt;TypeDescription, Class&lt;?&gt;&gt;(TypeDescription.class, TypeDescription.CLASS, values);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public U[] resolve() {
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            U[] resolved = (U[]) Array.newInstance(unloadedComponentType, values.size());
&nbsp;            int index = 0;
&nbsp;            for (AnnotationValue&lt;?, ?&gt; value : values) {
&nbsp;                Array.set(resolved, index++, value.resolve());
&nbsp;            }
&nbsp;            return resolved;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public AnnotationValue.Loaded&lt;V[]&gt; load(ClassLoader classLoader) throws ClassNotFoundException {
&nbsp;            List&lt;AnnotationValue.Loaded&lt;?&gt;&gt; values = new ArrayList&lt;AnnotationValue.Loaded&lt;?&gt;&gt;(this.values.size());
&nbsp;            for (AnnotationValue&lt;?, ?&gt; value : this.values) {
&nbsp;                values.add(value.load(classLoader));
&nbsp;            }
&nbsp;            return new Loaded&lt;V&gt;((Class&lt;V&gt;) Class.forName(componentType.getName(), false, classLoader), values);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof AnnotationValue&lt;?, ?&gt;)) {
&nbsp;                return false;
&nbsp;            }
&nbsp;            AnnotationValue&lt;?, ?&gt; annotationValue = (AnnotationValue&lt;?, ?&gt;) other;
&nbsp;            Object value = annotationValue.resolve();
&nbsp;            if (!(value instanceof Object[])) {
&nbsp;                return false;
&nbsp;            }
&nbsp;            Object[] arrayValue = (Object[]) value;
&nbsp;            if (values.size() != arrayValue.length) {
&nbsp;                return false;
&nbsp;            }
&nbsp;            Iterator&lt;? extends AnnotationValue&lt;?, ?&gt;&gt; iterator = values.iterator();
&nbsp;            for (Object aValue : arrayValue) {
&nbsp;                AnnotationValue&lt;?, ?&gt; self = iterator.next();
&nbsp;                if (!self.resolve().equals(aValue)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;            return true;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
&nbsp;            int result = 1;
&nbsp;            for (AnnotationValue&lt;?, ?&gt; value : values) {
&nbsp;                result = 31 * result + value.hashCode();
&nbsp;            }
&nbsp;            return result;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
&nbsp;            return RenderingDispatcher.CURRENT.toSourceString(values);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a loaded complex array.
&nbsp;         *
&nbsp;         * @param &lt;W&gt; The component type of the loaded array.
&nbsp;         */
&nbsp;        protected static class Loaded&lt;W&gt; extends AnnotationValue.Loaded.AbstractBase&lt;W[]&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The loaded component type of the array.
&nbsp;             */
&nbsp;            private final Class&lt;W&gt; componentType;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of loaded values that the represented array contains.
&nbsp;             */
&nbsp;            private final List&lt;AnnotationValue.Loaded&lt;?&gt;&gt; values;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new loaded value representing a complex array.
&nbsp;             *
&nbsp;             * @param componentType The loaded component type of the array.
&nbsp;             * @param values        A list of loaded values that the represented array contains.
&nbsp;             */
&nbsp;            protected Loaded(Class&lt;W&gt; componentType, List&lt;AnnotationValue.Loaded&lt;?&gt;&gt; values) {
&nbsp;                this.componentType = componentType;
&nbsp;                this.values = values;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public State getState() {
&nbsp;                for (AnnotationValue.Loaded&lt;?&gt; value : values) {
&nbsp;                    if (!value.getState().isResolved()) {
&nbsp;                        return State.UNRESOLVED;
&nbsp;                    }
&nbsp;                }
&nbsp;                return State.RESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public W[] resolve() {
&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                W[] array = (W[]) Array.newInstance(componentType, values.size());
&nbsp;                int index = 0;
&nbsp;                for (AnnotationValue.Loaded&lt;?&gt; annotationValue : values) {
&nbsp;                    Array.set(array, index++, annotationValue.resolve());
&nbsp;                }
&nbsp;                return array;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(Object value) {
&nbsp;                if (!(value instanceof Object[])) return false;
&nbsp;                if (value.getClass().getComponentType() != componentType) return false;
&nbsp;                Object[] array = (Object[]) value;
&nbsp;                if (values.size() != array.length) return false;
&nbsp;                Iterator&lt;AnnotationValue.Loaded&lt;?&gt;&gt; iterator = values.iterator();
&nbsp;                for (Object aValue : array) {
&nbsp;                    AnnotationValue.Loaded&lt;?&gt; self = iterator.next();
&nbsp;                    if (!self.represents(aValue)) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                }
&nbsp;                return true;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof AnnotationValue.Loaded&lt;?&gt;)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;                AnnotationValue.Loaded&lt;?&gt; annotationValue = (AnnotationValue.Loaded&lt;?&gt;) other;
&nbsp;                if (!annotationValue.getState().isResolved()) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;                Object value = annotationValue.resolve();
&nbsp;                if (!(value instanceof Object[])) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;                Object[] arrayValue = (Object[]) value;
&nbsp;                if (values.size() != arrayValue.length) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;                Iterator&lt;AnnotationValue.Loaded&lt;?&gt;&gt; iterator = values.iterator();
&nbsp;                for (Object aValue : arrayValue) {
&nbsp;                    AnnotationValue.Loaded&lt;?&gt; self = iterator.next();
&nbsp;                    if (!self.getState().isResolved() || !self.resolve().equals(aValue)) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                }
&nbsp;                return true;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
&nbsp;                int result = 1;
&nbsp;                for (AnnotationValue.Loaded&lt;?&gt; value : values) {
&nbsp;                    result = 31 * result + value.hashCode();
&nbsp;                }
&nbsp;                return result;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
&nbsp;                return RenderingDispatcher.CURRENT.toSourceString(values);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
