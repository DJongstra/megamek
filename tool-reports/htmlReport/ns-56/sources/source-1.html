


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MethodDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.method</a>
</div>

<h1>Coverage Summary for Class: MethodDescription (net.bytebuddy.description.method)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    57,9%
  </span>
  <span class="absValue">
    (22/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    17,2%
  </span>
  <span class="absValue">
    (70/408)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27,4%
  </span>
  <span class="absValue">
    (72/263)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$ForLoadedConstructor</td>
<td class="coverageStat">
  <span class="percent">
    77,8%
  </span>
  <span class="absValue">
    (14/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16,7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81%
  </span>
  <span class="absValue">
    (17/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$ForLoadedMethod</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (16/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37,5%
  </span>
  <span class="absValue">
    (6/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69,7%
  </span>
  <span class="absValue">
    (23/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (8/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InGenericShape</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Latent</td>
<td class="coverageStat">
  <span class="percent">
    91,7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93,9%
  </span>
  <span class="absValue">
    (31/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Latent$TypeInitializer</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90,9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$SignatureToken</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (7/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58,6%
  </span>
  <span class="absValue">
    (17/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token</td>
<td class="coverageStat">
  <span class="percent">
    83,3%
  </span>
  <span class="absValue">
    (15/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7,5%
  </span>
  <span class="absValue">
    (3/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58,1%
  </span>
  <span class="absValue">
    (36/62)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeSubstituting</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeToken</td>
<td class="coverageStat">
  <span class="percent">
    83,3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63,2%
  </span>
  <span class="absValue">
    (12/19)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    78,5%
  </span>
  <span class="absValue">
    (117/149)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    19,6%
  </span>
  <span class="absValue">
    (99/506)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    49%
  </span>
  <span class="absValue">
    (247/504)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.description.method;
&nbsp;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.ModifierReviewable;
&nbsp;import net.bytebuddy.description.NamedElement;
&nbsp;import net.bytebuddy.description.TypeVariableSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.modifier.ModifierContributor;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeVariableToken;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.JavaConstant;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.jar.asm.Opcodes;
&nbsp;import net.bytebuddy.jar.asm.Type;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureWriter;
&nbsp;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.GenericSignatureFormatError;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.not;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.ofSort;
&nbsp;
&nbsp;/**
&nbsp; * Implementations of this interface describe a Java method, i.e. a method or a constructor. Implementations of this
&nbsp; * interface must provide meaningful {@code equal(Object)} and {@code hashCode()} implementations.
&nbsp; */
&nbsp;public interface MethodDescription extends TypeVariableSource,
&nbsp;        ModifierReviewable.ForMethodDescription,
&nbsp;        NamedElement.WithGenericName,
&nbsp;        ByteCodeElement,
&nbsp;        ByteCodeElement.TypeDependant&lt;MethodDescription.InDefinedShape, MethodDescription.Token&gt; {
&nbsp;
&nbsp;    /**
&nbsp;     * The internal name of a Java constructor.
&nbsp;     */
&nbsp;    String CONSTRUCTOR_INTERNAL_NAME = &quot;&lt;init&gt;&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The internal name of a Java static initializer.
&nbsp;     */
&nbsp;    String TYPE_INITIALIZER_INTERNAL_NAME = &quot;&lt;clinit&gt;&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The type initializer of any representation of a type initializer.
&nbsp;     */
&nbsp;    int TYPE_INITIALIZER_MODIFIER = Opcodes.ACC_STATIC;
&nbsp;
&nbsp;    /**
&nbsp;     * Represents any undefined property of a type description that is instead represented as {@code null} in order
&nbsp;     * to resemble the Java reflection API which returns {@code null} and is intuitive to many Java developers.
&nbsp;     */
<b class="fc">&nbsp;    MethodDescription UNDEFINED = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the return type of the described method.
&nbsp;     *
&nbsp;     * @return The return type of the described method.
&nbsp;     */
&nbsp;    TypeDescription.Generic getReturnType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list of this method&#39;s parameters.
&nbsp;     *
&nbsp;     * @return A list of this method&#39;s parameters.
&nbsp;     */
&nbsp;    ParameterList&lt;?&gt; getParameters();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the exception types of the described method.
&nbsp;     *
&nbsp;     * @return The exception types of the described method.
&nbsp;     */
&nbsp;    TypeList.Generic getExceptionTypes();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this method&#39;s actual modifiers as it is present in a class file, i.e. includes a flag if this method
&nbsp;     * is marked {@link Deprecated}.
&nbsp;     *
&nbsp;     * @return The method&#39;s actual modifiers.
&nbsp;     */
&nbsp;    int getActualModifiers();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this method&#39;s actual modifiers as it is present in a class file, i.e. includes a flag if this method
&nbsp;     * is marked {@link Deprecated} and adjusts the modifiers for being abstract or not.
&nbsp;     *
&nbsp;     * @param manifest {@code true} if the method should be treated as non-abstract.
&nbsp;     * @return The method&#39;s actual modifiers.
&nbsp;     */
&nbsp;    int getActualModifiers(boolean manifest);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this method&#39;s actual modifiers as it is present in a class file, i.e. includes a flag if this method
&nbsp;     * is marked {@link Deprecated} and adjusts the modifiers for being abstract or not. Additionally, this method
&nbsp;     * resolves a required minimal visibility.
&nbsp;     *
&nbsp;     * @param manifest {@code true} if the method should be treated as non-abstract.
&nbsp;     * @param visibility  The minimal visibility to enforce for this method.
&nbsp;     * @return The method&#39;s actual modifiers.
&nbsp;     */
&nbsp;    int getActualModifiers(boolean manifest, Visibility visibility);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method description represents a constructor.
&nbsp;     *
&nbsp;     * @return {@code true} if this method description represents a constructor.
&nbsp;     */
&nbsp;    boolean isConstructor();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method description represents a method, i.e. not a constructor or a type initializer.
&nbsp;     *
&nbsp;     * @return {@code true} if this method description represents a Java method.
&nbsp;     */
&nbsp;    boolean isMethod();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method is a type initializer.
&nbsp;     *
&nbsp;     * @return {@code true} if this method description represents a type initializer.
&nbsp;     */
&nbsp;    boolean isTypeInitializer();
&nbsp;
&nbsp;    /**
&nbsp;     * Verifies if a method description represents a given loaded method.
&nbsp;     *
&nbsp;     * @param method The method to be checked.
&nbsp;     * @return {@code true} if this method description represents the given loaded method.
&nbsp;     */
&nbsp;    boolean represents(Method method);
&nbsp;
&nbsp;    /**
&nbsp;     * Verifies if a method description represents a given loaded constructor.
&nbsp;     *
&nbsp;     * @param constructor The constructor to be checked.
&nbsp;     * @return {@code true} if this method description represents the given loaded constructor.
&nbsp;     */
&nbsp;    boolean represents(Constructor&lt;?&gt; constructor);
&nbsp;
&nbsp;    /**
&nbsp;     * Verifies if this method describes a virtual method, i.e. a method that is inherited by a sub type of this type.
&nbsp;     *
&nbsp;     * @return {@code true} if this method is virtual.
&nbsp;     */
&nbsp;    boolean isVirtual();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the size of the local variable array that is required for this method, i.e. the size of all parameters
&nbsp;     * if they were loaded on the stack including a reference to {@code this} if this method represented a non-static
&nbsp;     * method.
&nbsp;     *
&nbsp;     * @return The size of this method on the operand stack.
&nbsp;     */
&nbsp;    int getStackSize();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method represents a default (defender) method.
&nbsp;     *
&nbsp;     * @return {@code true} if this method is a default method.
&nbsp;     */
&nbsp;    boolean isDefaultMethod();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method can be called using the {@code INVOKESPECIAL} for a given type.
&nbsp;     *
&nbsp;     * @param typeDescription The type o
&nbsp;     * @return {@code true} if this method can be called using the {@code INVOKESPECIAL} instruction
&nbsp;     * using the given type.
&nbsp;     */
&nbsp;    boolean isSpecializableFor(TypeDescription typeDescription);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the method&#39;s default annotation value or {@code null} if no default value is defined for this method.
&nbsp;     *
&nbsp;     * @return The method&#39;s default annotation value or {@code null} if no default value is defined for this method.
&nbsp;     */
&nbsp;    AnnotationValue&lt;?, ?&gt; getDefaultValue();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default value but casts it to the given type. If the type differs from the value, a
&nbsp;     * {@link java.lang.ClassCastException} is thrown.
&nbsp;     *
&nbsp;     * @param type The type to cast the default value to.
&nbsp;     * @param &lt;T&gt;  The type to cast the default value to.
&nbsp;     * @return The casted default value.
&nbsp;     */
&nbsp;    &lt;T&gt; T getDefaultValue(Class&lt;T&gt; type);
&nbsp;
&nbsp;    /**
&nbsp;     * Asserts if this method is invokable on an instance of the given type, i.e. the method is an instance method or
&nbsp;     * a constructor and the method is visible to the type and can be invoked on the given instance.
&nbsp;     *
&nbsp;     * @param typeDescription The type to check.
&nbsp;     * @return {@code true} if this method is invokable on an instance of the given type.
&nbsp;     */
&nbsp;    boolean isInvokableOn(TypeDescription typeDescription);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the method is a bootstrap method.
&nbsp;     *
&nbsp;     * @return {@code true} if the method is a bootstrap method.
&nbsp;     */
&nbsp;    boolean isBootstrap();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the method is a bootstrap method that accepts the given arguments.
&nbsp;     *
&nbsp;     * @param arguments The arguments that the bootstrap method is expected to accept where primitive values
&nbsp;     *                  are to be represented as their wrapper types, loaded types by {@link TypeDescription},
&nbsp;     *                  method handles by {@link JavaConstant.MethodHandle} instances and
&nbsp;     *                  method types by {@link JavaConstant.MethodType} instances.
&nbsp;     * @return {@code true} if the method is a bootstrap method that accepts the given arguments.
&nbsp;     */
&nbsp;    boolean isBootstrap(List&lt;?&gt; arguments);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method is capable of defining a default annotation value.
&nbsp;     *
&nbsp;     * @return {@code true} if it is possible to define a default annotation value for this method.
&nbsp;     */
&nbsp;    boolean isDefaultValue();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the given value can describe a default annotation value for this method.
&nbsp;     *
&nbsp;     * @param annotationValue The value that describes the default annotation value for this method.
&nbsp;     * @return {@code true} if the given value can describe a default annotation value for this method.
&nbsp;     */
&nbsp;    boolean isDefaultValue(AnnotationValue&lt;?, ?&gt; annotationValue);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this methods receiver type. A receiver type is undefined for {@code static} methods
&nbsp;     * where {@code null} is returned. Other than a receiver type that is provided by the Java reflection
&nbsp;     * API, Byte Buddy is capable of extracting annotations on type parameters of receiver types when
&nbsp;     * directly accessing a class file. Therefore, a receiver type might be parameterized.
&nbsp;     *
&nbsp;     * @return This method&#39;s (annotated) receiver type.
&nbsp;     */
&nbsp;    TypeDescription.Generic getReceiverType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a signature token representing this method.
&nbsp;     *
&nbsp;     * @return A signature token representing this method.
&nbsp;     */
&nbsp;    SignatureToken asSignatureToken();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a type token that represents this method&#39;s raw return and parameter types.
&nbsp;     *
&nbsp;     * @return A type token that represents this method&#39;s raw return and parameter types.
&nbsp;     */
&nbsp;    TypeToken asTypeToken();
&nbsp;
&nbsp;    /**
&nbsp;     * Validates that the supplied type token can implement a bridge method to this method.
&nbsp;     *
&nbsp;     * @param typeToken A type token representing a potential bridge method to this method.
&nbsp;     * @return {@code true} if the supplied type token can represent a bridge method to this method.
&nbsp;     */
&nbsp;    boolean isBridgeCompatible(TypeToken typeToken);
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a method description in its generic shape, i.e. in the shape it is defined by a generic or raw type.
&nbsp;     */
&nbsp;    interface InGenericShape extends MethodDescription {
&nbsp;
&nbsp;        @Override
&nbsp;        TypeDescription.Generic getDeclaringType();
&nbsp;
&nbsp;        @Override
&nbsp;        ParameterList&lt;ParameterDescription.InGenericShape&gt; getParameters();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a method in its defined shape, i.e. in the form it is defined by a class without its type variables being resolved.
&nbsp;     */
&nbsp;    interface InDefinedShape extends MethodDescription {
&nbsp;
&nbsp;        @Override
&nbsp;        TypeDescription getDeclaringType();
&nbsp;
&nbsp;        @Override
&nbsp;        ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters();
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a method description in its defined shape.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase extends MethodDescription.AbstractBase implements InDefinedShape {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public InDefinedShape asDefined() {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription.Generic getReceiverType() {
<b class="pc">&nbsp;                if (isStatic()) {</b>
<b class="nc">&nbsp;                    return TypeDescription.Generic.UNDEFINED;</b>
<b class="fc">&nbsp;                } else if (isConstructor()) {</b>
<b class="fc">&nbsp;                    TypeDescription declaringType = getDeclaringType(), enclosingDeclaringType = getDeclaringType().getEnclosingType();</b>
<b class="pc">&nbsp;                    if (enclosingDeclaringType == null) {</b>
<b class="fc">&nbsp;                        return TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(declaringType);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return declaringType.isStatic()</b>
<b class="nc">&nbsp;                                ? enclosingDeclaringType.asGenericType()</b>
<b class="nc">&nbsp;                                : TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(enclosingDeclaringType);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="fc">&nbsp;                    return TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(getDeclaringType());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract base implementation of a method description.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase extends TypeVariableSource.AbstractBase implements MethodDescription {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A merger of all method modifiers that are visible in the Java source code.
&nbsp;         */
&nbsp;        private static final int SOURCE_MODIFIERS = Modifier.PUBLIC
&nbsp;                | Modifier.PROTECTED
&nbsp;                | Modifier.PRIVATE
&nbsp;                | Modifier.ABSTRACT
&nbsp;                | Modifier.STATIC
&nbsp;                | Modifier.FINAL
&nbsp;                | Modifier.SYNCHRONIZED
&nbsp;                | Modifier.NATIVE;
&nbsp;
&nbsp;        @Override
&nbsp;        public int getStackSize() {
<b class="fc">&nbsp;            return getParameters().asTypeList().getStackSize() + (isStatic() ? 0 : 1);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isMethod() {
<b class="fc">&nbsp;            return !isConstructor() &amp;&amp; !isTypeInitializer();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isConstructor() {
<b class="fc">&nbsp;            return CONSTRUCTOR_INTERNAL_NAME.equals(getInternalName());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isTypeInitializer() {
<b class="fc">&nbsp;            return TYPE_INITIALIZER_INTERNAL_NAME.equals(getInternalName());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean represents(Method method) {
<b class="nc">&nbsp;            return equals(new ForLoadedMethod(method));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean represents(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;            return equals(new ForLoadedConstructor(constructor));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="pc">&nbsp;            return isMethod()</b>
<b class="fc">&nbsp;                    ? getInternalName()</b>
<b class="nc">&nbsp;                    : getDeclaringType().asErasure().getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getActualName() {
<b class="pc">&nbsp;            return isMethod()</b>
<b class="fc">&nbsp;                    ? getName()</b>
&nbsp;                    : EMPTY_NAME;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            StringBuilder descriptor = new StringBuilder().append(&#39;(&#39;);</b>
<b class="fc">&nbsp;            for (TypeDescription parameterType : getParameters().asTypeList().asErasures()) {</b>
<b class="fc">&nbsp;                descriptor.append(parameterType.getDescriptor());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return descriptor.append(&#39;)&#39;).append(getReturnType().asErasure().getDescriptor()).toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getGenericSignature() {
&nbsp;            try {
<b class="fc">&nbsp;                SignatureWriter signatureWriter = new SignatureWriter();</b>
<b class="fc">&nbsp;                boolean generic = false;</b>
<b class="pc">&nbsp;                for (TypeDescription.Generic typeVariable : getTypeVariables()) {</b>
<b class="nc">&nbsp;                    signatureWriter.visitFormalTypeParameter(typeVariable.getSymbol());</b>
<b class="nc">&nbsp;                    boolean classBound = true;</b>
<b class="nc">&nbsp;                    for (TypeDescription.Generic upperBound : typeVariable.getUpperBounds()) {</b>
<b class="nc">&nbsp;                        upperBound.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(classBound</b>
<b class="nc">&nbsp;                                ? signatureWriter.visitClassBound()</b>
<b class="nc">&nbsp;                                : signatureWriter.visitInterfaceBound()));</b>
<b class="nc">&nbsp;                        classBound = false;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    generic = true;</b>
<b class="nc">&nbsp;                }</b>
<b class="fc">&nbsp;                for (TypeDescription.Generic parameterType : getParameters().asTypeList()) {</b>
<b class="fc">&nbsp;                    parameterType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(signatureWriter.visitParameterType()));</b>
<b class="fc">&nbsp;                    generic = generic || !parameterType.getSort().isNonGeneric();</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                TypeDescription.Generic returnType = getReturnType();</b>
<b class="fc">&nbsp;                returnType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(signatureWriter.visitReturnType()));</b>
<b class="fc">&nbsp;                generic = generic || !returnType.getSort().isNonGeneric();</b>
<b class="fc">&nbsp;                TypeList.Generic exceptionTypes = getExceptionTypes();</b>
<b class="pc">&nbsp;                if (!exceptionTypes.filter(not(ofSort(TypeDefinition.Sort.NON_GENERIC))).isEmpty()) {</b>
<b class="nc">&nbsp;                    for (TypeDescription.Generic exceptionType : exceptionTypes) {</b>
<b class="nc">&nbsp;                        exceptionType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(signatureWriter.visitExceptionType()));</b>
<b class="nc">&nbsp;                        generic = generic || !exceptionType.getSort().isNonGeneric();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="fc">&nbsp;                return generic</b>
<b class="fc">&nbsp;                        ? signatureWriter.toString()</b>
&nbsp;                        : NON_GENERIC_SIGNATURE;
<b class="nc">&nbsp;            } catch (GenericSignatureFormatError ignored) {</b>
<b class="nc">&nbsp;                return NON_GENERIC_SIGNATURE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getActualModifiers() {
<b class="fc">&nbsp;            return getModifiers() | (getDeclaredAnnotations().isAnnotationPresent(Deprecated.class)</b>
&nbsp;                    ? Opcodes.ACC_DEPRECATED
&nbsp;                    : EMPTY_MASK);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getActualModifiers(boolean manifest) {
<b class="pc">&nbsp;            return manifest</b>
<b class="fc">&nbsp;                    ? getActualModifiers() &amp; ~(Opcodes.ACC_ABSTRACT | Opcodes.ACC_NATIVE)</b>
<b class="nc">&nbsp;                    : getActualModifiers() &amp; ~Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getActualModifiers(boolean manifest, Visibility visibility) {
<b class="fc">&nbsp;            return ModifierContributor.Resolver.of(Collections.singleton(getVisibility().expandTo(visibility))).resolve(getActualModifiers(manifest));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isVisibleTo(TypeDescription typeDescription) {
<b class="pc">&nbsp;            return (isVirtual() || getDeclaringType().asErasure().isVisibleTo(typeDescription))</b>
<b class="fc">&nbsp;                    &amp;&amp; (isPublic()</b>
<b class="pc">&nbsp;                    || typeDescription.equals(getDeclaringType().asErasure())</b>
<b class="fc">&nbsp;                    || (isProtected() &amp;&amp; getDeclaringType().asErasure().isAssignableFrom(typeDescription))</b>
<b class="pc">&nbsp;                    || (!isPrivate() &amp;&amp; typeDescription.isSamePackage(getDeclaringType().asErasure())));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAccessibleTo(TypeDescription typeDescription) {
<b class="pc">&nbsp;            return (isVirtual() || getDeclaringType().asErasure().isVisibleTo(typeDescription))</b>
<b class="pc">&nbsp;                    &amp;&amp; (isPublic()</b>
<b class="nc">&nbsp;                    || typeDescription.equals(getDeclaringType().asErasure())</b>
<b class="nc">&nbsp;                    || (!isPrivate() &amp;&amp; typeDescription.isSamePackage(getDeclaringType().asErasure())));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isVirtual() {
<b class="pc">&nbsp;            return !(isConstructor() || isPrivate() || isStatic() || isTypeInitializer());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isDefaultMethod() {
<b class="nc">&nbsp;            return !isAbstract() &amp;&amp; !isBridge() &amp;&amp; getDeclaringType().isInterface();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isSpecializableFor(TypeDescription targetType) {
<b class="pc">&nbsp;            if (isStatic()) { // Static private methods are never specializable, check static property first</b>
<b class="nc">&nbsp;                return false;</b>
<b class="pc">&nbsp;            } else if (isPrivate() || isConstructor()) {</b>
<b class="fc">&nbsp;                return getDeclaringType().equals(targetType);</b>
&nbsp;            } else {
<b class="pc">&nbsp;                return !isAbstract() &amp;&amp; getDeclaringType().asErasure().isAssignableFrom(targetType);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public &lt;T&gt; T getDefaultValue(Class&lt;T&gt; type) {
<b class="nc">&nbsp;            return type.cast(getDefaultValue());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isInvokableOn(TypeDescription typeDescription) {
<b class="nc">&nbsp;            return !isStatic()</b>
<b class="nc">&nbsp;                    &amp;&amp; !isTypeInitializer()</b>
<b class="nc">&nbsp;                    &amp;&amp; isVisibleTo(typeDescription)</b>
<b class="nc">&nbsp;                    &amp;&amp; (isVirtual()</b>
<b class="nc">&nbsp;                    ? getDeclaringType().asErasure().isAssignableFrom(typeDescription)</b>
<b class="nc">&nbsp;                    : getDeclaringType().asErasure().equals(typeDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isBootstrap() {
<b class="nc">&nbsp;            TypeDescription returnType = getReturnType().asErasure();</b>
<b class="nc">&nbsp;            if ((isMethod() &amp;&amp; (!isStatic()</b>
<b class="nc">&nbsp;                    || !(JavaType.CALL_SITE.getTypeStub().isAssignableFrom(returnType) || JavaType.CALL_SITE.getTypeStub().isAssignableTo(returnType))))</b>
<b class="nc">&nbsp;                    || (isConstructor() &amp;&amp; !JavaType.CALL_SITE.getTypeStub().isAssignableFrom(getDeclaringType().asErasure()))) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            TypeList parameterTypes = getParameters().asTypeList().asErasures();</b>
<b class="nc">&nbsp;            switch (parameterTypes.size()) {</b>
&nbsp;                case 0:
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                case 1:
<b class="nc">&nbsp;                    return parameterTypes.getOnly().represents(Object[].class);</b>
&nbsp;                case 2:
<b class="nc">&nbsp;                    return JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().isAssignableTo(parameterTypes.get(0))</b>
<b class="nc">&nbsp;                            &amp;&amp; parameterTypes.get(1).represents(Object[].class);</b>
&nbsp;                case 3:
<b class="nc">&nbsp;                    return JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().isAssignableTo(parameterTypes.get(0))</b>
<b class="nc">&nbsp;                            &amp;&amp; (parameterTypes.get(1).represents(Object.class) || parameterTypes.get(1).represents(String.class))</b>
<b class="nc">&nbsp;                            &amp;&amp; (parameterTypes.get(2).represents(Object[].class) || JavaType.METHOD_TYPE.getTypeStub().isAssignableTo(parameterTypes.get(2)));</b>
&nbsp;                default:
<b class="nc">&nbsp;                    if (!(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().isAssignableTo(parameterTypes.get(0))</b>
<b class="nc">&nbsp;                            &amp;&amp; (parameterTypes.get(1).represents(Object.class) || parameterTypes.get(1).represents(String.class))</b>
<b class="nc">&nbsp;                            &amp;&amp; (JavaType.METHOD_TYPE.getTypeStub().isAssignableTo(parameterTypes.get(2))))) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    int parameterIndex = 4;</b>
<b class="nc">&nbsp;                    for (TypeDescription parameterType : parameterTypes.subList(3, parameterTypes.size())) {</b>
<b class="nc">&nbsp;                        if (!parameterType.represents(Object.class) &amp;&amp; !parameterType.isConstantPool()) {</b>
<b class="nc">&nbsp;                            return parameterType.represents(Object[].class) &amp;&amp; parameterIndex == parameterTypes.size();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        parameterIndex++;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isBootstrap(List&lt;?&gt; arguments) {
<b class="nc">&nbsp;            if (!isBootstrap()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Object argument : arguments) {</b>
<b class="nc">&nbsp;                Class&lt;?&gt; argumentType = argument.getClass();</b>
<b class="nc">&nbsp;                if (!(argumentType == String.class</b>
&nbsp;                        || argumentType == Integer.class
&nbsp;                        || argumentType == Long.class
&nbsp;                        || argumentType == Float.class
&nbsp;                        || argumentType == Double.class
<b class="nc">&nbsp;                        || TypeDescription.class.isAssignableFrom(argumentType)</b>
<b class="nc">&nbsp;                        || JavaConstant.MethodHandle.class.isAssignableFrom(argumentType)</b>
<b class="nc">&nbsp;                        || JavaConstant.MethodType.class.isAssignableFrom(argumentType))) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Not a bootstrap argument: &quot; + argument);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            TypeList parameterTypes = getParameters().asTypeList().asErasures();</b>
&nbsp;            // The following assumes that the bootstrap method is a valid one, as checked above.
<b class="nc">&nbsp;            if (parameterTypes.size() &lt; 4) {</b>
<b class="nc">&nbsp;                return arguments.isEmpty() || parameterTypes.get(parameterTypes.size() - 1).represents(Object[].class);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                int index = 4;</b>
<b class="nc">&nbsp;                Iterator&lt;?&gt; argumentIterator = arguments.iterator();</b>
<b class="nc">&nbsp;                for (TypeDescription parameterType : parameterTypes.subList(3, parameterTypes.size())) {</b>
<b class="nc">&nbsp;                    boolean finalParameterCheck = !argumentIterator.hasNext();</b>
<b class="nc">&nbsp;                    if (!finalParameterCheck) {</b>
<b class="nc">&nbsp;                        Class&lt;?&gt; argumentType = argumentIterator.next().getClass();</b>
<b class="nc">&nbsp;                        finalParameterCheck = !(parameterType.represents(String.class) &amp;&amp; argumentType == String.class)</b>
<b class="nc">&nbsp;                                &amp;&amp; !(parameterType.represents(int.class) &amp;&amp; argumentType == Integer.class)</b>
<b class="nc">&nbsp;                                &amp;&amp; !(parameterType.represents(long.class) &amp;&amp; argumentType == Long.class)</b>
<b class="nc">&nbsp;                                &amp;&amp; !(parameterType.represents(float.class) &amp;&amp; argumentType == Float.class)</b>
<b class="nc">&nbsp;                                &amp;&amp; !(parameterType.represents(double.class) &amp;&amp; argumentType == Double.class)</b>
<b class="nc">&nbsp;                                &amp;&amp; !(parameterType.represents(Class.class) &amp;&amp; TypeDescription.class.isAssignableFrom(argumentType))</b>
<b class="nc">&nbsp;                                &amp;&amp; !(parameterType.isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub()) &amp;&amp; JavaConstant.MethodHandle.class.isAssignableFrom(argumentType))</b>
<b class="nc">&nbsp;                                &amp;&amp; !(parameterType.equals(JavaType.METHOD_TYPE.getTypeStub()) &amp;&amp; JavaConstant.MethodType.class.isAssignableFrom(argumentType));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (finalParameterCheck) {</b>
<b class="nc">&nbsp;                        return index == parameterTypes.size() &amp;&amp; parameterType.represents(Object[].class);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    index++;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isDefaultValue() {
<b class="nc">&nbsp;            return !isConstructor()</b>
<b class="nc">&nbsp;                    &amp;&amp; !isStatic()</b>
<b class="nc">&nbsp;                    &amp;&amp; getReturnType().asErasure().isAnnotationReturnType()</b>
<b class="nc">&nbsp;                    &amp;&amp; getParameters().isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isDefaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="nc">&nbsp;            if (!isDefaultValue()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            TypeDescription returnType = getReturnType().asErasure();</b>
<b class="nc">&nbsp;            Object value = annotationValue.resolve();</b>
<b class="nc">&nbsp;            return (returnType.represents(boolean.class) &amp;&amp; value instanceof Boolean)</b>
<b class="nc">&nbsp;                    || (returnType.represents(byte.class) &amp;&amp; value instanceof Byte)</b>
<b class="nc">&nbsp;                    || (returnType.represents(char.class) &amp;&amp; value instanceof Character)</b>
<b class="nc">&nbsp;                    || (returnType.represents(short.class) &amp;&amp; value instanceof Short)</b>
<b class="nc">&nbsp;                    || (returnType.represents(int.class) &amp;&amp; value instanceof Integer)</b>
<b class="nc">&nbsp;                    || (returnType.represents(long.class) &amp;&amp; value instanceof Long)</b>
<b class="nc">&nbsp;                    || (returnType.represents(float.class) &amp;&amp; value instanceof Float)</b>
<b class="nc">&nbsp;                    || (returnType.represents(double.class) &amp;&amp; value instanceof Double)</b>
<b class="nc">&nbsp;                    || (returnType.represents(String.class) &amp;&amp; value instanceof String)</b>
<b class="nc">&nbsp;                    || (returnType.isAssignableTo(Enum.class) &amp;&amp; value instanceof EnumerationDescription &amp;&amp; isEnumerationType(returnType, (EnumerationDescription) value))</b>
<b class="nc">&nbsp;                    || (returnType.isAssignableTo(Annotation.class) &amp;&amp; value instanceof AnnotationDescription &amp;&amp; isAnnotationType(returnType, (AnnotationDescription) value))</b>
<b class="nc">&nbsp;                    || (returnType.represents(Class.class) &amp;&amp; value instanceof TypeDescription)</b>
<b class="nc">&nbsp;                    || (returnType.represents(boolean[].class) &amp;&amp; value instanceof boolean[])</b>
<b class="nc">&nbsp;                    || (returnType.represents(byte[].class) &amp;&amp; value instanceof byte[])</b>
<b class="nc">&nbsp;                    || (returnType.represents(char[].class) &amp;&amp; value instanceof char[])</b>
<b class="nc">&nbsp;                    || (returnType.represents(short[].class) &amp;&amp; value instanceof short[])</b>
<b class="nc">&nbsp;                    || (returnType.represents(int[].class) &amp;&amp; value instanceof int[])</b>
<b class="nc">&nbsp;                    || (returnType.represents(long[].class) &amp;&amp; value instanceof long[])</b>
<b class="nc">&nbsp;                    || (returnType.represents(float[].class) &amp;&amp; value instanceof float[])</b>
<b class="nc">&nbsp;                    || (returnType.represents(double[].class) &amp;&amp; value instanceof double[])</b>
<b class="nc">&nbsp;                    || (returnType.represents(String[].class) &amp;&amp; value instanceof String[])</b>
<b class="nc">&nbsp;                    || (returnType.isAssignableTo(Enum[].class) &amp;&amp; value instanceof EnumerationDescription[] &amp;&amp; isEnumerationType(returnType.getComponentType(), (EnumerationDescription[]) value))</b>
<b class="nc">&nbsp;                    || (returnType.isAssignableTo(Annotation[].class) &amp;&amp; value instanceof AnnotationDescription[] &amp;&amp; isAnnotationType(returnType.getComponentType(), (AnnotationDescription[]) value))</b>
<b class="nc">&nbsp;                    || (returnType.represents(Class[].class) &amp;&amp; value instanceof TypeDescription[]);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if the supplied enumeration descriptions describe the correct enumeration type.
&nbsp;         *
&nbsp;         * @param enumerationType        The enumeration type to check for.
&nbsp;         * @param enumerationDescription The enumeration descriptions to check.
&nbsp;         * @return {@code true} if all enumeration descriptions represent the enumeration type in question.
&nbsp;         */
&nbsp;        private static boolean isEnumerationType(TypeDescription enumerationType, EnumerationDescription... enumerationDescription) {
<b class="nc">&nbsp;            for (EnumerationDescription anEnumerationDescription : enumerationDescription) {</b>
<b class="nc">&nbsp;                if (!anEnumerationDescription.getEnumerationType().equals(enumerationType)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if the supplied enumeration descriptions describe the correct annotation type.
&nbsp;         *
&nbsp;         * @param annotationType        The annotation type to check for.
&nbsp;         * @param annotationDescription The annotation descriptions to check.
&nbsp;         * @return {@code true} if all annotation descriptions represent the annotation type in question.
&nbsp;         */
&nbsp;        private static boolean isAnnotationType(TypeDescription annotationType, AnnotationDescription... annotationDescription) {
<b class="nc">&nbsp;            for (AnnotationDescription anAnnotationDescription : annotationDescription) {</b>
<b class="nc">&nbsp;                if (!anAnnotationDescription.getAnnotationType().equals(annotationType)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeVariableSource getEnclosingSource() {
<b class="nc">&nbsp;            return isStatic()</b>
&nbsp;                    ? TypeVariableSource.UNDEFINED
<b class="nc">&nbsp;                    : getDeclaringType().asErasure();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public &lt;T&gt; T accept(TypeVariableSource.Visitor&lt;T&gt; visitor) {
<b class="nc">&nbsp;            return visitor.onMethod(this.asDefined());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isGenerified() {
<b class="nc">&nbsp;            return !getTypeVariables().isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodDescription.Token asToken(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;            TypeDescription.Generic receiverType = getReceiverType();</b>
<b class="fc">&nbsp;            return new MethodDescription.Token(getInternalName(),</b>
<b class="fc">&nbsp;                    getModifiers(),</b>
<b class="fc">&nbsp;                    getTypeVariables().asTokenList(matcher),</b>
<b class="fc">&nbsp;                    getReturnType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)),</b>
<b class="fc">&nbsp;                    getParameters().asTokenList(matcher),</b>
<b class="fc">&nbsp;                    getExceptionTypes().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)),</b>
<b class="fc">&nbsp;                    getDeclaredAnnotations(),</b>
<b class="pc">&nbsp;                    getDefaultValue(),</b>
&nbsp;                    receiverType == null
&nbsp;                            ? TypeDescription.Generic.UNDEFINED
<b class="fc">&nbsp;                            : receiverType.accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public SignatureToken asSignatureToken() {
<b class="fc">&nbsp;            return new SignatureToken(getInternalName(), getReturnType().asErasure(), getParameters().asTypeList().asErasures());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeToken asTypeToken() {
<b class="fc">&nbsp;            return new TypeToken(getReturnType().asErasure(), getParameters().asTypeList().asErasures());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isBridgeCompatible(TypeToken typeToken) {
<b class="fc">&nbsp;            List&lt;TypeDescription&gt; types = getParameters().asTypeList().asErasures(), bridgeTypes = typeToken.getParameterTypes();</b>
<b class="pc">&nbsp;            if (types.size() != bridgeTypes.size()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="pc">&nbsp;            for (int index = 0; index &lt; types.size(); index++) {</b>
<b class="nc">&nbsp;                if (!types.get(index).equals(bridgeTypes.get(index)) &amp;&amp; (types.get(index).isPrimitive() || bridgeTypes.get(index).isPrimitive())) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            TypeDescription returnType = getReturnType().asErasure(), bridgeReturnType = typeToken.getReturnType();</b>
<b class="pc">&nbsp;            return returnType.equals(bridgeReturnType) || (!returnType.isPrimitive() &amp;&amp; !bridgeReturnType.isPrimitive());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
<b class="pc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="pc">&nbsp;            } else if (!(other instanceof MethodDescription)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodDescription methodDescription = (MethodDescription) other;</b>
<b class="fc">&nbsp;            return getInternalName().equals(methodDescription.getInternalName())</b>
<b class="pc">&nbsp;                    &amp;&amp; getDeclaringType().equals(methodDescription.getDeclaringType())</b>
<b class="pc">&nbsp;                    &amp;&amp; getReturnType().asErasure().equals(methodDescription.getReturnType().asErasure())</b>
<b class="fc">&nbsp;                    &amp;&amp; getParameters().asTypeList().asErasures().equals(methodDescription.getParameters().asTypeList().asErasures());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            int hashCode = 17 + getDeclaringType().hashCode();</b>
<b class="fc">&nbsp;            hashCode = 31 * hashCode + getInternalName().hashCode();</b>
<b class="fc">&nbsp;            hashCode = 31 * hashCode + getReturnType().asErasure().hashCode();</b>
<b class="fc">&nbsp;            return 31 * hashCode + getParameters().asTypeList().asErasures().hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toGenericString() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
<b class="nc">&nbsp;            int modifiers = getModifiers() &amp; SOURCE_MODIFIERS;</b>
<b class="nc">&nbsp;            if (modifiers != EMPTY_MASK) {</b>
<b class="nc">&nbsp;                stringBuilder.append(Modifier.toString(modifiers)).append(&#39; &#39;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (isMethod()) {</b>
<b class="nc">&nbsp;                stringBuilder.append(getReturnType().getActualName()).append(&#39; &#39;);</b>
<b class="nc">&nbsp;                stringBuilder.append(getDeclaringType().asErasure().getActualName()).append(&#39;.&#39;);</b>
&nbsp;            }
<b class="nc">&nbsp;            stringBuilder.append(getName()).append(&#39;(&#39;);</b>
<b class="nc">&nbsp;            boolean first = true;</b>
<b class="nc">&nbsp;            for (TypeDescription.Generic typeDescription : getParameters().asTypeList()) {</b>
<b class="nc">&nbsp;                if (!first) {</b>
<b class="nc">&nbsp;                    stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    first = false;</b>
&nbsp;                }
<b class="nc">&nbsp;                stringBuilder.append(typeDescription.getActualName());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            stringBuilder.append(&#39;)&#39;);</b>
<b class="nc">&nbsp;            TypeList.Generic exceptionTypes = getExceptionTypes();</b>
<b class="nc">&nbsp;            if (!exceptionTypes.isEmpty()) {</b>
<b class="nc">&nbsp;                stringBuilder.append(&quot; throws &quot;);</b>
<b class="nc">&nbsp;                first = true;</b>
<b class="nc">&nbsp;                for (TypeDescription.Generic typeDescription : exceptionTypes) {</b>
<b class="nc">&nbsp;                    if (!first) {</b>
<b class="nc">&nbsp;                        stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        first = false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    stringBuilder.append(typeDescription.getActualName());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            return stringBuilder.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
<b class="nc">&nbsp;            int modifiers = getModifiers() &amp; SOURCE_MODIFIERS;</b>
<b class="nc">&nbsp;            if (modifiers != EMPTY_MASK) {</b>
<b class="nc">&nbsp;                stringBuilder.append(Modifier.toString(modifiers)).append(&#39; &#39;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (isMethod()) {</b>
<b class="nc">&nbsp;                stringBuilder.append(getReturnType().asErasure().getActualName()).append(&#39; &#39;);</b>
<b class="nc">&nbsp;                stringBuilder.append(getDeclaringType().asErasure().getActualName()).append(&#39;.&#39;);</b>
&nbsp;            }
<b class="nc">&nbsp;            stringBuilder.append(getName()).append(&#39;(&#39;);</b>
<b class="nc">&nbsp;            boolean first = true;</b>
<b class="nc">&nbsp;            for (TypeDescription typeDescription : getParameters().asTypeList().asErasures()) {</b>
<b class="nc">&nbsp;                if (!first) {</b>
<b class="nc">&nbsp;                    stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    first = false;</b>
&nbsp;                }
<b class="nc">&nbsp;                stringBuilder.append(typeDescription.getActualName());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            stringBuilder.append(&#39;)&#39;);</b>
<b class="nc">&nbsp;            TypeList exceptionTypes = getExceptionTypes().asErasures();</b>
<b class="nc">&nbsp;            if (!exceptionTypes.isEmpty()) {</b>
<b class="nc">&nbsp;                stringBuilder.append(&quot; throws &quot;);</b>
<b class="nc">&nbsp;                first = true;</b>
<b class="nc">&nbsp;                for (TypeDescription typeDescription : exceptionTypes) {</b>
<b class="nc">&nbsp;                    if (!first) {</b>
<b class="nc">&nbsp;                        stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        first = false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    stringBuilder.append(typeDescription.getActualName());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            return stringBuilder.toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation of a method description for a loaded constructor.
&nbsp;     */
&nbsp;    class ForLoadedConstructor extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The loaded constructor that is represented by this instance.
&nbsp;         */
&nbsp;        private final Constructor&lt;?&gt; constructor;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new immutable method description for a loaded constructor.
&nbsp;         *
&nbsp;         * @param constructor The loaded constructor to be represented by this method description.
&nbsp;         */
<b class="fc">&nbsp;        public ForLoadedConstructor(Constructor&lt;?&gt; constructor) {</b>
<b class="fc">&nbsp;            this.constructor = constructor;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return TypeDescription.ForLoadedType.of(constructor.getDeclaringClass());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;            return TypeDescription.Generic.VOID;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;            return ParameterList.ForLoadedExecutable.of(constructor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;            return new TypeList.Generic.OfConstructorExceptionTypes(constructor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isConstructor() {
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isTypeInitializer() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean represents(Method method) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean represents(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;            return this.constructor.equals(constructor) || equals(new ForLoadedConstructor(constructor));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return constructor.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return constructor.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isSynthetic() {
<b class="nc">&nbsp;            return constructor.isSynthetic();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return CONSTRUCTOR_INTERNAL_NAME;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            return Type.getConstructorDescriptor(constructor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="fc">&nbsp;            return AnnotationValue.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.ForLoadedAnnotations(constructor.getDeclaredAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;            return TypeList.Generic.ForLoadedTypes.OfTypeVariables.of(constructor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription.Generic getReceiverType() {
<b class="fc">&nbsp;            TypeDescription.Generic receiverType = TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveReceiverType(constructor);</b>
<b class="pc">&nbsp;            return receiverType == null</b>
<b class="fc">&nbsp;                    ? super.getReceiverType()</b>
&nbsp;                    : receiverType;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation of a method description for a loaded method.
&nbsp;     */
&nbsp;    class ForLoadedMethod extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The loaded method that is represented by this instance.
&nbsp;         */
&nbsp;        private final Method method;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new immutable method description for a loaded method.
&nbsp;         *
&nbsp;         * @param method The loaded method to be represented by this method description.
&nbsp;         */
<b class="fc">&nbsp;        public ForLoadedMethod(Method method) {</b>
<b class="fc">&nbsp;            this.method = method;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return TypeDescription.ForLoadedType.of(method.getDeclaringClass());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription.Generic getReturnType() {
<b class="pc">&nbsp;            if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(method.getReturnType());</b>
&nbsp;            }
<b class="fc">&nbsp;            return new TypeDescription.Generic.LazyProjection.ForLoadedReturnType(method);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;            return ParameterList.ForLoadedExecutable.of(method);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getExceptionTypes() {
<b class="pc">&nbsp;            if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                return new TypeList.Generic.ForLoadedTypes(method.getExceptionTypes());</b>
&nbsp;            }
<b class="fc">&nbsp;            return new TypeList.Generic.OfMethodExceptionTypes(method);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isConstructor() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isTypeInitializer() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isBridge() {
<b class="nc">&nbsp;            return method.isBridge();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean represents(Method method) {
<b class="nc">&nbsp;            return this.method.equals(method) || equals(new ForLoadedMethod(method));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean represents(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return method.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return method.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isSynthetic() {
<b class="nc">&nbsp;            return method.isSynthetic();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return method.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            return Type.getMethodDescriptor(method);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the loaded method that is represented by this method description.
&nbsp;         *
&nbsp;         * @return The loaded method that is represented by this method description.
&nbsp;         */
&nbsp;        public Method getLoadedMethod() {
<b class="fc">&nbsp;            return method;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.ForLoadedAnnotations(method.getDeclaredAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="fc">&nbsp;            Object value = method.getDefaultValue();</b>
<b class="pc">&nbsp;            return value == null</b>
&nbsp;                    ? AnnotationValue.UNDEFINED
<b class="nc">&nbsp;                    : AnnotationDescription.ForLoadedAnnotation.asValue(value, method.getReturnType());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="pc">&nbsp;            if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                return new TypeList.Generic.Empty();</b>
&nbsp;            }
<b class="fc">&nbsp;            return TypeList.Generic.ForLoadedTypes.OfTypeVariables.of(method);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription.Generic getReceiverType() {
<b class="pc">&nbsp;            if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                return super.getReceiverType();</b>
&nbsp;            }
<b class="fc">&nbsp;            TypeDescription.Generic receiverType = TypeDescription.Generic.AnnotationReader.DISPATCHER.resolveReceiverType(method);</b>
<b class="pc">&nbsp;            return receiverType == null</b>
<b class="nc">&nbsp;                    ? super.getReceiverType()</b>
&nbsp;                    : receiverType;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A latent method description describes a method that is not attached to a declaring
&nbsp;     * {@link TypeDescription}.
&nbsp;     */
&nbsp;    class Latent extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The type that is declaring this method.
&nbsp;         */
&nbsp;        private final TypeDescription declaringType;
&nbsp;
&nbsp;        /**
&nbsp;         * The internal name of this method.
&nbsp;         */
&nbsp;        private final String internalName;
&nbsp;
&nbsp;        /**
&nbsp;         * The modifiers of this method.
&nbsp;         */
&nbsp;        private final int modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * A tokenized list representing the method&#39;s type variables.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeVariableToken&gt; typeVariables;
&nbsp;
&nbsp;        /**
&nbsp;         * The return type of this method.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic returnType;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter tokens describing this method.
&nbsp;         */
&nbsp;        private final List&lt;? extends ParameterDescription.Token&gt; parameterTokens;
&nbsp;
&nbsp;        /**
&nbsp;         * This method&#39;s exception types.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeDescription.Generic&gt; exceptionTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotations of this method.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; declaredAnnotations;
&nbsp;
&nbsp;        /**
&nbsp;         * The default value of this method or {@code null} if no default annotation value is defined.
&nbsp;         */
&nbsp;        private final AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;        /**
&nbsp;         * The receiver type of this method or {@code null} if the receiver type is defined implicitly.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic receiverType;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent method description. All provided types are attached to this instance before they are returned.
&nbsp;         *
&nbsp;         * @param declaringType The declaring type of the method.
&nbsp;         * @param token         A token representing the method&#39;s shape.
&nbsp;         */
&nbsp;        public Latent(TypeDescription declaringType, MethodDescription.Token token) {
<b class="fc">&nbsp;            this(declaringType,</b>
<b class="fc">&nbsp;                    token.getName(),</b>
<b class="fc">&nbsp;                    token.getModifiers(),</b>
<b class="fc">&nbsp;                    token.getTypeVariableTokens(),</b>
<b class="fc">&nbsp;                    token.getReturnType(),</b>
<b class="fc">&nbsp;                    token.getParameterTokens(),</b>
<b class="fc">&nbsp;                    token.getExceptionTypes(),</b>
<b class="fc">&nbsp;                    token.getAnnotations(),</b>
<b class="fc">&nbsp;                    token.getDefaultValue(),</b>
<b class="fc">&nbsp;                    token.getReceiverType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent method description. All provided types are attached to this instance before they are returned.
&nbsp;         *
&nbsp;         * @param declaringType       The type that is declaring this method.
&nbsp;         * @param internalName        The internal name of this method.
&nbsp;         * @param modifiers           The modifiers of this method.
&nbsp;         * @param typeVariables       The type variables of the described method.
&nbsp;         * @param returnType          The return type of this method.
&nbsp;         * @param parameterTokens     The parameter tokens describing this method.
&nbsp;         * @param exceptionTypes      This method&#39;s exception types.
&nbsp;         * @param declaredAnnotations The annotations of this method.
&nbsp;         * @param defaultValue        The default value of this method or {@code null} if no default annotation value is defined.
&nbsp;         * @param receiverType        The receiver type of this method or {@code null} if the receiver type is defined implicitly.
&nbsp;         */
&nbsp;        public Latent(TypeDescription declaringType,
&nbsp;                      String internalName,
&nbsp;                      int modifiers,
&nbsp;                      List&lt;? extends TypeVariableToken&gt; typeVariables,
&nbsp;                      TypeDescription.Generic returnType,
&nbsp;                      List&lt;? extends ParameterDescription.Token&gt; parameterTokens,
&nbsp;                      List&lt;? extends TypeDescription.Generic&gt; exceptionTypes,
&nbsp;                      List&lt;? extends AnnotationDescription&gt; declaredAnnotations,
&nbsp;                      AnnotationValue&lt;?, ?&gt; defaultValue,
<b class="fc">&nbsp;                      TypeDescription.Generic receiverType) {</b>
<b class="fc">&nbsp;            this.declaringType = declaringType;</b>
<b class="fc">&nbsp;            this.internalName = internalName;</b>
<b class="fc">&nbsp;            this.modifiers = modifiers;</b>
<b class="fc">&nbsp;            this.typeVariables = typeVariables;</b>
<b class="fc">&nbsp;            this.returnType = returnType;</b>
<b class="fc">&nbsp;            this.parameterTokens = parameterTokens;</b>
<b class="fc">&nbsp;            this.exceptionTypes = exceptionTypes;</b>
<b class="fc">&nbsp;            this.declaredAnnotations = declaredAnnotations;</b>
<b class="fc">&nbsp;            this.defaultValue = defaultValue;</b>
<b class="fc">&nbsp;            this.receiverType = receiverType;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;            return TypeList.Generic.ForDetachedTypes.attachVariables(this, typeVariables);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;            return returnType.accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;            return new ParameterList.ForTokens(this, parameterTokens);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;            return TypeList.Generic.ForDetachedTypes.attach(this, exceptionTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(declaredAnnotations);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return internalName;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return declaringType;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return modifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="nc">&nbsp;            return defaultValue;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription.Generic getReceiverType() {
<b class="pc">&nbsp;            return receiverType == null</b>
<b class="fc">&nbsp;                    ? super.getReceiverType()</b>
<b class="nc">&nbsp;                    : receiverType.accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A method description that represents the type initializer.
&nbsp;         */
&nbsp;        public static class TypeInitializer extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The type for which the type initializer should be represented.
&nbsp;             */
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new method description representing the type initializer.
&nbsp;             *
&nbsp;             * @param typeDescription The type for which the type initializer should be represented.
&nbsp;             */
<b class="fc">&nbsp;            public TypeInitializer(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;                return TypeDescription.Generic.VOID;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;                return new ParameterList.Empty&lt;ParameterDescription.InDefinedShape&gt;();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;                return new TypeList.Generic.Empty();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="nc">&nbsp;                return AnnotationValue.UNDEFINED;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;                return new TypeList.Generic.Empty();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                return new AnnotationList.Empty();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                return typeDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int getModifiers() {
<b class="fc">&nbsp;                return TYPE_INITIALIZER_MODIFIER;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getInternalName() {
<b class="fc">&nbsp;                return MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method description that represents a given method but with substituted method types.
&nbsp;     */
&nbsp;    class TypeSubstituting extends AbstractBase implements InGenericShape {
&nbsp;
&nbsp;        /**
&nbsp;         * The type that declares this type-substituted method.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic declaringType;
&nbsp;
&nbsp;        /**
&nbsp;         * The represented method description.
&nbsp;         */
&nbsp;        private final MethodDescription methodDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * A visitor that is applied to the method type.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method description with substituted method types.
&nbsp;         *
&nbsp;         * @param declaringType     The type that is declaring the substituted method.
&nbsp;         * @param methodDescription The represented method description.
&nbsp;         * @param visitor           A visitor that is applied to the method type.
&nbsp;         */
&nbsp;        public TypeSubstituting(TypeDescription.Generic declaringType,
&nbsp;                                MethodDescription methodDescription,
<b class="fc">&nbsp;                                TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {</b>
<b class="fc">&nbsp;            this.declaringType = declaringType;</b>
<b class="fc">&nbsp;            this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;            this.visitor = visitor;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;            return methodDescription.getReturnType().accept(visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;            return methodDescription.getTypeVariables().accept(visitor).filter(ElementMatchers.ofSort(TypeDefinition.Sort.VARIABLE));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ParameterList&lt;ParameterDescription.InGenericShape&gt; getParameters() {
<b class="fc">&nbsp;            return new ParameterList.TypeSubstituting(this, methodDescription.getParameters(), visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;            return new TypeList.Generic.ForDetachedTypes(methodDescription.getExceptionTypes(), visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="fc">&nbsp;            return methodDescription.getDefaultValue();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription.Generic getReceiverType() {
<b class="fc">&nbsp;            TypeDescription.Generic receiverType = methodDescription.getReceiverType();</b>
<b class="pc">&nbsp;            return receiverType == null</b>
&nbsp;                    ? TypeDescription.Generic.UNDEFINED
<b class="fc">&nbsp;                    : receiverType.accept(visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return methodDescription.getDeclaredAnnotations();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription.Generic getDeclaringType() {
<b class="fc">&nbsp;            return declaringType;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return methodDescription.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return methodDescription.getInternalName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public InDefinedShape asDefined() {
<b class="fc">&nbsp;            return methodDescription.asDefined();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isConstructor() {
<b class="fc">&nbsp;            return methodDescription.isConstructor();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isMethod() {
<b class="fc">&nbsp;            return methodDescription.isMethod();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isTypeInitializer() {
<b class="fc">&nbsp;            return methodDescription.isTypeInitializer();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A token representing a method&#39;s properties detached from a type.
&nbsp;     */
&nbsp;    class Token implements ByteCodeElement.Token&lt;Token&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The internal name of the represented method.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The modifiers of the represented method.
&nbsp;         */
&nbsp;        private final int modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of tokens representing the method&#39;s type variables.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeVariableToken&gt; typeVariableTokens;
&nbsp;
&nbsp;        /**
&nbsp;         * The return type of the represented method.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic returnType;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter tokens of the represented method.
&nbsp;         */
&nbsp;        private final List&lt;? extends ParameterDescription.Token&gt; parameterTokens;
&nbsp;
&nbsp;        /**
&nbsp;         * The exception types of the represented method.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeDescription.Generic&gt; exceptionTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotations of the represented method.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;
&nbsp;        /**
&nbsp;         * The default value of the represented method or {@code null} if no such value exists.
&nbsp;         */
&nbsp;        private final AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;        /**
&nbsp;         * The receiver type of the represented method or {@code null} if the receiver type is implicit.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic receiverType;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new method token representing a constructor without any parameters, exception types, type variables or annotations.
&nbsp;         * All types must be represented in an detached format.
&nbsp;         *
&nbsp;         * @param modifiers The constructor&#39;s modifiers.
&nbsp;         */
&nbsp;        public Token(int modifiers) {
<b class="fc">&nbsp;            this(MethodDescription.CONSTRUCTOR_INTERNAL_NAME, modifiers, TypeDescription.Generic.VOID);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new method token representing a method without any parameters, exception types, type variables or annotations.
&nbsp;         * All types must be represented in an detached format.
&nbsp;         *
&nbsp;         * @param name       The name of the method.
&nbsp;         * @param modifiers  The modifiers of the method.
&nbsp;         * @param returnType The return type of the method.
&nbsp;         */
&nbsp;        public Token(String name, int modifiers, TypeDescription.Generic returnType) {
<b class="fc">&nbsp;            this(name, modifiers, returnType, Collections.&lt;TypeDescription.Generic&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new method token with simple values. All types must be represented in an detached format.
&nbsp;         *
&nbsp;         * @param name           The internal name of the represented method.
&nbsp;         * @param modifiers      The modifiers of the represented method.
&nbsp;         * @param returnType     The return type of the represented method.
&nbsp;         * @param parameterTypes The parameter types of this method.
&nbsp;         */
&nbsp;        public Token(String name, int modifiers, TypeDescription.Generic returnType, List&lt;? extends TypeDescription.Generic&gt; parameterTypes) {
<b class="fc">&nbsp;            this(name,</b>
&nbsp;                    modifiers,
<b class="fc">&nbsp;                    Collections.&lt;TypeVariableToken&gt;emptyList(),</b>
&nbsp;                    returnType,
&nbsp;                    new ParameterDescription.Token.TypeList(parameterTypes),
<b class="fc">&nbsp;                    Collections.&lt;TypeDescription.Generic&gt;emptyList(),</b>
<b class="fc">&nbsp;                    Collections.&lt;AnnotationDescription&gt;emptyList(),</b>
&nbsp;                    AnnotationValue.UNDEFINED,
&nbsp;                    TypeDescription.Generic.UNDEFINED);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new token for a method description. All types must be represented in an detached format.
&nbsp;         *
&nbsp;         * @param name               The internal name of the represented method.
&nbsp;         * @param modifiers          The modifiers of the represented method.
&nbsp;         * @param typeVariableTokens The type variables of the the represented method.
&nbsp;         * @param returnType         The return type of the represented method.
&nbsp;         * @param parameterTokens    The parameter tokens of the represented method.
&nbsp;         * @param exceptionTypes     The exception types of the represented method.
&nbsp;         * @param annotations        The annotations of the represented method.
&nbsp;         * @param defaultValue       The default value of the represented method or {@code null} if no such value exists.
&nbsp;         * @param receiverType       The receiver type of the represented method or {@code null} if the receiver type is implicit.
&nbsp;         */
&nbsp;        public Token(String name,
&nbsp;                     int modifiers,
&nbsp;                     List&lt;? extends TypeVariableToken&gt; typeVariableTokens,
&nbsp;                     TypeDescription.Generic returnType,
&nbsp;                     List&lt;? extends ParameterDescription.Token&gt; parameterTokens,
&nbsp;                     List&lt;? extends TypeDescription.Generic&gt; exceptionTypes,
&nbsp;                     List&lt;? extends AnnotationDescription&gt; annotations,
&nbsp;                     AnnotationValue&lt;?, ?&gt; defaultValue,
<b class="fc">&nbsp;                     TypeDescription.Generic receiverType) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.modifiers = modifiers;</b>
<b class="fc">&nbsp;            this.typeVariableTokens = typeVariableTokens;</b>
<b class="fc">&nbsp;            this.returnType = returnType;</b>
<b class="fc">&nbsp;            this.parameterTokens = parameterTokens;</b>
<b class="fc">&nbsp;            this.exceptionTypes = exceptionTypes;</b>
<b class="fc">&nbsp;            this.annotations = annotations;</b>
<b class="fc">&nbsp;            this.defaultValue = defaultValue;</b>
<b class="fc">&nbsp;            this.receiverType = receiverType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the internal name of the represented method.
&nbsp;         *
&nbsp;         * @return The internal name of the represented method.
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the modifiers of the represented method.
&nbsp;         *
&nbsp;         * @return The modifiers of the represented method.
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return modifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type variables of this method token.
&nbsp;         *
&nbsp;         * @return A a list of tokens representing the method&#39;s type variables.
&nbsp;         */
&nbsp;        public TokenList&lt;TypeVariableToken&gt; getTypeVariableTokens() {
<b class="fc">&nbsp;            return new TokenList&lt;TypeVariableToken&gt;(typeVariableTokens);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the return type of the represented method.
&nbsp;         *
&nbsp;         * @return The return type of the represented method.
&nbsp;         */
&nbsp;        public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;            return returnType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the parameter tokens of the represented method.
&nbsp;         *
&nbsp;         * @return The parameter tokens of the represented method.
&nbsp;         */
&nbsp;        public TokenList&lt;ParameterDescription.Token&gt; getParameterTokens() {
<b class="fc">&nbsp;            return new TokenList&lt;ParameterDescription.Token&gt;(parameterTokens);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the exception types of the represented method.
&nbsp;         *
&nbsp;         * @return The exception types of the represented method.
&nbsp;         */
&nbsp;        public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;            return new TypeList.Generic.Explicit(exceptionTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the annotations of the represented method.
&nbsp;         *
&nbsp;         * @return The annotations of the represented method.
&nbsp;         */
&nbsp;        public AnnotationList getAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(annotations);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the default value of the represented method.
&nbsp;         *
&nbsp;         * @return The default value of the represented method or {@code null} if no such value exists.
&nbsp;         */
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="fc">&nbsp;            return defaultValue;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the receiver type of this token or {@code null} if the receiver type is implicit.
&nbsp;         *
&nbsp;         * @return The receiver type of this token or {@code null} if the receiver type is implicit.
&nbsp;         */
&nbsp;        public TypeDescription.Generic getReceiverType() {
<b class="fc">&nbsp;            return receiverType;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Token accept(TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
<b class="fc">&nbsp;            return new Token(name,</b>
&nbsp;                    modifiers,
<b class="fc">&nbsp;                    getTypeVariableTokens().accept(visitor),</b>
<b class="fc">&nbsp;                    returnType.accept(visitor),</b>
<b class="fc">&nbsp;                    getParameterTokens().accept(visitor),</b>
<b class="pc">&nbsp;                    getExceptionTypes().accept(visitor),</b>
&nbsp;                    annotations,
&nbsp;                    defaultValue,
&nbsp;                    receiverType == null
&nbsp;                            ? TypeDescription.Generic.UNDEFINED
<b class="nc">&nbsp;                            : receiverType.accept(visitor));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a signature token that represents the method that is represented by this token.
&nbsp;         *
&nbsp;         * @param declaringType The declaring type of the method that this token represents.
&nbsp;         * @return A signature token representing this token.
&nbsp;         */
&nbsp;        public SignatureToken asSignatureToken(TypeDescription declaringType) {
<b class="fc">&nbsp;            TypeDescription.Generic.Visitor&lt;TypeDescription&gt; visitor = new TypeDescription.Generic.Visitor.Reducing(declaringType, typeVariableTokens);</b>
<b class="fc">&nbsp;            List&lt;TypeDescription&gt; parameters = new ArrayList&lt;TypeDescription&gt;(parameterTokens.size());</b>
<b class="fc">&nbsp;            for (ParameterDescription.Token parameter : parameterTokens) {</b>
<b class="fc">&nbsp;                parameters.add(parameter.getType().accept(visitor));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new SignatureToken(name, returnType.accept(visitor), parameters);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
<b class="nc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (other == null || getClass() != other.getClass()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            Token token = (Token) other;</b>
<b class="nc">&nbsp;            return modifiers == token.modifiers</b>
<b class="nc">&nbsp;                    &amp;&amp; name.equals(token.name)</b>
<b class="nc">&nbsp;                    &amp;&amp; typeVariableTokens.equals(token.typeVariableTokens)</b>
<b class="nc">&nbsp;                    &amp;&amp; returnType.equals(token.returnType)</b>
<b class="nc">&nbsp;                    &amp;&amp; parameterTokens.equals(token.parameterTokens)</b>
<b class="nc">&nbsp;                    &amp;&amp; exceptionTypes.equals(token.exceptionTypes)</b>
<b class="nc">&nbsp;                    &amp;&amp; annotations.equals(token.annotations)</b>
<b class="nc">&nbsp;                    &amp;&amp; (defaultValue != null ? defaultValue.equals(token.defaultValue) : token.defaultValue == null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (receiverType != null ? receiverType.equals(token.receiverType) : token.receiverType == null);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = name.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + modifiers;</b>
<b class="nc">&nbsp;            result = 31 * result + typeVariableTokens.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + returnType.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + parameterTokens.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + exceptionTypes.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + annotations.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + (defaultValue != null ? defaultValue.hashCode() : 0);</b>
<b class="nc">&nbsp;            result = 31 * result + (receiverType != null ? receiverType.hashCode() : 0);</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return &quot;MethodDescription.Token{&quot; +</b>
&nbsp;                    &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
&nbsp;                    &quot;, modifiers=&quot; + modifiers +
&nbsp;                    &quot;, typeVariableTokens=&quot; + typeVariableTokens +
&nbsp;                    &quot;, returnType=&quot; + returnType +
&nbsp;                    &quot;, parameterTokens=&quot; + parameterTokens +
&nbsp;                    &quot;, exceptionTypes=&quot; + exceptionTypes +
&nbsp;                    &quot;, annotations=&quot; + annotations +
&nbsp;                    &quot;, defaultValue=&quot; + defaultValue +
&nbsp;                    &quot;, receiverType=&quot; + receiverType +
&nbsp;                    &#39;}&#39;;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A token representing a method&#39;s name and raw return and parameter types.
&nbsp;     */
&nbsp;    class SignatureToken {
&nbsp;
&nbsp;        /**
&nbsp;         * The internal name of the represented method.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The represented method&#39;s raw return type.
&nbsp;         */
&nbsp;        private final TypeDescription returnType;
&nbsp;
&nbsp;        /**
&nbsp;         * The represented method&#39;s raw parameter types.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeDescription&gt; parameterTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type token.
&nbsp;         *
&nbsp;         * @param name           The internal name of the represented method.
&nbsp;         * @param returnType     The represented method&#39;s raw return type.
&nbsp;         * @param parameterTypes The represented method&#39;s raw parameter types.
&nbsp;         */
<b class="fc">&nbsp;        public SignatureToken(String name, TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.returnType = returnType;</b>
<b class="fc">&nbsp;            this.parameterTypes = parameterTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the internal name of the represented method.
&nbsp;         *
&nbsp;         * @return The internal name of the represented method.
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns this token&#39;s return type.
&nbsp;         *
&nbsp;         * @return This token&#39;s return type.
&nbsp;         */
&nbsp;        public TypeDescription getReturnType() {
<b class="nc">&nbsp;            return returnType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns this token&#39;s parameter types.
&nbsp;         *
&nbsp;         * @return This token&#39;s parameter types.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public List&lt;TypeDescription&gt; getParameterTypes() {
<b class="fc">&nbsp;            return (List&lt;TypeDescription&gt;) parameterTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns this signature token as a type token.
&nbsp;         *
&nbsp;         * @return This signature token as a type token.
&nbsp;         */
&nbsp;        public TypeToken asTypeToken() {
<b class="fc">&nbsp;            return new TypeToken(returnType, parameterTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            int result = name.hashCode();</b>
<b class="fc">&nbsp;            result = 31 * result + returnType.hashCode();</b>
<b class="fc">&nbsp;            result = 31 * result + parameterTypes.hashCode();</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
<b class="pc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="pc">&nbsp;            } else if (!(other instanceof SignatureToken)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            SignatureToken signatureToken = (SignatureToken) other;</b>
<b class="fc">&nbsp;            return name.equals(signatureToken.name)</b>
<b class="pc">&nbsp;                    &amp;&amp; returnType.equals(signatureToken.returnType)</b>
<b class="fc">&nbsp;                    &amp;&amp; parameterTypes.equals(signatureToken.parameterTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder().append(returnType).append(&#39; &#39;).append(name).append(&#39;(&#39;);</b>
<b class="nc">&nbsp;            boolean first = true;</b>
<b class="nc">&nbsp;            for (TypeDescription parameterType : parameterTypes) {</b>
<b class="nc">&nbsp;                if (first) {</b>
<b class="nc">&nbsp;                    first = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                }
<b class="nc">&nbsp;                stringBuilder.append(parameterType);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return stringBuilder.append(&#39;)&#39;).toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A token representing a method&#39;s erased return and parameter types.
&nbsp;     */
&nbsp;    class TypeToken {
&nbsp;
&nbsp;        /**
&nbsp;         * The represented method&#39;s raw return type.
&nbsp;         */
&nbsp;        private final TypeDescription returnType;
&nbsp;
&nbsp;        /**
&nbsp;         * The represented method&#39;s raw parameter types.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeDescription&gt; parameterTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type token.
&nbsp;         *
&nbsp;         * @param returnType     The represented method&#39;s raw return type.
&nbsp;         * @param parameterTypes The represented method&#39;s raw parameter types.
&nbsp;         */
<b class="fc">&nbsp;        public TypeToken(TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {</b>
<b class="fc">&nbsp;            this.returnType = returnType;</b>
<b class="fc">&nbsp;            this.parameterTypes = parameterTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns this token&#39;s return type.
&nbsp;         *
&nbsp;         * @return This token&#39;s return type.
&nbsp;         */
&nbsp;        public TypeDescription getReturnType() {
<b class="fc">&nbsp;            return returnType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns this token&#39;s parameter types.
&nbsp;         *
&nbsp;         * @return This token&#39;s parameter types.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public List&lt;TypeDescription&gt; getParameterTypes() {
<b class="fc">&nbsp;            return (List&lt;TypeDescription&gt;) parameterTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            int result = returnType.hashCode();</b>
<b class="fc">&nbsp;            result = 31 * result + parameterTypes.hashCode();</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
<b class="pc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="pc">&nbsp;            } else if (!(other instanceof TypeToken)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            TypeToken typeToken = (TypeToken) other;</b>
<b class="fc">&nbsp;            return returnType.equals(typeToken.returnType) &amp;&amp; parameterTypes.equals(typeToken.parameterTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder().append(&#39;(&#39;);</b>
<b class="nc">&nbsp;            for (TypeDescription parameterType : parameterTypes) {</b>
<b class="nc">&nbsp;                stringBuilder.append(parameterType.getDescriptor());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return stringBuilder.append(&#39;)&#39;).append(returnType.getDescriptor()).toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
