


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > ParameterDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.method</a>
</div>

<h1>Coverage Summary for Class: ParameterDescription (net.bytebuddy.description.method)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">ParameterDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (4/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22,7%
  </span>
  <span class="absValue">
    (5/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36,4%
  </span>
  <span class="absValue">
    (12/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter</td>
<td class="coverageStat">
  <span class="percent">
    85,7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88,9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$Dispatcher$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$Dispatcher$ForJava8CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    83,3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    34,6%
  </span>
  <span class="absValue">
    (9/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$OfConstructor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (2/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$OfMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83,3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$InDefinedShape</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$InDefinedShape$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$InGenericShape</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$Latent</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (9/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12,5%
  </span>
  <span class="absValue">
    (1/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77,8%
  </span>
  <span class="absValue">
    (21/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$Token</td>
<td class="coverageStat">
  <span class="percent">
    69,2%
  </span>
  <span class="absValue">
    (9/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46,7%
  </span>
  <span class="absValue">
    (14/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$Token$TypeList</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$TypeSubstituting</td>
<td class="coverageStat">
  <span class="percent">
    72,7%
  </span>
  <span class="absValue">
    (8/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78,6%
  </span>
  <span class="absValue">
    (11/14)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    73%
  </span>
  <span class="absValue">
    (54/74)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16,2%
  </span>
  <span class="absValue">
    (11/68)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58,5%
  </span>
  <span class="absValue">
    (100/171)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.description.method;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.ModifierReviewable;
&nbsp;import net.bytebuddy.description.NamedElement;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationSource;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.*;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.AbstractList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;
&nbsp;/**
&nbsp; * Description of the parameter of a Java method or constructor.
&nbsp; */
&nbsp;public interface ParameterDescription extends AnnotationSource,
&nbsp;        NamedElement.WithRuntimeName,
&nbsp;        NamedElement.WithOptionalName,
&nbsp;        ModifierReviewable.ForParameterDescription,
&nbsp;        ByteCodeElement.TypeDependant&lt;ParameterDescription.InDefinedShape, ParameterDescription.Token&gt; {
&nbsp;
&nbsp;    /**
&nbsp;     * The prefix for names of an unnamed parameter.
&nbsp;     */
&nbsp;    String NAME_PREFIX = &quot;arg&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the type of this parameter.
&nbsp;     *
&nbsp;     * @return The type of this parameter.
&nbsp;     */
&nbsp;    TypeDescription.Generic getType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the method that declares this parameter.
&nbsp;     *
&nbsp;     * @return The method that declares this parameter.
&nbsp;     */
&nbsp;    MethodDescription getDeclaringMethod();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this parameter&#39;s index.
&nbsp;     *
&nbsp;     * @return The index of this parameter.
&nbsp;     */
&nbsp;    int getIndex();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this parameter has an explicit modifier. A parameter without a modifier is simply treated as
&nbsp;     * if it had a modifier of zero.
&nbsp;     *
&nbsp;     * @return {@code true} if this parameter defines explicit modifiers.
&nbsp;     */
&nbsp;    boolean hasModifiers();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the offset to the parameter value within the local method variable.
&nbsp;     *
&nbsp;     * @return The offset of this parameter&#39;s value.
&nbsp;     */
&nbsp;    int getOffset();
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a parameter description in its generic shape, i.e. in the shape it is defined by a generic or raw type.
&nbsp;     */
&nbsp;    interface InGenericShape extends ParameterDescription {
&nbsp;
&nbsp;        @Override
&nbsp;        MethodDescription.InGenericShape getDeclaringMethod();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a parameter in its defined shape, i.e. in the form it is defined by a class without its type variables being resolved.
&nbsp;     */
&nbsp;    interface InDefinedShape extends ParameterDescription {
&nbsp;
&nbsp;        @Override
&nbsp;        MethodDescription.InDefinedShape getDeclaringMethod();
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a parameter description in its defined shape.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase extends ParameterDescription.AbstractBase implements InDefinedShape {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public InDefinedShape asDefined() {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A base implementation of a method parameter description.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase extends ModifierReviewable.AbstractBase implements ParameterDescription {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return NAME_PREFIX.concat(String.valueOf(getIndex()));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getInternalName() {
<b class="nc">&nbsp;            return getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getActualName() {
<b class="nc">&nbsp;            return isNamed()</b>
<b class="nc">&nbsp;                    ? getName()</b>
&nbsp;                    : EMPTY_NAME;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
<b class="nc">&nbsp;            return EMPTY_MASK;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOffset() {
<b class="fc">&nbsp;            TypeList parameterType = getDeclaringMethod().getParameters().asTypeList().asErasures();</b>
<b class="pc">&nbsp;            int offset = getDeclaringMethod().isStatic()</b>
<b class="nc">&nbsp;                    ? StackSize.ZERO.getSize()</b>
<b class="fc">&nbsp;                    : StackSize.SINGLE.getSize();</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; getIndex(); i++) {</b>
<b class="fc">&nbsp;                offset += parameterType.get(i).getStackSize().getSize();</b>
&nbsp;            }
<b class="fc">&nbsp;            return offset;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Token asToken(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;            return new Token(getType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)),</b>
<b class="fc">&nbsp;                    getDeclaredAnnotations(),</b>
<b class="pc">&nbsp;                    isNamed()</b>
<b class="nc">&nbsp;                            ? getName()</b>
&nbsp;                            : Token.NO_NAME,
<b class="pc">&nbsp;                    hasModifiers()</b>
<b class="nc">&nbsp;                            ? (Integer) getModifiers()</b>
&nbsp;                            : Token.NO_MODIFIERS);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
<b class="nc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (!(other instanceof ParameterDescription)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            ParameterDescription parameterDescription = (ParameterDescription) other;</b>
<b class="nc">&nbsp;            return getDeclaringMethod().equals(parameterDescription.getDeclaringMethod()) &amp;&amp; getIndex() == parameterDescription.getIndex();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return getDeclaringMethod().hashCode() ^ getIndex();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder(Modifier.toString(getModifiers()));</b>
<b class="nc">&nbsp;            if (getModifiers() != EMPTY_MASK) {</b>
<b class="nc">&nbsp;                stringBuilder.append(&#39; &#39;);</b>
&nbsp;            }
<b class="nc">&nbsp;            stringBuilder.append(isVarArgs()</b>
<b class="nc">&nbsp;                    ? getType().asErasure().getName().replaceFirst(&quot;\\[\\]$&quot;, &quot;...&quot;)</b>
<b class="nc">&nbsp;                    : getType().asErasure().getName());</b>
<b class="nc">&nbsp;            return stringBuilder.append(&#39; &#39;).append(getName()).toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Description of a loaded parameter with support for the information exposed by {@code java.lang.reflect.Parameter}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the {@code java.lang.reflect.Executable} that this list represents.
&nbsp;     */
&nbsp;    abstract class ForLoadedParameter&lt;T extends AccessibleObject&gt; extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for reading properties from {@code java.lang.reflect.Executable} instances.
&nbsp;         */
<b class="fc">&nbsp;        private static final Dispatcher DISPATCHER = AccessController.doPrivileged(Dispatcher.CreationAction.INSTANCE);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The {@code java.lang.reflect.Executable} for which the parameter types are described.
&nbsp;         */
&nbsp;        protected final T executable;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter&#39;s index.
&nbsp;         */
&nbsp;        protected final int index;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new description for a loaded parameter.
&nbsp;         *
&nbsp;         * @param executable The {@code java.lang.reflect.Executable} for which the parameter types are described.
&nbsp;         * @param index      The parameter&#39;s index.
&nbsp;         */
<b class="fc">&nbsp;        protected ForLoadedParameter(T executable, int index) {</b>
<b class="fc">&nbsp;            this.executable = executable;</b>
<b class="fc">&nbsp;            this.index = index;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return DISPATCHER.getName(executable, index);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getIndex() {
<b class="fc">&nbsp;            return index;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isNamed() {
<b class="fc">&nbsp;            return DISPATCHER.isNamePresent(executable, index);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return DISPATCHER.getModifiers(executable, index);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean hasModifiers() {
&nbsp;            // Rational: If a parameter is not named despite the information being attached,
&nbsp;            // it is synthetic, i.e. it has non-default modifiers.
<b class="pc">&nbsp;            return isNamed() || getModifiers() != EMPTY_MASK;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher creating parameter descriptions based on the API that is available for the current JVM.
&nbsp;         */
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the given parameter&#39;s modifiers.
&nbsp;             *
&nbsp;             * @param executable The executable to introspect.
&nbsp;             * @param index      The parameter&#39;s index.
&nbsp;             * @return The parameter&#39;s modifiers.
&nbsp;             */
&nbsp;            int getModifiers(AccessibleObject executable, int index);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if the given parameter has an explicit name.
&nbsp;             *
&nbsp;             * @param executable The parameter to introspect.
&nbsp;             * @param index      The parameter&#39;s index.
&nbsp;             * @return {@code true} if the given parameter has an explicit name.
&nbsp;             */
&nbsp;            boolean isNamePresent(AccessibleObject executable, int index);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the given parameter&#39;s implicit or explicit name.
&nbsp;             *
&nbsp;             * @param executable The parameter to introspect.
&nbsp;             * @param index      The parameter&#39;s index.
&nbsp;             * @return The parameter&#39;s name.
&nbsp;             */
&nbsp;            String getName(AccessibleObject executable, int index);
&nbsp;
&nbsp;            /**
&nbsp;             * A creation action for a dispatcher.
&nbsp;             */
<b class="fc">&nbsp;            enum CreationAction implements PrivilegedAction&lt;Dispatcher&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                @Override
&nbsp;                @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback&quot;)
&nbsp;                public Dispatcher run() {
&nbsp;                    try {
<b class="fc">&nbsp;                        Class&lt;?&gt; executableType = Class.forName(&quot;java.lang.reflect.Executable&quot;);</b>
<b class="fc">&nbsp;                        Class&lt;?&gt; parameterType = Class.forName(&quot;java.lang.reflect.Parameter&quot;);</b>
<b class="fc">&nbsp;                        return new Dispatcher.ForJava8CapableVm(executableType.getMethod(&quot;getParameters&quot;),</b>
<b class="fc">&nbsp;                                parameterType.getMethod(&quot;getName&quot;),</b>
<b class="fc">&nbsp;                                parameterType.getMethod(&quot;isNamePresent&quot;),</b>
<b class="fc">&nbsp;                                parameterType.getMethod(&quot;getModifiers&quot;));</b>
<b class="nc">&nbsp;                    } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                        return Dispatcher.ForLegacyVm.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for VMs that support the {@code java.lang.reflect.Parameter} API for Java 8+.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForJava8CapableVm implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * An empty array that can be used to indicate no arguments to avoid an allocation on a reflective call.
&nbsp;                 */
<b class="fc">&nbsp;                private static final Object[] NO_ARGUMENTS = new Object[0];</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A reference to {@code java.lang.reflect.Executable#getParameters}.
&nbsp;                 */
&nbsp;                private final Method getParameters;
&nbsp;
&nbsp;                /**
&nbsp;                 * A reference to {@code java.lang.reflect.Parameter#getName}.
&nbsp;                 */
&nbsp;                private final Method getName;
&nbsp;
&nbsp;                /**
&nbsp;                 * A reference to {@code java.lang.reflect.Parameter#isNamePresent}.
&nbsp;                 */
&nbsp;                private final Method isNamePresent;
&nbsp;
&nbsp;                /**
&nbsp;                 * A reference to {@code java.lang.reflect.Parameter#getModifiers}.
&nbsp;                 */
&nbsp;                private final Method getModifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new dispatcher for a modern VM.
&nbsp;                 *
&nbsp;                 * @param getParameters A reference to {@code java.lang.reflect.Executable#getTypeArguments}.
&nbsp;                 * @param getName       A reference to {@code java.lang.reflect.Parameter#getName}.
&nbsp;                 * @param isNamePresent A reference to {@code java.lang.reflect.Parameter#isNamePresent}.
&nbsp;                 * @param getModifiers  A reference to {@code java.lang.reflect.Parameter#getModifiers}.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForJava8CapableVm(Method getParameters, Method getName, Method isNamePresent, Method getModifiers) {</b>
<b class="fc">&nbsp;                    this.getParameters = getParameters;</b>
<b class="fc">&nbsp;                    this.getName = getName;</b>
<b class="fc">&nbsp;                    this.isNamePresent = isNamePresent;</b>
<b class="fc">&nbsp;                    this.getModifiers = getModifiers;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int getModifiers(AccessibleObject executable, int index) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Integer) getModifiers.invoke(getParameter(executable, index), NO_ARGUMENTS);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access java.lang.reflect.Parameter#getModifiers&quot;, exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Error invoking java.lang.reflect.Parameter#getModifiers&quot;, exception.getCause());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isNamePresent(AccessibleObject executable, int index) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Boolean) isNamePresent.invoke(getParameter(executable, index), NO_ARGUMENTS);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access java.lang.reflect.Parameter#isNamePresent&quot;, exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Error invoking java.lang.reflect.Parameter#isNamePresent&quot;, exception.getCause());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getName(AccessibleObject executable, int index) {
&nbsp;                    try {
<b class="nc">&nbsp;                        return (String) getName.invoke(getParameter(executable, index), NO_ARGUMENTS);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access java.lang.reflect.Parameter#getName&quot;, exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Error invoking java.lang.reflect.Parameter#getName&quot;, exception.getCause());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the {@code java.lang.reflect.Parameter} of an executable at a given index.
&nbsp;                 *
&nbsp;                 * @param executable The executable for which a parameter should be read.
&nbsp;                 * @param index      The index of the parameter.
&nbsp;                 * @return The parameter for the given index.
&nbsp;                 */
&nbsp;                private Object getParameter(AccessibleObject executable, int index) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return Array.get(getParameters.invoke(executable, NO_ARGUMENTS), index);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access java.lang.reflect.Executable#getParameters&quot;, exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Error invoking java.lang.reflect.Executable#getParameters&quot;, exception.getCause());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a legacy VM that does not know the {@code java.lang.reflect.Parameter} type that only throws
&nbsp;             * exceptions on any property extraction.
&nbsp;             */
&nbsp;            enum ForLegacyVm implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                @Override
&nbsp;                public int getModifiers(AccessibleObject executable, int index) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot dispatch method for java.lang.reflect.Parameter&quot;);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isNamePresent(AccessibleObject executable, int index) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot dispatch method for java.lang.reflect.Parameter&quot;);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getName(AccessibleObject executable, int index) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot dispatch method for java.lang.reflect.Parameter&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A description of a loaded {@link Method} parameter for a modern VM.
&nbsp;         */
&nbsp;        protected static class OfMethod extends ForLoadedParameter&lt;Method&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new description for a loaded method.
&nbsp;             *
&nbsp;             * @param method The method for which a parameter is represented.
&nbsp;             * @param index  The index of the parameter.
&nbsp;             */
&nbsp;            protected OfMethod(Method method, int index) {
<b class="fc">&nbsp;                super(method, index);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;BC_UNCONFIRMED_CAST&quot;, justification = &quot;The implicit field type casting is not understood by Findbugs&quot;)
&nbsp;            public MethodDescription.InDefinedShape getDeclaringMethod() {
<b class="fc">&nbsp;                return new MethodDescription.ForLoadedMethod(executable);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;BC_UNCONFIRMED_CAST&quot;, justification = &quot;The implicit field type casting is not understood by Findbugs&quot;)
&nbsp;            public TypeDescription.Generic getType() {
<b class="pc">&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                    return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(executable.getParameterTypes()[index]);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new TypeDescription.Generic.LazyProjection.OfMethodParameter(executable, index, executable.getParameterTypes());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;BC_UNCONFIRMED_CAST&quot;, justification = &quot;The implicit field type casting is not understood by Findbugs&quot;)
&nbsp;            public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                return new AnnotationList.ForLoadedAnnotations(executable.getParameterAnnotations()[index]);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A description of a loaded {@link Constructor} parameter for a modern VM.
&nbsp;         */
&nbsp;        protected static class OfConstructor extends ForLoadedParameter&lt;Constructor&lt;?&gt;&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new description for a loaded constructor.
&nbsp;             *
&nbsp;             * @param constructor The constructor for which a parameter is represented.
&nbsp;             * @param index       The index of the parameter.
&nbsp;             */
&nbsp;            protected OfConstructor(Constructor&lt;?&gt; constructor, int index) {
<b class="fc">&nbsp;                super(constructor, index);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;BC_UNCONFIRMED_CAST&quot;, justification = &quot;The implicit field type casting is not understood by Findbugs&quot;)
&nbsp;            public MethodDescription.InDefinedShape getDeclaringMethod() {
<b class="fc">&nbsp;                return new MethodDescription.ForLoadedConstructor(executable);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;BC_UNCONFIRMED_CAST&quot;, justification = &quot;The implicit field type casting is not understood by Findbugs&quot;)
&nbsp;            public TypeDescription.Generic getType() {
<b class="pc">&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                    return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(executable.getParameterTypes()[index]);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new TypeDescription.Generic.LazyProjection.OfConstructorParameter(executable, index, executable.getParameterTypes());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;BC_UNCONFIRMED_CAST&quot;, justification = &quot;The implicit field type casting is not understood by Findbugs&quot;)
&nbsp;            public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                Annotation[][] annotation = executable.getParameterAnnotations();</b>
<b class="fc">&nbsp;                MethodDescription.InDefinedShape declaringMethod = getDeclaringMethod();</b>
<b class="pc">&nbsp;                if (annotation.length != declaringMethod.getParameters().size() &amp;&amp; declaringMethod.getDeclaringType().isInnerClass()) {</b>
<b class="nc">&nbsp;                    return index == 0</b>
&nbsp;                            ? new AnnotationList.Empty()
&nbsp;                            : new AnnotationList.ForLoadedAnnotations(annotation[index - 1]);
&nbsp;                } else {
<b class="fc">&nbsp;                    return new AnnotationList.ForLoadedAnnotations(annotation[index]);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Description of a loaded method&#39;s parameter on a virtual machine where {@code java.lang.reflect.Parameter}
&nbsp;         * is not available.
&nbsp;         */
&nbsp;        protected static class OfLegacyVmMethod extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The method that declares this parameter.
&nbsp;             */
&nbsp;            private final Method method;
&nbsp;
&nbsp;            /**
&nbsp;             * The index of this parameter.
&nbsp;             */
&nbsp;            private final int index;
&nbsp;
&nbsp;            /**
&nbsp;             * The type erasures of the represented method.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt;[] parameterType;
&nbsp;
&nbsp;            /**
&nbsp;             * The annotations of the represented method&#39;s parameters.
&nbsp;             */
&nbsp;            private final Annotation[][] parameterAnnotation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a legacy representation of a method&#39;s parameter.
&nbsp;             *
&nbsp;             * @param method              The method that declares this parameter.
&nbsp;             * @param index               The index of this parameter.
&nbsp;             * @param parameterType       The type erasures of the represented method.
&nbsp;             * @param parameterAnnotation The annotations of the represented method&#39;s parameters.
&nbsp;             */
&nbsp;            protected OfLegacyVmMethod(Method method, int index, Class&lt;?&gt;[] parameterType, Annotation[][] parameterAnnotation) {
&nbsp;                this.method = method;
&nbsp;                this.index = index;
&nbsp;                this.parameterType = parameterType;
&nbsp;                this.parameterAnnotation = parameterAnnotation;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription.Generic getType() {
&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {
&nbsp;                    return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(parameterType[index]);
&nbsp;                }
&nbsp;                return new TypeDescription.Generic.LazyProjection.OfMethodParameter(method, index, parameterType);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription.InDefinedShape getDeclaringMethod() {
&nbsp;                return new MethodDescription.ForLoadedMethod(method);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int getIndex() {
&nbsp;                return index;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isNamed() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean hasModifiers() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationList getDeclaredAnnotations() {
&nbsp;                return new AnnotationList.ForLoadedAnnotations(parameterAnnotation[index]);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Description of a loaded constructor&#39;s parameter on a virtual machine where {@code java.lang.reflect.Parameter}
&nbsp;         * is not available.
&nbsp;         */
&nbsp;        protected static class OfLegacyVmConstructor extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The method that declares this parameter.
&nbsp;             */
&nbsp;            private final Constructor&lt;?&gt; constructor;
&nbsp;
&nbsp;            /**
&nbsp;             * The index of this parameter.
&nbsp;             */
&nbsp;            private final int index;
&nbsp;
&nbsp;            /**
&nbsp;             * The type erasures of the represented method.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt;[] parameterType;
&nbsp;
&nbsp;            /**
&nbsp;             * The annotations of this parameter.
&nbsp;             */
&nbsp;            private final Annotation[][] parameterAnnotation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a legacy representation of a method&#39;s parameter.
&nbsp;             *
&nbsp;             * @param constructor         The constructor that declares this parameter.
&nbsp;             * @param index               The index of this parameter.
&nbsp;             * @param parameterType       The type erasures of the represented method.
&nbsp;             * @param parameterAnnotation An array of all parameter annotations of the represented method.
&nbsp;             */
&nbsp;            protected OfLegacyVmConstructor(Constructor&lt;?&gt; constructor, int index, Class&lt;?&gt;[] parameterType, Annotation[][] parameterAnnotation) {
&nbsp;                this.constructor = constructor;
&nbsp;                this.index = index;
&nbsp;                this.parameterType = parameterType;
&nbsp;                this.parameterAnnotation = parameterAnnotation;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription.Generic getType() {
&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {
&nbsp;                    return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(parameterType[index]);
&nbsp;                }
&nbsp;                return new TypeDescription.Generic.LazyProjection.OfConstructorParameter(constructor, index, parameterType);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription.InDefinedShape getDeclaringMethod() {
&nbsp;                return new MethodDescription.ForLoadedConstructor(constructor);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int getIndex() {
&nbsp;                return index;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isNamed() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean hasModifiers() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationList getDeclaredAnnotations() {
&nbsp;                MethodDescription.InDefinedShape declaringMethod = getDeclaringMethod();
&nbsp;                if (parameterAnnotation.length != declaringMethod.getParameters().size() &amp;&amp; declaringMethod.getDeclaringType().isInnerClass()) {
&nbsp;                    return index == 0
&nbsp;                            ? new AnnotationList.Empty()
&nbsp;                            : new AnnotationList.ForLoadedAnnotations(parameterAnnotation[index - 1]);
&nbsp;                } else {
&nbsp;                    return new AnnotationList.ForLoadedAnnotations(parameterAnnotation[index]);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A latent description of a parameter that is not attached to a method or constructor.
&nbsp;     */
&nbsp;    class Latent extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The method that is declaring the parameter.
&nbsp;         */
&nbsp;        private final MethodDescription.InDefinedShape declaringMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * The type of the parameter.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic parameterType;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotations of the parameter.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; declaredAnnotations;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the parameter or {@code null} if no name is explicitly defined.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The modifiers of the parameter or {@code null} if no modifiers are explicitly defined.
&nbsp;         */
&nbsp;        private final Integer modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * The index of the parameter.
&nbsp;         */
&nbsp;        private final int index;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter&#39;s offset in the local method variables array.
&nbsp;         */
&nbsp;        private final int offset;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a latent parameter description. All provided types are attached to this instance before they are returned.
&nbsp;         *
&nbsp;         * @param declaringMethod The method that is declaring the parameter.
&nbsp;         * @param token           The token describing the shape of the parameter.
&nbsp;         * @param index           The index of the parameter.
&nbsp;         * @param offset          The parameter&#39;s offset in the local method variables array.
&nbsp;         */
&nbsp;        public Latent(MethodDescription.InDefinedShape declaringMethod, Token token, int index, int offset) {
<b class="fc">&nbsp;            this(declaringMethod,</b>
<b class="fc">&nbsp;                    token.getType(),</b>
<b class="fc">&nbsp;                    token.getAnnotations(),</b>
<b class="fc">&nbsp;                    token.getName(),</b>
<b class="fc">&nbsp;                    token.getModifiers(),</b>
&nbsp;                    index,
&nbsp;                    offset);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent parameter descriptions for a parameter without explicit meta data or annotations.
&nbsp;         *
&nbsp;         * @param declaringMethod The method declaring this parameter.
&nbsp;         * @param parameterType   The type of the parameter.
&nbsp;         * @param index           The index of the parameter.
&nbsp;         * @param offset          The offset of the parameter.
&nbsp;         */
&nbsp;        public Latent(MethodDescription.InDefinedShape declaringMethod,
&nbsp;                      TypeDescription.Generic parameterType,
&nbsp;                      int index,
&nbsp;                      int offset) {
<b class="fc">&nbsp;            this(declaringMethod,</b>
&nbsp;                    parameterType,
<b class="fc">&nbsp;                    Collections.&lt;AnnotationDescription&gt;emptyList(),</b>
&nbsp;                    Token.NO_NAME,
&nbsp;                    Token.NO_MODIFIERS,
&nbsp;                    index,
&nbsp;                    offset);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a latent parameter description. All provided types are attached to this instance before they are returned.
&nbsp;         *
&nbsp;         * @param declaringMethod     The method that is declaring the parameter.
&nbsp;         * @param parameterType       The parameter&#39;s type.
&nbsp;         * @param declaredAnnotations The annotations of the parameter.
&nbsp;         * @param name                The name of the parameter or {@code null} if no name is explicitly defined.
&nbsp;         * @param modifiers           The modifiers of the parameter or {@code null} if no modifiers are explicitly defined.
&nbsp;         * @param index               The index of the parameter.
&nbsp;         * @param offset              The parameter&#39;s offset in the local method variables array.
&nbsp;         */
&nbsp;        public Latent(MethodDescription.InDefinedShape declaringMethod,
&nbsp;                      TypeDescription.Generic parameterType,
&nbsp;                      List&lt;? extends AnnotationDescription&gt; declaredAnnotations,
&nbsp;                      String name,
&nbsp;                      Integer modifiers,
&nbsp;                      int index,
<b class="fc">&nbsp;                      int offset) {</b>
<b class="fc">&nbsp;            this.declaringMethod = declaringMethod;</b>
<b class="fc">&nbsp;            this.parameterType = parameterType;</b>
<b class="fc">&nbsp;            this.declaredAnnotations = declaredAnnotations;</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.modifiers = modifiers;</b>
<b class="fc">&nbsp;            this.index = index;</b>
<b class="fc">&nbsp;            this.offset = offset;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return parameterType.accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodDescription.InDefinedShape getDeclaringMethod() {
<b class="fc">&nbsp;            return declaringMethod;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getIndex() {
<b class="fc">&nbsp;            return index;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOffset() {
<b class="fc">&nbsp;            return offset;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isNamed() {
<b class="pc">&nbsp;            return name != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean hasModifiers() {
<b class="nc">&nbsp;            return modifiers != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return isNamed()</b>
&nbsp;                    ? name
<b class="nc">&nbsp;                    : super.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
<b class="nc">&nbsp;            return hasModifiers()</b>
<b class="nc">&nbsp;                    ? modifiers</b>
<b class="nc">&nbsp;                    : super.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(declaredAnnotations);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A parameter description that represents a given parameter but with a substituted parameter type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: The supplied visitor must assure to not substitute
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    class TypeSubstituting extends AbstractBase implements InGenericShape {
&nbsp;
&nbsp;        /**
&nbsp;         * The method that declares this type-substituted parameter.
&nbsp;         */
&nbsp;        private final MethodDescription.InGenericShape declaringMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * The represented parameter.
&nbsp;         */
&nbsp;        private final ParameterDescription parameterDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * A visitor that is applied to the parameter type.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type substituting parameter.
&nbsp;         *
&nbsp;         * @param declaringMethod      The method that declares this type-substituted parameter.
&nbsp;         * @param parameterDescription The represented parameter.
&nbsp;         * @param visitor              A visitor that is applied to the parameter type.
&nbsp;         */
&nbsp;        public TypeSubstituting(MethodDescription.InGenericShape declaringMethod,
&nbsp;                                ParameterDescription parameterDescription,
<b class="fc">&nbsp;                                TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {</b>
<b class="fc">&nbsp;            this.declaringMethod = declaringMethod;</b>
<b class="fc">&nbsp;            this.parameterDescription = parameterDescription;</b>
<b class="fc">&nbsp;            this.visitor = visitor;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return parameterDescription.getType().accept(visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodDescription.InGenericShape getDeclaringMethod() {
<b class="fc">&nbsp;            return declaringMethod;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getIndex() {
<b class="fc">&nbsp;            return parameterDescription.getIndex();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isNamed() {
<b class="fc">&nbsp;            return parameterDescription.isNamed();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean hasModifiers() {
<b class="fc">&nbsp;            return parameterDescription.hasModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOffset() {
<b class="fc">&nbsp;            return parameterDescription.getOffset();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return parameterDescription.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
<b class="nc">&nbsp;            return parameterDescription.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return parameterDescription.getDeclaredAnnotations();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public InDefinedShape asDefined() {
<b class="nc">&nbsp;            return parameterDescription.asDefined();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A token representing a parameter&#39;s properties detached from a type.
&nbsp;     */
&nbsp;    class Token implements ByteCodeElement.Token&lt;Token&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicator for a method parameter without an explicit name.
&nbsp;         */
<b class="fc">&nbsp;        public static final String NO_NAME = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Indicator for a method parameter without explicit modifiers.
&nbsp;         */
<b class="fc">&nbsp;        public static final Integer NO_MODIFIERS = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The type of the represented parameter.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic type;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of parameter annotations.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the parameter or {@code null} if no explicit name is defined.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The modifiers of the parameter or {@code null} if no explicit modifiers is defined.
&nbsp;         */
&nbsp;        private final Integer modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new parameter token without an explicit name, an explicit modifier or annotations.
&nbsp;         * The parameter type must be represented in its detached format.
&nbsp;         *
&nbsp;         * @param type The type of the represented parameter.
&nbsp;         */
&nbsp;        public Token(TypeDescription.Generic type) {
<b class="fc">&nbsp;            this(type, Collections.&lt;AnnotationDescription&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new parameter token without an explicit name or an explicit modifier. The parameter type must be represented in its detached format.
&nbsp;         *
&nbsp;         * @param type        The type of the represented parameter.
&nbsp;         * @param annotations The annotations of the parameter.
&nbsp;         */
&nbsp;        public Token(TypeDescription.Generic type, List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;            this(type, annotations, NO_NAME, NO_MODIFIERS);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a parameter token without annotations. The parameter type must be represented in its detached format.
&nbsp;         *
&nbsp;         * @param type      The type of the represented parameter.
&nbsp;         * @param name      The name of the parameter or {@code null} if no explicit name is defined.
&nbsp;         * @param modifiers The modifiers of the parameter or {@code null} if no explicit modifiers is defined.
&nbsp;         */
&nbsp;        public Token(TypeDescription.Generic type, String name, Integer modifiers) {
<b class="nc">&nbsp;            this(type, Collections.&lt;AnnotationDescription&gt;emptyList(), name, modifiers);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new parameter token. The parameter type must be represented in its detached format.
&nbsp;         *
&nbsp;         * @param type        The type of the represented parameter.
&nbsp;         * @param annotations The annotations of the parameter.
&nbsp;         * @param name        The name of the parameter or {@code null} if no explicit name is defined.
&nbsp;         * @param modifiers   The modifiers of the parameter or {@code null} if no explicit modifiers is defined.
&nbsp;         */
&nbsp;        public Token(TypeDescription.Generic type,
&nbsp;                     List&lt;? extends AnnotationDescription&gt; annotations,
&nbsp;                     String name,
<b class="fc">&nbsp;                     Integer modifiers) {</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.annotations = annotations;</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.modifiers = modifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type of the represented method parameter.
&nbsp;         *
&nbsp;         * @return The type of the represented method parameter.
&nbsp;         */
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return type;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the annotations of the represented method parameter.
&nbsp;         *
&nbsp;         * @return The annotations of the represented method parameter.
&nbsp;         */
&nbsp;        public AnnotationList getAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(annotations);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name of the represented method parameter.
&nbsp;         *
&nbsp;         * @return The name of the parameter or {@code null} if no explicit name is defined.
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the modifiers of the represented method parameter.
&nbsp;         *
&nbsp;         * @return The modifiers of the parameter or {@code null} if no explicit modifiers is defined.
&nbsp;         */
&nbsp;        public Integer getModifiers() {
<b class="fc">&nbsp;            return modifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Token accept(TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
<b class="fc">&nbsp;            return new Token(type.accept(visitor),</b>
&nbsp;                    annotations,
&nbsp;                    name,
&nbsp;                    modifiers);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
<b class="nc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (!(other instanceof Token)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            Token token = (Token) other;</b>
<b class="nc">&nbsp;            return type.equals(token.type)</b>
<b class="nc">&nbsp;                    &amp;&amp; annotations.equals(token.annotations)</b>
<b class="nc">&nbsp;                    &amp;&amp; (name != null ? name.equals(token.name) : token.name == null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (modifiers != null ? modifiers.equals(token.modifiers) : token.modifiers == null);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = type.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + annotations.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + (name != null ? name.hashCode() : 0);</b>
<b class="nc">&nbsp;            result = 31 * result + (modifiers != null ? modifiers.hashCode() : 0);</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return &quot;ParameterDescription.Token{&quot; +</b>
&nbsp;                    &quot;type=&quot; + type +
&nbsp;                    &quot;, annotations=&quot; + annotations +
&nbsp;                    &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
&nbsp;                    &quot;, modifiers=&quot; + modifiers +
&nbsp;                    &#39;}&#39;;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A list of types represented as a list of parameter tokens.
&nbsp;         */
&nbsp;        public static class TypeList extends AbstractList&lt;Token&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The list of types to represent as parameter tokens.
&nbsp;             */
&nbsp;            private final List&lt;? extends TypeDefinition&gt; typeDescriptions;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new list of types that represent parameters.
&nbsp;             *
&nbsp;             * @param typeDescriptions The types to represent.
&nbsp;             */
<b class="fc">&nbsp;            public TypeList(List&lt;? extends TypeDefinition&gt; typeDescriptions) {</b>
<b class="fc">&nbsp;                this.typeDescriptions = typeDescriptions;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Token get(int index) {
<b class="nc">&nbsp;                return new Token(typeDescriptions.get(index).asGenericType());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int size() {
<b class="fc">&nbsp;                return typeDescriptions.size();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
