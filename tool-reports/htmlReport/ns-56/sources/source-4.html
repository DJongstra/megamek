


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > ParameterList</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.method</a>
</div>

<h1>Coverage Summary for Class: ParameterList (net.bytebuddy.description.method)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">ParameterList$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58,3%
  </span>
  <span class="absValue">
    (7/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68,2%
  </span>
  <span class="absValue">
    (15/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$Empty</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$Explicit$ForTypes</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88,9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForLoadedExecutable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForLoadedExecutable$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForLoadedExecutable$Dispatcher$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForLoadedExecutable$Dispatcher$ForJava8CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForLoadedExecutable$OfConstructor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForLoadedExecutable$OfMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForTokens</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$TypeSubstituting</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    86,5%
  </span>
  <span class="absValue">
    (32/37)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    65%
  </span>
  <span class="absValue">
    (13/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78,9%
  </span>
  <span class="absValue">
    (60/76)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.description.method;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.FilterableList;
&nbsp;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.List;
&nbsp;
&nbsp;/**
&nbsp; * Represents a list of parameters of a method or a constructor.
&nbsp; *
&nbsp; * @param &lt;T&gt; The type of parameter descriptions represented by this list.
&nbsp; */
&nbsp;public interface ParameterList&lt;T extends ParameterDescription&gt; extends FilterableList&lt;T, ParameterList&lt;T&gt;&gt; {
&nbsp;
&nbsp;    /**
&nbsp;     * Transforms this list of parameters into a list of the types of the represented parameters.
&nbsp;     *
&nbsp;     * @return A list of types representing the parameters of this list.
&nbsp;     */
&nbsp;    TypeList.Generic asTypeList();
&nbsp;
&nbsp;    /**
&nbsp;     * Transforms the list of parameter descriptions into a list of detached tokens. All types that are matched by the provided
&nbsp;     * target type matcher are substituted by {@link net.bytebuddy.dynamic.TargetType}.
&nbsp;     *
&nbsp;     * @param matcher A matcher that indicates type substitution.
&nbsp;     * @return The transformed token list.
&nbsp;     */
&nbsp;    ByteCodeElement.Token.TokenList&lt;ParameterDescription.Token&gt; asTokenList(ElementMatcher&lt;? super TypeDescription&gt; matcher);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this list of these parameter descriptions resolved to their defined shape.
&nbsp;     *
&nbsp;     * @return A list of parameters in their defined shape.
&nbsp;     */
&nbsp;    ParameterList&lt;ParameterDescription.InDefinedShape&gt; asDefined();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if all parameters in this list define both an explicit name and an explicit modifier.
&nbsp;     *
&nbsp;     * @return {@code true} if all parameters in this list define both an explicit name and an explicit modifier.
&nbsp;     */
&nbsp;    boolean hasExplicitMetaData();
&nbsp;
&nbsp;    /**
&nbsp;     * An base implementation for a {@link ParameterList}.
&nbsp;     *
&nbsp;     * @param &lt;S&gt; The type of parameter descriptions represented by this list.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase&lt;S extends ParameterDescription&gt; extends FilterableList.AbstractBase&lt;S, ParameterList&lt;S&gt;&gt; implements ParameterList&lt;S&gt; {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean hasExplicitMetaData() {
<b class="fc">&nbsp;            for (ParameterDescription parameterDescription : this) {</b>
<b class="pc">&nbsp;                if (!parameterDescription.isNamed() || !parameterDescription.hasModifiers()) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ByteCodeElement.Token.TokenList&lt;ParameterDescription.Token&gt; asTokenList(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;            List&lt;ParameterDescription.Token&gt; tokens = new ArrayList&lt;ParameterDescription.Token&gt;(size());</b>
<b class="fc">&nbsp;            for (ParameterDescription parameterDescription : this) {</b>
<b class="fc">&nbsp;                tokens.add(parameterDescription.asToken(matcher));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new ByteCodeElement.Token.TokenList&lt;ParameterDescription.Token&gt;(tokens);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic asTypeList() {
<b class="fc">&nbsp;            List&lt;TypeDescription.Generic&gt; types = new ArrayList&lt;TypeDescription.Generic&gt;(size());</b>
<b class="fc">&nbsp;            for (ParameterDescription parameterDescription : this) {</b>
<b class="fc">&nbsp;                types.add(parameterDescription.getType());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new TypeList.Generic.Explicit(types);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; asDefined() {
<b class="nc">&nbsp;            List&lt;ParameterDescription.InDefinedShape&gt; declaredForms = new ArrayList&lt;ParameterDescription.InDefinedShape&gt;(size());</b>
<b class="nc">&nbsp;            for (ParameterDescription parameterDescription : this) {</b>
<b class="nc">&nbsp;                declaredForms.add(parameterDescription.asDefined());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return new Explicit&lt;ParameterDescription.InDefinedShape&gt;(declaredForms);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected ParameterList&lt;S&gt; wrap(List&lt;S&gt; values) {
<b class="nc">&nbsp;            return new Explicit&lt;S&gt;(values);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a list of parameters for an executable, i.e. a {@link java.lang.reflect.Method} or {@link java.lang.reflect.Constructor}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the {@code java.lang.reflect.Executable} that this list represents.
&nbsp;     */
&nbsp;    abstract class ForLoadedExecutable&lt;T&gt; extends AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The dispatcher used creating parameter list instances and for accessing {@code java.lang.reflect.Executable} instances.
&nbsp;         */
<b class="fc">&nbsp;        private static final Dispatcher DISPATCHER = AccessController.doPrivileged(Dispatcher.CreationAction.INSTANCE);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The executable for which a parameter list is represented.
&nbsp;         */
&nbsp;        protected final T executable;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new description for a loaded executable.
&nbsp;         *
&nbsp;         * @param executable The executable for which a parameter list is represented.
&nbsp;         */
<b class="fc">&nbsp;        protected ForLoadedExecutable(T executable) {</b>
<b class="fc">&nbsp;            this.executable = executable;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new list that describes the parameters of the given {@link Constructor}.
&nbsp;         *
&nbsp;         * @param constructor The constructor for which the parameters should be described.
&nbsp;         * @return A list describing the constructor&#39;s parameters.
&nbsp;         */
&nbsp;        public static ParameterList&lt;ParameterDescription.InDefinedShape&gt; of(Constructor&lt;?&gt; constructor) {
<b class="fc">&nbsp;            return DISPATCHER.describe(constructor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new list that describes the parameters of the given {@link Method}.
&nbsp;         *
&nbsp;         * @param method The method for which the parameters should be described.
&nbsp;         * @return A list describing the method&#39;s parameters.
&nbsp;         */
&nbsp;        public static ParameterList&lt;ParameterDescription.InDefinedShape&gt; of(Method method) {
<b class="fc">&nbsp;            return DISPATCHER.describe(method);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int size() {
<b class="fc">&nbsp;            return DISPATCHER.getParameterCount(executable);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for creating descriptions of parameter lists and for evaluating the size of an {@code java.lang.reflect.Executable}&#39;s parameters.
&nbsp;         */
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the amount of parameters of a given executable..
&nbsp;             *
&nbsp;             * @param executable The executable for which the amount of parameters should be found.
&nbsp;             * @return The amount of parameters of the given executable.
&nbsp;             */
&nbsp;            int getParameterCount(Object executable);
&nbsp;
&nbsp;            /**
&nbsp;             * Describes a {@link Constructor}&#39;s parameters of the given VM.
&nbsp;             *
&nbsp;             * @param constructor The constructor for which the parameters should be described.
&nbsp;             * @return A list describing the constructor&#39;s parameters.
&nbsp;             */
&nbsp;            ParameterList&lt;ParameterDescription.InDefinedShape&gt; describe(Constructor&lt;?&gt; constructor);
&nbsp;
&nbsp;            /**
&nbsp;             * Describes a {@link Method}&#39;s parameters of the given VM.
&nbsp;             *
&nbsp;             * @param method The method for which the parameters should be described.
&nbsp;             * @return A list describing the method&#39;s parameters.
&nbsp;             */
&nbsp;            ParameterList&lt;ParameterDescription.InDefinedShape&gt; describe(Method method);
&nbsp;
&nbsp;            /**
&nbsp;             * A creation action for a dispatcher.
&nbsp;             */
<b class="fc">&nbsp;            enum CreationAction implements PrivilegedAction&lt;Dispatcher&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                @Override
&nbsp;                @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback&quot;)
&nbsp;                public Dispatcher run() {
&nbsp;                    try {
<b class="fc">&nbsp;                        return new Dispatcher.ForJava8CapableVm(Class.forName(&quot;java.lang.reflect.Executable&quot;).getMethod(&quot;getParameterCount&quot;));</b>
<b class="nc">&nbsp;                    } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                        return Dispatcher.ForLegacyVm.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a legacy VM that does not support the {@code java.lang.reflect.Parameter} type.
&nbsp;             */
&nbsp;            enum ForLegacyVm implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                @Override
&nbsp;                public int getParameterCount(Object executable) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot dispatch method for java.lang.reflect.Executable&quot;);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; describe(Constructor&lt;?&gt; constructor) {
&nbsp;                    return new OfLegacyVmConstructor(constructor);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; describe(Method method) {
&nbsp;                    return new OfLegacyVmMethod(method);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a legacy VM that does support the {@code java.lang.reflect.Parameter} type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForJava8CapableVm implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * An empty array that can be used to indicate no arguments to avoid an allocation on a reflective call.
&nbsp;                 */
<b class="fc">&nbsp;                private static final Object[] NO_ARGUMENTS = new Object[0];</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.reflect.Executable#getParameterCount()} method.
&nbsp;                 */
&nbsp;                private final Method getParameterCount;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new dispatcher for a modern VM.
&nbsp;                 *
&nbsp;                 * @param getParameterCount The {@code java.lang.reflect.Executable#getParameterCount()} method.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForJava8CapableVm(Method getParameterCount) {</b>
<b class="fc">&nbsp;                    this.getParameterCount = getParameterCount;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int getParameterCount(Object executable) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Integer) getParameterCount.invoke(executable, NO_ARGUMENTS);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access java.lang.reflect.Parameter#getModifiers&quot;, exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Error invoking java.lang.reflect.Parameter#getModifiers&quot;, exception.getCause());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; describe(Constructor&lt;?&gt; constructor) {
<b class="fc">&nbsp;                    return new OfConstructor(constructor);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; describe(Method method) {
<b class="fc">&nbsp;                    return new OfMethod(method);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Describes the list of {@link Constructor} parameters on a modern VM.
&nbsp;         */
&nbsp;        protected static class OfConstructor extends ForLoadedExecutable&lt;Constructor&lt;?&gt;&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new description of the parameters of a constructor.
&nbsp;             *
&nbsp;             * @param constructor The constructor that is represented by this instance.
&nbsp;             */
&nbsp;            protected OfConstructor(Constructor&lt;?&gt; constructor) {
<b class="fc">&nbsp;                super(constructor);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public ParameterDescription.InDefinedShape get(int index) {
<b class="fc">&nbsp;                return new ParameterDescription.ForLoadedParameter.OfConstructor(executable, index);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Describes the list of {@link Method} parameters on a modern VM.
&nbsp;         */
&nbsp;        protected static class OfMethod extends ForLoadedExecutable&lt;Method&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new description of the parameters of a method.
&nbsp;             *
&nbsp;             * @param method The method that is represented by this instance.
&nbsp;             */
&nbsp;            protected OfMethod(Method method) {
<b class="fc">&nbsp;                super(method);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public ParameterDescription.InDefinedShape get(int index) {
<b class="fc">&nbsp;                return new ParameterDescription.ForLoadedParameter.OfMethod(executable, index);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a list of constructor parameters on virtual machines where the {@code java.lang.reflect.Parameter}
&nbsp;         * type is not available.
&nbsp;         */
&nbsp;        protected static class OfLegacyVmConstructor extends ParameterList.AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented constructor.
&nbsp;             */
&nbsp;            private final Constructor&lt;?&gt; constructor;
&nbsp;
&nbsp;            /**
&nbsp;             * An array of this method&#39;s parameter types.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt;[] parameterType;
&nbsp;
&nbsp;            /**
&nbsp;             * An array of all parameter annotations of the represented method.
&nbsp;             */
&nbsp;            private final Annotation[][] parameterAnnotation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a legacy representation of a constructor&#39;s parameters.
&nbsp;             *
&nbsp;             * @param constructor The constructor to represent.
&nbsp;             */
&nbsp;            public OfLegacyVmConstructor(Constructor&lt;?&gt; constructor) {
&nbsp;                this.constructor = constructor;
&nbsp;                this.parameterType = constructor.getParameterTypes();
&nbsp;                this.parameterAnnotation = constructor.getParameterAnnotations();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public ParameterDescription.InDefinedShape get(int index) {
&nbsp;                return new ParameterDescription.ForLoadedParameter.OfLegacyVmConstructor(constructor, index, parameterType, parameterAnnotation);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int size() {
&nbsp;                return parameterType.length;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a list of method parameters on virtual machines where the {@code java.lang.reflect.Parameter}
&nbsp;         * type is not available.
&nbsp;         */
&nbsp;        protected static class OfLegacyVmMethod extends ParameterList.AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented method.
&nbsp;             */
&nbsp;            private final Method method;
&nbsp;
&nbsp;            /**
&nbsp;             * An array of this method&#39;s parameter types.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt;[] parameterType;
&nbsp;
&nbsp;            /**
&nbsp;             * An array of all parameter annotations of the represented method.
&nbsp;             */
&nbsp;            private final Annotation[][] parameterAnnotation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a legacy representation of a method&#39;s parameters.
&nbsp;             *
&nbsp;             * @param method The method to represent.
&nbsp;             */
&nbsp;            protected OfLegacyVmMethod(Method method) {
&nbsp;                this.method = method;
&nbsp;                this.parameterType = method.getParameterTypes();
&nbsp;                this.parameterAnnotation = method.getParameterAnnotations();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public ParameterDescription.InDefinedShape get(int index) {
&nbsp;                return new ParameterDescription.ForLoadedParameter.OfLegacyVmMethod(method, index, parameterType, parameterAnnotation);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int size() {
&nbsp;                return parameterType.length;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A list of explicitly provided parameter descriptions.
&nbsp;     *
&nbsp;     * @param &lt;S&gt; The type of parameter descriptions represented by this list.
&nbsp;     */
&nbsp;    class Explicit&lt;S extends ParameterDescription&gt; extends AbstractBase&lt;S&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The list of parameter descriptions that are represented by this list.
&nbsp;         */
&nbsp;        private final List&lt;? extends S&gt; parameterDescriptions;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new list of explicit parameter descriptions.
&nbsp;         *
&nbsp;         * @param parameterDescription The list of parameter descriptions that are represented by this list.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public Explicit(S... parameterDescription) {
&nbsp;            this(Arrays.asList(parameterDescription));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new list of explicit parameter descriptions.
&nbsp;         *
&nbsp;         * @param parameterDescriptions The list of parameter descriptions that are represented by this list.
&nbsp;         */
&nbsp;        public Explicit(List&lt;? extends S&gt; parameterDescriptions) {
&nbsp;            this.parameterDescriptions = parameterDescriptions;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public S get(int index) {
&nbsp;            return parameterDescriptions.get(index);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int size() {
&nbsp;            return parameterDescriptions.size();
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A parameter list representing parameters without meta data or annotations.
&nbsp;         */
&nbsp;        public static class ForTypes extends ParameterList.AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The method description that declares the parameters.
&nbsp;             */
&nbsp;            private final MethodDescription.InDefinedShape methodDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of detached types representing the parameters.
&nbsp;             */
&nbsp;            private final List&lt;? extends TypeDefinition&gt; typeDefinitions;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new parameter type list.
&nbsp;             *
&nbsp;             * @param methodDescription The method description that declares the parameters.
&nbsp;             * @param typeDefinition    A list of detached types representing the parameters.
&nbsp;             */
&nbsp;            public ForTypes(MethodDescription.InDefinedShape methodDescription, TypeDefinition... typeDefinition) {
<b class="nc">&nbsp;                this(methodDescription, Arrays.asList(typeDefinition));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new parameter type list.
&nbsp;             *
&nbsp;             * @param methodDescription The method description that declares the parameters.
&nbsp;             * @param typeDefinitions   A list of detached types representing the parameters.
&nbsp;             */
<b class="fc">&nbsp;            public ForTypes(MethodDescription.InDefinedShape methodDescription, List&lt;? extends TypeDefinition&gt; typeDefinitions) {</b>
<b class="fc">&nbsp;                this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                this.typeDefinitions = typeDefinitions;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public ParameterDescription.InDefinedShape get(int index) {
<b class="pc">&nbsp;                int offset = methodDescription.isStatic() ? 0 : 1;</b>
<b class="fc">&nbsp;                for (int previous = 0; previous &lt; index; previous++) {</b>
<b class="fc">&nbsp;                    offset += typeDefinitions.get(previous).getStackSize().getSize();</b>
&nbsp;                }
<b class="fc">&nbsp;                return new ParameterDescription.Latent(methodDescription, typeDefinitions.get(index).asGenericType(), index, offset);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int size() {
<b class="fc">&nbsp;                return typeDefinitions.size();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A list of parameter descriptions for a list of detached tokens. For the returned parameter, each token is attached to its parameter representation.
&nbsp;     */
&nbsp;    class ForTokens extends AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The method that is declaring the represented token.
&nbsp;         */
&nbsp;        private final MethodDescription.InDefinedShape declaringMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * The list of tokens to represent.
&nbsp;         */
&nbsp;        private final List&lt;? extends ParameterDescription.Token&gt; tokens;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new parameter list for the provided tokens.
&nbsp;         *
&nbsp;         * @param declaringMethod The method that is declaring the represented token.
&nbsp;         * @param tokens          The list of tokens to represent.
&nbsp;         */
<b class="fc">&nbsp;        public ForTokens(MethodDescription.InDefinedShape declaringMethod, List&lt;? extends ParameterDescription.Token&gt; tokens) {</b>
<b class="fc">&nbsp;            this.declaringMethod = declaringMethod;</b>
<b class="fc">&nbsp;            this.tokens = tokens;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ParameterDescription.InDefinedShape get(int index) {
<b class="pc">&nbsp;            int offset = declaringMethod.isStatic() ? 0 : 1;</b>
<b class="fc">&nbsp;            for (ParameterDescription.Token token : tokens.subList(0, index)) {</b>
<b class="fc">&nbsp;                offset += token.getType().getStackSize().getSize();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new ParameterDescription.Latent(declaringMethod, tokens.get(index), index, offset);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int size() {
<b class="fc">&nbsp;            return tokens.size();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A list of parameter descriptions that yields {@link net.bytebuddy.description.method.ParameterDescription.TypeSubstituting}.
&nbsp;     */
&nbsp;    class TypeSubstituting extends AbstractBase&lt;ParameterDescription.InGenericShape&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The method that is declaring the transformed parameters.
&nbsp;         */
&nbsp;        private final MethodDescription.InGenericShape declaringMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * The untransformed parameters that are represented by this list.
&nbsp;         */
&nbsp;        private final List&lt;? extends ParameterDescription&gt; parameterDescriptions;
&nbsp;
&nbsp;        /**
&nbsp;         * The visitor to apply to the parameter types before returning them.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type substituting parameter list.
&nbsp;         *
&nbsp;         * @param declaringMethod       The method that is declaring the transformed parameters.
&nbsp;         * @param parameterDescriptions The untransformed parameters that are represented by this list.
&nbsp;         * @param visitor               The visitor to apply to the parameter types before returning them.
&nbsp;         */
&nbsp;        public TypeSubstituting(MethodDescription.InGenericShape declaringMethod,
&nbsp;                                List&lt;? extends ParameterDescription&gt; parameterDescriptions,
<b class="fc">&nbsp;                                TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {</b>
<b class="fc">&nbsp;            this.declaringMethod = declaringMethod;</b>
<b class="fc">&nbsp;            this.parameterDescriptions = parameterDescriptions;</b>
<b class="fc">&nbsp;            this.visitor = visitor;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ParameterDescription.InGenericShape get(int index) {
<b class="fc">&nbsp;            return new ParameterDescription.TypeSubstituting(declaringMethod, parameterDescriptions.get(index), visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int size() {
<b class="fc">&nbsp;            return parameterDescriptions.size();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An empty list of parameters.
&nbsp;     *
&nbsp;     * @param &lt;S&gt; The type of parameter descriptions represented by this list.
&nbsp;     */
<b class="fc">&nbsp;    class Empty&lt;S extends ParameterDescription&gt; extends FilterableList.Empty&lt;S, ParameterList&lt;S&gt;&gt; implements ParameterList&lt;S&gt; {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean hasExplicitMetaData() {
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic asTypeList() {
<b class="fc">&nbsp;            return new TypeList.Generic.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ByteCodeElement.Token.TokenList&lt;ParameterDescription.Token&gt; asTokenList(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="nc">&nbsp;            return new ByteCodeElement.Token.TokenList&lt;ParameterDescription.Token&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; asDefined() {
<b class="nc">&nbsp;            return (ParameterList&lt;ParameterDescription.InDefinedShape&gt;) this;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
