


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TypeDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.type</a>
</div>

<h1>Coverage Summary for Class: TypeDescription (net.bytebuddy.description.type)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TypeDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    52,5%
  </span>
  <span class="absValue">
    (21/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    15,7%
  </span>
  <span class="absValue">
    (54/344)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28,1%
  </span>
  <span class="absValue">
    (66/235)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$OfSimpleType</td>
<td class="coverageStat">
  <span class="percent">
    62,5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21,7%
  </span>
  <span class="absValue">
    (5/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$ArrayProjection</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (9/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    54,5%
  </span>
  <span class="absValue">
    (12/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    43,4%
  </span>
  <span class="absValue">
    (23/53)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    73,5%
  </span>
  <span class="absValue">
    (25/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    44,4%
  </span>
  <span class="absValue">
    (32/72)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56,8%
  </span>
  <span class="absValue">
    (63/111)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (5/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (5/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$Chained</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71,4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Dispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Dispatcher$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71,4%
  </span>
  <span class="absValue">
    (10/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Dispatcher$ForJava8CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    81,8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64,3%
  </span>
  <span class="absValue">
    (18/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Dispatcher$ForJava8CapableVm$AnnotatedExceptionType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Dispatcher$ForJava8CapableVm$AnnotatedInterfaceType</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37,5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Dispatcher$ForJava8CapableVm$AnnotatedParameterizedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Dispatcher$ForJava8CapableVm$AnnotatedReturnType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42,9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Dispatcher$ForJava8CapableVm$AnnotatedSuperClass</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28,6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Dispatcher$ForJava8CapableVm$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForComponentType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (3/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeArgument</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (4/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    21,4%
  </span>
  <span class="absValue">
    (3/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26,7%
  </span>
  <span class="absValue">
    (4/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (11/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (11/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$ForLoadedReturnType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$ForLoadedSuperClass</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$OfConstructorParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$OfMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithEagerNavigation</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithEagerNavigation$OfAnnotatedElement</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithLazyNavigation</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithLazyNavigation$OfAnnotatedElement</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithResolvedErasure</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87,5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfGenericArray</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (8/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18,2%
  </span>
  <span class="absValue">
    (4/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26,8%
  </span>
  <span class="absValue">
    (11/41)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfGenericArray$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType</td>
<td class="coverageStat">
  <span class="percent">
    52,2%
  </span>
  <span class="absValue">
    (12/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64,3%
  </span>
  <span class="absValue">
    (9/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56,2%
  </span>
  <span class="absValue">
    (18/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$ForErasure</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    88,9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91,7%
  </span>
  <span class="absValue">
    (33/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType</td>
<td class="coverageStat">
  <span class="percent">
    30,4%
  </span>
  <span class="absValue">
    (7/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7,9%
  </span>
  <span class="absValue">
    (3/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18%
  </span>
  <span class="absValue">
    (11/61)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForGenerifiedErasure</td>
<td class="coverageStat">
  <span class="percent">
    16,7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11,1%
  </span>
  <span class="absValue">
    (1/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    85,7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81,8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForLoadedType$ParameterArgumentTypeList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$ForRawType</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16,7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (4/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$ForSignatureVisitor</td>
<td class="coverageStat">
  <span class="percent">
    57,1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72%
  </span>
  <span class="absValue">
    (18/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$ForSignatureVisitor$OfTypeArgument</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31,2%
  </span>
  <span class="absValue">
    (5/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reducing</td>
<td class="coverageStat">
  <span class="percent">
    42,9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38,5%
  </span>
  <span class="absValue">
    (5/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reifying</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62,5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reifying$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reifying$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83,3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76,9%
  </span>
  <span class="absValue">
    (10/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForAttachment</td>
<td class="coverageStat">
  <span class="percent">
    87,5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69,2%
  </span>
  <span class="absValue">
    (9/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForDetachment</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$WithoutTypeSubstitution</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$TypeErasing</td>
<td class="coverageStat">
  <span class="percent">
    16,7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28,6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    58%
  </span>
  <span class="absValue">
    (233/402)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    24,4%
  </span>
  <span class="absValue">
    (149/610)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    47,6%
  </span>
  <span class="absValue">
    (470/988)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.description.type;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.ModifierReviewable;
&nbsp;import net.bytebuddy.description.TypeVariableSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationSource;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.dynamic.TargetType;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.privilege.GetSystemPropertyAction;
&nbsp;import net.bytebuddy.jar.asm.Opcodes;
&nbsp;import net.bytebuddy.jar.asm.Type;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureVisitor;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureWriter;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.annotation.ElementType;
&nbsp;import java.lang.reflect.*;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.is;
&nbsp;
&nbsp;/**
&nbsp; * Implementations of this interface represent a Java type, i.e. a class or interface. Instances of this interface always
&nbsp; * represent non-generic types of sort {@link Generic.Sort#NON_GENERIC}.
&nbsp; */
&nbsp;public interface TypeDescription extends TypeDefinition, ByteCodeElement, TypeVariableSource {
&nbsp;
&nbsp;    /**
&nbsp;     * A representation of the {@link java.lang.Object} type.
&nbsp;     */
<b class="fc">&nbsp;    TypeDescription OBJECT = new ForLoadedType(Object.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A representation of the {@link java.lang.String} type.
&nbsp;     */
<b class="fc">&nbsp;    TypeDescription STRING = new ForLoadedType(String.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A representation of the {@link java.lang.Class} type.
&nbsp;     */
<b class="fc">&nbsp;    TypeDescription CLASS = new ForLoadedType(Class.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A representation of the {@link java.lang.Throwable} type.
&nbsp;     */
<b class="fc">&nbsp;    TypeDescription THROWABLE = new ForLoadedType(Throwable.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A representation of the {@code void} non-type.
&nbsp;     */
<b class="fc">&nbsp;    TypeDescription VOID = new ForLoadedType(void.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A list of interfaces that are implicitly implemented by any array type.
&nbsp;     */
<b class="fc">&nbsp;    TypeList.Generic ARRAY_INTERFACES = new TypeList.Generic.ForLoadedTypes(Cloneable.class, Serializable.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Represents any undefined property representing a type description that is instead represented as {@code null} in order
&nbsp;     * to resemble the Java reflection API which returns {@code null} and is intuitive to many Java developers.
&nbsp;     */
<b class="fc">&nbsp;    TypeDescription UNDEFINED = null;</b>
&nbsp;
&nbsp;    @Override
&nbsp;    FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields();
&nbsp;
&nbsp;    @Override
&nbsp;    MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if {@code value} is an instance of the type represented by this instance.
&nbsp;     *
&nbsp;     * @param value The object of interest.
&nbsp;     * @return {@code true} if the object is an instance of the type described by this instance.
&nbsp;     */
&nbsp;    boolean isInstance(Object value);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type is assignable from the type described by this instance, for example for
&nbsp;     * {@code class Foo} and {@code class Bar extends Foo}, this method would return {@code true} for
&nbsp;     * {@code Foo.class.isAssignableFrom(Bar.class)}.
&nbsp;     *
&nbsp;     * @param type The type of interest.
&nbsp;     * @return {@code true} if this type is assignable from {@code type}.
&nbsp;     */
&nbsp;    boolean isAssignableFrom(Class&lt;?&gt; type);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type is assignable from the type described by this instance, for example for
&nbsp;     * {@code class Foo} and {@code class Bar extends Foo}, this method would return {@code true} for
&nbsp;     * {@code Foo.class.isAssignableFrom(Bar.class)}.
&nbsp;     * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp;     * Implementations of this methods are allowed to delegate to
&nbsp;     * {@link TypeDescription#isAssignableFrom(Class)}
&nbsp;     *
&nbsp;     * @param typeDescription The type of interest.
&nbsp;     * @return {@code true} if this type is assignable from {@code type}.
&nbsp;     */
&nbsp;    boolean isAssignableFrom(TypeDescription typeDescription);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type is assignable from the type described by this instance, for example for
&nbsp;     * {@code class Foo} and {@code class Bar extends Foo}, this method would return {@code true} for
&nbsp;     * {@code Bar.class.isAssignableTo(Foo.class)}.
&nbsp;     *
&nbsp;     * @param type The type of interest.
&nbsp;     * @return {@code true} if this type is assignable to {@code type}.
&nbsp;     */
&nbsp;    boolean isAssignableTo(Class&lt;?&gt; type);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type is assignable from the type described by this instance, for example for
&nbsp;     * {@code class Foo} and {@code class Bar extends Foo}, this method would return {@code true} for
&nbsp;     * {@code Bar.class.isAssignableFrom(Foo.class)}.
&nbsp;     * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp;     * Implementations of this methods are allowed to delegate to
&nbsp;     * {@link TypeDescription#isAssignableTo(Class)}
&nbsp;     *
&nbsp;     * @param typeDescription The type of interest.
&nbsp;     * @return {@code true} if this type is assignable to {@code type}.
&nbsp;     */
&nbsp;    boolean isAssignableTo(TypeDescription typeDescription);
&nbsp;
&nbsp;    @Override
&nbsp;    TypeDescription getComponentType();
&nbsp;
&nbsp;    @Override
&nbsp;    TypeDescription getDeclaringType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list of types that are declared by this type excluding anonymous classes.
&nbsp;     *
&nbsp;     * @return A list of types that are declared within this type.
&nbsp;     */
&nbsp;    TypeList getDeclaredTypes();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a description of the method that encloses this type. If this method is not enclosed by any type or is
&nbsp;     * enclosed by the type initializer, {@code null} is returned by this method.
&nbsp;     *
&nbsp;     * @return A description of the enclosing method of this type or {@code null} if there is no such method.
&nbsp;     */
&nbsp;    MethodDescription getEnclosingMethod();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a description of this type&#39;s enclosing type if any.
&nbsp;     *
&nbsp;     * @return A description of the enclosing type of this type or {@code null} if there is no such type.
&nbsp;     */
&nbsp;    TypeDescription getEnclosingType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the type&#39;s actual modifiers as present in the class file. For example, a type cannot be {@code private}.
&nbsp;     * but it modifiers might reflect this property nevertheless if a class was defined as a private inner class. The
&nbsp;     * returned modifiers take also into account if the type is marked as {@link Deprecated}. Anonymous classes that are
&nbsp;     * enclosed in a static method or the type initializer are additionally marked as {@code final} as it is also done
&nbsp;     * by the Java compiler.
&nbsp;     *
&nbsp;     * @param superFlag {@code true} if the modifier&#39;s super flag should be set.
&nbsp;     * @return The type&#39;s actual modifiers.
&nbsp;     */
&nbsp;    int getActualModifiers(boolean superFlag);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the simple internalName of this type.
&nbsp;     *
&nbsp;     * @return The simple internalName of this type.
&nbsp;     */
&nbsp;    String getSimpleName();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the canonical name of this type if it exists.
&nbsp;     *
&nbsp;     * @return The canonical name of this type. Might be {@code null}.
&nbsp;     */
&nbsp;    String getCanonicalName();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type description represents an anonymous type.
&nbsp;     *
&nbsp;     * @return {@code true} if this type description represents an anonymous type.
&nbsp;     */
&nbsp;    boolean isAnonymousClass();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type description represents a local type.
&nbsp;     *
&nbsp;     * @return {@code true} if this type description represents a local type.
&nbsp;     */
&nbsp;    boolean isLocalClass();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type description represents a member type.
&nbsp;     *
&nbsp;     * @return {@code true} if this type description represents a member type.
&nbsp;     */
&nbsp;    boolean isMemberClass();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the package of the type described by this instance or {@code null} if the described type does not imply a package.
&nbsp;     *
&nbsp;     * @return The package of the type described by this instance or {@code null} if the described type does not imply a package.
&nbsp;     */
&nbsp;    PackageDescription getPackage();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the annotations that this type declares or inherits from super types.
&nbsp;     *
&nbsp;     * @return A list of all inherited annotations.
&nbsp;     */
&nbsp;    AnnotationList getInheritedAnnotations();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if two types are defined in the same package.
&nbsp;     *
&nbsp;     * @param typeDescription The type of interest.
&nbsp;     * @return {@code true} if this type and the given type are in the same package.
&nbsp;     */
&nbsp;    boolean isSamePackage(TypeDescription typeDescription);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if instances of this type can be stored in the constant pool of a class. Note that any primitive
&nbsp;     * type that is smaller than an {@code int} cannot be stored in the constant pool as those types are represented
&nbsp;     * as {@code int} values internally.
&nbsp;     *
&nbsp;     * @return {@code true} if instances of this type can be stored in the constant pool of a class.
&nbsp;     */
&nbsp;    boolean isConstantPool();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type represents a wrapper type for a primitive type. The {@link java.lang.Void} type is
&nbsp;     * not considered to be a wrapper type.
&nbsp;     *
&nbsp;     * @return {@code true} if this type represents a wrapper type.
&nbsp;     */
&nbsp;    boolean isPrimitiveWrapper();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if instances of this type can be returned from an annotation method.
&nbsp;     *
&nbsp;     * @return {@code true} if instances of this type can be returned from an annotation method.
&nbsp;     */
&nbsp;    boolean isAnnotationReturnType();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if instances of this type can be used for describing an annotation value.
&nbsp;     *
&nbsp;     * @return {@code true} if instances of this type can be used for describing an annotation value.
&nbsp;     */
&nbsp;    boolean isAnnotationValue();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if instances of this type can be used for describing the given annotation value.
&nbsp;     *
&nbsp;     * @param value The value that is supposed to describe the annotation value for this instance.
&nbsp;     * @return {@code true} if instances of this type can be used for describing the given annotation value..
&nbsp;     */
&nbsp;    boolean isAnnotationValue(Object value);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type represents a class that is a place holder for a package description.
&nbsp;     *
&nbsp;     * @return {@code true} if this type represents a package description.
&nbsp;     */
&nbsp;    boolean isPackageType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the amount of outer classes this type defines. If this type is not an inner type of another class, {@code 0} is returned.
&nbsp;     *
&nbsp;     * @return The number of outer classes relatively to this type.
&nbsp;     */
&nbsp;    int getInnerClassCount();
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if this class is an inner class.
&nbsp;     *
&nbsp;     * @return {@code true} if this class is an inner class.
&nbsp;     */
&nbsp;    boolean isInnerClass();
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if this class is a nested class.
&nbsp;     *
&nbsp;     * @return {@code true} if this class is a nested class.
&nbsp;     */
&nbsp;    boolean isNestedClass();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a description of this type that represents this type as a boxed type for primitive types, unless its {@code void}.
&nbsp;     *
&nbsp;     * @return A description of this type in its boxed form.
&nbsp;     */
&nbsp;    TypeDescription asBoxed();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a description of this type that represents this type as an unboxed type for boxing types, unless its {@link Void}.
&nbsp;     *
&nbsp;     * @return A description of this type in its unboxed form.
&nbsp;     */
&nbsp;    TypeDescription asUnboxed();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default value for this type, i.e. the zero value for a primitive type and {@code null} for a reference type.
&nbsp;     * For {@code void}, {@code null} is returned.
&nbsp;     *
&nbsp;     * @return This types default value.
&nbsp;     */
&nbsp;    Object getDefaultValue();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Represents a generic type of the Java programming language. A non-generic {@link TypeDescription} is considered to be
&nbsp;     * a specialization of a generic type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Note that annotations that are declared on an annotated type refer to any type annotations that are declared by this
&nbsp;     * generic type. For reading annotations of the erasure type, {@link TypeDefinition#asErasure()} must be called before.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    interface Generic extends TypeDefinition, AnnotationSource {
&nbsp;
&nbsp;        /**
&nbsp;         * A representation of the {@link Object} type.
&nbsp;         */
<b class="fc">&nbsp;        Generic OBJECT = new OfNonGenericType.ForLoadedType(Object.class);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A representation of the {@link Class} non-type.
&nbsp;         */
<b class="fc">&nbsp;        Generic CLASS = new OfNonGenericType.ForLoadedType(Class.class);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A representation of the {@code void} non-type.
&nbsp;         */
<b class="fc">&nbsp;        Generic VOID = new OfNonGenericType.ForLoadedType(void.class);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A representation of the {@link Annotation} type.
&nbsp;         */
<b class="fc">&nbsp;        Generic ANNOTATION = new OfNonGenericType.ForLoadedType(Annotation.class);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Represents any undefined property representing a generic type description that is instead represented as {@code null} in order
&nbsp;         * to resemble the Java reflection API which returns {@code null} and is intuitive to many Java developers.
&nbsp;         */
<b class="fc">&nbsp;        Generic UNDEFINED = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Returns this type as a raw type. This resembles calling {@code asErasure().asGenericType()}.
&nbsp;         *
&nbsp;         * @return This type as a raw type.
&nbsp;         */
&nbsp;        Generic asRawType();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Returns the upper bounds of this type. Any type with a well-defined upper bound is bound by at least one type. If no such
&nbsp;         * type is defined, the bound is implicitly {@link Object}.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Only non-symbolic type variables ({@link net.bytebuddy.description.type.TypeDefinition.Sort#VARIABLE}, and wildcard types
&nbsp;         * ({@link net.bytebuddy.description.type.TypeDefinition.Sort#WILDCARD}) have well-defined upper bounds. For other
&nbsp;         * types, an {@link IllegalStateException} is thrown.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return The upper bounds of this type.
&nbsp;         */
&nbsp;        TypeList.Generic getUpperBounds();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Returns the lower bounds of this type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Only wildcard types ({@link Sort#WILDCARD}) define a lower bound. For other
&nbsp;         * types, an {@link IllegalStateException} is thrown.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return The lower bounds of this type.
&nbsp;         */
&nbsp;        TypeList.Generic getLowerBounds();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Returns the type arguments of this type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Parameters are only well-defined for parameterized types ({@link Sort#PARAMETERIZED}).
&nbsp;         * For all other types, this method throws an {@link IllegalStateException}.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return A list of this type&#39;s type parameters.
&nbsp;         */
&nbsp;        TypeList.Generic getTypeArguments();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Returns the owner type of this type. A type&#39;s owner type describes a nested type&#39;s declaring type.
&nbsp;         * If it exists, the returned type can be a non-generic or parameterized type. If a class has no
&nbsp;         * declaring type, {@code null} is returned.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * An owner type is only well-defined for parameterized types ({@link Sort#PARAMETERIZED}),
&nbsp;         * for non-generic types ({@link Sort#NON_GENERIC}) and for generic arrays ({@link Sort#GENERIC_ARRAY}).
&nbsp;         * For all other types, this method throws an {@link IllegalStateException}.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return This type&#39;s owner type or {@code null} if no owner type exists.
&nbsp;         */
&nbsp;        Generic getOwnerType();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Returns the parameter binding of the supplied type variable.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * This method must only be called for parameterized types ({@link Sort#PARAMETERIZED}). For all other types,
&nbsp;         * this method throws an {@link IllegalStateException}.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param typeVariable The type variable for which a value should be located.
&nbsp;         * @return The value that is bound to the supplied type variable or {@code null} if the type variable
&nbsp;         * is not bound by this parameterized type.
&nbsp;         */
&nbsp;        Generic findBindingOf(Generic typeVariable);
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the source of this type variable. A type variable source is only well-defined for an attached type variable
&nbsp;         * ({@link Sort#VARIABLE}. For other types, this method
&nbsp;         * throws an {@link IllegalStateException}.
&nbsp;         *
&nbsp;         * @return This type&#39;s type variable source.
&nbsp;         */
&nbsp;        TypeVariableSource getTypeVariableSource();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the symbol of this type variable. A symbol is only well-defined for type variables
&nbsp;         * ({@link Sort#VARIABLE}, {@link Sort#VARIABLE_SYMBOLIC}). For other types, this method
&nbsp;         * throws an {@link IllegalStateException}.
&nbsp;         *
&nbsp;         * @return This type&#39;s type variable symbol.
&nbsp;         */
&nbsp;        String getSymbol();
&nbsp;
&nbsp;        @Override
&nbsp;        Generic getComponentType();
&nbsp;
&nbsp;        @Override
&nbsp;        FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields();
&nbsp;
&nbsp;        @Override
&nbsp;        MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods();
&nbsp;
&nbsp;        /**
&nbsp;         * Applies a visitor to this generic type description.
&nbsp;         *
&nbsp;         * @param visitor The visitor to apply.
&nbsp;         * @param &lt;T&gt;     The value that this visitor yields.
&nbsp;         * @return The visitor&#39;s return value.
&nbsp;         */
&nbsp;        &lt;T&gt; T accept(Visitor&lt;T&gt; visitor);
&nbsp;
&nbsp;        /**
&nbsp;         * A visitor that can be applied to a {@link Generic} for differentiating on the sort of the visited type.
&nbsp;         *
&nbsp;         * @param &lt;T&gt; The visitor&#39;s return value&#39;s type.
&nbsp;         */
&nbsp;        interface Visitor&lt;T&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Visits a generic array type ({@link Sort#GENERIC_ARRAY}).
&nbsp;             *
&nbsp;             * @param genericArray The generic array type.
&nbsp;             * @return The visitor&#39;s return value.
&nbsp;             */
&nbsp;            T onGenericArray(Generic genericArray);
&nbsp;
&nbsp;            /**
&nbsp;             * Visits a wildcard ({@link Sort#WILDCARD}).
&nbsp;             *
&nbsp;             * @param wildcard The wildcard.
&nbsp;             * @return The visitor&#39;s return value.
&nbsp;             */
&nbsp;            T onWildcard(Generic wildcard);
&nbsp;
&nbsp;            /**
&nbsp;             * Visits a parameterized type ({@link Sort#PARAMETERIZED}).
&nbsp;             *
&nbsp;             * @param parameterizedType The generic array type.
&nbsp;             * @return The visitor&#39;s return value.
&nbsp;             */
&nbsp;            T onParameterizedType(Generic parameterizedType);
&nbsp;
&nbsp;            /**
&nbsp;             * Visits a type variable ({@link Sort#VARIABLE}, {@link Sort#VARIABLE_SYMBOLIC}).
&nbsp;             *
&nbsp;             * @param typeVariable The generic array type.
&nbsp;             * @return The visitor&#39;s return value.
&nbsp;             */
&nbsp;            T onTypeVariable(Generic typeVariable);
&nbsp;
&nbsp;            /**
&nbsp;             * Visits a non-generic type ({@link Sort#NON_GENERIC}).
&nbsp;             *
&nbsp;             * @param typeDescription The non-generic type.
&nbsp;             * @return The visitor&#39;s return value.
&nbsp;             */
&nbsp;            T onNonGenericType(Generic typeDescription);
&nbsp;
&nbsp;            /**
&nbsp;             * A non-operational generic type visitor. Any visited type is returned in its existing form.
&nbsp;             */
&nbsp;            enum NoOp implements Visitor&lt;Generic&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onGenericArray(Generic genericArray) {
&nbsp;                    return genericArray;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onWildcard(Generic wildcard) {
&nbsp;                    return wildcard;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                    return parameterizedType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                    return typeVariable;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    return typeDescription;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor that returns the erasure of any visited type. For wildcard types, an exception is thrown.
&nbsp;             */
<b class="fc">&nbsp;            enum TypeErasing implements Visitor&lt;Generic&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onGenericArray(Generic genericArray) {
<b class="nc">&nbsp;                    return genericArray.asRawType();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onWildcard(Generic wildcard) {
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot erase a wildcard type: &quot; + wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
<b class="nc">&nbsp;                    return parameterizedType.asRawType();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
<b class="nc">&nbsp;                    return typeVariable.asRawType();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
<b class="nc">&nbsp;                    return typeDescription.asRawType();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor that strips all type annotations of all types.
&nbsp;             */
&nbsp;            enum AnnotationStripper implements Visitor&lt;Generic&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onGenericArray(Generic genericArray) {
&nbsp;                    return new OfGenericArray.Latent(genericArray.getComponentType().accept(this), Empty.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onWildcard(Generic wildcard) {
&nbsp;                    return new OfWildcardType.Latent(wildcard.getUpperBounds().accept(this), wildcard.getLowerBounds().accept(this), Empty.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                    Generic ownerType = parameterizedType.getOwnerType();
&nbsp;                    return new OfParameterizedType.Latent(parameterizedType.asErasure(),
&nbsp;                            ownerType == null
&nbsp;                                    ? UNDEFINED
&nbsp;                                    : ownerType.accept(this),
&nbsp;                            parameterizedType.getTypeArguments().accept(this),
&nbsp;                            Empty.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                    return new NonAnnotatedTypeVariable(typeVariable);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    return typeDescription.isArray()
&nbsp;                            ? new OfGenericArray.Latent(onNonGenericType(typeDescription.getComponentType()), Empty.INSTANCE)
&nbsp;                            : new OfNonGenericType.Latent(typeDescription.asErasure(), Empty.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Representation of a type variable without annotations.
&nbsp;                 */
&nbsp;                protected static class NonAnnotatedTypeVariable extends OfTypeVariable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented type variable.
&nbsp;                     */
&nbsp;                    private final Generic typeVariable;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new non-annotated type variable.
&nbsp;                     *
&nbsp;                     * @param typeVariable The represented type variable.
&nbsp;                     */
&nbsp;                    protected NonAnnotatedTypeVariable(Generic typeVariable) {
&nbsp;                        this.typeVariable = typeVariable;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeList.Generic getUpperBounds() {
&nbsp;                        return typeVariable.getUpperBounds();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeVariableSource getTypeVariableSource() {
&nbsp;                        return typeVariable.getTypeVariableSource();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getSymbol() {
&nbsp;                        return typeVariable.getSymbol();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return new AnnotationList.Empty();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor that determines the direct assignability of a type to another generic type. This visitor only checks
&nbsp;             * for strict assignability and does not perform any form of boxing or primitive type widening that are allowed
&nbsp;             * in the Java language.
&nbsp;             */
&nbsp;            enum Assigner implements Visitor&lt;Assigner.Dispatcher&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                @Override
&nbsp;                public Dispatcher onGenericArray(Generic genericArray) {
&nbsp;                    return new Dispatcher.ForGenericArray(genericArray);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Dispatcher onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalArgumentException(&quot;A wildcard is not a first level type: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Dispatcher onParameterizedType(Generic parameterizedType) {
&nbsp;                    return new Dispatcher.ForParameterizedType(parameterizedType);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Dispatcher onTypeVariable(Generic typeVariable) {
&nbsp;                    return new Dispatcher.ForTypeVariable(typeVariable);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Dispatcher onNonGenericType(Generic typeDescription) {
&nbsp;                    return new Dispatcher.ForNonGenericType(typeDescription.asErasure());
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher that allows to check if the visited generic type is assignable to the supplied type.
&nbsp;                 */
&nbsp;                public interface Dispatcher {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Checks if the represented type is a super type of the type that is supplied as an argument.
&nbsp;                     *
&nbsp;                     * @param typeDescription The type to check for being assignable to the represented type.
&nbsp;                     * @return {@code true} if the represented type is assignable to the supplied type.
&nbsp;                     */
&nbsp;                    boolean isAssignableFrom(Generic typeDescription);
&nbsp;
&nbsp;                    /**
&nbsp;                     * An abstract base implementation of a dispatcher that forwards the decision to a visitor implementation.
&nbsp;                     */
&nbsp;                    abstract class AbstractBase implements Dispatcher, Visitor&lt;Boolean&gt; {
&nbsp;
&nbsp;                        @Override
&nbsp;                        public boolean isAssignableFrom(Generic typeDescription) {
&nbsp;                            return typeDescription.accept(this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for checking the assignability of a non-generic type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class ForNonGenericType extends AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The description of the type to which another type is assigned.
&nbsp;                         */
&nbsp;                        private final TypeDescription typeDescription;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new dispatcher of a non-generic type.
&nbsp;                         *
&nbsp;                         * @param typeDescription The description of the type to which another type is assigned.
&nbsp;                         */
&nbsp;                        protected ForNonGenericType(TypeDescription typeDescription) {
&nbsp;                            this.typeDescription = typeDescription;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
&nbsp;                            return typeDescription.isArray()
&nbsp;                                    ? genericArray.getComponentType().accept(new ForNonGenericType(typeDescription.getComponentType()))
&nbsp;                                    : typeDescription.represents(Object.class) || TypeDescription.ARRAY_INTERFACES.contains(typeDescription.asGenericType());
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                            if (typeDescription.equals(parameterizedType.asErasure())) {
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                            Generic superClass = parameterizedType.getSuperClass();
&nbsp;                            if (superClass != null &amp;&amp; isAssignableFrom(superClass)) {
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                            for (Generic interfaceType : parameterizedType.getInterfaces()) {
&nbsp;                                if (isAssignableFrom(interfaceType)) {
&nbsp;                                    return true;
&nbsp;                                }
&nbsp;                            }
&nbsp;                            return typeDescription.represents(Object.class);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                            for (Generic upperBound : typeVariable.getUpperBounds()) {
&nbsp;                                if (isAssignableFrom(upperBound)) {
&nbsp;                                    return true;
&nbsp;                                }
&nbsp;                            }
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                            return this.typeDescription.isAssignableFrom(typeDescription.asErasure());
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for checking the assignability of a type variable.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class ForTypeVariable extends AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The description of the type variable to which another type is assigned.
&nbsp;                         */
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new dispatcher of a type variable.
&nbsp;                         *
&nbsp;                         * @param typeVariable The description of the type variable to which another type is assigned.
&nbsp;                         */
&nbsp;                        protected ForTypeVariable(Generic typeVariable) {
&nbsp;                            this.typeVariable = typeVariable;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                            if (typeVariable.equals(this.typeVariable)) {
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                            for (Generic upperBound : typeVariable.getUpperBounds()) {
&nbsp;                                if (isAssignableFrom(upperBound)) {
&nbsp;                                    return true;
&nbsp;                                }
&nbsp;                            }
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for checking the assignability of a parameterized type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class ForParameterizedType extends AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The parameterized type to which another type is assigned.
&nbsp;                         */
&nbsp;                        private final Generic parameterizedType;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new dispatcher for checking the assignability of a parameterized type.
&nbsp;                         *
&nbsp;                         * @param parameterizedType The parameterized type to which another type is assigned.
&nbsp;                         */
&nbsp;                        protected ForParameterizedType(Generic parameterizedType) {
&nbsp;                            this.parameterizedType = parameterizedType;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                            if (this.parameterizedType.asErasure().equals(parameterizedType.asErasure())) {
&nbsp;                                Generic fromOwner = this.parameterizedType.getOwnerType(), toOwner = parameterizedType.getOwnerType();
&nbsp;                                if (fromOwner != null &amp;&amp; toOwner != null &amp;&amp; !fromOwner.accept(Assigner.INSTANCE).isAssignableFrom(toOwner)) {
&nbsp;                                    return false;
&nbsp;                                }
&nbsp;                                TypeList.Generic fromArguments = this.parameterizedType.getTypeArguments(), toArguments = parameterizedType.getTypeArguments();
&nbsp;                                if (fromArguments.size() == toArguments.size()) {
&nbsp;                                    for (int index = 0; index &lt; fromArguments.size(); index++) {
&nbsp;                                        if (!fromArguments.get(index).accept(ParameterAssigner.INSTANCE).isAssignableFrom(toArguments.get(index))) {
&nbsp;                                            return false;
&nbsp;                                        }
&nbsp;                                    }
&nbsp;                                    return true;
&nbsp;                                } else {
&nbsp;                                    throw new IllegalArgumentException(&quot;Incompatible generic types: &quot; + parameterizedType + &quot; and &quot; + this.parameterizedType);
&nbsp;                                }
&nbsp;                            }
&nbsp;                            Generic superClass = parameterizedType.getSuperClass();
&nbsp;                            if (superClass != null &amp;&amp; isAssignableFrom(superClass)) {
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                            for (Generic interfaceType : parameterizedType.getInterfaces()) {
&nbsp;                                if (isAssignableFrom(interfaceType)) {
&nbsp;                                    return true;
&nbsp;                                }
&nbsp;                            }
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                            for (Generic upperBound : typeVariable.getUpperBounds()) {
&nbsp;                                if (isAssignableFrom(upperBound)) {
&nbsp;                                    return true;
&nbsp;                                }
&nbsp;                            }
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                            if (parameterizedType.asErasure().equals(typeDescription.asErasure())) {
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                            Generic superClass = typeDescription.getSuperClass();
&nbsp;                            if (superClass != null &amp;&amp; isAssignableFrom(superClass)) {
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                            for (Generic interfaceType : typeDescription.getInterfaces()) {
&nbsp;                                if (isAssignableFrom(interfaceType)) {
&nbsp;                                    return true;
&nbsp;                                }
&nbsp;                            }
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An assigner for a parameter of a parameterized type.
&nbsp;                         */
&nbsp;                        protected enum ParameterAssigner implements Visitor&lt;Dispatcher&gt; {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The singleton instance.
&nbsp;                             */
&nbsp;                            INSTANCE;
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Dispatcher onGenericArray(Generic genericArray) {
&nbsp;                                return new InvariantBinding(genericArray);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Dispatcher onWildcard(Generic wildcard) {
&nbsp;                                TypeList.Generic lowerBounds = wildcard.getLowerBounds();
&nbsp;                                return lowerBounds.isEmpty()
&nbsp;                                        ? new CovariantBinding(wildcard.getUpperBounds().getOnly())
&nbsp;                                        : new ContravariantBinding(lowerBounds.getOnly());
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Dispatcher onParameterizedType(Generic parameterizedType) {
&nbsp;                                return new InvariantBinding(parameterizedType);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Dispatcher onTypeVariable(Generic typeVariable) {
&nbsp;                                return new InvariantBinding(typeVariable);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Dispatcher onNonGenericType(Generic typeDescription) {
&nbsp;                                return new InvariantBinding(typeDescription);
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A dispatcher for an invariant parameter of a parameterized type, i.e. a type without a wildcard.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class InvariantBinding implements Dispatcher {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The invariant type of the parameter.
&nbsp;                                 */
&nbsp;                                private final Generic typeDescription;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new dispatcher for an invariant parameter of a parameterized type.
&nbsp;                                 *
&nbsp;                                 * @param typeDescription The invariant type of the parameter.
&nbsp;                                 */
&nbsp;                                protected InvariantBinding(Generic typeDescription) {
&nbsp;                                    this.typeDescription = typeDescription;
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public boolean isAssignableFrom(Generic typeDescription) {
&nbsp;                                    return typeDescription.equals(this.typeDescription);
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A dispatcher for an covariant parameter of a parameterized type, i.e. a type that is the lower bound of a wildcard.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class CovariantBinding implements Dispatcher {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The lower bound type of a covariant parameter.
&nbsp;                                 */
&nbsp;                                private final Generic upperBound;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new dispatcher for covariant parameter of a parameterized type.
&nbsp;                                 *
&nbsp;                                 * @param upperBound The upper bound type of a covariant parameter.
&nbsp;                                 */
&nbsp;                                protected CovariantBinding(Generic upperBound) {
&nbsp;                                    this.upperBound = upperBound;
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public boolean isAssignableFrom(Generic typeDescription) {
&nbsp;                                    if (typeDescription.getSort().isWildcard()) {
&nbsp;                                        return typeDescription.getLowerBounds().isEmpty() &amp;&amp; upperBound.accept(Assigner.INSTANCE)
&nbsp;                                                .isAssignableFrom(typeDescription.getUpperBounds().getOnly());
&nbsp;                                    } else {
&nbsp;                                        return upperBound.accept(Assigner.INSTANCE).isAssignableFrom(typeDescription);
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A dispatcher for an contravariant parameter of a parameterized type, i.e. a type that is the lower bound of a wildcard.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class ContravariantBinding implements Dispatcher {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The lower bound type of a contravariant parameter.
&nbsp;                                 */
&nbsp;                                private final Generic lowerBound;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new dispatcher for contravariant parameter of a parameterized type.
&nbsp;                                 *
&nbsp;                                 * @param lowerBound The lower bound type of a contravariant parameter.
&nbsp;                                 */
&nbsp;                                protected ContravariantBinding(Generic lowerBound) {
&nbsp;                                    this.lowerBound = lowerBound;
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public boolean isAssignableFrom(Generic typeDescription) {
&nbsp;                                    if (typeDescription.getSort().isWildcard()) {
&nbsp;                                        TypeList.Generic lowerBounds = typeDescription.getLowerBounds();
&nbsp;                                        return !lowerBounds.isEmpty() &amp;&amp; lowerBounds.getOnly().accept(Assigner.INSTANCE).isAssignableFrom(lowerBound);
&nbsp;                                    } else {
&nbsp;                                        return typeDescription.getSort().isWildcard() || typeDescription.accept(Assigner.INSTANCE).isAssignableFrom(lowerBound);
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for checking the assignability of a generic array type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class ForGenericArray extends AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The generic array type to which another type is assigned.
&nbsp;                         */
&nbsp;                        private final Generic genericArray;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new dispatcher for checking the assignability of a generic array type.
&nbsp;                         *
&nbsp;                         * @param genericArray The generic array type to which another type is assigned.
&nbsp;                         */
&nbsp;                        protected ForGenericArray(Generic genericArray) {
&nbsp;                            this.genericArray = genericArray;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
&nbsp;                            return this.genericArray.getComponentType().accept(Assigner.INSTANCE).isAssignableFrom(genericArray.getComponentType());
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                            return typeDescription.isArray()
&nbsp;                                    &amp;&amp; genericArray.getComponentType().accept(Assigner.INSTANCE).isAssignableFrom(typeDescription.getComponentType());
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A validator for Java types that are defined for a specified type use within a Java class file.
&nbsp;             */
&nbsp;            enum Validator implements Visitor&lt;Boolean&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for checking a type&#39;s non-null super class.
&nbsp;                 */
&nbsp;                SUPER_CLASS(false, false, false, false) {
&nbsp;                    @Override
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                        return super.onNonGenericType(typeDescription) &amp;&amp; !typeDescription.isInterface();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                        return !parameterizedType.isInterface();
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for an interface type.
&nbsp;                 */
&nbsp;                INTERFACE(false, false, false, false) {
&nbsp;                    @Override
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                        return super.onNonGenericType(typeDescription) &amp;&amp; typeDescription.isInterface();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                        return parameterizedType.isInterface();
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for a type variable.
&nbsp;                 */
&nbsp;                TYPE_VARIABLE(false, false, true, false),
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for a field type.
&nbsp;                 */
&nbsp;                FIELD(true, true, true, false),
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for a method return type.
&nbsp;                 */
&nbsp;                METHOD_RETURN(true, true, true, true),
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for a method parameter type.
&nbsp;                 */
&nbsp;                METHOD_PARAMETER(true, true, true, false),
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for a method exception type.
&nbsp;                 */
&nbsp;                EXCEPTION(false, false, true, false) {
&nbsp;                    @Override
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                        for (TypeDescription.Generic bound : typeVariable.getUpperBounds()) {
&nbsp;                            if (bound.accept(this)) {
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                        }
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                        return typeDescription.asErasure().isAssignableTo(Throwable.class);
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for a method receiver type.
&nbsp;                 */
&nbsp;                RECEIVER(false, false, false, false);
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this validator accepts array types.
&nbsp;                 */
&nbsp;                private final boolean acceptsArray;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this validator accepts primitive types.
&nbsp;                 */
&nbsp;                private final boolean acceptsPrimitive;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this validator accepts type variables.
&nbsp;                 */
&nbsp;                private final boolean acceptsVariable;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this validator accepts the {@code void} type.
&nbsp;                 */
&nbsp;                private final boolean acceptsVoid;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new validator.
&nbsp;                 *
&nbsp;                 * @param acceptsArray     {@code true} if this validator accepts array types.
&nbsp;                 * @param acceptsPrimitive {@code true} if this validator accepts primitive types.
&nbsp;                 * @param acceptsVariable  {@code true} if this validator accepts type variables.
&nbsp;                 * @param acceptsVoid      {@code true} if this validator accepts the {@code void} type.
&nbsp;                 */
&nbsp;                Validator(boolean acceptsArray, boolean acceptsPrimitive, boolean acceptsVariable, boolean acceptsVoid) {
&nbsp;                    this.acceptsArray = acceptsArray;
&nbsp;                    this.acceptsPrimitive = acceptsPrimitive;
&nbsp;                    this.acceptsVariable = acceptsVariable;
&nbsp;                    this.acceptsVoid = acceptsVoid;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Boolean onGenericArray(Generic genericArray) {
&nbsp;                    return acceptsArray;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Boolean onWildcard(Generic wildcard) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                    return acceptsVariable;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                    return (acceptsArray || !typeDescription.isArray())
&nbsp;                            &amp;&amp; (acceptsPrimitive || !typeDescription.isPrimitive())
&nbsp;                            &amp;&amp; (acceptsVoid || !typeDescription.represents(void.class));
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A type validator for checking type annotations.
&nbsp;                 */
&nbsp;                public enum ForTypeAnnotations implements Visitor&lt;Boolean&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@link ElementType}&#39;s {@code TYPE_USE} constant.
&nbsp;                     */
&nbsp;                    private final ElementType typeUse;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@link ElementType}&#39;s {@code TYPE_PARAMETER} constant.
&nbsp;                     */
&nbsp;                    private final ElementType typeParameter;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new type annotation validator.
&nbsp;                     */
&nbsp;                    ForTypeAnnotations() {
&nbsp;                        ElementType typeUse, typeParameter;
&nbsp;                        try {
&nbsp;                            typeUse = Enum.valueOf(ElementType.class, &quot;TYPE_USE&quot;);
&nbsp;                            typeParameter = Enum.valueOf(ElementType.class, &quot;TYPE_PARAMETER&quot;);
&nbsp;                        } catch (IllegalArgumentException ignored) {
&nbsp;                            // Setting these values null results in this validator always failing for pre Java-8 VMs.
&nbsp;                            typeUse = null;
&nbsp;                            typeParameter = null;
&nbsp;                        }
&nbsp;                        this.typeUse = typeUse;
&nbsp;                        this.typeParameter = typeParameter;
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Validates the type annotations on a formal type variable but not on its bounds..
&nbsp;                     *
&nbsp;                     * @param typeVariable The type variable to validate.
&nbsp;                     * @return {@code true} if the formal type variable declares invalid type annotations.
&nbsp;                     */
&nbsp;                    public static boolean ofFormalTypeVariable(Generic typeVariable) {
&nbsp;                        Set&lt;TypeDescription&gt; annotationTypes = new HashSet&lt;TypeDescription&gt;();
&nbsp;                        for (AnnotationDescription annotationDescription : typeVariable.getDeclaredAnnotations()) {
&nbsp;                            if (!annotationDescription.getElementTypes().contains(INSTANCE.typeParameter) || !annotationTypes.add(annotationDescription.getAnnotationType())) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        }
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Boolean onGenericArray(Generic genericArray) {
&nbsp;                        return isValid(genericArray) &amp;&amp; genericArray.getComponentType().accept(this);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Boolean onWildcard(Generic wildcard) {
&nbsp;                        if (!isValid(wildcard)) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                        TypeList.Generic lowerBounds = wildcard.getLowerBounds();
&nbsp;                        return (lowerBounds.isEmpty()
&nbsp;                                ? wildcard.getUpperBounds()
&nbsp;                                : lowerBounds).getOnly().accept(this);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                        if (!isValid(parameterizedType)) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                        Generic ownerType = parameterizedType.getOwnerType();
&nbsp;                        if (ownerType != null &amp;&amp; !ownerType.accept(this)) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                        for (Generic typeArgument : parameterizedType.getTypeArguments()) {
&nbsp;                            if (!typeArgument.accept(this)) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        }
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                        return isValid(typeVariable);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                        return isValid(typeDescription) &amp;&amp; (!typeDescription.isArray() || typeDescription.getComponentType().accept(this));
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Checks if the supplied type&#39;s type annotations are valid.
&nbsp;                     *
&nbsp;                     * @param typeDescription The type to validate.
&nbsp;                     * @return {@code true} if the supplied type&#39;s type annotations are valid.
&nbsp;                     */
&nbsp;                    private boolean isValid(Generic typeDescription) {
&nbsp;                        Set&lt;TypeDescription&gt; annotationTypes = new HashSet&lt;TypeDescription&gt;();
&nbsp;                        for (AnnotationDescription annotationDescription : typeDescription.getDeclaredAnnotations()) {
&nbsp;                            if (!annotationDescription.getElementTypes().contains(typeUse) || !annotationTypes.add(annotationDescription.getAnnotationType())) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        }
&nbsp;                        return true;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor that reifies type descriptions if they represent raw types.
&nbsp;             */
<b class="fc">&nbsp;            enum Reifying implements Visitor&lt;Generic&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A visitor that reifies non-generic types if they represent raw types. This visitor should be applied when
&nbsp;                 * visiting a potential raw type.
&nbsp;                 */
<b class="fc">&nbsp;                INITIATING {</b>
&nbsp;                    @Override
&nbsp;                    public Generic onParameterizedType(Generic parameterizedType) {
<b class="nc">&nbsp;                        return parameterizedType;</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A visitor that reifies non-generic types if they represent raw types or are parameterized types. This visitor
&nbsp;                 * should only be applied when a type was inherited from a reified type.
&nbsp;                 */
<b class="fc">&nbsp;                INHERITING {</b>
&nbsp;                    @Override
&nbsp;                    public Generic onParameterizedType(Generic parameterizedType) {
<b class="nc">&nbsp;                        return new OfParameterizedType.ForReifiedType(parameterizedType);</b>
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onGenericArray(Generic genericArray) {
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot reify a generic array: &quot; + genericArray);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onWildcard(Generic wildcard) {
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot reify a wildcard: &quot; + wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot reify a type variable: &quot; + typeVariable);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    TypeDescription erasure = typeDescription.asErasure();</b>
<b class="pc">&nbsp;                    return erasure.isGenerified()</b>
&nbsp;                            ? new OfNonGenericType.ForReifiedErasure(erasure)
&nbsp;                            : typeDescription;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Visits a generic type and appends the discovered type to the supplied signature visitor.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForSignatureVisitor implements Visitor&lt;SignatureVisitor&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Index of a {@link String}&#39;s only character to improve code readability.
&nbsp;                 */
&nbsp;                private static final int ONLY_CHARACTER = 0;
&nbsp;
&nbsp;                /**
&nbsp;                 * The signature visitor that receives the discovered generic type.
&nbsp;                 */
&nbsp;                protected final SignatureVisitor signatureVisitor;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new visitor for the given signature visitor.
&nbsp;                 *
&nbsp;                 * @param signatureVisitor The signature visitor that receives the discovered generic type.
&nbsp;                 */
<b class="fc">&nbsp;                public ForSignatureVisitor(SignatureVisitor signatureVisitor) {</b>
<b class="fc">&nbsp;                    this.signatureVisitor = signatureVisitor;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor onGenericArray(Generic genericArray) {
<b class="nc">&nbsp;                    genericArray.getComponentType().accept(new ForSignatureVisitor(signatureVisitor.visitArrayType()));</b>
<b class="nc">&nbsp;                    return signatureVisitor;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor onWildcard(Generic wildcard) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Unexpected wildcard: &quot; + wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                    onOwnableType(parameterizedType);</b>
<b class="fc">&nbsp;                    signatureVisitor.visitEnd();</b>
<b class="fc">&nbsp;                    return signatureVisitor;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Visits a type which might define an owner type.
&nbsp;                 *
&nbsp;                 * @param ownableType The visited generic type.
&nbsp;                 */
&nbsp;                private void onOwnableType(Generic ownableType) {
<b class="fc">&nbsp;                    Generic ownerType = ownableType.getOwnerType();</b>
<b class="pc">&nbsp;                    if (ownerType != null &amp;&amp; ownerType.getSort().isParameterized()) {</b>
<b class="nc">&nbsp;                        onOwnableType(ownerType);</b>
<b class="nc">&nbsp;                        signatureVisitor.visitInnerClassType(ownableType.asErasure().getSimpleName());</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        signatureVisitor.visitClassType(ownableType.asErasure().getInternalName());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    for (Generic typeArgument : ownableType.getTypeArguments()) {</b>
<b class="fc">&nbsp;                        typeArgument.accept(new OfTypeArgument(signatureVisitor));</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor onTypeVariable(Generic typeVariable) {
<b class="nc">&nbsp;                    signatureVisitor.visitTypeVariable(typeVariable.getSymbol());</b>
<b class="nc">&nbsp;                    return signatureVisitor;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    if (typeDescription.isArray()) {</b>
<b class="fc">&nbsp;                        typeDescription.getComponentType().accept(new ForSignatureVisitor(signatureVisitor.visitArrayType()));</b>
<b class="fc">&nbsp;                    } else if (typeDescription.isPrimitive()) {</b>
<b class="fc">&nbsp;                        signatureVisitor.visitBaseType(typeDescription.asErasure().getDescriptor().charAt(ONLY_CHARACTER));</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        signatureVisitor.visitClassType(typeDescription.asErasure().getInternalName());</b>
<b class="fc">&nbsp;                        signatureVisitor.visitEnd();</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return signatureVisitor;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Visits a parameter while visiting a generic type for delegating discoveries to a signature visitor.
&nbsp;                 */
&nbsp;                protected static class OfTypeArgument extends ForSignatureVisitor {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new parameter visitor.
&nbsp;                     *
&nbsp;                     * @param signatureVisitor The signature visitor which is notified over visited types.
&nbsp;                     */
&nbsp;                    protected OfTypeArgument(SignatureVisitor signatureVisitor) {
<b class="fc">&nbsp;                        super(signatureVisitor);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor onWildcard(Generic wildcard) {
<b class="nc">&nbsp;                        TypeList.Generic upperBounds = wildcard.getUpperBounds(), lowerBounds = wildcard.getLowerBounds();</b>
<b class="nc">&nbsp;                        if (lowerBounds.isEmpty() &amp;&amp; upperBounds.getOnly().represents(Object.class)) {</b>
<b class="nc">&nbsp;                            signatureVisitor.visitTypeArgument();</b>
<b class="nc">&nbsp;                        } else if (!lowerBounds.isEmpty() /* &amp;&amp; upperBounds.isEmpty() */) {</b>
<b class="nc">&nbsp;                            lowerBounds.getOnly().accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.SUPER)));</b>
&nbsp;                        } else /* if (!upperBounds.isEmpty() &amp;&amp; lowerBounds.isEmpty()) */ {
<b class="nc">&nbsp;                            upperBounds.getOnly().accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.EXTENDS)));</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return signatureVisitor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor onGenericArray(Generic genericArray) {
<b class="nc">&nbsp;                        genericArray.accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.INSTANCEOF)));</b>
<b class="nc">&nbsp;                        return signatureVisitor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                        parameterizedType.accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.INSTANCEOF)));</b>
<b class="fc">&nbsp;                        return signatureVisitor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor onTypeVariable(Generic typeVariable) {
<b class="nc">&nbsp;                        typeVariable.accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.INSTANCEOF)));</b>
<b class="nc">&nbsp;                        return signatureVisitor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                        typeDescription.accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.INSTANCEOF)));</b>
<b class="fc">&nbsp;                        return signatureVisitor;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract implementation of a visitor that substitutes generic types by replacing (nested)
&nbsp;             * type variables and/or non-generic component types.
&nbsp;             */
<b class="fc">&nbsp;            abstract class Substitutor implements Visitor&lt;Generic&gt; {</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                    Generic ownerType = parameterizedType.getOwnerType();</b>
<b class="fc">&nbsp;                    List&lt;Generic&gt; typeArguments = new ArrayList&lt;Generic&gt;(parameterizedType.getTypeArguments().size());</b>
<b class="fc">&nbsp;                    for (Generic typeArgument : parameterizedType.getTypeArguments()) {</b>
<b class="fc">&nbsp;                        typeArguments.add(typeArgument.accept(this));</b>
<b class="fc">&nbsp;                    }</b>
<b class="pc">&nbsp;                    return new OfParameterizedType.Latent(parameterizedType.asRawType().accept(this).asErasure(),</b>
&nbsp;                            ownerType == null
&nbsp;                                    ? UNDEFINED
<b class="nc">&nbsp;                                    : ownerType.accept(this),</b>
&nbsp;                            typeArguments,
&nbsp;                            parameterizedType);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onGenericArray(Generic genericArray) {
<b class="nc">&nbsp;                    return new OfGenericArray.Latent(genericArray.getComponentType().accept(this), genericArray);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onWildcard(Generic wildcard) {
<b class="nc">&nbsp;                    return new OfWildcardType.Latent(wildcard.getUpperBounds().accept(this), wildcard.getLowerBounds().accept(this), wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    return typeDescription.isArray()</b>
<b class="fc">&nbsp;                            ? new OfGenericArray.Latent(typeDescription.getComponentType().accept(this), typeDescription)</b>
<b class="fc">&nbsp;                            : onSimpleType(typeDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Visits a simple, non-generic type, i.e. either a component type of an array or a non-array type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type that is visited.
&nbsp;                 * @return The substituted type.
&nbsp;                 */
&nbsp;                protected abstract Generic onSimpleType(Generic typeDescription);
&nbsp;
&nbsp;                /**
&nbsp;                 * A {@link Substitutor} that only substitutes type variables but fully preserves non-generic type definitions.
&nbsp;                 */
<b class="fc">&nbsp;                public abstract static class WithoutTypeSubstitution extends Substitutor {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                        return typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
<b class="nc">&nbsp;                        return typeDescription;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A substitutor that attaches type variables to a type variable source and replaces representations of
&nbsp;                 * {@link TargetType} with a given declaring type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForAttachment extends Substitutor {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The declaring type which is filled in for {@link TargetType}.
&nbsp;                     */
&nbsp;                    private final TypeDescription declaringType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The source which is used for locating type variables.
&nbsp;                     */
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a visitor for attaching type variables.
&nbsp;                     *
&nbsp;                     * @param declaringType      The declaring type which is filled in for {@link TargetType} in its erased form.
&nbsp;                     * @param typeVariableSource The source which is used for locating type variables.
&nbsp;                     */
&nbsp;                    protected ForAttachment(TypeDefinition declaringType, TypeVariableSource typeVariableSource) {
<b class="fc">&nbsp;                        this(declaringType.asErasure(), typeVariableSource);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a visitor for attaching type variables.
&nbsp;                     *
&nbsp;                     * @param declaringType      The declaring type which is filled in for {@link TargetType}.
&nbsp;                     * @param typeVariableSource The source which is used for locating type variables.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForAttachment(TypeDescription declaringType, TypeVariableSource typeVariableSource) {</b>
<b class="fc">&nbsp;                        this.declaringType = declaringType;</b>
<b class="fc">&nbsp;                        this.typeVariableSource = typeVariableSource;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Attaches all types to the given field description.
&nbsp;                     *
&nbsp;                     * @param fieldDescription The field description to which visited types should be attached to.
&nbsp;                     * @return A substitutor that attaches visited types to the given field&#39;s type context.
&nbsp;                     */
&nbsp;                    public static ForAttachment of(FieldDescription fieldDescription) {
<b class="fc">&nbsp;                        return new ForAttachment(fieldDescription.getDeclaringType(), fieldDescription.getDeclaringType().asErasure());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Attaches all types to the given method description.
&nbsp;                     *
&nbsp;                     * @param methodDescription The method description to which visited types should be attached to.
&nbsp;                     * @return A substitutor that attaches visited types to the given method&#39;s type context.
&nbsp;                     */
&nbsp;                    public static ForAttachment of(MethodDescription methodDescription) {
<b class="fc">&nbsp;                        return new ForAttachment(methodDescription.getDeclaringType(), methodDescription);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Attaches all types to the given parameter description.
&nbsp;                     *
&nbsp;                     * @param parameterDescription The parameter description to which visited types should be attached to.
&nbsp;                     * @return A substitutor that attaches visited types to the given parameter&#39;s type context.
&nbsp;                     */
&nbsp;                    public static ForAttachment of(ParameterDescription parameterDescription) {
<b class="fc">&nbsp;                        return new ForAttachment(parameterDescription.getDeclaringMethod().getDeclaringType(), parameterDescription.getDeclaringMethod());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Attaches all types to the given type description.
&nbsp;                     *
&nbsp;                     * @param typeDescription The type description to which visited types should be attached to.
&nbsp;                     * @return A substitutor that attaches visited types to the given type&#39;s type context.
&nbsp;                     */
&nbsp;                    public static ForAttachment of(TypeDescription typeDescription) {
<b class="fc">&nbsp;                        return new ForAttachment(typeDescription, typeDescription);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
<b class="nc">&nbsp;                        Generic attachedVariable = typeVariableSource.findVariable(typeVariable.getSymbol());</b>
<b class="nc">&nbsp;                        if (attachedVariable == null) {</b>
<b class="nc">&nbsp;                            throw new IllegalArgumentException(&quot;Cannot attach undefined variable: &quot; + typeVariable);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return new OfTypeVariable.WithAnnotationOverlay(attachedVariable, typeVariable);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
<b class="pc">&nbsp;                        return typeDescription.represents(TargetType.class)</b>
&nbsp;                                ? new OfNonGenericType.Latent(declaringType, typeDescription)
&nbsp;                                : typeDescription;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A visitor for detaching a type from its declaration context by detaching type variables. This is achieved by
&nbsp;                 * detaching type variables and by replacing the declaring type which is identified by a provided {@link ElementMatcher}
&nbsp;                 * with {@link TargetType}.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForDetachment extends Substitutor {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A type matcher for identifying the declaring type.
&nbsp;                     */
&nbsp;                    private final ElementMatcher&lt;? super TypeDescription&gt; typeMatcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a visitor for detaching a type.
&nbsp;                     *
&nbsp;                     * @param typeMatcher A type matcher for identifying the declaring type.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForDetachment(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher) {</b>
<b class="fc">&nbsp;                        this.typeMatcher = typeMatcher;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns a new detachment visitor that detaches any type matching the supplied type description.
&nbsp;                     *
&nbsp;                     * @param typeDefinition The type to detach.
&nbsp;                     * @return A detachment visitor for the supplied type description.
&nbsp;                     */
&nbsp;                    public static Visitor&lt;Generic&gt; of(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                        return new ForDetachment(is(typeDefinition));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
<b class="nc">&nbsp;                        return new OfTypeVariable.Symbolic(typeVariable.getSymbol(), typeVariable);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
<b class="pc">&nbsp;                        return typeMatcher.matches(typeDescription.asErasure())</b>
<b class="nc">&nbsp;                                ? new OfNonGenericType.Latent(TargetType.DESCRIPTION, typeDescription.getOwnerType(), typeDescription)</b>
&nbsp;                                : typeDescription;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A visitor for binding type variables to their values.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForTypeVariableBinding extends WithoutTypeSubstitution {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The parameterized type for which type variables are bound.
&nbsp;                     */
&nbsp;                    private final Generic parameterizedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new visitor for binding a parameterized type&#39;s type arguments to its type variables.
&nbsp;                     *
&nbsp;                     * @param parameterizedType The parameterized type for which type variables are bound.
&nbsp;                     */
&nbsp;                    protected ForTypeVariableBinding(Generic parameterizedType) {
&nbsp;                        this.parameterizedType = parameterizedType;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                        return typeVariable.getTypeVariableSource().accept(new TypeVariableSubstitutor(typeVariable));
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Substitutes a type variable, either with a new binding if the variable is defined by a type or with a
&nbsp;                     * retained type variable if the variable is defined by a method.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class TypeVariableSubstitutor implements TypeVariableSource.Visitor&lt;Generic&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The discovered type variable.
&nbsp;                         */
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new type variable substitutor.
&nbsp;                         *
&nbsp;                         * @param typeVariable The discovered type variable.
&nbsp;                         */
&nbsp;                        protected TypeVariableSubstitutor(Generic typeVariable) {
&nbsp;                            this.typeVariable = typeVariable;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic onType(TypeDescription typeDescription) {
&nbsp;                            // A type variable might be undeclared due to breaking inner class semantics or due to incorrect scoping by a compiler.
&nbsp;                            Generic typeArgument = parameterizedType.findBindingOf(typeVariable);
&nbsp;                            return typeArgument == null
&nbsp;                                    ? typeVariable.asRawType()
&nbsp;                                    : typeArgument;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic onMethod(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                            return new RetainedMethodTypeVariable(typeVariable);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Implementation of a type variable on a method that is not substituted.
&nbsp;                     */
&nbsp;                    protected class RetainedMethodTypeVariable extends OfTypeVariable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The discovered type variable.
&nbsp;                         */
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new retained type variable.
&nbsp;                         *
&nbsp;                         * @param typeVariable The discovered type variable.
&nbsp;                         */
&nbsp;                        protected RetainedMethodTypeVariable(Generic typeVariable) {
&nbsp;                            this.typeVariable = typeVariable;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic getUpperBounds() {
&nbsp;                            return typeVariable.getUpperBounds().accept(ForTypeVariableBinding.this);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeVariableSource getTypeVariableSource() {
&nbsp;                            return typeVariable.getTypeVariableSource();
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public String getSymbol() {
&nbsp;                            return typeVariable.getSymbol();
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return typeVariable.getDeclaredAnnotations();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A substitutor that normalizes a token to represent all {@link TargetType} by a given type and that symbolizes all type variables.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForTokenNormalization extends Substitutor {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type description to substitute all {@link TargetType} representations with.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new token normalization visitor.
&nbsp;                     *
&nbsp;                     * @param typeDescription The type description to substitute all {@link TargetType}
&nbsp;                     */
&nbsp;                    public ForTokenNormalization(TypeDescription typeDescription) {
&nbsp;                        this.typeDescription = typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
&nbsp;                        return typeDescription.represents(TargetType.class)
&nbsp;                                ? new OfNonGenericType.Latent(this.typeDescription, typeDescription)
&nbsp;                                : typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                        return new OfTypeVariable.Symbolic(typeVariable.getSymbol(), typeVariable);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor that transforms any type into a raw type if declaring type is generified. If the declaring type is
&nbsp;             * not generified, the original type description is returned.
&nbsp;             */
&nbsp;            class ForRawType implements Visitor&lt;Generic&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type description that is potentially a raw type.
&nbsp;                 */
&nbsp;                private final TypeDescription declaringType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a visitor for representing declared types of a potentially raw type.
&nbsp;                 *
&nbsp;                 * @param declaringType The type description that is potentially a raw type.
&nbsp;                 */
<b class="fc">&nbsp;                public ForRawType(TypeDescription declaringType) {</b>
<b class="fc">&nbsp;                    this.declaringType = declaringType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onGenericArray(Generic genericArray) {
<b class="nc">&nbsp;                    return declaringType.isGenerified()</b>
<b class="nc">&nbsp;                            ? new Generic.OfNonGenericType.Latent(genericArray.asErasure(), genericArray)</b>
&nbsp;                            : genericArray;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onWildcard(Generic wildcard) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Did not expect wildcard on top-level: &quot; + wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
<b class="pc">&nbsp;                    return declaringType.isGenerified()</b>
<b class="nc">&nbsp;                            ? new Generic.OfNonGenericType.Latent(parameterizedType.asErasure(), parameterizedType)</b>
&nbsp;                            : parameterizedType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
<b class="nc">&nbsp;                    return declaringType.isGenerified()</b>
<b class="nc">&nbsp;                            ? new Generic.OfNonGenericType.Latent(typeVariable.asErasure(), typeVariable)</b>
&nbsp;                            : typeVariable;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    return typeDescription;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor that reduces a detached generic type to its erasure.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Reducing implements Visitor&lt;TypeDescription&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic type&#39;s declaring type.
&nbsp;                 */
&nbsp;                private final TypeDescription declaringType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Any type variables that are directly declared by the member that declares the type being reduced.
&nbsp;                 */
&nbsp;                private final List&lt;? extends TypeVariableToken&gt; typeVariableTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new reducing type visitor.
&nbsp;                 *
&nbsp;                 * @param declaringType     The generic type&#39;s declaring type.
&nbsp;                 * @param typeVariableToken Any type variables that are directly declared by the member that declares the type being reduced.
&nbsp;                 */
&nbsp;                public Reducing(TypeDescription declaringType, TypeVariableToken... typeVariableToken) {
<b class="fc">&nbsp;                    this(declaringType, Arrays.asList(typeVariableToken));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new reducing type visitor.
&nbsp;                 *
&nbsp;                 * @param declaringType      The generic type&#39;s declaring type.
&nbsp;                 * @param typeVariableTokens Any type variables that are directly declared by the member that declares the type being reduced.
&nbsp;                 */
<b class="fc">&nbsp;                public Reducing(TypeDescription declaringType, List&lt;? extends TypeVariableToken&gt; typeVariableTokens) {</b>
<b class="fc">&nbsp;                    this.declaringType = declaringType;</b>
<b class="fc">&nbsp;                    this.typeVariableTokens = typeVariableTokens;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription onGenericArray(Generic genericArray) {
<b class="nc">&nbsp;                    return TargetType.resolve(genericArray.asErasure(), declaringType);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription onWildcard(Generic wildcard) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;A wildcard cannot be a top-level type: &quot; + wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription onParameterizedType(Generic parameterizedType) {
<b class="nc">&nbsp;                    return TargetType.resolve(parameterizedType.asErasure(), declaringType);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription onTypeVariable(Generic typeVariable) {
<b class="nc">&nbsp;                    for (TypeVariableToken typeVariableToken : typeVariableTokens) {</b>
<b class="nc">&nbsp;                        if (typeVariable.getSymbol().equals(typeVariableToken.getSymbol())) {</b>
<b class="nc">&nbsp;                            return typeVariableToken.getBounds().get(0).accept(this);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    return TargetType.resolve(declaringType.findVariable(typeVariable.getSymbol()).asErasure(), declaringType);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    return TargetType.resolve(typeDescription.asErasure(), declaringType);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An annotation reader is responsible for lazily evaluating type annotations if this language
&nbsp;         * feature is available on the current JVM.
&nbsp;         */
&nbsp;        interface AnnotationReader {
&nbsp;
&nbsp;            /**
&nbsp;             * The dispatcher to use.
&nbsp;             */
<b class="fc">&nbsp;            Dispatcher DISPATCHER = AccessController.doPrivileged(Dispatcher.CreationAction.INSTANCE);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the underlying {@link AnnotatedElement}.
&nbsp;             *
&nbsp;             * @return The underlying annotated element.
&nbsp;             */
&nbsp;            AnnotatedElement resolve();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the underlying type annotations as a list.
&nbsp;             *
&nbsp;             * @return The underlying type annotations as a list.
&nbsp;             */
&nbsp;            AnnotationList asList();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a reader for type annotations of an represented element&#39;s wildcard upper bound.
&nbsp;             *
&nbsp;             * @param index The wildcard bound&#39;s index.
&nbsp;             * @return An annotation reader for the underlying annotated upper bound.
&nbsp;             */
&nbsp;            AnnotationReader ofWildcardUpperBoundType(int index);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a reader for type annotations of an represented element&#39;s wildcard lower bound.
&nbsp;             *
&nbsp;             * @param index The wildcard bound&#39;s index.
&nbsp;             * @return An annotation reader for the underlying annotated lower bound.
&nbsp;             */
&nbsp;            AnnotationReader ofWildcardLowerBoundType(int index);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a reader for type annotations of a type variable&#39;s bound.
&nbsp;             *
&nbsp;             * @param index The bound&#39;s index.
&nbsp;             * @return An annotation reader for the underlying annotated bound.
&nbsp;             */
&nbsp;            AnnotationReader ofTypeVariableBoundType(int index);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a reader for type annotations of a parameterized type&#39;s type argument.
&nbsp;             *
&nbsp;             * @param index The bound&#39;s index.
&nbsp;             * @return An annotation reader for the underlying annotated bound..
&nbsp;             */
&nbsp;            AnnotationReader ofTypeArgument(int index);
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * Returns a reader for type annotations of a parameterized type&#39;s owner type.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * &lt;b&gt;Important&lt;/b&gt;: This feature is not currently implemented by the Java reflection API.
&nbsp;             * &lt;/p&gt;
&nbsp;             *
&nbsp;             * @return An annotation reader for the underlying owner type.
&nbsp;             */
&nbsp;            AnnotationReader ofOwnerType();
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * Returns a reader for type annotations of an inner class type&#39;s outer type.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * &lt;b&gt;Important&lt;/b&gt;: This feature is not currently implemented by the Java reflection API.
&nbsp;             * &lt;/p&gt;
&nbsp;             *
&nbsp;             * @return An annotation reader for the underlying owner type.
&nbsp;             */
&nbsp;            AnnotationReader ofOuterClass();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a reader for type annotations of an array&#39;s component type.
&nbsp;             *
&nbsp;             * @return An annotation reader for the underlying component type.
&nbsp;             */
&nbsp;            AnnotationReader ofComponentType();
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher that represents the type annotation API via reflective calls if the language feature is available on the current JVM.
&nbsp;             */
&nbsp;            interface Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * An empty array that can be used to indicate no arguments to avoid an allocation on a reflective call.
&nbsp;                 */
<b class="fc">&nbsp;                Object[] NO_ARGUMENTS = new Object[0];</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a formal type variable&#39;s type annotations.
&nbsp;                 *
&nbsp;                 * @param typeVariable The type variable to represent.
&nbsp;                 * @return A suitable annotation reader.
&nbsp;                 */
&nbsp;                AnnotationReader resolveTypeVariable(TypeVariable&lt;?&gt; typeVariable);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a loaded type&#39;s super class&#39;s type annotations.
&nbsp;                 *
&nbsp;                 * @param type The type to represent.
&nbsp;                 * @return A suitable annotation reader.
&nbsp;                 */
&nbsp;                AnnotationReader resolveSuperClassType(Class&lt;?&gt; type);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a loaded type&#39;s interface type&#39;s type annotations.
&nbsp;                 *
&nbsp;                 * @param type  The type to represent.
&nbsp;                 * @param index The index of the interface.
&nbsp;                 * @return A suitable annotation reader.
&nbsp;                 */
&nbsp;                AnnotationReader resolveInterfaceType(Class&lt;?&gt; type, int index);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a loaded field&#39;s type&#39;s type annotations.
&nbsp;                 *
&nbsp;                 * @param field The field to represent.
&nbsp;                 * @return A suitable annotation reader.
&nbsp;                 */
&nbsp;                AnnotationReader resolveFieldType(Field field);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a loaded method&#39;s return type&#39;s type annotations.
&nbsp;                 *
&nbsp;                 * @param method The method to represent.
&nbsp;                 * @return A suitable annotation reader.
&nbsp;                 */
&nbsp;                AnnotationReader resolveReturnType(Method method);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a loaded executable&#39;s type argument type&#39;s type annotations.
&nbsp;                 *
&nbsp;                 * @param executable The executable to represent.
&nbsp;                 * @param index      The type argument&#39;s index.
&nbsp;                 * @return A suitable annotation reader.
&nbsp;                 */
&nbsp;                AnnotationReader resolveParameterType(AccessibleObject executable, int index);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a loaded executable&#39;s exception type&#39;s type annotations.
&nbsp;                 *
&nbsp;                 * @param executable The executable to represent.
&nbsp;                 * @param index      The type argument&#39;s index.
&nbsp;                 * @return A suitable annotation reader.
&nbsp;                 */
&nbsp;                AnnotationReader resolveExceptionType(AccessibleObject executable, int index);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a method&#39;s or constructor&#39;s receiver type. If receiver types are not available on the executing VM,
&nbsp;                 * {@code null} is returned.
&nbsp;                 *
&nbsp;                 * @param executable The executable for which the receiver type should be resolved.
&nbsp;                 * @return The executable&#39;s receiver type or {@code null}.
&nbsp;                 */
&nbsp;                Generic resolveReceiverType(AccessibleObject executable);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the annotated type as generic type description.
&nbsp;                 *
&nbsp;                 * @param annotatedType The loaded annotated type.
&nbsp;                 * @return A description of the supplied annotated type.
&nbsp;                 */
&nbsp;                Generic resolve(AnnotatedElement annotatedType);
&nbsp;
&nbsp;                /**
&nbsp;                 * A creation action for a dispatcher.
&nbsp;                 */
<b class="fc">&nbsp;                enum CreationAction implements PrivilegedAction&lt;Dispatcher&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Dispatcher run() {
&nbsp;                        try {
<b class="fc">&nbsp;                            return new ForJava8CapableVm(Class.class.getMethod(&quot;getAnnotatedSuperclass&quot;),</b>
<b class="fc">&nbsp;                                    Class.class.getMethod(&quot;getAnnotatedInterfaces&quot;),</b>
<b class="fc">&nbsp;                                    Field.class.getMethod(&quot;getAnnotatedType&quot;),</b>
<b class="fc">&nbsp;                                    Method.class.getMethod(&quot;getAnnotatedReturnType&quot;),</b>
<b class="fc">&nbsp;                                    Class.forName(&quot;java.lang.reflect.Executable&quot;).getMethod(&quot;getAnnotatedParameterTypes&quot;),</b>
<b class="fc">&nbsp;                                    Class.forName(&quot;java.lang.reflect.Executable&quot;).getMethod(&quot;getAnnotatedExceptionTypes&quot;),</b>
<b class="fc">&nbsp;                                    Class.forName(&quot;java.lang.reflect.Executable&quot;).getMethod(&quot;getAnnotatedReceiverType&quot;),</b>
<b class="fc">&nbsp;                                    Class.forName(&quot;java.lang.reflect.AnnotatedType&quot;).getMethod(&quot;getType&quot;));</b>
<b class="nc">&nbsp;                        } catch (RuntimeException exception) {</b>
<b class="nc">&nbsp;                            throw exception;</b>
<b class="nc">&nbsp;                        } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                            return Dispatcher.ForLegacyVm.INSTANCE;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for {@link AnnotationReader}s on a legacy VM that does not support type annotations.
&nbsp;                 */
&nbsp;                enum ForLegacyVm implements Dispatcher {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveTypeVariable(TypeVariable&lt;?&gt; typeVariable) {
&nbsp;                        return NoOp.INSTANCE;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveSuperClassType(Class&lt;?&gt; type) {
&nbsp;                        return NoOp.INSTANCE;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveInterfaceType(Class&lt;?&gt; type, int index) {
&nbsp;                        return NoOp.INSTANCE;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveFieldType(Field field) {
&nbsp;                        return NoOp.INSTANCE;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveReturnType(Method method) {
&nbsp;                        return NoOp.INSTANCE;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveParameterType(AccessibleObject executable, int index) {
&nbsp;                        return NoOp.INSTANCE;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveExceptionType(AccessibleObject executable, int index) {
&nbsp;                        return NoOp.INSTANCE;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic resolveReceiverType(AccessibleObject executable) {
&nbsp;                        return UNDEFINED;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic resolve(AnnotatedElement annotatedType) {
&nbsp;                        throw new IllegalStateException(&quot;Loaded annotated type cannot be represented on this VM&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for a modern JVM that supports type annotations.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;                class ForJava8CapableVm implements Dispatcher {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code java.lang.Class#getAnnotatedSuperclass} method.
&nbsp;                     */
&nbsp;                    private final Method getAnnotatedSuperclass;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code java.lang.Class#getAnnotatedInterfaces} method.
&nbsp;                     */
&nbsp;                    private final Method getAnnotatedInterfaces;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code java.lang.reflect.Field#getAnnotatedType} method.
&nbsp;                     */
&nbsp;                    private final Method getAnnotatedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code java.lang.reflect.Method#getAnnotatedReturnType} method.
&nbsp;                     */
&nbsp;                    private final Method getAnnotatedReturnType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code java.lang.reflect.Executable#getAnnotatedParameterTypes} method.
&nbsp;                     */
&nbsp;                    private final Method getAnnotatedParameterTypes;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code java.lang.reflect.Executable#getAnnotatedExceptionTypes} method.
&nbsp;                     */
&nbsp;                    private final Method getAnnotatedExceptionTypes;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code java.lang.reflect.Executable#getAnnotatedReceiverType} method.
&nbsp;                     */
&nbsp;                    private final Method getAnnotatedReceiverType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code java.lang.reflect.AnnotatedType#getType} method.
&nbsp;                     */
&nbsp;                    private final Method getType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new dispatcher for a VM that supports type annotations.
&nbsp;                     *
&nbsp;                     * @param getAnnotatedSuperclass     The {@code java.lang.Class#getAnnotatedSuperclass} method.
&nbsp;                     * @param getAnnotatedInterfaces     The {@code java.lang.Class#getAnnotatedInterfaces} method.
&nbsp;                     * @param getAnnotatedType           The {@code java.lang.reflect.Field#getAnnotatedType} method.
&nbsp;                     * @param getAnnotatedReturnType     The {@code java.lang.reflect.Method#getAnnotatedReturnType} method.
&nbsp;                     * @param getAnnotatedParameterTypes The {@code java.lang.reflect.Executable#getAnnotatedParameterTypes} method.
&nbsp;                     * @param getAnnotatedExceptionTypes The {@code java.lang.reflect.Executable#getAnnotatedExceptionTypes} method.
&nbsp;                     * @param getAnnotatedReceiverType   The {@code java.lang.reflect.Executable#getAnnotatedReceiverType} method.
&nbsp;                     * @param getType                    The {@code java.lang.reflect.AnnotatedType#getType} method.
&nbsp;                     */
&nbsp;                    protected ForJava8CapableVm(Method getAnnotatedSuperclass,
&nbsp;                                                Method getAnnotatedInterfaces,
&nbsp;                                                Method getAnnotatedType,
&nbsp;                                                Method getAnnotatedReturnType,
&nbsp;                                                Method getAnnotatedParameterTypes,
&nbsp;                                                Method getAnnotatedExceptionTypes,
&nbsp;                                                Method getAnnotatedReceiverType,
<b class="fc">&nbsp;                                                Method getType) {</b>
<b class="fc">&nbsp;                        this.getAnnotatedSuperclass = getAnnotatedSuperclass;</b>
<b class="fc">&nbsp;                        this.getAnnotatedInterfaces = getAnnotatedInterfaces;</b>
<b class="fc">&nbsp;                        this.getAnnotatedType = getAnnotatedType;</b>
<b class="fc">&nbsp;                        this.getAnnotatedReturnType = getAnnotatedReturnType;</b>
<b class="fc">&nbsp;                        this.getAnnotatedParameterTypes = getAnnotatedParameterTypes;</b>
<b class="fc">&nbsp;                        this.getAnnotatedExceptionTypes = getAnnotatedExceptionTypes;</b>
<b class="fc">&nbsp;                        this.getAnnotatedReceiverType = getAnnotatedReceiverType;</b>
<b class="fc">&nbsp;                        this.getType = getType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveTypeVariable(TypeVariable&lt;?&gt; typeVariable) {
<b class="nc">&nbsp;                        return new AnnotatedTypeVariableType(typeVariable);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveSuperClassType(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                        return new AnnotatedSuperClass(type);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveInterfaceType(Class&lt;?&gt; type, int index) {
<b class="fc">&nbsp;                        return new AnnotatedInterfaceType(type, index);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveFieldType(Field field) {
<b class="nc">&nbsp;                        return new AnnotatedFieldType(field);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveReturnType(Method method) {
<b class="fc">&nbsp;                        return new AnnotatedReturnType(method);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveParameterType(AccessibleObject executable, int index) {
<b class="fc">&nbsp;                        return new AnnotatedParameterizedType(executable, index);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationReader resolveExceptionType(AccessibleObject executable, int index) {
<b class="fc">&nbsp;                        return new AnnotatedExceptionType(executable, index);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic resolveReceiverType(AccessibleObject executable) {
&nbsp;                        try {
<b class="fc">&nbsp;                            return resolve((AnnotatedElement) getAnnotatedReceiverType.invoke(executable, NO_ARGUMENTS));</b>
<b class="nc">&nbsp;                        } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot access java.lang.reflect.Executable#getAnnotatedReceiverType&quot;, exception);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Error invoking java.lang.reflect.Executable#getAnnotatedReceiverType&quot;, exception.getCause());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic resolve(AnnotatedElement annotatedType) {
&nbsp;                        try {
<b class="fc">&nbsp;                            return annotatedType == null</b>
&nbsp;                                    ? UNDEFINED
<b class="fc">&nbsp;                                    : Sort.describe((java.lang.reflect.Type) getType.invoke(annotatedType, NO_ARGUMENTS), new Resolved(annotatedType));</b>
<b class="nc">&nbsp;                        } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot access java.lang.reflect.AnnotatedType#getType&quot;, exception);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Error invoking java.lang.reflect.AnnotatedType#getType&quot;, exception.getCause());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A delegator for an existing {@code java.lang.reflect.Annotatedelement}.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class Resolved extends Delegator {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented annotated element.
&nbsp;                         */
&nbsp;                        private final AnnotatedElement annotatedElement;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new resolved delegator.
&nbsp;                         *
&nbsp;                         * @param annotatedElement The represented annotated element.
&nbsp;                         */
<b class="fc">&nbsp;                        protected Resolved(AnnotatedElement annotatedElement) {</b>
<b class="fc">&nbsp;                            this.annotatedElement = annotatedElement;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotatedElement resolve() {
<b class="fc">&nbsp;                            return annotatedElement;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A delegating annotation reader for an annotated type variable.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class AnnotatedTypeVariableType extends Delegator {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented type variable.
&nbsp;                         */
&nbsp;                        private final TypeVariable&lt;?&gt; typeVariable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation reader for the given type variable.
&nbsp;                         *
&nbsp;                         * @param typeVariable The represented type variable.
&nbsp;                         */
&nbsp;                        protected AnnotatedTypeVariableType(TypeVariable&lt;?&gt; typeVariable) {
&nbsp;                            this.typeVariable = typeVariable;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotatedElement resolve() {
&nbsp;                            return (AnnotatedElement) typeVariable;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationReader ofTypeVariableBoundType(int index) {
&nbsp;                            return new ForTypeVariableBoundType.OfFormalTypeVariable(typeVariable, index);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A delegating annotation reader for an annotated super type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class AnnotatedSuperClass extends Delegator {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented type.
&nbsp;                         */
&nbsp;                        private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation reader for an annotated super type.
&nbsp;                         *
&nbsp;                         * @param type The represented type.
&nbsp;                         */
<b class="fc">&nbsp;                        protected AnnotatedSuperClass(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;                            this.type = type;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotatedElement resolve() {
&nbsp;                            try {
<b class="nc">&nbsp;                                return (AnnotatedElement) getAnnotatedSuperclass.invoke(type, NO_ARGUMENTS);</b>
<b class="nc">&nbsp;                            } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot access java.lang.Class#getAnnotatedSuperclass&quot;, exception);</b>
<b class="nc">&nbsp;                            } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Error invoking java.lang.Class#getAnnotatedSuperclass&quot;, exception.getCause());</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A delegating annotation reader for an annotated interface type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class AnnotatedInterfaceType extends Delegator {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented interface type.
&nbsp;                         */
&nbsp;                        private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The interface type&#39;s index.
&nbsp;                         */
&nbsp;                        private final int index;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation reader for an annotated interface type.
&nbsp;                         *
&nbsp;                         * @param type  The represented interface type.
&nbsp;                         * @param index The interface type&#39;s index.
&nbsp;                         */
<b class="fc">&nbsp;                        protected AnnotatedInterfaceType(Class&lt;?&gt; type, int index) {</b>
<b class="fc">&nbsp;                            this.type = type;</b>
<b class="fc">&nbsp;                            this.index = index;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotatedElement resolve() {
&nbsp;                            try {
<b class="nc">&nbsp;                                return (AnnotatedElement) Array.get(getAnnotatedInterfaces.invoke(type), index);</b>
<b class="nc">&nbsp;                            } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot access java.lang.Class#getAnnotatedInterfaces&quot;, exception);</b>
<b class="nc">&nbsp;                            } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Error invoking java.lang.Class#getAnnotatedInterfaces&quot;, exception.getCause());</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A delegating annotation reader for an annotated field variable.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class AnnotatedFieldType extends Delegator {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented field.
&nbsp;                         */
&nbsp;                        private final Field field;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation reader for an annotated field type.
&nbsp;                         *
&nbsp;                         * @param field The represented field.
&nbsp;                         */
&nbsp;                        protected AnnotatedFieldType(Field field) {
&nbsp;                            this.field = field;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotatedElement resolve() {
&nbsp;                            try {
&nbsp;                                return (AnnotatedElement) getAnnotatedType.invoke(field, NO_ARGUMENTS);
&nbsp;                            } catch (IllegalAccessException exception) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot access java.lang.reflect.Field#getAnnotatedType&quot;, exception);
&nbsp;                            } catch (InvocationTargetException exception) {
&nbsp;                                throw new IllegalStateException(&quot;Error invoking java.lang.reflect.Field#getAnnotatedType&quot;, exception.getCause());
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A delegating annotation reader for an annotated return variable.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class AnnotatedReturnType extends Delegator {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented method.
&nbsp;                         */
&nbsp;                        private final Method method;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation reader for an annotated return type.
&nbsp;                         *
&nbsp;                         * @param method The represented method.
&nbsp;                         */
<b class="fc">&nbsp;                        protected AnnotatedReturnType(Method method) {</b>
<b class="fc">&nbsp;                            this.method = method;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotatedElement resolve() {
&nbsp;                            try {
<b class="fc">&nbsp;                                return (AnnotatedElement) getAnnotatedReturnType.invoke(method, NO_ARGUMENTS);</b>
<b class="nc">&nbsp;                            } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot access java.lang.reflect.Method#getAnnotatedReturnType&quot;, exception);</b>
<b class="nc">&nbsp;                            } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Error invoking java.lang.reflect.Method#getAnnotatedReturnType&quot;, exception.getCause());</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A delegating annotation reader for an annotated parameter variable.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class AnnotatedParameterizedType extends Delegator {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented executable.
&nbsp;                         */
&nbsp;                        private final AccessibleObject executable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type argument&#39;s index.
&nbsp;                         */
&nbsp;                        private final int index;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation reader for an annotated type argument type.
&nbsp;                         *
&nbsp;                         * @param executable The represented executable.
&nbsp;                         * @param index      The type argument&#39;s index.
&nbsp;                         */
<b class="fc">&nbsp;                        protected AnnotatedParameterizedType(AccessibleObject executable, int index) {</b>
<b class="fc">&nbsp;                            this.executable = executable;</b>
<b class="fc">&nbsp;                            this.index = index;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotatedElement resolve() {
&nbsp;                            try {
<b class="fc">&nbsp;                                return (AnnotatedElement) Array.get(getAnnotatedParameterTypes.invoke(executable, NO_ARGUMENTS), index);</b>
<b class="nc">&nbsp;                            } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot access java.lang.reflect.Executable#getAnnotatedParameterTypes&quot;, exception);</b>
<b class="nc">&nbsp;                            } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Error invoking java.lang.reflect.Executable#getAnnotatedParameterTypes&quot;, exception.getCause());</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A delegating annotation reader for an annotated exception variable.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class AnnotatedExceptionType extends Delegator {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented executable.
&nbsp;                         */
&nbsp;                        private final AccessibleObject executable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The exception type&#39;s index.
&nbsp;                         */
&nbsp;                        private final int index;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation reader for an annotated exception type.
&nbsp;                         *
&nbsp;                         * @param executable The represented executable.
&nbsp;                         * @param index      The exception type&#39;s index.
&nbsp;                         */
<b class="fc">&nbsp;                        protected AnnotatedExceptionType(AccessibleObject executable, int index) {</b>
<b class="fc">&nbsp;                            this.executable = executable;</b>
<b class="fc">&nbsp;                            this.index = index;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotatedElement resolve() {
&nbsp;                            try {
<b class="fc">&nbsp;                                return (AnnotatedElement) Array.get(getAnnotatedExceptionTypes.invoke(executable, NO_ARGUMENTS), index);</b>
<b class="nc">&nbsp;                            } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot access java.lang.reflect.Executable#getAnnotatedExceptionTypes&quot;, exception);</b>
<b class="nc">&nbsp;                            } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Error invoking java.lang.reflect.Executable#getAnnotatedExceptionTypes&quot;, exception.getCause());</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A non-operational annotation reader.
&nbsp;             */
<b class="fc">&nbsp;            enum NoOp implements AnnotationReader, AnnotatedElement {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotatedElement resolve() {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList asList() {
<b class="fc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofWildcardUpperBoundType(int index) {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofWildcardLowerBoundType(int index) {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofTypeVariableBoundType(int index) {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofTypeArgument(int index) {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofOwnerType() {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofOuterClass() {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofComponentType() {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve annotations for no-op reader: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve annotations for no-op reader: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Annotation[] getAnnotations() {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve annotations for no-op reader: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Annotation[] getDeclaredAnnotations() {
<b class="nc">&nbsp;                    return new Annotation[0];</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A delegating annotation reader that delegates all invocations to an annotation reader that wraps the previous one.
&nbsp;             */
<b class="fc">&nbsp;            abstract class Delegator implements AnnotationReader {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * An empty array that can be used to indicate no arguments to avoid an allocation on a reflective call.
&nbsp;                 */
<b class="fc">&nbsp;                protected static final Object[] NO_ARGUMENTS = new Object[0];</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofWildcardUpperBoundType(int index) {
<b class="nc">&nbsp;                    return new ForWildcardUpperBoundType(this, index);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofWildcardLowerBoundType(int index) {
<b class="nc">&nbsp;                    return new ForWildcardLowerBoundType(this, index);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofTypeVariableBoundType(int index) {
<b class="nc">&nbsp;                    return new ForTypeVariableBoundType(this, index);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofTypeArgument(int index) {
<b class="fc">&nbsp;                    return new ForTypeArgument(this, index);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofOwnerType() {
<b class="nc">&nbsp;                    return ForOwnerType.of(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofOuterClass() {
<b class="nc">&nbsp;                    return ForOwnerType.of(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationReader ofComponentType() {
<b class="fc">&nbsp;                    return new ForComponentType(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList asList() {
<b class="fc">&nbsp;                    return new AnnotationList.ForLoadedAnnotations(resolve().getDeclaredAnnotations());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A chained delegator that bases its result on an underlying annotation reader.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected abstract static class Chained extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Indicates that a method is not available on the current VM.
&nbsp;                     */
<b class="fc">&nbsp;                    protected static final Method NOT_AVAILABLE = null;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The underlying annotation reader.
&nbsp;                     */
&nbsp;                    protected final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new chained annotation reader.
&nbsp;                     *
&nbsp;                     * @param annotationReader The underlying annotation reader.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Chained(AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                        this.annotationReader = annotationReader;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves the method to invoke or returns {@code null} if the method does not exist on the current VM.
&nbsp;                     *
&nbsp;                     * @param typeName   The declaring type&#39;s name.
&nbsp;                     * @param methodName The method&#39;s name.
&nbsp;                     * @return The resolved method or {@code null}.
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback&quot;)
&nbsp;                    protected static Method of(String typeName, String methodName) {
&nbsp;                        try {
<b class="fc">&nbsp;                            return Class.forName(typeName).getMethod(methodName);</b>
<b class="nc">&nbsp;                        } catch (Exception exception) {</b>
<b class="nc">&nbsp;                            return NOT_AVAILABLE;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotatedElement resolve() {
<b class="fc">&nbsp;                        return resolve(annotationReader.resolve());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves the type annotations from a given annotated element into the annotated element that this instance represents.
&nbsp;                     *
&nbsp;                     * @param annotatedElement The original annotated element.
&nbsp;                     * @return The resolved annotated element.
&nbsp;                     */
&nbsp;                    protected abstract AnnotatedElement resolve(AnnotatedElement annotatedElement);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A chained annotation reader for reading a wildcard type&#39;s upper bound type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForWildcardUpperBoundType extends Delegator.Chained {
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.reflect.AnnotatedWildcardType#getAnnotatedUpperBounds} method.
&nbsp;                 */
&nbsp;                private static final Method GET_ANNOTATED_UPPER_BOUNDS = of(&quot;java.lang.reflect.AnnotatedWildcardType&quot;, &quot;getAnnotatedUpperBounds&quot;);
&nbsp;
&nbsp;                /**
&nbsp;                 * The wildcard bound&#39;s index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading a upper-bound wildcard&#39;s bound type.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 * @param index            The wildcard bound&#39;s index.
&nbsp;                 */
&nbsp;                protected ForWildcardUpperBoundType(AnnotationReader annotationReader, int index) {
&nbsp;                    super(annotationReader);
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    try {
&nbsp;                        Object annotatedUpperBounds = GET_ANNOTATED_UPPER_BOUNDS.invoke(annotatedElement, NO_ARGUMENTS);
&nbsp;                        return Array.getLength(annotatedUpperBounds) == 0 // Wildcards with a lower bound do not define annotations for their implicit upper bound.
&nbsp;                                ? NoOp.INSTANCE
&nbsp;                                : (AnnotatedElement) Array.get(annotatedUpperBounds, index);
&nbsp;                    } catch (ClassCastException ignored) { // To avoid bug on early releases of Java 8.
&nbsp;                        return NoOp.INSTANCE;
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot access java.lang.reflect.AnnotatedWildcardType#getAnnotatedUpperBounds&quot;, exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(&quot;Error invoking java.lang.reflect.AnnotatedWildcardType#getAnnotatedUpperBounds&quot;, exception.getCause());
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A chained annotation reader for reading a wildcard type&#39;s lower bound type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForWildcardLowerBoundType extends Delegator.Chained {
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.reflect.AnnotatedWildcardType#getAnnotatedLowerBounds} method.
&nbsp;                 */
&nbsp;                private static final Method GET_ANNOTATED_LOWER_BOUNDS = of(&quot;java.lang.reflect.AnnotatedWildcardType&quot;, &quot;getAnnotatedLowerBounds&quot;);
&nbsp;
&nbsp;                /**
&nbsp;                 * The wildcard bound&#39;s index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading a lower-bound wildcard&#39;s bound type.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 * @param index            The wildcard bound&#39;s index.
&nbsp;                 */
&nbsp;                protected ForWildcardLowerBoundType(AnnotationReader annotationReader, int index) {
&nbsp;                    super(annotationReader);
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    try {
&nbsp;                        return (AnnotatedElement) Array.get(GET_ANNOTATED_LOWER_BOUNDS.invoke(annotatedElement, NO_ARGUMENTS), index);
&nbsp;                    } catch (ClassCastException ignored) { // To avoid bug on early releases of Java 8.
&nbsp;                        return NoOp.INSTANCE;
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot access java.lang.reflect.AnnotatedWildcardType#getAnnotatedLowerBounds&quot;, exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(&quot;Error invoking java.lang.reflect.AnnotatedWildcardType#getAnnotatedLowerBounds&quot;, exception.getCause());
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A chained annotation reader for reading a type variable&#39;s type argument.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForTypeVariableBoundType extends Delegator.Chained {
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.reflect.AnnotatedTypeVariable#getAnnotatedBounds} method.
&nbsp;                 */
&nbsp;                private static final Method GET_ANNOTATED_BOUNDS = of(&quot;java.lang.reflect.AnnotatedTypeVariable&quot;, &quot;getAnnotatedBounds&quot;);
&nbsp;
&nbsp;                /**
&nbsp;                 * The type variable&#39;s index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading a type variable&#39;s bound type.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 * @param index            The type variable&#39;s index.
&nbsp;                 */
&nbsp;                protected ForTypeVariableBoundType(AnnotationReader annotationReader, int index) {
&nbsp;                    super(annotationReader);
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    try {
&nbsp;                        return (AnnotatedElement) Array.get(GET_ANNOTATED_BOUNDS.invoke(annotatedElement, NO_ARGUMENTS), index);
&nbsp;                    } catch (ClassCastException ignored) { // To avoid bug on early releases of Java 8.
&nbsp;                        return NoOp.INSTANCE;
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot access java.lang.reflect.AnnotatedTypeVariable#getAnnotatedBounds&quot;, exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(&quot;Error invoking java.lang.reflect.AnnotatedTypeVariable#getAnnotatedBounds&quot;, exception.getCause());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A chained annotation reader for reading a formal type variable&#39;s type argument.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class OfFormalTypeVariable extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code java.lang.reflect.TypeVariable#getAnnotatedBounds} method.
&nbsp;                     */
&nbsp;                    private static final Method GET_ANNOTATED_BOUNDS = of(TypeVariable.class.getName(), &quot;getAnnotatedBounds&quot;);
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented type variable.
&nbsp;                     */
&nbsp;                    private final TypeVariable&lt;?&gt; typeVariable;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type variable&#39;s index.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a chained annotation reader for reading a formal type variable&#39;s bound type.
&nbsp;                     *
&nbsp;                     * @param typeVariable The represented type variable.
&nbsp;                     * @param index        The type variable&#39;s index.
&nbsp;                     */
&nbsp;                    protected OfFormalTypeVariable(TypeVariable&lt;?&gt; typeVariable, int index) {
&nbsp;                        this.typeVariable = typeVariable;
&nbsp;                        this.index = index;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        try {
&nbsp;                            return (AnnotatedElement) Array.get(GET_ANNOTATED_BOUNDS.invoke(typeVariable, NO_ARGUMENTS), index);
&nbsp;                        } catch (ClassCastException ignored) { // To avoid bug on early releases of Java 8.
&nbsp;                            return NoOp.INSTANCE;
&nbsp;                        } catch (IllegalAccessException exception) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot access java.lang.reflect.TypeVariable#getAnnotatedBounds&quot;, exception);
&nbsp;                        } catch (InvocationTargetException exception) {
&nbsp;                            throw new IllegalStateException(&quot;Error invoking java.lang.reflect.TypeVariable#getAnnotatedBounds&quot;, exception.getCause());
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A chained annotation reader for reading a parameterized type&#39;s type argument.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForTypeArgument extends Delegator.Chained {
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.reflect.AnnotatedParameterizedType#getAnnotatedActualTypeArguments} method.
&nbsp;                 */
<b class="fc">&nbsp;                private static final Method GET_ANNOTATED_ACTUAL_TYPE_ARGUMENTS = of(&quot;java.lang.reflect.AnnotatedParameterizedType&quot;, &quot;getAnnotatedActualTypeArguments&quot;);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The type argument&#39;s index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading a component type.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 * @param index            The type argument&#39;s index.
&nbsp;                 */
&nbsp;                protected ForTypeArgument(AnnotationReader annotationReader, int index) {
<b class="fc">&nbsp;                    super(annotationReader);</b>
<b class="fc">&nbsp;                    this.index = index;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (AnnotatedElement) Array.get(GET_ANNOTATED_ACTUAL_TYPE_ARGUMENTS.invoke(annotatedElement, NO_ARGUMENTS), index);</b>
<b class="nc">&nbsp;                    } catch (ClassCastException ignored) { // To avoid bug on early releases of Java 8.</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access java.lang.reflect.AnnotatedParameterizedType#getAnnotatedActualTypeArguments&quot;, exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Error invoking java.lang.reflect.AnnotatedParameterizedType#getAnnotatedActualTypeArguments&quot;, exception.getCause());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A chained annotation reader for reading a component type.
&nbsp;             */
&nbsp;            class ForComponentType extends Delegator.Chained {
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.reflect.AnnotatedArrayType#getAnnotatedGenericComponentType} method.
&nbsp;                 */
<b class="fc">&nbsp;                private static final Method GET_ANNOTATED_GENERIC_COMPONENT_TYPE = of(&quot;java.lang.reflect.AnnotatedArrayType&quot;, &quot;getAnnotatedGenericComponentType&quot;);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading a component type.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 */
&nbsp;                protected ForComponentType(AnnotationReader annotationReader) {
<b class="fc">&nbsp;                    super(annotationReader);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (AnnotatedElement) GET_ANNOTATED_GENERIC_COMPONENT_TYPE.invoke(annotatedElement, NO_ARGUMENTS);</b>
<b class="nc">&nbsp;                    } catch (ClassCastException ignored) { // To avoid bug on early releases of Java 8.</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access java.lang.reflect.AnnotatedArrayType#getAnnotatedGenericComponentType&quot;, exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Error invoking java.lang.reflect.AnnotatedArrayType#getAnnotatedGenericComponentType&quot;, exception.getCause());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A chained annotation reader for reading an owner type.
&nbsp;             */
&nbsp;            class ForOwnerType extends Delegator.Chained {
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.reflect.AnnotatedType#getAnnotatedOwnerType} method.
&nbsp;                 */
&nbsp;                private static final Method GET_ANNOTATED_OWNER_TYPE = of(&quot;java.lang.reflect.AnnotatedType&quot;, &quot;getAnnotatedOwnerType&quot;);
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading an owner type if it is accessible. This method checks if annotated
&nbsp;                 * owner types are available on the executing VM (Java 9+). If this is not the case, a non-operational annotation
&nbsp;                 * reader is returned.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 * @return An annotation reader for the resolved type&#39;s owner type.
&nbsp;                 */
&nbsp;                private static AnnotationReader of(AnnotationReader annotationReader) {
&nbsp;                    return GET_ANNOTATED_OWNER_TYPE == null
&nbsp;                            ? NoOp.INSTANCE
&nbsp;                            : new ForOwnerType(annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading an owner type if it is accessible.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 */
&nbsp;                protected ForOwnerType(AnnotationReader annotationReader) {
&nbsp;                    super(annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    try {
&nbsp;                        AnnotatedElement annotatedOwnerType = (AnnotatedElement) GET_ANNOTATED_OWNER_TYPE.invoke(annotatedElement, NO_ARGUMENTS);
&nbsp;                        return annotatedOwnerType == null
&nbsp;                                ? NoOp.INSTANCE
&nbsp;                                : annotatedOwnerType;
&nbsp;                    } catch (ClassCastException ignored) { // To avoid bug on early releases of Java 8.
&nbsp;                        return NoOp.INSTANCE;
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot access java.lang.reflect.AnnotatedType#getAnnotatedOwnerType&quot;, exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(&quot;Error invoking java.lang.reflect.AnnotatedType#getAnnotatedOwnerType&quot;, exception.getCause());
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a generic type description.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase extends ModifierReviewable.AbstractBase implements Generic {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public int getModifiers() {
<b class="fc">&nbsp;                return asErasure().getModifiers();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic asGenericType() {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic asRawType() {
<b class="fc">&nbsp;                return asErasure().asGenericType();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                return equals(Sort.describe(type));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * A raw type representation of a non-generic type. This raw type differs from a raw type in the Java programming language by
&nbsp;         * representing a minimal erasure compared to Java&#39;s full erasure. This means that generic types are preserved as long as they
&nbsp;         * do not involve a type variable. Nested type variables are erased on the deepest possible level.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * All fields, methods, interfaces and the super type that are returned from this instance represent appropriately erased types.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        abstract class OfNonGenericType extends AbstractBase {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public Sort getSort() {
<b class="fc">&nbsp;                return Sort.NON_GENERIC;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getSuperClass() {
<b class="fc">&nbsp;                TypeDescription erasure = asErasure();</b>
<b class="fc">&nbsp;                Generic superClass = erasure.getSuperClass();</b>
<b class="pc">&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                    return superClass;</b>
&nbsp;                }
<b class="fc">&nbsp;                return superClass == null</b>
&nbsp;                        ? Generic.UNDEFINED
&nbsp;                        : new Generic.LazyProjection.WithResolvedErasure(superClass, new Visitor.ForRawType(erasure), Empty.INSTANCE);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                TypeDescription erasure = asErasure();</b>
<b class="pc">&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                    return erasure.getInterfaces();</b>
&nbsp;                }
<b class="fc">&nbsp;                return new TypeList.Generic.ForDetachedTypes.WithResolvedErasure(erasure.getInterfaces(), new Visitor.ForRawType(erasure));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="nc">&nbsp;                TypeDescription erasure = asErasure();</b>
<b class="nc">&nbsp;                return new FieldList.TypeSubstituting(this, erasure.getDeclaredFields(), TypeDescription.AbstractBase.RAW_TYPES</b>
&nbsp;                        ? Visitor.NoOp.INSTANCE
&nbsp;                        : new Visitor.ForRawType(erasure));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                TypeDescription erasure = asErasure();</b>
<b class="pc">&nbsp;                return new MethodList.TypeSubstituting(this, erasure.getDeclaredMethods(), TypeDescription.AbstractBase.RAW_TYPES</b>
&nbsp;                        ? Visitor.NoOp.INSTANCE
&nbsp;                        : new Visitor.ForRawType(erasure));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getTypeArguments() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="fc">&nbsp;                return visitor.onNonGenericType(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getTypeName() {
<b class="nc">&nbsp;                return asErasure().getTypeName();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getUpperBounds() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply upper type bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getLowerBounds() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply lower type bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeVariableSource getTypeVariableSource() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply a type variable source: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getSymbol() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply a symbol: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                return asErasure().getStackSize();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getActualName() {
<b class="nc">&nbsp;                return asErasure().getActualName();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isArray() {
<b class="fc">&nbsp;                return asErasure().isArray();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isPrimitive() {
<b class="fc">&nbsp;                return asErasure().isPrimitive();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                return asErasure().represents(type);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="nc">&nbsp;                return new SuperClassIterator(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return asErasure().hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;, justification = &quot;Type check is performed by erasure implementation&quot;)
&nbsp;            public boolean equals(Object other) {
<b class="fc">&nbsp;                return this == other || asErasure().equals(other);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="nc">&nbsp;                return asErasure().toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a non-generic type for a loaded {@link Class}.
&nbsp;             */
&nbsp;            public static class ForLoadedType extends OfNonGenericType {
&nbsp;
&nbsp;                /**
&nbsp;                 * A cache of generic type descriptions for commonly used types to avoid unnecessary allocations.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;MS_MUTABLE_COLLECTION_PKGPROTECT&quot;, justification = &quot;This collection is not exposed.&quot;)
&nbsp;                private static final Map&lt;Class&lt;?&gt;, Generic&gt; TYPE_CACHE;
&nbsp;
&nbsp;                /*
&nbsp;                 * Initializes the type cache.
&nbsp;                 */
&nbsp;                static {
<b class="fc">&nbsp;                    TYPE_CACHE = new HashMap&lt;Class&lt;?&gt;, Generic&gt;();</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(TargetType.class, new ForLoadedType(TargetType.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Object.class, new ForLoadedType(Object.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(String.class, new ForLoadedType(String.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Boolean.class, new ForLoadedType(Boolean.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Byte.class, new ForLoadedType(Byte.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Short.class, new ForLoadedType(Short.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Character.class, new ForLoadedType(Character.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Integer.class, new ForLoadedType(Integer.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Long.class, new ForLoadedType(Long.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Float.class, new ForLoadedType(Float.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Double.class, new ForLoadedType(Double.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(void.class, new ForLoadedType(void.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(boolean.class, new ForLoadedType(boolean.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(byte.class, new ForLoadedType(byte.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(short.class, new ForLoadedType(short.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(char.class, new ForLoadedType(char.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(int.class, new ForLoadedType(int.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(long.class, new ForLoadedType(long.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(float.class, new ForLoadedType(float.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(double.class, new ForLoadedType(double.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * The type that this instance represents.
&nbsp;                 */
&nbsp;                private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation reader to query for the non-generic type&#39;s annotations.
&nbsp;                 */
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new description of a generic type of a loaded type. This constructor should not normally be used.
&nbsp;                 * Use {@link ForLoadedType#of(Class)} instead.
&nbsp;                 *
&nbsp;                 * @param type The represented type.
&nbsp;                 */
&nbsp;                public ForLoadedType(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                    this(type, AnnotationReader.NoOp.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * /**
&nbsp;                 * Creates a new description of a generic type of a loaded type.
&nbsp;                 *
&nbsp;                 * @param type             The represented type.
&nbsp;                 * @param annotationReader The annotation reader to query for the non-generic type&#39;s annotations.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForLoadedType(Class&lt;?&gt; type, AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                    this.type = type;</b>
<b class="fc">&nbsp;                    this.annotationReader = annotationReader;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a new immutable generic type description for a loaded type.
&nbsp;                 *
&nbsp;                 * @param type The type to be represented by this generic type description.
&nbsp;                 * @return The generic type description representing the given type.
&nbsp;                 */
&nbsp;                public static Generic of(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                    Generic typeDescription = TYPE_CACHE.get(type);</b>
<b class="fc">&nbsp;                    return typeDescription == null</b>
&nbsp;                            ? new ForLoadedType(type)
&nbsp;                            : typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return TypeDescription.ForLoadedType.of(type);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getOwnerType() {
<b class="nc">&nbsp;                    Class&lt;?&gt; declaringClass = this.type.getDeclaringClass();</b>
<b class="nc">&nbsp;                    return declaringClass == null</b>
&nbsp;                            ? Generic.UNDEFINED
<b class="nc">&nbsp;                            : new ForLoadedType(declaringClass, annotationReader.ofOuterClass());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getComponentType() {
<b class="fc">&nbsp;                    Class&lt;?&gt; componentType = type.getComponentType();</b>
<b class="pc">&nbsp;                    return componentType == null</b>
&nbsp;                            ? Generic.UNDEFINED
<b class="fc">&nbsp;                            : new ForLoadedType(componentType, annotationReader.ofComponentType());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationReader.asList();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean represents(java.lang.reflect.Type type) {
<b class="pc">&nbsp;                    return this.type == type || super.represents(type);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A type description for a type erasure. Compared to a {@link Latent} representation, this
&nbsp;             * representation does not allow for the specification of any complex properties but does
&nbsp;             * not require any form of navigation on the type.
&nbsp;             */
&nbsp;            public static class ForErasure extends OfNonGenericType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented type erasure.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new description of a non-generic type as an erasure.
&nbsp;                 *
&nbsp;                 * @param typeDescription The represented type erasure.
&nbsp;                 */
<b class="fc">&nbsp;                public ForErasure(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getOwnerType() {
<b class="nc">&nbsp;                    TypeDescription declaringType = typeDescription.getDeclaringType();</b>
<b class="nc">&nbsp;                    return declaringType == null</b>
&nbsp;                            ? Generic.UNDEFINED
<b class="nc">&nbsp;                            : declaringType.asGenericType();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getComponentType() {
<b class="fc">&nbsp;                    TypeDescription componentType = typeDescription.getComponentType();</b>
<b class="pc">&nbsp;                    return componentType == null</b>
&nbsp;                            ? Generic.UNDEFINED
<b class="fc">&nbsp;                            : componentType.asGenericType();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A latent description of a non-generic type.
&nbsp;             */
&nbsp;            public static class Latent extends OfNonGenericType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The non-generic type&#39;s raw type.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The non-generic type&#39;s declaring type.
&nbsp;                 */
&nbsp;                private final TypeDescription.Generic declaringType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a non-generic type with an implicit owner type.
&nbsp;                 *
&nbsp;                 * @param typeDescription  The non-generic type&#39;s raw type.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                public Latent(TypeDescription typeDescription, AnnotationSource annotationSource) {
&nbsp;                    this(typeDescription, typeDescription.getDeclaringType(), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a non-generic type with a raw owner type.
&nbsp;                 *
&nbsp;                 * @param typeDescription  The non-generic type&#39;s raw type.
&nbsp;                 * @param declaringType    The non-generic type&#39;s declaring type.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private Latent(TypeDescription typeDescription, TypeDescription declaringType, AnnotationSource annotationSource) {
&nbsp;                    this(typeDescription,
&nbsp;                            declaringType == null
&nbsp;                                    ? Generic.UNDEFINED
&nbsp;                                    : declaringType.asGenericType(),
&nbsp;                            annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a non-generic type.
&nbsp;                 *
&nbsp;                 * @param typeDescription  The non-generic type&#39;s raw type.
&nbsp;                 * @param declaringType    The non-generic type&#39;s declaring type.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                protected Latent(TypeDescription typeDescription, Generic declaringType, AnnotationSource annotationSource) {
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                    this.declaringType = declaringType;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getOwnerType() {
&nbsp;                    return declaringType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getComponentType() {
&nbsp;                    TypeDescription componentType = typeDescription.getComponentType();
&nbsp;                    return componentType == null
&nbsp;                            ? Generic.UNDEFINED
&nbsp;                            : componentType.asGenericType();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return typeDescription;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A representation of a raw type that preserves its generic super types&#39; generic information with a minimum
&nbsp;             * but erases all of their members&#39; types.
&nbsp;             */
&nbsp;            public static class ForReifiedErasure extends OfNonGenericType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented type erasure.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new reified non-generic type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The represented type erasure.
&nbsp;                 */
&nbsp;                protected ForReifiedErasure(TypeDescription typeDescription) {
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new generic type representation for an erasure where any generified type is reified.
&nbsp;                 *
&nbsp;                 * @param typeDescription The erasure to represent.
&nbsp;                 * @return An appropriate generic type representation where any generified type is reified.
&nbsp;                 */
&nbsp;                protected static Generic of(TypeDescription typeDescription) {
&nbsp;                    return typeDescription.isGenerified()
&nbsp;                            ? new ForReifiedErasure(typeDescription)
&nbsp;                            : new ForErasure(typeDescription);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getSuperClass() {
&nbsp;                    Generic superClass = typeDescription.getSuperClass();
&nbsp;                    return superClass == null
&nbsp;                            ? Generic.UNDEFINED
&nbsp;                            : new LazyProjection.WithResolvedErasure(superClass, Visitor.Reifying.INHERITING);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    return new TypeList.Generic.ForDetachedTypes.WithResolvedErasure(typeDescription.getInterfaces(), Visitor.Reifying.INHERITING);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                    return new FieldList.TypeSubstituting(this, typeDescription.getDeclaredFields(), Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                    return new MethodList.TypeSubstituting(this, typeDescription.getDeclaredMethods(), Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getOwnerType() {
&nbsp;                    TypeDescription declaringType = typeDescription.getDeclaringType();
&nbsp;                    return declaringType == null
&nbsp;                            ? Generic.UNDEFINED
&nbsp;                            : of(declaringType);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getComponentType() {
&nbsp;                    TypeDescription componentType = typeDescription.getComponentType();
&nbsp;                    return componentType == null
&nbsp;                            ? Generic.UNDEFINED
&nbsp;                            : of(componentType);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A base implementation of a generic type description that represents a potentially generic array. Instances represent a non-generic type
&nbsp;         * if the given component type is non-generic.
&nbsp;         */
<b class="fc">&nbsp;        abstract class OfGenericArray extends AbstractBase {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public Sort getSort() {
<b class="pc">&nbsp;                return getComponentType().getSort().isNonGeneric()</b>
&nbsp;                        ? Sort.NON_GENERIC
&nbsp;                        : Sort.GENERIC_ARRAY;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription asErasure() {
<b class="fc">&nbsp;                return ArrayProjection.of(getComponentType().asErasure(), 1);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getSuperClass() {
<b class="nc">&nbsp;                return TypeDescription.Generic.OBJECT;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getInterfaces() {
<b class="nc">&nbsp;                return ARRAY_INTERFACES;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="nc">&nbsp;                return new FieldList.Empty&lt;FieldDescription.InGenericShape&gt;();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="nc">&nbsp;                return new MethodList.Empty&lt;MethodDescription.InGenericShape&gt;();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getUpperBounds() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply upper type bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getLowerBounds() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply lower type bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeVariableSource getTypeVariableSource() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply a type variable source: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getTypeArguments() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getOwnerType() {
<b class="nc">&nbsp;                return Generic.UNDEFINED;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getSymbol() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply a symbol: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getTypeName() {
<b class="nc">&nbsp;                return getSort().isNonGeneric()</b>
<b class="nc">&nbsp;                        ? asErasure().getTypeName()</b>
<b class="nc">&nbsp;                        : toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getActualName() {
<b class="nc">&nbsp;                return getSort().isNonGeneric()</b>
<b class="nc">&nbsp;                        ? asErasure().getActualName()</b>
<b class="nc">&nbsp;                        : toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isArray() {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isPrimitive() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="nc">&nbsp;                return new SuperClassIterator(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="pc">&nbsp;                return getSort().isNonGeneric()</b>
<b class="fc">&nbsp;                        ? visitor.onNonGenericType(this)</b>
<b class="nc">&nbsp;                        : visitor.onGenericArray(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                return StackSize.SINGLE;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;, justification = &quot;Type check is performed by erasure implementation&quot;)
&nbsp;            public boolean equals(Object other) {
<b class="pc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="pc">&nbsp;                } else if (getSort().isNonGeneric()) {</b>
<b class="fc">&nbsp;                    return asErasure().equals(other);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!(other instanceof Generic)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                Generic typeDescription = (Generic) other;</b>
<b class="nc">&nbsp;                return typeDescription.getSort().isGenericArray() &amp;&amp; getComponentType().equals(typeDescription.getComponentType());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
<b class="nc">&nbsp;                return getSort().isNonGeneric()</b>
<b class="nc">&nbsp;                        ? asErasure().hashCode()</b>
<b class="nc">&nbsp;                        : getComponentType().hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="nc">&nbsp;                return getSort().isNonGeneric()</b>
<b class="nc">&nbsp;                        ? asErasure().toString()</b>
<b class="nc">&nbsp;                        : getComponentType().getTypeName() + &quot;[]&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A description of a loaded generic array type.
&nbsp;             */
&nbsp;            public static class ForLoadedType extends OfGenericArray {
&nbsp;
&nbsp;                /**
&nbsp;                 * The loaded generic array type.
&nbsp;                 */
&nbsp;                private final GenericArrayType genericArrayType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation reader to query for the generic array type&#39;s annotations.
&nbsp;                 */
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a type description of the given generic array type.
&nbsp;                 *
&nbsp;                 * @param genericArrayType The loaded generic array type.
&nbsp;                 */
&nbsp;                public ForLoadedType(GenericArrayType genericArrayType) {
&nbsp;                    this(genericArrayType, AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a type description of the given generic array type.
&nbsp;                 *
&nbsp;                 * @param genericArrayType The loaded generic array type.
&nbsp;                 * @param annotationReader The annotation reader to query for the generic array type&#39;s annotations.
&nbsp;                 */
&nbsp;                protected ForLoadedType(GenericArrayType genericArrayType, AnnotationReader annotationReader) {
&nbsp;                    this.genericArrayType = genericArrayType;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getComponentType() {
&nbsp;                    return Sort.describe(genericArrayType.getGenericComponentType(), annotationReader.ofComponentType());
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return annotationReader.asList();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean represents(java.lang.reflect.Type type) {
&nbsp;                    return genericArrayType == type || super.represents(type);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A latent implementation of a generic array type.
&nbsp;             */
&nbsp;            public static class Latent extends OfGenericArray {
&nbsp;
&nbsp;                /**
&nbsp;                 * The component type of the generic array.
&nbsp;                 */
&nbsp;                private final Generic componentType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a latent representation of a generic array type.
&nbsp;                 *
&nbsp;                 * @param componentType    The component type.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
<b class="fc">&nbsp;                public Latent(Generic componentType, AnnotationSource annotationSource) {</b>
<b class="fc">&nbsp;                    this.componentType = componentType;</b>
<b class="fc">&nbsp;                    this.annotationSource = annotationSource;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getComponentType() {
<b class="fc">&nbsp;                    return componentType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationSource.getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A base implementation of a generic type description that represents a wildcard type.
&nbsp;         */
&nbsp;        abstract class OfWildcardType extends AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The source code representation of a wildcard.
&nbsp;             */
&nbsp;            public static final String SYMBOL = &quot;?&quot;;
&nbsp;
&nbsp;            @Override
&nbsp;            public Sort getSort() {
&nbsp;                return Sort.WILDCARD;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription asErasure() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not represent an erasable type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getSuperClass() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a super type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply an interface type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply field definitions: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply method definitions: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getComponentType() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a component type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeVariableSource getTypeVariableSource() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a type variable source: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getTypeArguments() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getOwnerType() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply an owner type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getSymbol() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a symbol: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getTypeName() {
&nbsp;                return toString();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getActualName() {
&nbsp;                return toString();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isPrimitive() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isArray() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(java.lang.reflect.Type type) {
&nbsp;                return equals(Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a super type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return visitor.onWildcard(this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackSize getStackSize() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply an operand stack size: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
&nbsp;                int lowerHash = 1, upperHash = 1;
&nbsp;                for (Generic lowerBound : getLowerBounds()) {
&nbsp;                    lowerHash = 31 * lowerHash + lowerBound.hashCode();
&nbsp;                }
&nbsp;                for (Generic upperBound : getUpperBounds()) {
&nbsp;                    upperHash = 31 * upperHash + upperBound.hashCode();
&nbsp;                }
&nbsp;                return lowerHash ^ upperHash;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof Generic)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;                Generic typeDescription = (Generic) other;
&nbsp;                return typeDescription.getSort().isWildcard()
&nbsp;                        &amp;&amp; getUpperBounds().equals(typeDescription.getUpperBounds())
&nbsp;                        &amp;&amp; getLowerBounds().equals(typeDescription.getLowerBounds());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
&nbsp;                StringBuilder stringBuilder = new StringBuilder(SYMBOL);
&nbsp;                TypeList.Generic bounds = getLowerBounds();
&nbsp;                if (!bounds.isEmpty()) {
&nbsp;                    stringBuilder.append(&quot; super &quot;);
&nbsp;                } else {
&nbsp;                    bounds = getUpperBounds();
&nbsp;                    if (bounds.getOnly().equals(TypeDescription.Generic.OBJECT)) {
&nbsp;                        return SYMBOL;
&nbsp;                    }
&nbsp;                    stringBuilder.append(&quot; extends &quot;);
&nbsp;                }
&nbsp;                return stringBuilder.append(bounds.getOnly().getTypeName()).toString();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Description of a loaded wildcard.
&nbsp;             */
&nbsp;            public static class ForLoadedType extends OfWildcardType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented loaded wildcard type.
&nbsp;                 */
&nbsp;                private final WildcardType wildcardType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation reader to query for the wildcard type&#39;s annotations.
&nbsp;                 */
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of a loaded wildcard.
&nbsp;                 *
&nbsp;                 * @param wildcardType The represented loaded wildcard type.
&nbsp;                 */
&nbsp;                public ForLoadedType(WildcardType wildcardType) {
&nbsp;                    this(wildcardType, AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of a loaded wildcard.
&nbsp;                 *
&nbsp;                 * @param wildcardType     The represented loaded wildcard type.
&nbsp;                 * @param annotationReader The annotation reader to query for the wildcard type&#39;s annotations.
&nbsp;                 */
&nbsp;                protected ForLoadedType(WildcardType wildcardType, AnnotationReader annotationReader) {
&nbsp;                    this.wildcardType = wildcardType;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    return new WildcardUpperBoundTypeList(wildcardType.getUpperBounds(), annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getLowerBounds() {
&nbsp;                    return new WildcardLowerBoundTypeList(wildcardType.getLowerBounds(), annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return annotationReader.asList();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean represents(java.lang.reflect.Type type) {
&nbsp;                    return wildcardType == type || super.represents(type);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A type list representing an upper-bound type variable&#39;s bound types.
&nbsp;                 */
&nbsp;                protected static class WildcardUpperBoundTypeList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented upper bounds.
&nbsp;                     */
&nbsp;                    private final java.lang.reflect.Type[] upperBound;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation reader to query for type annotations.
&nbsp;                     */
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a type list for a wildcard type&#39;s upper bounds.
&nbsp;                     *
&nbsp;                     * @param upperBound       The represented upper bounds.
&nbsp;                     * @param annotationReader The annotation reader to query for type annotations.
&nbsp;                     */
&nbsp;                    protected WildcardUpperBoundTypeList(java.lang.reflect.Type[] upperBound, AnnotationReader annotationReader) {
&nbsp;                        this.upperBound = upperBound;
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic get(int index) {
&nbsp;                        return Sort.describe(upperBound[index], annotationReader.ofWildcardUpperBoundType(index));
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int size() {
&nbsp;                        return upperBound.length;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A type list representing an upper-bound type variable&#39;s bound types.
&nbsp;                 */
&nbsp;                protected static class WildcardLowerBoundTypeList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented lower bounds.
&nbsp;                     */
&nbsp;                    private final java.lang.reflect.Type[] lowerBound;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation reader to query for type annotations.
&nbsp;                     */
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a type list for a wildcard type&#39;s lower bounds.
&nbsp;                     *
&nbsp;                     * @param lowerBound       The represented lower bounds.
&nbsp;                     * @param annotationReader The annotation reader to query for type annotations.
&nbsp;                     */
&nbsp;                    protected WildcardLowerBoundTypeList(java.lang.reflect.Type[] lowerBound, AnnotationReader annotationReader) {
&nbsp;                        this.lowerBound = lowerBound;
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic get(int index) {
&nbsp;                        return Sort.describe(lowerBound[index], annotationReader.ofWildcardLowerBoundType(index));
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int size() {
&nbsp;                        return lowerBound.length;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A latent description of a wildcard type.
&nbsp;             */
&nbsp;            public static class Latent extends OfWildcardType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The wildcard&#39;s upper bounds.
&nbsp;                 */
&nbsp;                private final List&lt;? extends Generic&gt; upperBounds;
&nbsp;
&nbsp;                /**
&nbsp;                 * The wildcard&#39;s lower bounds.
&nbsp;                 */
&nbsp;                private final List&lt;? extends Generic&gt; lowerBounds;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of a latent wildcard.
&nbsp;                 *
&nbsp;                 * @param upperBounds      The wildcard&#39;s upper bounds.
&nbsp;                 * @param lowerBounds      The wildcard&#39;s lower bounds.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                protected Latent(List&lt;? extends Generic&gt; upperBounds, List&lt;? extends Generic&gt; lowerBounds, AnnotationSource annotationSource) {
&nbsp;                    this.upperBounds = upperBounds;
&nbsp;                    this.lowerBounds = lowerBounds;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an unbounded wildcard. Such a wildcard is implicitly bound above by the {@link Object} type.
&nbsp;                 *
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 * @return A description of an unbounded wildcard.
&nbsp;                 */
&nbsp;                public static Generic unbounded(AnnotationSource annotationSource) {
&nbsp;                    return new Latent(Collections.singletonList(TypeDescription.Generic.OBJECT), Collections.&lt;Generic&gt;emptyList(), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a wildcard with an upper bound.
&nbsp;                 *
&nbsp;                 * @param upperBound       The upper bound of the wildcard.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 * @return A wildcard with the given upper bound.
&nbsp;                 */
&nbsp;                public static Generic boundedAbove(Generic upperBound, AnnotationSource annotationSource) {
&nbsp;                    return new Latent(Collections.singletonList(upperBound), Collections.&lt;Generic&gt;emptyList(), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a wildcard with a lower bound. Such a wildcard is implicitly bounded above by the {@link Object} type.
&nbsp;                 *
&nbsp;                 * @param lowerBound       The lower bound of the wildcard.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 * @return A wildcard with the given lower bound.
&nbsp;                 */
&nbsp;                public static Generic boundedBelow(Generic lowerBound, AnnotationSource annotationSource) {
&nbsp;                    return new Latent(Collections.singletonList(TypeDescription.Generic.OBJECT), Collections.singletonList(lowerBound), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    return new TypeList.Generic.Explicit(upperBounds);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getLowerBounds() {
&nbsp;                    return new TypeList.Generic.Explicit(lowerBounds);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A base implementation of a generic type description that represents a parameterized type.
&nbsp;         */
<b class="fc">&nbsp;        abstract class OfParameterizedType extends AbstractBase {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public Sort getSort() {
<b class="fc">&nbsp;                return Sort.PARAMETERIZED;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getSuperClass() {
<b class="nc">&nbsp;                Generic superClass = asErasure().getSuperClass();</b>
<b class="nc">&nbsp;                return superClass == null</b>
&nbsp;                        ? Generic.UNDEFINED
&nbsp;                        : new LazyProjection.WithResolvedErasure(superClass, new Visitor.Substitutor.ForTypeVariableBinding(this));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getInterfaces() {
<b class="nc">&nbsp;                return new TypeList.Generic.ForDetachedTypes.WithResolvedErasure(asErasure().getInterfaces(), new Visitor.Substitutor.ForTypeVariableBinding(this));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="nc">&nbsp;                return new FieldList.TypeSubstituting(this, asErasure().getDeclaredFields(), new Visitor.Substitutor.ForTypeVariableBinding(this));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="nc">&nbsp;                return new MethodList.TypeSubstituting(this, asErasure().getDeclaredMethods(), new Visitor.Substitutor.ForTypeVariableBinding(this));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
<b class="nc">&nbsp;                Generic typeDescription = this;</b>
&nbsp;                do {
<b class="nc">&nbsp;                    TypeList.Generic typeArguments = typeDescription.getTypeArguments(), typeVariables = typeDescription.asErasure().getTypeVariables();</b>
<b class="nc">&nbsp;                    for (int index = 0; index &lt; Math.min(typeArguments.size(), typeVariables.size()); index++) {</b>
<b class="nc">&nbsp;                        if (typeVariable.equals(typeVariables.get(index))) {</b>
<b class="nc">&nbsp;                            return typeArguments.get(index);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    typeDescription = typeDescription.getOwnerType();</b>
<b class="nc">&nbsp;                } while (typeDescription != null &amp;&amp; typeDescription.getSort().isParameterized());</b>
<b class="nc">&nbsp;                return Generic.UNDEFINED;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getUpperBounds() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply upper bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getLowerBounds() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply lower bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getComponentType() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply a component type: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeVariableSource getTypeVariableSource() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply a type variable source: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getSymbol() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply a symbol: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getTypeName() {
<b class="nc">&nbsp;                return toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getActualName() {
<b class="nc">&nbsp;                return toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isPrimitive() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isArray() {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                return equals(Sort.describe(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="nc">&nbsp;                return new SuperClassIterator(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="fc">&nbsp;                return visitor.onParameterizedType(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                return StackSize.SINGLE;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
<b class="nc">&nbsp;                int result = 1;</b>
<b class="nc">&nbsp;                for (Generic typeArgument : getTypeArguments()) {</b>
<b class="nc">&nbsp;                    result = 31 * result + typeArgument.hashCode();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                Generic ownerType = getOwnerType();</b>
<b class="nc">&nbsp;                return result ^ (ownerType == null</b>
<b class="nc">&nbsp;                        ? asErasure().hashCode()</b>
<b class="nc">&nbsp;                        : ownerType.hashCode());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
<b class="pc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="pc">&nbsp;                } else if (!(other instanceof Generic)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                Generic typeDescription = (Generic) other;</b>
<b class="pc">&nbsp;                if (!typeDescription.getSort().isParameterized()) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                Generic ownerType = getOwnerType(), otherOwnerType = typeDescription.getOwnerType();</b>
<b class="nc">&nbsp;                return asErasure().equals(typeDescription.asErasure())</b>
<b class="nc">&nbsp;                        &amp;&amp; !(ownerType == null &amp;&amp; otherOwnerType != null) &amp;&amp; !(ownerType != null &amp;&amp; !ownerType.equals(otherOwnerType))</b>
<b class="nc">&nbsp;                        &amp;&amp; getTypeArguments().equals(typeDescription.getTypeArguments());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="nc">&nbsp;                StringBuilder stringBuilder = new StringBuilder();</b>
<b class="nc">&nbsp;                RenderingDelegate.CURRENT.apply(stringBuilder, asErasure(), getOwnerType());</b>
<b class="nc">&nbsp;                TypeList.Generic typeArguments = getTypeArguments();</b>
<b class="nc">&nbsp;                if (!typeArguments.isEmpty()) {</b>
<b class="nc">&nbsp;                    stringBuilder.append(&#39;&lt;&#39;);</b>
<b class="nc">&nbsp;                    boolean multiple = false;</b>
<b class="nc">&nbsp;                    for (Generic typeArgument : typeArguments) {</b>
<b class="nc">&nbsp;                        if (multiple) {</b>
<b class="nc">&nbsp;                            stringBuilder.append(&quot;, &quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        stringBuilder.append(typeArgument.getTypeName());</b>
<b class="nc">&nbsp;                        multiple = true;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    stringBuilder.append(&#39;&gt;&#39;);</b>
&nbsp;                }
<b class="nc">&nbsp;                return stringBuilder.toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A rendering delegate for resolving a parameterized type&#39;s {@link Object#toString()} representation.
&nbsp;             */
&nbsp;            protected enum RenderingDelegate {
&nbsp;
&nbsp;                /**
&nbsp;                 * A rendering delegate for any VM prior to Java 9 where types are concatenated using a {@code .} character
&nbsp;                 * and where the fully qualified names are appended to non-parameterized types.
&nbsp;                 */
&nbsp;                FOR_LEGACY_VM {
&nbsp;                    @Override
&nbsp;                    protected void apply(StringBuilder stringBuilder, TypeDescription erasure, Generic ownerType) {
&nbsp;                        if (ownerType != null) {
&nbsp;                            stringBuilder.append(ownerType.getTypeName()).append(&#39;.&#39;).append(ownerType.getSort().isParameterized()
&nbsp;                                    ? erasure.getSimpleName()
&nbsp;                                    : erasure.getName());
&nbsp;                        } else {
&nbsp;                            stringBuilder.append(erasure.getName());
&nbsp;                        }
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A rendering delegate for any VM supporting Java 8 or newer where a type&#39;s simple name is appended.
&nbsp;                 */
&nbsp;                FOR_JAVA_8_CAPABLE_VM {
&nbsp;                    @Override
&nbsp;                    protected void apply(StringBuilder stringBuilder, TypeDescription erasure, Generic ownerType) {
&nbsp;                        if (ownerType != null) {
&nbsp;                            stringBuilder.append(ownerType.getTypeName()).append(&#39;$&#39;);
&nbsp;                            if (ownerType.getSort().isParameterized()) {
&nbsp;                                stringBuilder.append(erasure.getName().replace(ownerType.asErasure().getName() + &quot;$&quot;, &quot;&quot;));
&nbsp;                            } else {
&nbsp;                                stringBuilder.append(erasure.getSimpleName());
&nbsp;                            }
&nbsp;                        } else {
&nbsp;                            stringBuilder.append(erasure.getName());
&nbsp;                        }
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * A rendering delegate for the current VM.
&nbsp;                 */
&nbsp;                protected static final RenderingDelegate CURRENT = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V6).isAtLeast(ClassFileVersion.JAVA_V8)
&nbsp;                        ? RenderingDelegate.FOR_JAVA_8_CAPABLE_VM
&nbsp;                        : RenderingDelegate.FOR_LEGACY_VM;
&nbsp;
&nbsp;                /**
&nbsp;                 * Applies this rendering delegate.
&nbsp;                 *
&nbsp;                 * @param stringBuilder The string builder which is used for creating a parameterized type&#39;s string representation.
&nbsp;                 * @param erasure       The rendered type&#39;s erasure.
&nbsp;                 * @param ownerType     The rendered type&#39;s owner type.
&nbsp;                 */
&nbsp;                protected abstract void apply(StringBuilder stringBuilder, TypeDescription erasure, Generic ownerType);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Description of a loaded parameterized type.
&nbsp;             */
&nbsp;            public static class ForLoadedType extends OfParameterizedType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented parameterized type.
&nbsp;                 */
&nbsp;                private final ParameterizedType parameterizedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation reader to query for the parameterized type&#39;s annotations.
&nbsp;                 */
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of the loaded parameterized type.
&nbsp;                 *
&nbsp;                 * @param parameterizedType The represented parameterized type.
&nbsp;                 */
&nbsp;                public ForLoadedType(ParameterizedType parameterizedType) {
<b class="nc">&nbsp;                    this(parameterizedType, AnnotationReader.NoOp.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of the loaded parameterized type.
&nbsp;                 *
&nbsp;                 * @param parameterizedType The represented parameterized type.
&nbsp;                 * @param annotationReader  The annotation reader to query for the parameterized type&#39;s annotations.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForLoadedType(ParameterizedType parameterizedType, AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                    this.parameterizedType = parameterizedType;</b>
<b class="fc">&nbsp;                    this.annotationReader = annotationReader;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                    return new ParameterArgumentTypeList(parameterizedType.getActualTypeArguments(), annotationReader);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getOwnerType() {
<b class="fc">&nbsp;                    java.lang.reflect.Type ownerType = parameterizedType.getOwnerType();</b>
<b class="pc">&nbsp;                    return ownerType == null</b>
&nbsp;                            ? Generic.UNDEFINED
<b class="nc">&nbsp;                            : Sort.describe(ownerType, annotationReader.ofOwnerType());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return TypeDescription.ForLoadedType.of((Class&lt;?&gt;) parameterizedType.getRawType());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationReader.asList();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean represents(java.lang.reflect.Type type) {
<b class="pc">&nbsp;                    return parameterizedType == type || super.represents(type);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A type list that represents a loaded parameterized type&#39;s parameter types.
&nbsp;                 */
&nbsp;                protected static class ParameterArgumentTypeList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented argument types.
&nbsp;                     */
&nbsp;                    private final java.lang.reflect.Type[] argumentType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation reader to query for type annotations.
&nbsp;                     */
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a list representing a parameterized type&#39;s type arguments.
&nbsp;                     *
&nbsp;                     * @param argumentType     The represented argument types.
&nbsp;                     * @param annotationReader The annotation reader to query for type annotations.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ParameterArgumentTypeList(java.lang.reflect.Type[] argumentType, AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                        this.argumentType = argumentType;</b>
<b class="fc">&nbsp;                        this.annotationReader = annotationReader;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic get(int index) {
&nbsp;                        // Obfuscators sometimes render parameterized type arguments as null values.
<b class="fc">&nbsp;                        return Sort.describe(argumentType[index], annotationReader.ofTypeArgument(index));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int size() {
<b class="fc">&nbsp;                        return argumentType.length;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A latent description of a parameterized type.
&nbsp;             */
&nbsp;            public static class Latent extends OfParameterizedType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The raw type of the described parameterized type.
&nbsp;                 */
&nbsp;                private final TypeDescription rawType;
&nbsp;
&nbsp;                /**
&nbsp;                 * This parameterized type&#39;s owner type or {@code null} if no owner type exists.
&nbsp;                 */
&nbsp;                private final Generic ownerType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameters of this parameterized type.
&nbsp;                 */
&nbsp;                private final List&lt;? extends Generic&gt; parameters;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of a latent parameterized type.
&nbsp;                 *
&nbsp;                 * @param rawType          The raw type of the described parameterized type.
&nbsp;                 * @param ownerType        This parameterized type&#39;s owner type or {@code null} if no owner type exists.
&nbsp;                 * @param parameters       The parameters of this parameterized type.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                public Latent(TypeDescription rawType,
&nbsp;                              Generic ownerType,
&nbsp;                              List&lt;? extends Generic&gt; parameters,
<b class="fc">&nbsp;                              AnnotationSource annotationSource) {</b>
<b class="fc">&nbsp;                    this.rawType = rawType;</b>
<b class="fc">&nbsp;                    this.ownerType = ownerType;</b>
<b class="fc">&nbsp;                    this.parameters = parameters;</b>
<b class="fc">&nbsp;                    this.annotationSource = annotationSource;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return rawType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getOwnerType() {
<b class="fc">&nbsp;                    return ownerType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                    return new TypeList.Generic.Explicit(parameters);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationSource.getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A representation of a parameterized type that is a super type of a raw type but preserves the minimal type information
&nbsp;             * that is required for allowing creating correct erasures for overridden methods. All members&#39; types are erased and all
&nbsp;             * type arguments are reduced to their erasure.
&nbsp;             */
&nbsp;            public static class ForReifiedType extends OfParameterizedType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented parameterized type.
&nbsp;                 */
&nbsp;                private final Generic parameterizedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new reified parameterized type.
&nbsp;                 *
&nbsp;                 * @param parameterizedType The represented parameterized type.
&nbsp;                 */
&nbsp;                protected ForReifiedType(Generic parameterizedType) {
&nbsp;                    this.parameterizedType = parameterizedType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getSuperClass() {
&nbsp;                    Generic superClass = super.getSuperClass();
&nbsp;                    return superClass == null
&nbsp;                            ? Generic.UNDEFINED
&nbsp;                            : new LazyProjection.WithResolvedErasure(superClass, Visitor.Reifying.INHERITING);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    return new TypeList.Generic.ForDetachedTypes.WithResolvedErasure(super.getInterfaces(), Visitor.Reifying.INHERITING);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                    return new FieldList.TypeSubstituting(this, super.getDeclaredFields(), Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                    return new MethodList.TypeSubstituting(this, super.getDeclaredMethods(), Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getTypeArguments() {
&nbsp;                    return new TypeList.Generic.ForDetachedTypes(parameterizedType.getTypeArguments(), Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getOwnerType() {
&nbsp;                    Generic ownerType = parameterizedType.getOwnerType();
&nbsp;                    return ownerType == null
&nbsp;                            ? Generic.UNDEFINED
&nbsp;                            : ownerType.accept(Visitor.Reifying.INHERITING);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return parameterizedType.asErasure();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents an erasure as a generic type where all type variables are representing their own arguments.
&nbsp;             */
&nbsp;            public static class ForGenerifiedErasure extends OfParameterizedType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented erasure.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new generified erasure.
&nbsp;                 *
&nbsp;                 * @param typeDescription The represented erasure.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForGenerifiedErasure(TypeDescription typeDescription) {</b>
<b class="nc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents the supplied type description as a generified erasure if it is generified or as a non-generic type if not so.
&nbsp;                 *
&nbsp;                 * @param typeDescription The represented erasure.
&nbsp;                 * @return An appropriate generic type.
&nbsp;                 */
&nbsp;                public static Generic of(TypeDescription typeDescription) {
<b class="pc">&nbsp;                    return typeDescription.isGenerified()</b>
&nbsp;                            ? new ForGenerifiedErasure(typeDescription)
&nbsp;                            : new OfNonGenericType.ForErasure(typeDescription);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
<b class="nc">&nbsp;                    return typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getTypeArguments() {
<b class="nc">&nbsp;                    return new TypeList.Generic.ForDetachedTypes(typeDescription.getTypeVariables(), Visitor.AnnotationStripper.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getOwnerType() {
<b class="nc">&nbsp;                    TypeDescription declaringType = typeDescription.getDeclaringType();</b>
<b class="nc">&nbsp;                    return declaringType == null</b>
&nbsp;                            ? Generic.UNDEFINED
<b class="nc">&nbsp;                            : of(declaringType);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A base implementation of a generic type description that represents a type variable.
&nbsp;         */
&nbsp;        abstract class OfTypeVariable extends AbstractBase {
&nbsp;
&nbsp;            @Override
&nbsp;            public Sort getSort() {
&nbsp;                return Sort.VARIABLE;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription asErasure() {
&nbsp;                TypeList.Generic upperBounds = getUpperBounds();
&nbsp;                return upperBounds.isEmpty()
&nbsp;                        ? TypeDescription.OBJECT
&nbsp;                        : upperBounds.get(0).asErasure();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getSuperClass() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply a super type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply an interface type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply field definitions: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply method definitions: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getComponentType() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply a component type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getTypeArguments() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getLowerBounds() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply lower bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getOwnerType() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply an owner type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getTypeName() {
&nbsp;                return toString();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getActualName() {
&nbsp;                return getSymbol();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return visitor.onTypeVariable(this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackSize getStackSize() {
&nbsp;                return StackSize.SINGLE;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isArray() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isPrimitive() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(java.lang.reflect.Type type) {
&nbsp;                return equals(Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply a super type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
&nbsp;                return getTypeVariableSource().hashCode() ^ getSymbol().hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof Generic)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;                Generic typeDescription = (Generic) other;
&nbsp;                return typeDescription.getSort().isTypeVariable()
&nbsp;                        &amp;&amp; getSymbol().equals(typeDescription.getSymbol())
&nbsp;                        &amp;&amp; getTypeVariableSource().equals(typeDescription.getTypeVariableSource());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
&nbsp;                return getSymbol();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Implementation of a symbolic type variable.
&nbsp;             */
&nbsp;            public static class Symbolic extends Generic.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The symbol of the symbolic type variable.
&nbsp;                 */
&nbsp;                private final String symbol;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a symbolic type variable.
&nbsp;                 *
&nbsp;                 * @param symbol           The symbol of the symbolic type variable.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                public Symbolic(String symbol, AnnotationSource annotationSource) {
&nbsp;                    this.symbol = symbol;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Sort getSort() {
&nbsp;                    return Sort.VARIABLE_SYMBOLIC;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getSymbol() {
&nbsp;                    return symbol;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an erasure: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an upper type bound: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeVariableSource getTypeVariableSource() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a variable source: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getSuperClass() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a super type definition: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an interface type definition: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply field definitions: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply method definitions: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getComponentType() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a component type: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getTypeArguments() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply type arguments: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic findBindingOf(Generic typeVariable) {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply type arguments: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getLowerBounds() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply lower bounds: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getOwnerType() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an owner type: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getTypeName() {
&nbsp;                    return toString();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getActualName() {
&nbsp;                    return getSymbol();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                    return visitor.onTypeVariable(this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public StackSize getStackSize() {
&nbsp;                    return StackSize.SINGLE;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isArray() {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isPrimitive() {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean represents(java.lang.reflect.Type type) {
&nbsp;                    if (type == null) {
&nbsp;                        throw new NullPointerException();
&nbsp;                    }
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a super type definition: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int hashCode() {
&nbsp;                    return symbol.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean equals(Object other) {
&nbsp;                    if (this == other) {
&nbsp;                        return true;
&nbsp;                    } else if (!(other instanceof Generic)) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                    Generic typeDescription = (Generic) other;
&nbsp;                    return typeDescription.getSort().isTypeVariable() &amp;&amp; getSymbol().equals(typeDescription.getSymbol());
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String toString() {
&nbsp;                    return getSymbol();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Description of a loaded type variable.
&nbsp;             */
&nbsp;            public static class ForLoadedType extends OfTypeVariable {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented type variable.
&nbsp;                 */
&nbsp;                private final TypeVariable&lt;?&gt; typeVariable;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation reader to query for the variable&#39;s annotations.
&nbsp;                 */
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of a loaded type variable.
&nbsp;                 *
&nbsp;                 * @param typeVariable The represented type variable.
&nbsp;                 */
&nbsp;                public ForLoadedType(TypeVariable&lt;?&gt; typeVariable) {
&nbsp;                    this(typeVariable, AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of a loaded type variable with an annotation.
&nbsp;                 *
&nbsp;                 * @param typeVariable     The represented type variable.
&nbsp;                 * @param annotationReader The annotation reader to query for the variable&#39;s annotations.
&nbsp;                 */
&nbsp;                protected ForLoadedType(TypeVariable&lt;?&gt; typeVariable, AnnotationReader annotationReader) {
&nbsp;                    this.typeVariable = typeVariable;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeVariableSource getTypeVariableSource() {
&nbsp;                    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
&nbsp;                    if (genericDeclaration instanceof Class) {
&nbsp;                        return TypeDescription.ForLoadedType.of((Class&lt;?&gt;) genericDeclaration);
&nbsp;                    } else if (genericDeclaration instanceof Method) {
&nbsp;                        return new MethodDescription.ForLoadedMethod((Method) genericDeclaration);
&nbsp;                    } else if (genericDeclaration instanceof Constructor) {
&nbsp;                        return new MethodDescription.ForLoadedConstructor((Constructor&lt;?&gt;) genericDeclaration);
&nbsp;                    } else {
&nbsp;                        throw new IllegalStateException(&quot;Unknown declaration: &quot; + genericDeclaration);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    return new TypeVariableBoundList(typeVariable.getBounds(), annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getSymbol() {
&nbsp;                    return typeVariable.getName();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return annotationReader.asList();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean represents(java.lang.reflect.Type type) {
&nbsp;                    return typeVariable == type || super.represents(type);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of type variable bounds for a loaded {@link TypeVariable} that resolves annotations..
&nbsp;                 */
&nbsp;                protected static class TypeVariableBoundList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type variable bounds.
&nbsp;                     */
&nbsp;                    private final java.lang.reflect.Type[] bound;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation reader to query for the type bounds.
&nbsp;                     */
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new list for a {@link TypeVariable}&#39;s bound.
&nbsp;                     *
&nbsp;                     * @param bound            The type variable bounds.
&nbsp;                     * @param annotationReader The annotation reader to query for the type bounds.
&nbsp;                     */
&nbsp;                    protected TypeVariableBoundList(java.lang.reflect.Type[] bound, AnnotationReader annotationReader) {
&nbsp;                        this.bound = bound;
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic get(int index) {
&nbsp;                        return Sort.describe(bound[index], annotationReader.ofTypeVariableBoundType(index));
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int size() {
&nbsp;                        return bound.length;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A type variable with explicit annotations that replace the annotations that are declared by the provided type variable.
&nbsp;             */
&nbsp;            public static class WithAnnotationOverlay extends OfTypeVariable {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type variable to represent.
&nbsp;                 */
&nbsp;                private final Generic typeVariable;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new type definition for a type variable with explicit annotations.
&nbsp;                 *
&nbsp;                 * @param typeVariable     The type variable to represent.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                public WithAnnotationOverlay(Generic typeVariable, AnnotationSource annotationSource) {
&nbsp;                    this.typeVariable = typeVariable;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    return typeVariable.getUpperBounds();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeVariableSource getTypeVariableSource() {
&nbsp;                    return typeVariable.getTypeVariableSource();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getSymbol() {
&nbsp;                    return typeVariable.getSymbol();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A lazy projection of a generic type. Such projections allow to only read generic type information in case it is required. This
&nbsp;         * is meaningful as the Java virtual needs to process generic type information which requires extra resources. Also, this allows
&nbsp;         * the extraction of non-generic type information even if the generic type information is invalid.
&nbsp;         */
<b class="fc">&nbsp;        abstract class LazyProjection extends AbstractBase {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the actual generic type.
&nbsp;             *
&nbsp;             * @return An actual description of the represented generic type.
&nbsp;             */
&nbsp;            protected abstract Generic resolve();
&nbsp;
&nbsp;            @Override
&nbsp;            public Sort getSort() {
<b class="fc">&nbsp;                return resolve().getSort();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="nc">&nbsp;                return resolve().getDeclaredFields();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                return resolve().getDeclaredMethods();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getUpperBounds() {
<b class="nc">&nbsp;                return resolve().getUpperBounds();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getLowerBounds() {
<b class="nc">&nbsp;                return resolve().getLowerBounds();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getComponentType() {
<b class="fc">&nbsp;                return resolve().getComponentType();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getTypeArguments() {
<b class="nc">&nbsp;                return resolve().getTypeArguments();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
<b class="nc">&nbsp;                return resolve().findBindingOf(typeVariable);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeVariableSource getTypeVariableSource() {
<b class="nc">&nbsp;                return resolve().getTypeVariableSource();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getOwnerType() {
<b class="nc">&nbsp;                return resolve().getOwnerType();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getTypeName() {
<b class="nc">&nbsp;                return resolve().getTypeName();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getSymbol() {
<b class="nc">&nbsp;                return resolve().getSymbol();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getActualName() {
<b class="nc">&nbsp;                return resolve().getActualName();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="fc">&nbsp;                return resolve().accept(visitor);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                return asErasure().getStackSize();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isArray() {
<b class="fc">&nbsp;                return asErasure().isArray();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isPrimitive() {
<b class="fc">&nbsp;                return asErasure().isPrimitive();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                return resolve().represents(type);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return resolve().hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
<b class="pc">&nbsp;                return this == other || other instanceof TypeDefinition &amp;&amp; resolve().equals(other);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="nc">&nbsp;                return resolve().toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of a type with a lazy resolution of super class and interface types. A lazy navigation
&nbsp;             * must only be used for describing types that are guaranteed to define a super class and interface types,
&nbsp;             * i.e. non-generic types and parameterized types. Lazy navigation can also be applied to array types where
&nbsp;             * the usage does however make little sense as those properties are never generic.
&nbsp;             */
<b class="fc">&nbsp;            public abstract static class WithLazyNavigation extends LazyProjection {</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getSuperClass() {
<b class="nc">&nbsp;                    return LazySuperClass.of(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getInterfaces() {
<b class="nc">&nbsp;                    return LazyInterfaceList.of(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="nc">&nbsp;                    return new TypeDefinition.SuperClassIterator(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy super class description for a lazy projection.
&nbsp;                 */
&nbsp;                protected static class LazySuperClass extends WithLazyNavigation {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The lazy projection for which this description is a delegate.
&nbsp;                     */
&nbsp;                    private final LazyProjection delegate;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy super class description.
&nbsp;                     *
&nbsp;                     * @param delegate The lazy projection for which this description is a delegate.
&nbsp;                     */
&nbsp;                    protected LazySuperClass(LazyProjection delegate) {
&nbsp;                        this.delegate = delegate;
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves a lazy super class description.
&nbsp;                     *
&nbsp;                     * @param delegate The lazy projection for which this description is a delegate.
&nbsp;                     * @return A lazy description of the super class or {@code null} if the delegate does not define a super class.
&nbsp;                     */
&nbsp;                    protected static Generic of(LazyProjection delegate) {
&nbsp;                        return delegate.asErasure().getSuperClass() == null
&nbsp;                                ? Generic.UNDEFINED
&nbsp;                                : new LazySuperClass(delegate);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return resolve().getDeclaredAnnotations();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeDescription asErasure() {
&nbsp;                        return delegate.asErasure().getSuperClass().asErasure();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic resolve() {
&nbsp;                        return delegate.resolve().getSuperClass();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy interface type description for a lazy projection.
&nbsp;                 */
&nbsp;                protected static class LazyInterfaceType extends WithLazyNavigation {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The lazy projection for which this description is a delegate.
&nbsp;                     */
&nbsp;                    private final LazyProjection delegate;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The index of the interface in question.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The raw interface that is declared by the erasure of the represented lazy projection.
&nbsp;                     */
&nbsp;                    private final TypeDescription.Generic rawInterface;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy interface type.
&nbsp;                     *
&nbsp;                     * @param delegate     The lazy projection for which this description is a delegate.
&nbsp;                     * @param index        The index of the interface in question.
&nbsp;                     * @param rawInterface The raw interface that is declared by the erasure of the represented lazy projection.
&nbsp;                     */
&nbsp;                    protected LazyInterfaceType(LazyProjection delegate, int index, Generic rawInterface) {
&nbsp;                        this.delegate = delegate;
&nbsp;                        this.index = index;
&nbsp;                        this.rawInterface = rawInterface;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return resolve().getDeclaredAnnotations();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeDescription asErasure() {
&nbsp;                        return rawInterface.asErasure();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic resolve() {
&nbsp;                        return delegate.resolve().getInterfaces().get(index);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy representation of a lazy projection&#39;s interfaces.
&nbsp;                 */
&nbsp;                protected static class LazyInterfaceList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The lazy projection for which this description is a delegate.
&nbsp;                     */
&nbsp;                    private final LazyProjection delegate;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of raw interface types declared by the lazy projection&#39;s erasure.
&nbsp;                     */
&nbsp;                    private final TypeList.Generic rawInterfaces;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy interface list.
&nbsp;                     *
&nbsp;                     * @param delegate      The lazy projection for which this description is a delegate.
&nbsp;                     * @param rawInterfaces A list of raw interface types declared by the lazy projection&#39;s erasure.
&nbsp;                     */
&nbsp;                    protected LazyInterfaceList(LazyProjection delegate, TypeList.Generic rawInterfaces) {
&nbsp;                        this.delegate = delegate;
&nbsp;                        this.rawInterfaces = rawInterfaces;
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves a lazy interface list.
&nbsp;                     *
&nbsp;                     * @param delegate The delegate for which to represent interfaces.
&nbsp;                     * @return A lazy list representing the delegate&#39;s interfaces lazily.
&nbsp;                     */
&nbsp;                    protected static TypeList.Generic of(LazyProjection delegate) {
&nbsp;                        return new LazyInterfaceList(delegate, delegate.asErasure().getInterfaces());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic get(int index) {
&nbsp;                        return new LazyInterfaceType(delegate, index, rawInterfaces.get(index));
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int size() {
&nbsp;                        return rawInterfaces.size();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of an annotated lazy type with lazy navigation.
&nbsp;                 */
<b class="fc">&nbsp;                protected abstract static class OfAnnotatedElement extends WithLazyNavigation {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the current type&#39;s annotation reader.
&nbsp;                     *
&nbsp;                     * @return The current type&#39;s annotation reader.
&nbsp;                     */
&nbsp;                    protected abstract AnnotationReader getAnnotationReader();
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                        return getAnnotationReader().asList();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of a type that resolves super class and interface types eagerly.
&nbsp;             */
<b class="fc">&nbsp;            public abstract static class WithEagerNavigation extends LazyProjection {</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getSuperClass() {
<b class="nc">&nbsp;                    return resolve().getSuperClass();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getInterfaces() {
<b class="nc">&nbsp;                    return resolve().getInterfaces();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="nc">&nbsp;                    return resolve().iterator();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of an annotated lazy type with eager navigation.
&nbsp;                 */
<b class="fc">&nbsp;                protected abstract static class OfAnnotatedElement extends WithEagerNavigation {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the current type&#39;s annotation reader.
&nbsp;                     *
&nbsp;                     * @return The current type&#39;s annotation reader.
&nbsp;                     */
&nbsp;                    protected abstract AnnotationReader getAnnotationReader();
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                        return getAnnotationReader().asList();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of a generic super type.
&nbsp;             */
&nbsp;            public static class ForLoadedSuperClass extends LazyProjection.WithLazyNavigation.OfAnnotatedElement {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type of which the super class is represented.
&nbsp;                 */
&nbsp;                private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy projection of a type&#39;s super class.
&nbsp;                 *
&nbsp;                 * @param type The type of which the super class is represented.
&nbsp;                 */
<b class="fc">&nbsp;                public ForLoadedSuperClass(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;                    this.type = type;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    java.lang.reflect.Type superClass = type.getGenericSuperclass();</b>
<b class="pc">&nbsp;                    return superClass == null</b>
&nbsp;                            ? Generic.UNDEFINED
<b class="fc">&nbsp;                            : Sort.describe(superClass, getAnnotationReader());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
<b class="nc">&nbsp;                    Class&lt;?&gt; superClass = type.getSuperclass();</b>
<b class="nc">&nbsp;                    return superClass == null</b>
&nbsp;                            ? TypeDescription.UNDEFINED
<b class="nc">&nbsp;                            : ForLoadedType.of(superClass);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotationReader getAnnotationReader() {
<b class="fc">&nbsp;                    return AnnotationReader.DISPATCHER.resolveSuperClassType(type);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of a field&#39;s type.
&nbsp;             */
&nbsp;            public static class ForLoadedFieldType extends LazyProjection.WithEagerNavigation.OfAnnotatedElement {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field of which the type is represented.
&nbsp;                 */
&nbsp;                private final Field field;
&nbsp;
&nbsp;                /**
&nbsp;                 * Create&#39;s a lazy projection of a field type.
&nbsp;                 *
&nbsp;                 * @param field The field of which the type is represented.
&nbsp;                 */
&nbsp;                public ForLoadedFieldType(Field field) {
&nbsp;                    this.field = field;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic resolve() {
&nbsp;                    return Sort.describe(field.getGenericType(), getAnnotationReader());
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return ForLoadedType.of(field.getType());
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return AnnotationReader.DISPATCHER.resolveFieldType(field);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of a method&#39;s generic return type.
&nbsp;             */
&nbsp;            public static class ForLoadedReturnType extends LazyProjection.WithEagerNavigation.OfAnnotatedElement {
&nbsp;
&nbsp;                /**
&nbsp;                 * The method which defines the return type.
&nbsp;                 */
&nbsp;                private final Method method;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy projection of a method&#39;s return type.
&nbsp;                 *
&nbsp;                 * @param method The method which defines the return type.
&nbsp;                 */
<b class="fc">&nbsp;                public ForLoadedReturnType(Method method) {</b>
<b class="fc">&nbsp;                    this.method = method;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    return Sort.describe(method.getGenericReturnType(), getAnnotationReader());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return ForLoadedType.of(method.getReturnType());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotationReader getAnnotationReader() {
<b class="fc">&nbsp;                    return AnnotationReader.DISPATCHER.resolveReturnType(method);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of the parameter type of a {@link Constructor}.
&nbsp;             */
&nbsp;            public static class OfConstructorParameter extends LazyProjection.WithEagerNavigation.OfAnnotatedElement {
&nbsp;
&nbsp;                /**
&nbsp;                 * The constructor of which a parameter type is represented.
&nbsp;                 */
&nbsp;                private final Constructor&lt;?&gt; constructor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter&#39;s index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * The erasure of the parameter type.
&nbsp;                 */
&nbsp;                private final Class&lt;?&gt;[] erasure;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a lazy projection of a constructor&#39;s parameter.
&nbsp;                 *
&nbsp;                 * @param constructor The constructor of which a parameter type is represented.
&nbsp;                 * @param index       The parameter&#39;s index.
&nbsp;                 * @param erasure     The erasure of the parameter type.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP2&quot;, justification = &quot;The array is never exposed outside of the class&quot;)
<b class="fc">&nbsp;                public OfConstructorParameter(Constructor&lt;?&gt; constructor, int index, Class&lt;?&gt;[] erasure) {</b>
<b class="fc">&nbsp;                    this.constructor = constructor;</b>
<b class="fc">&nbsp;                    this.index = index;</b>
<b class="fc">&nbsp;                    this.erasure = erasure;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    java.lang.reflect.Type[] type = constructor.getGenericParameterTypes();</b>
<b class="pc">&nbsp;                    return erasure.length == type.length</b>
<b class="fc">&nbsp;                            ? Sort.describe(type[index], getAnnotationReader())</b>
<b class="nc">&nbsp;                            : OfNonGenericType.ForLoadedType.of(erasure[index]);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return TypeDescription.ForLoadedType.of(erasure[index]);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotationReader getAnnotationReader() {
<b class="fc">&nbsp;                    return AnnotationReader.DISPATCHER.resolveParameterType(constructor, index);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of the parameter type of a {@link Method}.
&nbsp;             */
&nbsp;            public static class OfMethodParameter extends LazyProjection.WithEagerNavigation.OfAnnotatedElement {
&nbsp;
&nbsp;                /**
&nbsp;                 * The method of which a parameter type is represented.
&nbsp;                 */
&nbsp;                private final Method method;
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter&#39;s index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * The erasures of the method&#39;s parameter types.
&nbsp;                 */
&nbsp;                private final Class&lt;?&gt;[] erasure;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a lazy projection of a constructor&#39;s parameter.
&nbsp;                 *
&nbsp;                 * @param method  The method of which a parameter type is represented.
&nbsp;                 * @param index   The parameter&#39;s index.
&nbsp;                 * @param erasure The erasures of the method&#39;s parameter types.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP2&quot;, justification = &quot;The array is never exposed outside of the class&quot;)
<b class="fc">&nbsp;                public OfMethodParameter(Method method, int index, Class&lt;?&gt;[] erasure) {</b>
<b class="fc">&nbsp;                    this.method = method;</b>
<b class="fc">&nbsp;                    this.index = index;</b>
<b class="fc">&nbsp;                    this.erasure = erasure;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    java.lang.reflect.Type[] type = method.getGenericParameterTypes();</b>
<b class="pc">&nbsp;                    return erasure.length == type.length</b>
<b class="fc">&nbsp;                            ? Sort.describe(type[index], getAnnotationReader())</b>
<b class="nc">&nbsp;                            : OfNonGenericType.ForLoadedType.of(erasure[index]);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return TypeDescription.ForLoadedType.of(erasure[index]);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotationReader getAnnotationReader() {
<b class="fc">&nbsp;                    return AnnotationReader.DISPATCHER.resolveParameterType(method, index);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection that applies a visitor only when resolving the generic type but not when reading the erasure.
&nbsp;             */
&nbsp;            public static class WithResolvedErasure extends LazyProjection.WithEagerNavigation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The unresolved generic type.
&nbsp;                 */
&nbsp;                private final Generic delegate;
&nbsp;
&nbsp;                /**
&nbsp;                 * The visitor to apply for resolving the generic type.
&nbsp;                 */
&nbsp;                private final Visitor&lt;? extends Generic&gt; visitor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to apply.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a lazy projection with a resolved erasure that retains the delegates type annotations.
&nbsp;                 *
&nbsp;                 * @param delegate The unresolved generic type.
&nbsp;                 * @param visitor  The visitor to apply for resolving the generic type.
&nbsp;                 */
&nbsp;                public WithResolvedErasure(Generic delegate, Visitor&lt;? extends Generic&gt; visitor) {
<b class="fc">&nbsp;                    this(delegate, visitor, delegate);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a lazy projection with a resolved erasure.
&nbsp;                 *
&nbsp;                 * @param delegate         The unresolved generic type.
&nbsp;                 * @param visitor          The visitor to apply for resolving the generic type.
&nbsp;                 * @param annotationSource The annotation source representing this type&#39;s type annotations.
&nbsp;                 */
<b class="fc">&nbsp;                public WithResolvedErasure(Generic delegate, Visitor&lt;? extends Generic&gt; visitor, AnnotationSource annotationSource) {</b>
<b class="fc">&nbsp;                    this.delegate = delegate;</b>
<b class="fc">&nbsp;                    this.visitor = visitor;</b>
<b class="fc">&nbsp;                    this.annotationSource = annotationSource;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                    return annotationSource.getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return delegate.asErasure();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    return delegate.accept(visitor);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A builder for creating describing a generic type as a {@link Generic}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        abstract class Builder {
&nbsp;
&nbsp;            /**
&nbsp;             * Represents an undefined {@link java.lang.reflect.Type} within a build step.
&nbsp;             */
&nbsp;            private static final java.lang.reflect.Type UNDEFINED = null;
&nbsp;
&nbsp;            /**
&nbsp;             * The type annotations of the current annotated type.
&nbsp;             */
&nbsp;            protected final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new builder for a generic type description.
&nbsp;             *
&nbsp;             * @param annotations The type annotations of the current annotated type.
&nbsp;             */
&nbsp;            protected Builder(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                this.annotations = annotations;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a raw type of a type description.
&nbsp;             *
&nbsp;             * @param type The type to represent as a raw type.
&nbsp;             * @return A builder for creating a raw type.
&nbsp;             */
&nbsp;            public static Builder rawType(Class&lt;?&gt; type) {
&nbsp;                return rawType(ForLoadedType.of(type));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a raw type of a type description.
&nbsp;             *
&nbsp;             * @param type The type to represent as a raw type.
&nbsp;             * @return A builder for creating a raw type.
&nbsp;             */
&nbsp;            public static Builder rawType(TypeDescription type) {
&nbsp;                return new Builder.OfNonGenericType(type);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a raw type of a type description where the supplied owner type is used as .
&nbsp;             *
&nbsp;             * @param type      The type to represent as a raw type.
&nbsp;             * @param ownerType The raw type&#39;s (annotated) declaring type or {@code null} if no owner type should be declared.
&nbsp;             * @return A builder for creating a raw type.
&nbsp;             */
&nbsp;            public static Builder rawType(Class&lt;?&gt; type, Generic ownerType) {
&nbsp;                return rawType(ForLoadedType.of(type), ownerType);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a raw type of a type description.
&nbsp;             *
&nbsp;             * @param type      The type to represent as a raw type.
&nbsp;             * @param ownerType The raw type&#39;s (annotated) declaring type or {@code null} if no owner type should be declared.
&nbsp;             * @return A builder for creating a raw type.
&nbsp;             */
&nbsp;            public static Builder rawType(TypeDescription type, Generic ownerType) {
&nbsp;                TypeDescription declaringType = type.getDeclaringType();
&nbsp;                if (declaringType == null &amp;&amp; ownerType != null) {
&nbsp;                    throw new IllegalArgumentException(type + &quot; does not have a declaring type: &quot; + ownerType);
&nbsp;                } else if (declaringType != null &amp;&amp; (ownerType == null || !declaringType.equals(ownerType.asErasure()))) {
&nbsp;                    throw new IllegalArgumentException(ownerType + &quot; is not the declaring type of &quot; + type);
&nbsp;                }
&nbsp;                return new Builder.OfNonGenericType(type, ownerType);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an unbound wildcard without type annotations.
&nbsp;             *
&nbsp;             * @return A description of an unbound wildcard without type annotations.
&nbsp;             */
&nbsp;            public static Generic unboundWildcard() {
&nbsp;                return unboundWildcard(Collections.&lt;AnnotationDescription&gt;emptySet());
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an unbound wildcard.
&nbsp;             *
&nbsp;             * @param annotation The type annotations of the unbound wildcard.
&nbsp;             * @return A description of an unbound wildcard.
&nbsp;             */
&nbsp;            public static Generic unboundWildcard(Annotation... annotation) {
&nbsp;                return unboundWildcard(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an unbound wildcard.
&nbsp;             *
&nbsp;             * @param annotations The type annotations of the unbound wildcard.
&nbsp;             * @return A description of an unbound wildcard.
&nbsp;             */
&nbsp;            public static Generic unboundWildcard(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return unboundWildcard(new AnnotationList.ForLoadedAnnotations(annotations));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an unbound wildcard.
&nbsp;             *
&nbsp;             * @param annotation The type annotations of the unbound wildcard.
&nbsp;             * @return A description of an unbound wildcard.
&nbsp;             */
&nbsp;            public static Generic unboundWildcard(AnnotationDescription... annotation) {
&nbsp;                return unboundWildcard(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an unbound wildcard.
&nbsp;             *
&nbsp;             * @param annotations The type annotations of the unbound wildcard.
&nbsp;             * @return A description of an unbound wildcard.
&nbsp;             */
&nbsp;            public static Generic unboundWildcard(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return OfWildcardType.Latent.unbounded(new Explicit(new ArrayList&lt;AnnotationDescription&gt;(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a symbolic type variable of the given name.
&nbsp;             *
&nbsp;             * @param symbol The symbolic name of the type variable.
&nbsp;             * @return A builder for creating a type variable.
&nbsp;             */
&nbsp;            public static Builder typeVariable(String symbol) {
&nbsp;                return new OfTypeVariable(symbol);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameterized type without an owner type or with a non-generic owner type.
&nbsp;             *
&nbsp;             * @param rawType   A raw version of the type to describe as a parameterized type.
&nbsp;             * @param parameter The type arguments to attach to the raw type as parameters.
&nbsp;             * @return A builder for creating a parameterized type.
&nbsp;             */
&nbsp;            public static Builder parameterizedType(Class&lt;?&gt; rawType, java.lang.reflect.Type... parameter) {
&nbsp;                return parameterizedType(rawType, Arrays.asList(parameter));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameterized type without an owner type or with a non-generic owner type.
&nbsp;             *
&nbsp;             * @param rawType    A raw version of the type to describe as a parameterized type.
&nbsp;             * @param parameters The type arguments to attach to the raw type as parameters.
&nbsp;             * @return A builder for creating a parameterized type.
&nbsp;             */
&nbsp;            public static Builder parameterizedType(Class&lt;?&gt; rawType, List&lt;? extends java.lang.reflect.Type&gt; parameters) {
&nbsp;                return parameterizedType(rawType, UNDEFINED, parameters);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameterized type.
&nbsp;             *
&nbsp;             * @param rawType    A raw version of the type to describe as a parameterized type.
&nbsp;             * @param ownerType  The owner type of the parameterized type.
&nbsp;             * @param parameters The type arguments to attach to the raw type as parameters.
&nbsp;             * @return A builder for creating a parameterized type.
&nbsp;             */
&nbsp;            public static Builder parameterizedType(Class&lt;?&gt; rawType, java.lang.reflect.Type ownerType, List&lt;? extends java.lang.reflect.Type&gt; parameters) {
&nbsp;                return parameterizedType(ForLoadedType.of(rawType),
&nbsp;                        ownerType == null
&nbsp;                                ? null
&nbsp;                                : Sort.describe(ownerType),
&nbsp;                        new TypeList.Generic.ForLoadedTypes(parameters));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameterized type without an owner type or with a non-generic owner type.
&nbsp;             *
&nbsp;             * @param rawType   A raw version of the type to describe as a parameterized type.
&nbsp;             * @param parameter The type arguments to attach to the raw type as parameters.
&nbsp;             * @return A builder for creating a parameterized type.
&nbsp;             */
&nbsp;            public static Builder parameterizedType(TypeDescription rawType, TypeDefinition... parameter) {
&nbsp;                return parameterizedType(rawType, Arrays.asList(parameter));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameterized type without an owner type or with a non-generic owner type.
&nbsp;             *
&nbsp;             * @param rawType    A raw version of the type to describe as a parameterized type.
&nbsp;             * @param parameters The type arguments to attach to the raw type as parameters.
&nbsp;             * @return A builder for creating a parameterized type.
&nbsp;             */
&nbsp;            public static Builder parameterizedType(TypeDescription rawType, Collection&lt;? extends TypeDefinition&gt; parameters) {
&nbsp;                return parameterizedType(rawType, Generic.UNDEFINED, parameters);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameterized type.
&nbsp;             *
&nbsp;             * @param rawType    A raw version of the type to describe as a parameterized type.
&nbsp;             * @param ownerType  The owner type of the parameterized type.
&nbsp;             * @param parameters The type arguments to attach to the raw type as parameters.
&nbsp;             * @return A builder for creating a parameterized type.
&nbsp;             */
&nbsp;            public static Builder parameterizedType(TypeDescription rawType, Generic ownerType, Collection&lt;? extends TypeDefinition&gt; parameters) {
&nbsp;                TypeDescription declaringType = rawType.getDeclaringType();
&nbsp;                if (ownerType == null &amp;&amp; declaringType != null &amp;&amp; rawType.isStatic()) {
&nbsp;                    ownerType = declaringType.asGenericType();
&nbsp;                }
&nbsp;                if (!rawType.represents(TargetType.class)) {
&nbsp;                    if (!rawType.isGenerified()) {
&nbsp;                        throw new IllegalArgumentException(rawType + &quot; is not a parameterized type&quot;);
&nbsp;                    } else if (ownerType == null &amp;&amp; declaringType != null &amp;&amp; !rawType.isStatic()) {
&nbsp;                        throw new IllegalArgumentException(rawType + &quot; requires an owner type&quot;);
&nbsp;                    } else if (ownerType != null &amp;&amp; !ownerType.asErasure().equals(declaringType)) {
&nbsp;                        throw new IllegalArgumentException(ownerType + &quot; does not represent required owner for &quot; + rawType);
&nbsp;                    } else if (ownerType != null &amp;&amp; (rawType.isStatic() ^ ownerType.getSort().isNonGeneric())) {
&nbsp;                        throw new IllegalArgumentException(ownerType + &quot; does not define the correct parameters for owning &quot; + rawType);
&nbsp;                    } else if (rawType.getTypeVariables().size() != parameters.size()) {
&nbsp;                        throw new IllegalArgumentException(parameters + &quot; does not contain number of required parameters for &quot; + rawType);
&nbsp;                    }
&nbsp;                }
&nbsp;                return new Builder.OfParameterizedType(rawType, ownerType, new TypeList.Generic.Explicit(new ArrayList&lt;TypeDefinition&gt;(parameters)));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the upper bound of a wildcard type.
&nbsp;             *
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an upper bound.
&nbsp;             */
&nbsp;            public Generic asWildcardUpperBound() {
&nbsp;                return asWildcardUpperBound(Collections.&lt;AnnotationDescription&gt;emptySet());
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the upper bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotation Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an upper bound.
&nbsp;             */
&nbsp;            public Generic asWildcardUpperBound(Annotation... annotation) {
&nbsp;                return asWildcardUpperBound(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the upper bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an upper bound.
&nbsp;             */
&nbsp;            public Generic asWildcardUpperBound(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return asWildcardUpperBound(new AnnotationList.ForLoadedAnnotations(annotations));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the upper bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotation Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an upper bound.
&nbsp;             */
&nbsp;            public Generic asWildcardUpperBound(AnnotationDescription... annotation) {
&nbsp;                return asWildcardUpperBound(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the upper bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an upper bound.
&nbsp;             */
&nbsp;            public Generic asWildcardUpperBound(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return OfWildcardType.Latent.boundedAbove(build(), new Explicit(new ArrayList&lt;AnnotationDescription&gt;(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the lower bound of a wildcard type.
&nbsp;             *
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an lower bound.
&nbsp;             */
&nbsp;            public Generic asWildcardLowerBound() {
&nbsp;                return asWildcardLowerBound(Collections.&lt;AnnotationDescription&gt;emptySet());
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the lower bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotation Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an lower bound.
&nbsp;             */
&nbsp;            public Generic asWildcardLowerBound(Annotation... annotation) {
&nbsp;                return asWildcardLowerBound(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the lower bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an lower bound.
&nbsp;             */
&nbsp;            public Generic asWildcardLowerBound(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return asWildcardLowerBound(new AnnotationList.ForLoadedAnnotations(annotations));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the lower bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotation Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an lower bound.
&nbsp;             */
&nbsp;            public Generic asWildcardLowerBound(AnnotationDescription... annotation) {
&nbsp;                return asWildcardLowerBound(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the lower bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an lower bound.
&nbsp;             */
&nbsp;            public Generic asWildcardLowerBound(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return OfWildcardType.Latent.boundedBelow(build(), new Explicit(new ArrayList&lt;AnnotationDescription&gt;(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents the built type into an array.
&nbsp;             *
&nbsp;             * @return A builder for creating an array of the currently built type.
&nbsp;             */
&nbsp;            public Builder asArray() {
&nbsp;                return asArray(1);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents the built type into an array.
&nbsp;             *
&nbsp;             * @param arity The arity of the array.
&nbsp;             * @return A builder for creating an array of the currently built type.
&nbsp;             */
&nbsp;            public Builder asArray(int arity) {
&nbsp;                if (arity &lt; 1) {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot define an array of a non-positive arity: &quot; + arity);
&nbsp;                }
&nbsp;                TypeDescription.Generic typeDescription = build();
&nbsp;                while (--arity &gt; 0) {
&nbsp;                    typeDescription = new OfGenericArray.Latent(typeDescription, Empty.INSTANCE);
&nbsp;                }
&nbsp;                return new Builder.OfGenericArrayType(typeDescription);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Defines type annotations to be declared by the current type.
&nbsp;             *
&nbsp;             * @param annotation Type annotations to be declared by the current type.
&nbsp;             * @return A new builder where the current type declares the supplied type annotations.
&nbsp;             */
&nbsp;            public Builder annotate(Annotation... annotation) {
&nbsp;                return annotate(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Defines type annotations to be declared by the current type.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the current type.
&nbsp;             * @return A new builder where the current type declares the supplied type annotations.
&nbsp;             */
&nbsp;            public Builder annotate(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return annotate(new AnnotationList.ForLoadedAnnotations(annotations));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Defines type annotations to be declared by the current type.
&nbsp;             *
&nbsp;             * @param annotation Type annotations to be declared by the current type.
&nbsp;             * @return A new builder where the current type declares the supplied type annotations.
&nbsp;             */
&nbsp;            public Builder annotate(AnnotationDescription... annotation) {
&nbsp;                return annotate(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Defines type annotations to be declared by the current type.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the current type.
&nbsp;             * @return A new builder where the current type declares the supplied type annotations.
&nbsp;             */
&nbsp;            public Builder annotate(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return doAnnotate(new ArrayList&lt;AnnotationDescription&gt;(annotations));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new builder for the current type and the applied type annotations.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the current type.
&nbsp;             * @return A new builder where the current type declares the supplied type annotations.
&nbsp;             */
&nbsp;            protected abstract Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Finalizes the build and finalizes the created type as a generic type description.
&nbsp;             *
&nbsp;             * @return A generic type description of the built type.
&nbsp;             */
&nbsp;            public Generic build() {
&nbsp;                return doBuild();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Finalizes the build and finalizes the created type as a generic type description.
&nbsp;             *
&nbsp;             * @param annotation Type annotations place for the built generic type to declare.
&nbsp;             * @return A generic type description of the built type.
&nbsp;             */
&nbsp;            public Generic build(Annotation... annotation) {
&nbsp;                return build(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Finalizes the build and finalizes the created type as a generic type description.
&nbsp;             *
&nbsp;             * @param annotations Type annotations place for the built generic type to declare.
&nbsp;             * @return A generic type description of the built type.
&nbsp;             */
&nbsp;            public Generic build(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return build(new AnnotationList.ForLoadedAnnotations(annotations));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Finalizes the build and finalizes the created type as a generic type description.
&nbsp;             *
&nbsp;             * @param annotation Type annotations place for the built generic type to declare.
&nbsp;             * @return A generic type description of the built type.
&nbsp;             */
&nbsp;            public Generic build(AnnotationDescription... annotation) {
&nbsp;                return build(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Finalizes the build and finalizes the created type as a generic type description.
&nbsp;             *
&nbsp;             * @param annotations Type annotations place for the built generic type to declare.
&nbsp;             * @return A generic type description of the built type.
&nbsp;             */
&nbsp;            public Generic build(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return doAnnotate(new ArrayList&lt;AnnotationDescription&gt;(annotations)).doBuild();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Builds the generic type.
&nbsp;             *
&nbsp;             * @return The generic type.
&nbsp;             */
&nbsp;            protected abstract Generic doBuild();
&nbsp;
&nbsp;            /**
&nbsp;             * A generic type builder for building a non-generic type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfNonGenericType extends Builder {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s erasure.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The raw type&#39;s (annotated) declaring type or {@code null} if no such type is defined.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final Generic ownerType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a builder for a non-generic type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type&#39;s erasure.
&nbsp;                 */
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription) {
&nbsp;                    this(typeDescription, typeDescription.getDeclaringType());
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a builder for a non-generic type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type&#39;s erasure.
&nbsp;                 * @param ownerType       The raw type&#39;s raw declaring type or {@code null} if no such type is defined.
&nbsp;                 */
&nbsp;                private OfNonGenericType(TypeDescription typeDescription, TypeDescription ownerType) {
&nbsp;                    this(typeDescription, ownerType == null
&nbsp;                            ? Generic.UNDEFINED
&nbsp;                            : ownerType.asGenericType());
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a builder for a non-generic type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type&#39;s erasure.
&nbsp;                 * @param ownerType       The raw type&#39;s (annotated) declaring type.
&nbsp;                 */
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription, Generic ownerType) {
&nbsp;                    this(typeDescription, ownerType, Collections.&lt;AnnotationDescription&gt;emptyList());
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a builder for a non-generic type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type&#39;s erasure.
&nbsp;                 * @param ownerType       The raw type&#39;s (annotated) declaring type.
&nbsp;                 * @param annotations     The type&#39;s type annotations.
&nbsp;                 */
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription, Generic ownerType, List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    super(annotations);
&nbsp;                    this.ownerType = ownerType;
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    return new OfNonGenericType(typeDescription, ownerType, CompoundList.of(this.annotations, annotations));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic doBuild() {
&nbsp;                    if (typeDescription.represents(void.class) &amp;&amp; !annotations.isEmpty()) {
&nbsp;                        throw new IllegalArgumentException(&quot;The void non-type cannot be annotated&quot;);
&nbsp;                    }
&nbsp;                    return new Generic.OfNonGenericType.Latent(typeDescription, ownerType, new Explicit(annotations));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A generic type builder for building a parameterized type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfParameterizedType extends Builder {
&nbsp;
&nbsp;                /**
&nbsp;                 * The raw base type.
&nbsp;                 */
&nbsp;                private final TypeDescription rawType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic owner type.
&nbsp;                 */
&nbsp;                private final Generic ownerType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter types.
&nbsp;                 */
&nbsp;                private final List&lt;? extends Generic&gt; parameterTypes;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a builder for a parameterized type.
&nbsp;                 *
&nbsp;                 * @param rawType        The raw base type.
&nbsp;                 * @param ownerType      The generic owner type.
&nbsp;                 * @param parameterTypes The parameter types.
&nbsp;                 */
&nbsp;                protected OfParameterizedType(TypeDescription rawType, Generic ownerType, List&lt;? extends Generic&gt; parameterTypes) {
&nbsp;                    this(rawType, ownerType, parameterTypes, Collections.&lt;AnnotationDescription&gt;emptyList());
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a builder for a parameterized type.
&nbsp;                 *
&nbsp;                 * @param rawType        The raw base type.
&nbsp;                 * @param ownerType      The generic owner type.
&nbsp;                 * @param parameterTypes The parameter types.
&nbsp;                 * @param annotations    The type&#39;s type annotations.
&nbsp;                 */
&nbsp;                protected OfParameterizedType(TypeDescription rawType,
&nbsp;                                              Generic ownerType,
&nbsp;                                              List&lt;? extends Generic&gt; parameterTypes,
&nbsp;                                              List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    super(annotations);
&nbsp;                    this.rawType = rawType;
&nbsp;                    this.ownerType = ownerType;
&nbsp;                    this.parameterTypes = parameterTypes;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    return new OfParameterizedType(rawType, ownerType, parameterTypes, CompoundList.of(this.annotations, annotations));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic doBuild() {
&nbsp;                    return new Generic.OfParameterizedType.Latent(rawType, ownerType, parameterTypes, new Explicit(annotations));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A generic type builder building a generic array type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfGenericArrayType extends Builder {
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic component type.
&nbsp;                 */
&nbsp;                private final Generic componentType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a type builder for building a generic array type.
&nbsp;                 *
&nbsp;                 * @param componentType The generic component type.
&nbsp;                 */
&nbsp;                protected OfGenericArrayType(Generic componentType) {
&nbsp;                    this(componentType, Collections.&lt;AnnotationDescription&gt;emptyList());
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a type builder for building a generic array type.
&nbsp;                 *
&nbsp;                 * @param componentType The generic component type.
&nbsp;                 * @param annotations   The type&#39;s type annotations.
&nbsp;                 */
&nbsp;                protected OfGenericArrayType(Generic componentType, List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    super(annotations);
&nbsp;                    this.componentType = componentType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    return new OfGenericArrayType(componentType, CompoundList.of(this.annotations, annotations));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic doBuild() {
&nbsp;                    return new Generic.OfGenericArray.Latent(componentType, new Explicit(annotations));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A generic type builder building a symbolic type variable.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfTypeVariable extends Builder {
&nbsp;
&nbsp;                /**
&nbsp;                 * The variable&#39;s symbol.
&nbsp;                 */
&nbsp;                private final String symbol;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new builder for a symbolic type variable.
&nbsp;                 *
&nbsp;                 * @param symbol The variable&#39;s symbol.
&nbsp;                 */
&nbsp;                protected OfTypeVariable(String symbol) {
&nbsp;                    this(symbol, Collections.&lt;AnnotationDescription&gt;emptyList());
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new builder for a symbolic type variable.
&nbsp;                 *
&nbsp;                 * @param symbol      The variable&#39;s symbol.
&nbsp;                 * @param annotations The type&#39;s type annotations.
&nbsp;                 */
&nbsp;                protected OfTypeVariable(String symbol, List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    super(annotations);
&nbsp;                    this.symbol = symbol;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    return new OfTypeVariable(symbol, CompoundList.of(this.annotations, annotations));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic doBuild() {
&nbsp;                    return new Generic.OfTypeVariable.Symbolic(symbol, new Explicit(annotations));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract base implementation of a type description.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase extends TypeVariableSource.AbstractBase implements TypeDescription {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link TypeDefinition#RAW_TYPES_PROPERTY} property.
&nbsp;         */
&nbsp;        public static final boolean RAW_TYPES;
&nbsp;
&nbsp;        /*
&nbsp;         * Reads the raw type property.
&nbsp;         */
&nbsp;        static {
&nbsp;            boolean rawTypes;
&nbsp;            try {
<b class="fc">&nbsp;                rawTypes = Boolean.parseBoolean(AccessController.doPrivileged(new GetSystemPropertyAction(RAW_TYPES_PROPERTY)));</b>
<b class="nc">&nbsp;            } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                rawTypes = false;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            RAW_TYPES = rawTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if a specific type is assignable to another type where the source type must be a super
&nbsp;         * type of the target type.
&nbsp;         *
&nbsp;         * @param sourceType The source type to which another type is to be assigned to.
&nbsp;         * @param targetType The target type that is to be assigned to the source type.
&nbsp;         * @return {@code true} if the target type is assignable to the source type.
&nbsp;         */
&nbsp;        private static boolean isAssignable(TypeDescription sourceType, TypeDescription targetType) {
&nbsp;            // Means that &#39;[sourceType] var = ([targetType]) val;&#39; is a valid assignment. This is true, if:
&nbsp;            // (1) Both types are equal (implies primitive types.)
<b class="fc">&nbsp;            if (sourceType.equals(targetType)) {</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;            // (2) For arrays, there are special assignment rules.
<b class="fc">&nbsp;            if (targetType.isArray()) {</b>
<b class="pc">&nbsp;                return sourceType.isArray()</b>
<b class="nc">&nbsp;                        ? isAssignable(sourceType.getComponentType(), targetType.getComponentType())</b>
<b class="pc">&nbsp;                        : sourceType.represents(Object.class) || ARRAY_INTERFACES.contains(sourceType.asGenericType());</b>
&nbsp;            }
&nbsp;            // (3) Interfaces do not extend the Object type but are assignable to the Object type.
<b class="fc">&nbsp;            if (sourceType.represents(Object.class)) {</b>
<b class="pc">&nbsp;                return !targetType.isPrimitive();</b>
&nbsp;            }
&nbsp;            // (4) The sub type has a super type and this super type is assignable to the super type.
<b class="fc">&nbsp;            Generic superClass = targetType.getSuperClass();</b>
<b class="fc">&nbsp;            if (superClass != null &amp;&amp; sourceType.isAssignableFrom(superClass.asErasure())) {</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;            // (5) If the target type is an interface, any of this type&#39;s interfaces might be assignable to it.
<b class="fc">&nbsp;            if (sourceType.isInterface()) {</b>
<b class="pc">&nbsp;                for (TypeDescription interfaceType : targetType.getInterfaces().asErasures()) {</b>
<b class="nc">&nbsp;                    if (sourceType.isAssignableFrom(interfaceType)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            // (6) None of these criteria are true, i.e. the types are not assignable.
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAssignableFrom(Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return isAssignableFrom(ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAssignableFrom(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return isAssignable(this, typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAssignableTo(Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return isAssignableTo(ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAssignableTo(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return isAssignable(typeDescription, this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription asErasure() {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Generic asGenericType() {
<b class="fc">&nbsp;            return new Generic.OfNonGenericType.ForErasure(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Sort getSort() {
<b class="fc">&nbsp;            return Sort.NON_GENERIC;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isInstance(Object value) {
<b class="fc">&nbsp;            return isAssignableFrom(value.getClass());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAnnotationValue(Object value) {
<b class="nc">&nbsp;            if ((represents(Class.class) &amp;&amp; value instanceof TypeDescription)</b>
<b class="nc">&nbsp;                    || (value instanceof AnnotationDescription &amp;&amp; ((AnnotationDescription) value).getAnnotationType().equals(this))</b>
<b class="nc">&nbsp;                    || (value instanceof EnumerationDescription &amp;&amp; ((EnumerationDescription) value).getEnumerationType().equals(this))</b>
<b class="nc">&nbsp;                    || (represents(String.class) &amp;&amp; value instanceof String)</b>
<b class="nc">&nbsp;                    || (represents(boolean.class) &amp;&amp; value instanceof Boolean)</b>
<b class="nc">&nbsp;                    || (represents(byte.class) &amp;&amp; value instanceof Byte)</b>
<b class="nc">&nbsp;                    || (represents(short.class) &amp;&amp; value instanceof Short)</b>
<b class="nc">&nbsp;                    || (represents(char.class) &amp;&amp; value instanceof Character)</b>
<b class="nc">&nbsp;                    || (represents(int.class) &amp;&amp; value instanceof Integer)</b>
<b class="nc">&nbsp;                    || (represents(long.class) &amp;&amp; value instanceof Long)</b>
<b class="nc">&nbsp;                    || (represents(float.class) &amp;&amp; value instanceof Float)</b>
<b class="nc">&nbsp;                    || (represents(double.class) &amp;&amp; value instanceof Double)</b>
<b class="nc">&nbsp;                    || (represents(String[].class) &amp;&amp; value instanceof String[])</b>
<b class="nc">&nbsp;                    || (represents(boolean[].class) &amp;&amp; value instanceof boolean[])</b>
<b class="nc">&nbsp;                    || (represents(byte[].class) &amp;&amp; value instanceof byte[])</b>
<b class="nc">&nbsp;                    || (represents(short[].class) &amp;&amp; value instanceof short[])</b>
<b class="nc">&nbsp;                    || (represents(char[].class) &amp;&amp; value instanceof char[])</b>
<b class="nc">&nbsp;                    || (represents(int[].class) &amp;&amp; value instanceof int[])</b>
<b class="nc">&nbsp;                    || (represents(long[].class) &amp;&amp; value instanceof long[])</b>
<b class="nc">&nbsp;                    || (represents(float[].class) &amp;&amp; value instanceof float[])</b>
<b class="nc">&nbsp;                    || (represents(double[].class) &amp;&amp; value instanceof double[])</b>
<b class="nc">&nbsp;                    || (represents(Class[].class) &amp;&amp; value instanceof TypeDescription[])) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (isAssignableTo(Annotation[].class) &amp;&amp; value instanceof AnnotationDescription[]) {</b>
<b class="nc">&nbsp;                for (AnnotationDescription annotationDescription : (AnnotationDescription[]) value) {</b>
<b class="nc">&nbsp;                    if (!annotationDescription.getAnnotationType().equals(getComponentType())) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (isAssignableTo(Enum[].class) &amp;&amp; value instanceof EnumerationDescription[]) {</b>
<b class="nc">&nbsp;                for (EnumerationDescription enumerationDescription : (EnumerationDescription[]) value) {</b>
<b class="nc">&nbsp;                    if (!enumerationDescription.getEnumerationType().equals(getComponentType())) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return getName().replace(&#39;.&#39;, &#39;/&#39;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getActualModifiers(boolean superFlag) {
<b class="pc">&nbsp;            int actualModifiers = getModifiers() | (getDeclaredAnnotations().isAnnotationPresent(Deprecated.class)</b>
&nbsp;                    ? Opcodes.ACC_DEPRECATED
&nbsp;                    : EMPTY_MASK);
<b class="pc">&nbsp;            if (isPrivate()) {</b>
<b class="nc">&nbsp;                actualModifiers = actualModifiers &amp; ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC);</b>
<b class="pc">&nbsp;            } else if (isProtected()) {</b>
<b class="nc">&nbsp;                actualModifiers = actualModifiers &amp; ~(Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC) | Opcodes.ACC_PUBLIC;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                actualModifiers = actualModifiers &amp; ~Opcodes.ACC_STATIC;</b>
&nbsp;            }
<b class="pc">&nbsp;            return superFlag ? (actualModifiers | Opcodes.ACC_SUPER) : actualModifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getGenericSignature() {
&nbsp;            try {
<b class="fc">&nbsp;                SignatureWriter signatureWriter = new SignatureWriter();</b>
<b class="fc">&nbsp;                boolean generic = false;</b>
<b class="pc">&nbsp;                for (Generic typeVariable : getTypeVariables()) {</b>
<b class="nc">&nbsp;                    signatureWriter.visitFormalTypeParameter(typeVariable.getSymbol());</b>
<b class="nc">&nbsp;                    for (Generic upperBound : typeVariable.getUpperBounds()) {</b>
<b class="nc">&nbsp;                        upperBound.accept(new Generic.Visitor.ForSignatureVisitor(upperBound.asErasure().isInterface()</b>
<b class="nc">&nbsp;                                ? signatureWriter.visitInterfaceBound()</b>
<b class="nc">&nbsp;                                : signatureWriter.visitClassBound()));</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    generic = true;</b>
<b class="nc">&nbsp;                }</b>
<b class="fc">&nbsp;                Generic superClass = getSuperClass();</b>
&nbsp;                // The object type itself is non generic and implicitly returns a non-generic signature
<b class="pc">&nbsp;                if (superClass == null) {</b>
<b class="nc">&nbsp;                    superClass = TypeDescription.Generic.OBJECT;</b>
&nbsp;                }
<b class="fc">&nbsp;                superClass.accept(new Generic.Visitor.ForSignatureVisitor(signatureWriter.visitSuperclass()));</b>
<b class="pc">&nbsp;                generic = generic || !superClass.getSort().isNonGeneric();</b>
<b class="fc">&nbsp;                for (Generic interfaceType : getInterfaces()) {</b>
<b class="fc">&nbsp;                    interfaceType.accept(new Generic.Visitor.ForSignatureVisitor(signatureWriter.visitInterface()));</b>
<b class="pc">&nbsp;                    generic = generic || !interfaceType.getSort().isNonGeneric();</b>
<b class="fc">&nbsp;                }</b>
<b class="pc">&nbsp;                return generic</b>
<b class="nc">&nbsp;                        ? signatureWriter.toString()</b>
&nbsp;                        : NON_GENERIC_SIGNATURE;
<b class="nc">&nbsp;            } catch (GenericSignatureFormatError ignored) {</b>
<b class="nc">&nbsp;                return NON_GENERIC_SIGNATURE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isSamePackage(TypeDescription typeDescription) {
<b class="fc">&nbsp;            PackageDescription thisPackage = getPackage(), otherPackage = typeDescription.getPackage();</b>
<b class="pc">&nbsp;            return thisPackage == null || otherPackage == null</b>
&nbsp;                    ? thisPackage == otherPackage
<b class="fc">&nbsp;                    : thisPackage.equals(otherPackage);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isVisibleTo(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return isPrimitive() || (isArray()</b>
<b class="pc">&nbsp;                    ? getComponentType().isVisibleTo(typeDescription)</b>
<b class="pc">&nbsp;                    : isPublic() || isProtected() || isSamePackage(typeDescription)/* || equals(typeDescription.asErasure()) */);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAccessibleTo(TypeDescription typeDescription) {
<b class="nc">&nbsp;            return isPrimitive() || (isArray()</b>
<b class="nc">&nbsp;                    ? getComponentType().isVisibleTo(typeDescription)</b>
<b class="nc">&nbsp;                    : isPublic() || isSamePackage(typeDescription)/* || equals(typeDescription.asErasure()) */);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getInheritedAnnotations() {
<b class="nc">&nbsp;            Generic superClass = getSuperClass();</b>
<b class="nc">&nbsp;            AnnotationList declaredAnnotations = getDeclaredAnnotations();</b>
<b class="nc">&nbsp;            if (superClass == null) {</b>
<b class="nc">&nbsp;                return declaredAnnotations;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                Set&lt;TypeDescription&gt; annotationTypes = new HashSet&lt;TypeDescription&gt;();</b>
<b class="nc">&nbsp;                for (AnnotationDescription annotationDescription : declaredAnnotations) {</b>
<b class="nc">&nbsp;                    annotationTypes.add(annotationDescription.getAnnotationType());</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return new AnnotationList.Explicit(CompoundList.of(declaredAnnotations, superClass.asErasure().getInheritedAnnotations().inherited(annotationTypes)));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getActualName() {
<b class="pc">&nbsp;            if (isArray()) {</b>
<b class="nc">&nbsp;                TypeDescription typeDescription = this;</b>
<b class="nc">&nbsp;                int dimensions = 0;</b>
&nbsp;                do {
<b class="nc">&nbsp;                    dimensions++;</b>
<b class="nc">&nbsp;                    typeDescription = typeDescription.getComponentType();</b>
<b class="nc">&nbsp;                } while (typeDescription.isArray());</b>
<b class="nc">&nbsp;                StringBuilder stringBuilder = new StringBuilder();</b>
<b class="nc">&nbsp;                stringBuilder.append(typeDescription.getActualName());</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; dimensions; i++) {</b>
<b class="nc">&nbsp;                    stringBuilder.append(&quot;[]&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                return stringBuilder.toString();</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return getName();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isConstantPool() {
<b class="nc">&nbsp;            return represents(int.class)</b>
<b class="nc">&nbsp;                    || represents(long.class)</b>
<b class="nc">&nbsp;                    || represents(float.class)</b>
<b class="nc">&nbsp;                    || represents(double.class)</b>
<b class="nc">&nbsp;                    || represents(String.class)</b>
<b class="nc">&nbsp;                    || represents(Class.class)</b>
<b class="nc">&nbsp;                    || JavaType.METHOD_HANDLE.getTypeStub().equals(this)</b>
<b class="nc">&nbsp;                    || JavaType.METHOD_TYPE.getTypeStub().equals(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isPrimitiveWrapper() {
<b class="nc">&nbsp;            return represents(Boolean.class)</b>
<b class="nc">&nbsp;                    || represents(Byte.class)</b>
<b class="nc">&nbsp;                    || represents(Short.class)</b>
<b class="nc">&nbsp;                    || represents(Character.class)</b>
<b class="nc">&nbsp;                    || represents(Integer.class)</b>
<b class="nc">&nbsp;                    || represents(Long.class)</b>
<b class="nc">&nbsp;                    || represents(Float.class)</b>
<b class="nc">&nbsp;                    || represents(Double.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAnnotationReturnType() {
<b class="nc">&nbsp;            return isPrimitive()</b>
<b class="nc">&nbsp;                    || represents(String.class)</b>
<b class="nc">&nbsp;                    || (isAssignableTo(Enum.class) &amp;&amp; !represents(Enum.class))</b>
<b class="nc">&nbsp;                    || (isAssignableTo(Annotation.class) &amp;&amp; !represents(Annotation.class))</b>
<b class="nc">&nbsp;                    || represents(Class.class)</b>
<b class="nc">&nbsp;                    || (isArray() &amp;&amp; !getComponentType().isArray() &amp;&amp; getComponentType().isAnnotationReturnType());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAnnotationValue() {
<b class="nc">&nbsp;            return isPrimitive()</b>
<b class="nc">&nbsp;                    || represents(String.class)</b>
<b class="nc">&nbsp;                    || isAssignableTo(TypeDescription.class)</b>
<b class="nc">&nbsp;                    || isAssignableTo(AnnotationDescription.class)</b>
<b class="nc">&nbsp;                    || isAssignableTo(EnumerationDescription.class)</b>
<b class="nc">&nbsp;                    || (isArray() &amp;&amp; !getComponentType().isArray() &amp;&amp; getComponentType().isAnnotationValue());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @SuppressFBWarnings(value = &quot;EC_UNRELATED_CLASS_AND_INTERFACE&quot;, justification = &quot;Fits equality contract for type definitions&quot;)
&nbsp;        public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;            return equals(Sort.describe(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getTypeName() {
<b class="nc">&nbsp;            return getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeVariableSource getEnclosingSource() {
<b class="nc">&nbsp;            MethodDescription enclosingMethod = getEnclosingMethod();</b>
<b class="nc">&nbsp;            return enclosingMethod == null</b>
<b class="nc">&nbsp;                    ? (isStatic() ? TypeVariableSource.UNDEFINED : getEnclosingType()) // Top-level classes (non-static) have no enclosing type.</b>
&nbsp;                    : enclosingMethod;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public &lt;T&gt; T accept(TypeVariableSource.Visitor&lt;T&gt; visitor) {
<b class="nc">&nbsp;            return visitor.onType(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isPackageType() {
<b class="nc">&nbsp;            return getSimpleName().equals(PackageDescription.PACKAGE_CLASS_NAME);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isGenerified() {
<b class="pc">&nbsp;            if (!getTypeVariables().isEmpty()) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="pc">&nbsp;            } else if (isStatic()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            TypeDescription declaringType = getDeclaringType();</b>
<b class="pc">&nbsp;            return declaringType != null &amp;&amp; declaringType.isGenerified();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getInnerClassCount() {
<b class="fc">&nbsp;            if (isStatic()) {</b>
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="fc">&nbsp;            TypeDescription declaringType = getDeclaringType();</b>
<b class="fc">&nbsp;            return declaringType == null</b>
&nbsp;                    ? 0
<b class="fc">&nbsp;                    : declaringType.getInnerClassCount() + 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isInnerClass() {
<b class="nc">&nbsp;            return !isStatic() &amp;&amp; isNestedClass();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isNestedClass() {
<b class="nc">&nbsp;            return getDeclaringType() != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription asBoxed() {
<b class="nc">&nbsp;            if (represents(boolean.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(Boolean.class);</b>
<b class="nc">&nbsp;            } else if (represents(byte.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(Byte.class);</b>
<b class="nc">&nbsp;            } else if (represents(short.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(Short.class);</b>
<b class="nc">&nbsp;            } else if (represents(char.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(Character.class);</b>
<b class="nc">&nbsp;            } else if (represents(int.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(Integer.class);</b>
<b class="nc">&nbsp;            } else if (represents(long.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(Long.class);</b>
<b class="nc">&nbsp;            } else if (represents(float.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(Float.class);</b>
<b class="nc">&nbsp;            } else if (represents(double.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(Double.class);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription asUnboxed() {
<b class="nc">&nbsp;            if (represents(Boolean.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(boolean.class);</b>
<b class="nc">&nbsp;            } else if (represents(Byte.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(byte.class);</b>
<b class="nc">&nbsp;            } else if (represents(Short.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(short.class);</b>
<b class="nc">&nbsp;            } else if (represents(Character.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(char.class);</b>
<b class="nc">&nbsp;            } else if (represents(Integer.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(int.class);</b>
<b class="nc">&nbsp;            } else if (represents(Long.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(long.class);</b>
<b class="nc">&nbsp;            } else if (represents(Float.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(float.class);</b>
<b class="nc">&nbsp;            } else if (represents(Double.class)) {</b>
<b class="nc">&nbsp;                return ForLoadedType.of(double.class);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object getDefaultValue() {
<b class="nc">&nbsp;            if (represents(boolean.class)) {</b>
<b class="nc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            } else if (represents(byte.class)) {</b>
<b class="nc">&nbsp;                return (byte) 0;</b>
<b class="nc">&nbsp;            } else if (represents(short.class)) {</b>
<b class="nc">&nbsp;                return (short) 0;</b>
<b class="nc">&nbsp;            } else if (represents(char.class)) {</b>
<b class="nc">&nbsp;                return (char) 0;</b>
<b class="nc">&nbsp;            } else if (represents(int.class)) {</b>
<b class="nc">&nbsp;                return 0;</b>
<b class="nc">&nbsp;            } else if (represents(long.class)) {</b>
<b class="nc">&nbsp;                return 0L;</b>
<b class="nc">&nbsp;            } else if (represents(float.class)) {</b>
<b class="nc">&nbsp;                return 0f;</b>
<b class="nc">&nbsp;            } else if (represents(double.class)) {</b>
<b class="nc">&nbsp;                return 0d;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="fc">&nbsp;            return new SuperClassIterator(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="fc">&nbsp;                return true;</b>
<b class="pc">&nbsp;            } else if (!(other instanceof TypeDefinition)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            TypeDefinition typeDefinition = (TypeDefinition) other;</b>
<b class="pc">&nbsp;            return typeDefinition.getSort().isNonGeneric() &amp;&amp; getName().equals(typeDefinition.asErasure().getName());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return getName().hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return (isPrimitive() ? &quot;&quot; : (isInterface() ? &quot;interface&quot; : &quot;class&quot;) + &quot; &quot;) + getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An adapter implementation of a {@link TypeDescription} that
&nbsp;         * describes any type that is not an array or a primitive type.
&nbsp;         */
<b class="fc">&nbsp;        public abstract static class OfSimpleType extends TypeDescription.AbstractBase {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isPrimitive() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isArray() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription getComponentType() {
<b class="nc">&nbsp;                return TypeDescription.UNDEFINED;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getDescriptor() {
<b class="fc">&nbsp;                return &quot;L&quot; + getInternalName() + &quot;;&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getCanonicalName() {
<b class="nc">&nbsp;                if (isAnonymousClass() || isLocalClass()) {</b>
<b class="nc">&nbsp;                    return NO_NAME;</b>
&nbsp;                }
<b class="nc">&nbsp;                String internalName = getInternalName();</b>
<b class="nc">&nbsp;                TypeDescription enclosingType = getEnclosingType();</b>
<b class="nc">&nbsp;                if (enclosingType != null &amp;&amp; internalName.startsWith(enclosingType.getInternalName() + &quot;$&quot;)) {</b>
<b class="nc">&nbsp;                    return enclosingType.getCanonicalName() + &quot;.&quot; + internalName.substring(enclosingType.getInternalName().length() + 1);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return getName();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getSimpleName() {
<b class="nc">&nbsp;                String internalName = getInternalName();</b>
<b class="nc">&nbsp;                TypeDescription enclosingType = getEnclosingType();</b>
&nbsp;                int simpleNameIndex;
<b class="nc">&nbsp;                if (enclosingType != null &amp;&amp; internalName.startsWith(enclosingType.getInternalName() + &quot;$&quot;)) {</b>
<b class="nc">&nbsp;                    simpleNameIndex = enclosingType.getInternalName().length() + 1;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    simpleNameIndex = internalName.lastIndexOf(&#39;/&#39;);</b>
<b class="nc">&nbsp;                    if (simpleNameIndex == -1) {</b>
<b class="nc">&nbsp;                        return internalName;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                while (simpleNameIndex &lt; internalName.length() &amp;&amp; !Character.isLetter(internalName.charAt(simpleNameIndex))) {</b>
<b class="nc">&nbsp;                    simpleNameIndex += 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                return internalName.substring(simpleNameIndex);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                return StackSize.SINGLE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation of a type description that delegates all properties but the type&#39;s name to a delegate.
&nbsp;             */
&nbsp;            public abstract static class WithDelegation extends OfSimpleType {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the delegate type description to this type instance.
&nbsp;                 *
&nbsp;                 * @return The delegate type description.
&nbsp;                 */
&nbsp;                protected abstract TypeDescription delegate();
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getSuperClass() {
&nbsp;                    return delegate().getSuperClass();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    return delegate().getInterfaces();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;                    return delegate().getDeclaredFields();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;                    return delegate().getDeclaredMethods();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return delegate().getDeclaringType();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDescription getEnclosingMethod() {
&nbsp;                    return delegate().getEnclosingMethod();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription getEnclosingType() {
&nbsp;                    return delegate().getEnclosingType();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList getDeclaredTypes() {
&nbsp;                    return delegate().getDeclaredTypes();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isAnonymousClass() {
&nbsp;                    return delegate().isAnonymousClass();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isLocalClass() {
&nbsp;                    return delegate().isLocalClass();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isMemberClass() {
&nbsp;                    return delegate().isMemberClass();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public PackageDescription getPackage() {
&nbsp;                    return delegate().getPackage();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return delegate().getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return delegate().getTypeVariables();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int getModifiers() {
&nbsp;                    return delegate().getModifiers();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getGenericSignature() {
&nbsp;                    // Embrace use of native generic signature by direct delegation.
&nbsp;                    return delegate().getGenericSignature();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int getActualModifiers(boolean superFlag) {
&nbsp;                    // Embrace use of native actual modifiers by direct delegation.
&nbsp;                    return delegate().getActualModifiers(superFlag);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type description implementation that represents a loaded type.
&nbsp;     */
&nbsp;    class ForLoadedType extends AbstractBase implements Serializable {
&nbsp;
&nbsp;        /**
&nbsp;         * The class&#39;s serial version UID.
&nbsp;         */
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        /**
&nbsp;         * A cache of type descriptions for commonly used types to avoid unnecessary allocations.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;MS_MUTABLE_COLLECTION_PKGPROTECT&quot;, justification = &quot;This collection is not exposed.&quot;)
&nbsp;        private static final Map&lt;Class&lt;?&gt;, TypeDescription&gt; TYPE_CACHE;
&nbsp;
&nbsp;        /*
&nbsp;         * Initializes the type cache.
&nbsp;         */
&nbsp;        static {
<b class="fc">&nbsp;            TYPE_CACHE = new HashMap&lt;Class&lt;?&gt;, TypeDescription&gt;();</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(TargetType.class, new ForLoadedType(TargetType.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Object.class, new ForLoadedType(Object.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(String.class, new ForLoadedType(String.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Boolean.class, new ForLoadedType(Boolean.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Byte.class, new ForLoadedType(Byte.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Short.class, new ForLoadedType(Short.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Character.class, new ForLoadedType(Character.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Integer.class, new ForLoadedType(Integer.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Long.class, new ForLoadedType(Long.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Float.class, new ForLoadedType(Float.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Double.class, new ForLoadedType(Double.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(void.class, new ForLoadedType(void.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(boolean.class, new ForLoadedType(boolean.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(byte.class, new ForLoadedType(byte.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(short.class, new ForLoadedType(short.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(char.class, new ForLoadedType(char.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(int.class, new ForLoadedType(int.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(long.class, new ForLoadedType(long.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(float.class, new ForLoadedType(float.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(double.class, new ForLoadedType(double.class));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The loaded type this instance represents.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; type;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new immutable type description for a loaded type. This constructor should not normally be used.
&nbsp;         * Use {@link ForLoadedType#of(Class)} instead.
&nbsp;         *
&nbsp;         * @param type The type to be represented by this type description.
&nbsp;         */
<b class="fc">&nbsp;        public ForLoadedType(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;            this.type = type;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type&#39;s actual name where it is taken into consideration that this type might be loaded anonymously.
&nbsp;         * In this case, the remainder of the types name is suffixed by {@code /&lt;id&gt;} which is removed when using this method
&nbsp;         * but is retained when calling {@link Class#getName()}.
&nbsp;         *
&nbsp;         * @param type The type for which to resolve its name.
&nbsp;         * @return The type&#39;s actual name.
&nbsp;         */
&nbsp;        public static String getName(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            String name = type.getName();</b>
<b class="fc">&nbsp;            int anonymousLoaderIndex = name.indexOf(&#39;/&#39;);</b>
<b class="pc">&nbsp;            return anonymousLoaderIndex == -1</b>
&nbsp;                    ? name
<b class="nc">&nbsp;                    : name.substring(0, anonymousLoaderIndex);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a new immutable type description for a loaded type.
&nbsp;         *
&nbsp;         * @param type The type to be represented by this type description.
&nbsp;         * @return The type description representing the given type.
&nbsp;         */
&nbsp;        public static TypeDescription of(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            TypeDescription typeDescription = TYPE_CACHE.get(type);</b>
<b class="fc">&nbsp;            return typeDescription == null</b>
&nbsp;                    ? new ForLoadedType(type)
&nbsp;                    : typeDescription;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAssignableFrom(Class&lt;?&gt; type) {
<b class="pc">&nbsp;            return this.type.isAssignableFrom(type) || super.isAssignableFrom(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAssignableFrom(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; type.isAssignableFrom(((ForLoadedType) typeDescription).type) || super.isAssignableFrom(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAssignableTo(Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return type.isAssignableFrom(this.type) || super.isAssignableTo(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAssignableTo(TypeDescription typeDescription) {
<b class="pc">&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; ((ForLoadedType) typeDescription).type.isAssignableFrom(type) || super.isAssignableTo(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean represents(java.lang.reflect.Type type) {
<b class="pc">&nbsp;            return type == this.type || super.represents(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getComponentType() {
<b class="fc">&nbsp;            Class&lt;?&gt; componentType = type.getComponentType();</b>
<b class="pc">&nbsp;            return componentType == null</b>
&nbsp;                    ? TypeDescription.UNDEFINED
<b class="fc">&nbsp;                    : ForLoadedType.of(componentType);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isArray() {
<b class="fc">&nbsp;            return type.isArray();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isPrimitive() {
<b class="fc">&nbsp;            return type.isPrimitive();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAnnotation() {
<b class="fc">&nbsp;            return type.isAnnotation();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Generic getSuperClass() {
<b class="pc">&nbsp;            if (RAW_TYPES) {</b>
<b class="nc">&nbsp;                return type.getSuperclass() == null</b>
&nbsp;                        ? TypeDescription.Generic.UNDEFINED
<b class="nc">&nbsp;                        : Generic.OfNonGenericType.ForLoadedType.of(type.getSuperclass());</b>
&nbsp;            }
<b class="fc">&nbsp;            return type.getSuperclass() == null</b>
&nbsp;                    ? TypeDescription.Generic.UNDEFINED
&nbsp;                    : new Generic.LazyProjection.ForLoadedSuperClass(type);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getInterfaces() {
<b class="pc">&nbsp;            if (RAW_TYPES) {</b>
<b class="nc">&nbsp;                return isArray()</b>
&nbsp;                        ? ARRAY_INTERFACES
<b class="nc">&nbsp;                        : new TypeList.Generic.ForLoadedTypes(type.getInterfaces());</b>
&nbsp;            }
<b class="pc">&nbsp;            return isArray()</b>
&nbsp;                    ? ARRAY_INTERFACES
&nbsp;                    : new TypeList.Generic.OfLoadedInterfaceTypes(type);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            Class&lt;?&gt; declaringType = type.getDeclaringClass();</b>
<b class="fc">&nbsp;            return declaringType == null</b>
&nbsp;                    ? TypeDescription.UNDEFINED
<b class="fc">&nbsp;                    : ForLoadedType.of(declaringType);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodDescription getEnclosingMethod() {
<b class="nc">&nbsp;            Method enclosingMethod = type.getEnclosingMethod();</b>
<b class="nc">&nbsp;            Constructor&lt;?&gt; enclosingConstructor = type.getEnclosingConstructor();</b>
<b class="nc">&nbsp;            if (enclosingMethod != null) {</b>
<b class="nc">&nbsp;                return new MethodDescription.ForLoadedMethod(enclosingMethod);</b>
<b class="nc">&nbsp;            } else if (enclosingConstructor != null) {</b>
<b class="nc">&nbsp;                return new MethodDescription.ForLoadedConstructor(enclosingConstructor);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return MethodDescription.UNDEFINED;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getEnclosingType() {
<b class="fc">&nbsp;            Class&lt;?&gt; enclosingType = type.getEnclosingClass();</b>
<b class="pc">&nbsp;            return enclosingType == null</b>
&nbsp;                    ? TypeDescription.UNDEFINED
<b class="nc">&nbsp;                    : ForLoadedType.of(enclosingType);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList getDeclaredTypes() {
<b class="nc">&nbsp;            return new TypeList.ForLoadedTypes(type.getDeclaredClasses());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getSimpleName() {
<b class="nc">&nbsp;            String simpleName = type.getSimpleName();</b>
<b class="nc">&nbsp;            int anonymousLoaderIndex = simpleName.indexOf(&#39;/&#39;);</b>
<b class="nc">&nbsp;            if (anonymousLoaderIndex == -1) {</b>
<b class="nc">&nbsp;                return simpleName;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                StringBuilder normalized = new StringBuilder(simpleName.substring(0, anonymousLoaderIndex));</b>
<b class="nc">&nbsp;                Class&lt;?&gt; type = this.type;</b>
<b class="nc">&nbsp;                while (type.isArray()) {</b>
<b class="nc">&nbsp;                    normalized.append(&quot;[]&quot;);</b>
<b class="nc">&nbsp;                    type = type.getComponentType();</b>
&nbsp;                }
<b class="nc">&nbsp;                return normalized.toString();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAnonymousClass() {
<b class="nc">&nbsp;            return type.isAnonymousClass();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isLocalClass() {
<b class="nc">&nbsp;            return type.isLocalClass();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isMemberClass() {
<b class="nc">&nbsp;            return type.isMemberClass();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
<b class="nc">&nbsp;            return new FieldList.ForLoadedFields(type.getDeclaredFields());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;            return new MethodList.ForLoadedMethods(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PackageDescription getPackage() {
<b class="pc">&nbsp;            if (type.isArray() || type.isPrimitive()) {</b>
<b class="nc">&nbsp;                return PackageDescription.UNDEFINED;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                Package aPackage = type.getPackage();</b>
<b class="pc">&nbsp;                if (aPackage == null) {</b>
<b class="nc">&nbsp;                    String name = type.getName();</b>
<b class="nc">&nbsp;                    int index = name.lastIndexOf(&#39;.&#39;);</b>
<b class="nc">&nbsp;                    return index == -1</b>
&nbsp;                            ? new PackageDescription.Simple(EMPTY_NAME)
<b class="nc">&nbsp;                            : new PackageDescription.Simple(name.substring(0, index));</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new PackageDescription.ForLoadedPackage(aPackage);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public StackSize getStackSize() {
<b class="fc">&nbsp;            return StackSize.of(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return getName(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getCanonicalName() {
<b class="nc">&nbsp;            String canonicalName = type.getCanonicalName();</b>
<b class="nc">&nbsp;            if (canonicalName == null) {</b>
<b class="nc">&nbsp;                return NO_NAME;</b>
&nbsp;            }
<b class="nc">&nbsp;            int anonymousLoaderIndex = canonicalName.indexOf(&#39;/&#39;);</b>
<b class="nc">&nbsp;            if (anonymousLoaderIndex == -1) {</b>
<b class="nc">&nbsp;                return canonicalName;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                StringBuilder normalized = new StringBuilder(canonicalName.substring(0, anonymousLoaderIndex));</b>
<b class="nc">&nbsp;                Class&lt;?&gt; type = this.type;</b>
<b class="nc">&nbsp;                while (type.isArray()) {</b>
<b class="nc">&nbsp;                    normalized.append(&quot;[]&quot;);</b>
<b class="nc">&nbsp;                    type = type.getComponentType();</b>
&nbsp;                }
<b class="nc">&nbsp;                return normalized.toString();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            String name = type.getName();</b>
<b class="fc">&nbsp;            int anonymousLoaderIndex = name.indexOf(&#39;/&#39;);</b>
<b class="pc">&nbsp;            return anonymousLoaderIndex == -1</b>
<b class="fc">&nbsp;                    ? Type.getDescriptor(type)</b>
<b class="nc">&nbsp;                    : &quot;L&quot; + name.substring(0, anonymousLoaderIndex).replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return type.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="pc">&nbsp;            if (RAW_TYPES) {</b>
<b class="nc">&nbsp;                return new TypeList.Generic.Empty();</b>
&nbsp;            }
<b class="fc">&nbsp;            return TypeList.Generic.ForLoadedTypes.OfTypeVariables.of(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.ForLoadedAnnotations(type.getDeclaredAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Generic asGenericType() {
<b class="fc">&nbsp;            return Generic.OfNonGenericType.ForLoadedType.of(type);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A projection for an array type based on an existing {@link TypeDescription}.
&nbsp;     */
&nbsp;    class ArrayProjection extends AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * Modifiers that every array in Java implies.
&nbsp;         */
&nbsp;        private static final int ARRAY_IMPLIED = Opcodes.ACC_FINAL | Opcodes.ACC_ABSTRACT;
&nbsp;
&nbsp;        /**
&nbsp;         * Modifiers that no array in Java displays.
&nbsp;         */
&nbsp;        private static final int ARRAY_EXCLUDED = Opcodes.ACC_INTERFACE | Opcodes.ACC_ANNOTATION | Opcodes.ACC_STATIC;
&nbsp;
&nbsp;        /**
&nbsp;         * The base component type which is itself not an array.
&nbsp;         */
&nbsp;        private final TypeDescription componentType;
&nbsp;
&nbsp;        /**
&nbsp;         * The arity of this array.
&nbsp;         */
&nbsp;        private final int arity;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new array projection.
&nbsp;         *
&nbsp;         * @param componentType The base component type of the array which is itself not an array.
&nbsp;         * @param arity         The arity of this array.
&nbsp;         */
<b class="fc">&nbsp;        protected ArrayProjection(TypeDescription componentType, int arity) {</b>
<b class="fc">&nbsp;            this.componentType = componentType;</b>
<b class="fc">&nbsp;            this.arity = arity;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an array projection of an arity of one.
&nbsp;         *
&nbsp;         * @param componentType The component type of the array.
&nbsp;         * @return A projection of the component type as an array of the given value with an arity of one.
&nbsp;         */
&nbsp;        public static TypeDescription of(TypeDescription componentType) {
<b class="nc">&nbsp;            return of(componentType, 1);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an array projection.
&nbsp;         *
&nbsp;         * @param componentType The component type of the array.
&nbsp;         * @param arity         The arity of this array.
&nbsp;         * @return A projection of the component type as an array of the given value with the supplied arity.
&nbsp;         */
&nbsp;        public static TypeDescription of(TypeDescription componentType, int arity) {
<b class="pc">&nbsp;            if (arity &lt; 0) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Arrays cannot have a negative arity&quot;);</b>
&nbsp;            }
<b class="pc">&nbsp;            while (componentType.isArray()) {</b>
<b class="nc">&nbsp;                componentType = componentType.getComponentType();</b>
<b class="nc">&nbsp;                arity++;</b>
&nbsp;            }
<b class="pc">&nbsp;            return arity == 0</b>
&nbsp;                    ? componentType
&nbsp;                    : new ArrayProjection(componentType, arity);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isArray() {
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getComponentType() {
<b class="pc">&nbsp;            return arity == 1</b>
&nbsp;                    ? componentType
&nbsp;                    : new ArrayProjection(componentType, arity - 1);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isPrimitive() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Generic getSuperClass() {
<b class="nc">&nbsp;            return TypeDescription.Generic.OBJECT;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getInterfaces() {
<b class="nc">&nbsp;            return ARRAY_INTERFACES;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodDescription getEnclosingMethod() {
<b class="nc">&nbsp;            return MethodDescription.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getEnclosingType() {
<b class="nc">&nbsp;            return TypeDescription.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList getDeclaredTypes() {
<b class="nc">&nbsp;            return new TypeList.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getSimpleName() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder(componentType.getSimpleName());</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; arity; i++) {</b>
<b class="nc">&nbsp;                stringBuilder.append(&quot;[]&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return stringBuilder.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getCanonicalName() {
<b class="nc">&nbsp;            String canonicalName = componentType.getCanonicalName();</b>
<b class="nc">&nbsp;            if (canonicalName == null) {</b>
<b class="nc">&nbsp;                return NO_NAME;</b>
&nbsp;            }
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder(canonicalName);</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; arity; i++) {</b>
<b class="nc">&nbsp;                stringBuilder.append(&quot;[]&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return stringBuilder.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAnonymousClass() {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isLocalClass() {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isMemberClass() {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
<b class="nc">&nbsp;            return new FieldList.Empty&lt;FieldDescription.InDefinedShape&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
<b class="nc">&nbsp;            return new MethodList.Empty&lt;MethodDescription.InDefinedShape&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public StackSize getStackSize() {
<b class="nc">&nbsp;            return StackSize.SINGLE;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;            return new AnnotationList.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getInheritedAnnotations() {
<b class="nc">&nbsp;            return new AnnotationList.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PackageDescription getPackage() {
<b class="nc">&nbsp;            return PackageDescription.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="fc">&nbsp;            String descriptor = componentType.getDescriptor();</b>
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder(descriptor.length() + arity);</b>
<b class="fc">&nbsp;            for (int index = 0; index &lt; arity; index++) {</b>
<b class="fc">&nbsp;                stringBuilder.append(&#39;[&#39;);</b>
&nbsp;            }
<b class="fc">&nbsp;            for (int index = 0; index &lt; descriptor.length(); index++) {</b>
<b class="fc">&nbsp;                char character = descriptor.charAt(index);</b>
<b class="fc">&nbsp;                stringBuilder.append(character == &#39;/&#39; ? &#39;.&#39; : character);</b>
&nbsp;            }
<b class="fc">&nbsp;            return stringBuilder.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; arity; i++) {</b>
<b class="fc">&nbsp;                stringBuilder.append(&#39;[&#39;);</b>
&nbsp;            }
<b class="fc">&nbsp;            return stringBuilder.append(componentType.getDescriptor()).toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return TypeDescription.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return (getComponentType().getModifiers() &amp; ~ARRAY_EXCLUDED) | ARRAY_IMPLIED;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="nc">&nbsp;            return new TypeList.Generic.Empty();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A latent type description for a type without methods or fields.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: This type does not define most of its properties and should only be used as a simple placeholder. For more
&nbsp;     * complex placeholders, use an {@link net.bytebuddy.dynamic.scaffold.InstrumentedType.Default}.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    class Latent extends AbstractBase.OfSimpleType {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the type.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The modifiers of the type.
&nbsp;         */
&nbsp;        private final int modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * The super type or {@code null} if no such type exists.
&nbsp;         */
&nbsp;        private final Generic superClass;
&nbsp;
&nbsp;        /**
&nbsp;         * The interfaces that this type implements.
&nbsp;         */
&nbsp;        private final List&lt;? extends Generic&gt; interfaces;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent type.
&nbsp;         *
&nbsp;         * @param name        The name of the type.
&nbsp;         * @param modifiers   The modifiers of the type.
&nbsp;         * @param superClass  The super type or {@code null} if no such type exists.
&nbsp;         * @param anInterface The interfaces that this type implements.
&nbsp;         */
&nbsp;        public Latent(String name, int modifiers, Generic superClass, Generic... anInterface) {
&nbsp;            this(name, modifiers, superClass, Arrays.asList(anInterface));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent type.
&nbsp;         *
&nbsp;         * @param name       The name of the type.
&nbsp;         * @param modifiers  The modifiers of the type.
&nbsp;         * @param superClass The super type or {@code null} if no such type exists.
&nbsp;         * @param interfaces The interfaces that this type implements.
&nbsp;         */
&nbsp;        public Latent(String name, int modifiers, Generic superClass, List&lt;? extends Generic&gt; interfaces) {
&nbsp;            this.name = name;
&nbsp;            this.modifiers = modifiers;
&nbsp;            this.superClass = superClass;
&nbsp;            this.interfaces = interfaces;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Generic getSuperClass() {
&nbsp;            return superClass;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            return new TypeList.Generic.Explicit(interfaces);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodDescription getEnclosingMethod() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve enclosing method of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve enclosing type of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve inner types of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAnonymousClass() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve anonymous type property of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isLocalClass() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve local class property of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isMemberClass() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve member class property of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared fields of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared methods of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PackageDescription getPackage() {
&nbsp;            String name = getName();
&nbsp;            int index = name.lastIndexOf(&#39;.&#39;);
&nbsp;            return new PackageDescription.Simple(index == -1
&nbsp;                    ? EMPTY_NAME
&nbsp;                    : name.substring(0, index));
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared annotations of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared type of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
&nbsp;            return modifiers;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
&nbsp;            return name;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve type variables of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type representation of a package description.
&nbsp;     */
&nbsp;    class ForPackageDescription extends AbstractBase.OfSimpleType {
&nbsp;
&nbsp;        /**
&nbsp;         * The package to be described as a type.
&nbsp;         */
&nbsp;        private final PackageDescription packageDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type description of a package description.
&nbsp;         *
&nbsp;         * @param packageDescription The package to be described as a type.
&nbsp;         */
&nbsp;        public ForPackageDescription(PackageDescription packageDescription) {
&nbsp;            this.packageDescription = packageDescription;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Generic getSuperClass() {
&nbsp;            return TypeDescription.Generic.OBJECT;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            return new TypeList.Generic.Empty();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodDescription getEnclosingMethod() {
&nbsp;            return MethodDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            return TypeDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAnonymousClass() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isLocalClass() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isMemberClass() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            return new TypeList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            return new FieldList.Empty&lt;FieldDescription.InDefinedShape&gt;();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;            return new MethodList.Empty&lt;MethodDescription.InDefinedShape&gt;();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PackageDescription getPackage() {
&nbsp;            return packageDescription;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            return packageDescription.getDeclaredAnnotations();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return TypeDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return new TypeList.Generic.Empty();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
&nbsp;            return PackageDescription.PACKAGE_MODIFIERS;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
&nbsp;            return packageDescription.getName() + &quot;.&quot; + PackageDescription.PACKAGE_CLASS_NAME;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A delegating type description that always attempts to load the super types of a delegate type.
&nbsp;     */
&nbsp;    class SuperTypeLoading extends AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The delegate type description.
&nbsp;         */
&nbsp;        private final TypeDescription delegate;
&nbsp;
&nbsp;        /**
&nbsp;         * The class loader to use for loading a super type.
&nbsp;         */
&nbsp;        private final ClassLoader classLoader;
&nbsp;
&nbsp;        /**
&nbsp;         * A delegate for loading a type.
&nbsp;         */
&nbsp;        private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a super type loading type description.
&nbsp;         *
&nbsp;         * @param delegate    The delegate type description.
&nbsp;         * @param classLoader The class loader to use for loading a super type.
&nbsp;         */
&nbsp;        public SuperTypeLoading(TypeDescription delegate, ClassLoader classLoader) {
&nbsp;            this(delegate, classLoader, ClassLoadingDelegate.Simple.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a super type loading type description.
&nbsp;         *
&nbsp;         * @param delegate             The delegate type description.
&nbsp;         * @param classLoader          The class loader to use for loading a super type.
&nbsp;         * @param classLoadingDelegate A delegate for loading a type.
&nbsp;         */
&nbsp;        public SuperTypeLoading(TypeDescription delegate, ClassLoader classLoader, ClassLoadingDelegate classLoadingDelegate) {
&nbsp;            this.delegate = delegate;
&nbsp;            this.classLoader = classLoader;
&nbsp;            this.classLoadingDelegate = classLoadingDelegate;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            return delegate.getDeclaredAnnotations();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
&nbsp;            return delegate.getModifiers();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return delegate.getTypeVariables();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDescriptor() {
&nbsp;            return delegate.getDescriptor();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
&nbsp;            return delegate.getName();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Generic getSuperClass() {
&nbsp;            Generic superClass = delegate.getSuperClass();
&nbsp;            return superClass == null
&nbsp;                    ? Generic.UNDEFINED
&nbsp;                    : new ClassLoadingTypeProjection(superClass, classLoader, classLoadingDelegate);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            return new ClassLoadingTypeList(delegate.getInterfaces(), classLoader, classLoadingDelegate);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            return delegate.getDeclaredFields();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;            return delegate.getDeclaredMethods();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public StackSize getStackSize() {
&nbsp;            return delegate.getStackSize();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isArray() {
&nbsp;            return delegate.isArray();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isPrimitive() {
&nbsp;            return delegate.isPrimitive();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getComponentType() {
&nbsp;            return delegate.getComponentType();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return delegate.getDeclaringType();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            return delegate.getDeclaredTypes();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodDescription getEnclosingMethod() {
&nbsp;            return delegate.getEnclosingMethod();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            return delegate.getEnclosingType();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getSimpleName() {
&nbsp;            return delegate.getSimpleName();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getCanonicalName() {
&nbsp;            return delegate.getCanonicalName();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAnonymousClass() {
&nbsp;            return delegate.isAnonymousClass();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isLocalClass() {
&nbsp;            return delegate.isLocalClass();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isMemberClass() {
&nbsp;            return delegate.isMemberClass();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PackageDescription getPackage() {
&nbsp;            return delegate.getPackage();
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A class loading delegate is responsible for resolving a type given a class loader and a type name.
&nbsp;         */
&nbsp;        public interface ClassLoadingDelegate {
&nbsp;
&nbsp;            /**
&nbsp;             * Loads a type.
&nbsp;             *
&nbsp;             * @param name        The type&#39;s name,
&nbsp;             * @param classLoader The class loader to load the type from which might be {@code null} to represent the bootstrap class loader.
&nbsp;             * @return The loaded type.
&nbsp;             * @throws ClassNotFoundException If the type could not be found.
&nbsp;             */
&nbsp;            Class&lt;?&gt; load(String name, ClassLoader classLoader) throws ClassNotFoundException;
&nbsp;
&nbsp;            /**
&nbsp;             * A simple class loading delegate that simply loads a type.
&nbsp;             */
&nbsp;            enum Simple implements ClassLoadingDelegate {
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                @Override
&nbsp;                public Class&lt;?&gt; load(String name, ClassLoader classLoader) throws ClassNotFoundException {
&nbsp;                    return Class.forName(name, false, classLoader);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type projection that attempts to load any super type of the delegate type.
&nbsp;         */
&nbsp;        protected static class ClassLoadingTypeProjection extends TypeDescription.Generic.LazyProjection {
&nbsp;
&nbsp;            /**
&nbsp;             * The delegate type description.
&nbsp;             */
&nbsp;            private final Generic delegate;
&nbsp;
&nbsp;            /**
&nbsp;             * The class loader to use for loading types which might be {@code null} to represent the bootstrap class loader.
&nbsp;             */
&nbsp;            private final ClassLoader classLoader;
&nbsp;
&nbsp;            /**
&nbsp;             * A delegate for loading a type.
&nbsp;             */
&nbsp;            private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a class loading type description.
&nbsp;             *
&nbsp;             * @param delegate             The delegate type description.
&nbsp;             * @param classLoader          The class loader to use for loading types which might be {@code null} to represent the bootstrap class loader.
&nbsp;             * @param classLoadingDelegate A delegate for loading a type.
&nbsp;             */
&nbsp;            protected ClassLoadingTypeProjection(Generic delegate, ClassLoader classLoader, ClassLoadingDelegate classLoadingDelegate) {
&nbsp;                this.delegate = delegate;
&nbsp;                this.classLoader = classLoader;
&nbsp;                this.classLoadingDelegate = classLoadingDelegate;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationList getDeclaredAnnotations() {
&nbsp;                return delegate.getDeclaredAnnotations();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription asErasure() {
&nbsp;                try {
&nbsp;                    return ForLoadedType.of(classLoadingDelegate.load(delegate.asErasure().getName(), classLoader));
&nbsp;                } catch (ClassNotFoundException ignored) {
&nbsp;                    return delegate.asErasure();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Generic resolve() {
&nbsp;                return delegate;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getSuperClass() {
&nbsp;                Generic superClass = delegate.getSuperClass();
&nbsp;                if (superClass == null) {
&nbsp;                    return Generic.UNDEFINED;
&nbsp;                } else {
&nbsp;                    try {
&nbsp;                        return new ClassLoadingTypeProjection(superClass,
&nbsp;                                classLoadingDelegate.load(delegate.asErasure().getName(), classLoader).getClassLoader(),
&nbsp;                                classLoadingDelegate);
&nbsp;                    } catch (ClassNotFoundException ignored) {
&nbsp;                        return superClass;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                TypeList.Generic interfaces = delegate.getInterfaces();
&nbsp;                try {
&nbsp;                    return new ClassLoadingTypeList(interfaces,
&nbsp;                            classLoadingDelegate.load(delegate.asErasure().getName(), classLoader).getClassLoader(),
&nbsp;                            classLoadingDelegate);
&nbsp;                } catch (ClassNotFoundException ignored) {
&nbsp;                    return interfaces;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                return new SuperClassIterator(this);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type list that attempts loading any type.
&nbsp;         */
&nbsp;        protected static class ClassLoadingTypeList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The delegate type list.
&nbsp;             */
&nbsp;            private final TypeList.Generic delegate;
&nbsp;
&nbsp;            /**
&nbsp;             * The class loader to use for loading types which might be {@code null} to represent the bootstrap class loader.
&nbsp;             */
&nbsp;            private final ClassLoader classLoader;
&nbsp;
&nbsp;            /**
&nbsp;             * A delegate for loading a type.
&nbsp;             */
&nbsp;            private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a class loading type list.
&nbsp;             *
&nbsp;             * @param delegate             The delegate type list.
&nbsp;             * @param classLoader          The class loader to use for loading types which might be {@code null} to represent the bootstrap class loader.
&nbsp;             * @param classLoadingDelegate A delegate for loading a type.
&nbsp;             */
&nbsp;            protected ClassLoadingTypeList(TypeList.Generic delegate, ClassLoader classLoader, ClassLoadingDelegate classLoadingDelegate) {
&nbsp;                this.delegate = delegate;
&nbsp;                this.classLoader = classLoader;
&nbsp;                this.classLoadingDelegate = classLoadingDelegate;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic get(int index) {
&nbsp;                return new ClassLoadingTypeProjection(delegate.get(index), classLoader, classLoadingDelegate);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int size() {
&nbsp;                return delegate.size();
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
