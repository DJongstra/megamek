


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > DynamicType</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic</a>
</div>

<h1>Coverage Summary for Class: DynamicType (net.bytebuddy.dynamic)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">DynamicType$Builder</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    48,9%
  </span>
  <span class="absValue">
    (22/45)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27,5%
  </span>
  <span class="absValue">
    (22/80)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    55,6%
  </span>
  <span class="absValue">
    (10/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (24/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$FieldDefinitionAdapter</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (8/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodDefinitionAdapter</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (5/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    17,6%
  </span>
  <span class="absValue">
    (6/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodDefinitionAdapter$AnnotationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    42,9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16,2%
  </span>
  <span class="absValue">
    (6/37)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodDefinitionAdapter$SimpleParameterAnnotationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73,3%
  </span>
  <span class="absValue">
    (11/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodMatchAdapter</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71,4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodMatchAdapter$AnnotationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    57,1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$OptionalMethodMatchAdapter</td>
<td class="coverageStat">
  <span class="percent">
    57,1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (9/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Delegator</td>
<td class="coverageStat">
  <span class="percent">
    30,4%
  </span>
  <span class="absValue">
    (7/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    30,4%
  </span>
  <span class="absValue">
    (7/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional$Valuable</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional$Valuable$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    28,6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22,2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional$Valuable$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71,4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Valuable</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    14,3%
  </span>
  <span class="absValue">
    (1/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14,3%
  </span>
  <span class="absValue">
    (1/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ExceptionDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ExceptionDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ImplementationDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ImplementationDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ImplementationDefinition$Optional</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    16,7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16,7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Annotatable</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Initial</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Initial$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple$Annotatable</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple$Annotatable$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple$Annotatable$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    37,5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37,5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ReceiverTypeDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ReceiverTypeDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$TypeVariableDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$TypeVariableDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$TypeVariableDefinition$Annotatable</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$TypeVariableDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Default</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (4/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8,7%
  </span>
  <span class="absValue">
    (4/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16,7%
  </span>
  <span class="absValue">
    (18/108)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Default$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Default$Unloaded</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (4/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Loaded</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Unloaded</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    44,7%
  </span>
  <span class="absValue">
    (96/215)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10,5%
  </span>
  <span class="absValue">
    (8/76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    35,1%
  </span>
  <span class="absValue">
    (162/461)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.dynamic;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.asm.AsmVisitorWrapper;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.modifier.*;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeVariableToken;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
&nbsp;import net.bytebuddy.dynamic.loading.InjectionClassLoader;
&nbsp;import net.bytebuddy.dynamic.scaffold.*;
&nbsp;import net.bytebuddy.implementation.*;
&nbsp;import net.bytebuddy.implementation.attribute.*;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.LatentMatcher;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.*;
&nbsp;import java.util.*;
&nbsp;import java.util.jar.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * A dynamic type that is created at runtime, usually as the result of applying a
&nbsp; * {@link net.bytebuddy.dynamic.DynamicType.Builder} or as the result of an
&nbsp; * {@link net.bytebuddy.implementation.auxiliary.AuxiliaryType}.
&nbsp; * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp; * Note that the {@link TypeDescription}s will represent their
&nbsp; * unloaded forms and therefore differ from the loaded types, especially with regards to annotations.
&nbsp; */
&nbsp;public interface DynamicType {
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a description of this dynamic type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This description will most likely differ from the binary representation of this type. Normally,
&nbsp;     * annotations and intercepted methods are not added to this type description.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @return A description of this dynamic type.
&nbsp;     */
&nbsp;    TypeDescription getTypeDescription();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a byte array representing this dynamic type. This byte array might be reused by this dynamic type and
&nbsp;     * must therefore not be altered.
&nbsp;     *
&nbsp;     * @return A byte array of the type&#39;s binary representation.
&nbsp;     */
&nbsp;    byte[] getBytes();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a map of all auxiliary types that are required for making use of the main type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: The type descriptions will most likely differ from the binary representation of this type.
&nbsp;     * Normally, annotations and intercepted methods are not added to the type descriptions of auxiliary types.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @return A map of all auxiliary types by their descriptions to their binary representation.
&nbsp;     */
&nbsp;    Map&lt;TypeDescription, byte[]&gt; getAuxiliaryTypes();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns all types that are implied by this dynamic type.
&nbsp;     *
&nbsp;     * @return A mapping from all type descriptions, the actual type and its auxiliary types to their binary
&nbsp;     * representation
&nbsp;     */
&nbsp;    Map&lt;TypeDescription, byte[]&gt; getAllTypes();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a map of all loaded type initializers for the main type and all auxiliary types, if any.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: The type descriptions will most likely differ from the binary representation of this type.
&nbsp;     * Normally, annotations and intercepted methods are not added to the type descriptions of auxiliary types.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @return A mapping of all types&#39; descriptions to their loaded type initializers.
&nbsp;     */
&nbsp;    Map&lt;TypeDescription, LoadedTypeInitializer&gt; getLoadedTypeInitializers();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a dynamic type requires some form of explicit type initialization, either for itself or for one
&nbsp;     * of its auxiliary types, if any. This is the case when this dynamic type was defined to delegate method calls
&nbsp;     * to a specific instance which is stored in a field of the created type. If this class serialized, it could not
&nbsp;     * be used without its loaded type initializers since the field value represents a specific runtime context.
&nbsp;     *
&nbsp;     * @return {@code true} if this type requires explicit type initialization.
&nbsp;     */
&nbsp;    boolean hasAliveLoadedTypeInitializers();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Saves a dynamic type in a given folder using the Java class file format while respecting the naming conventions
&nbsp;     * for saving compiled Java classes. All auxiliary types, if any, are saved in the same directory. The resulting
&nbsp;     * folder structure will resemble the structure that is required for Java run times, i.e. each folder representing
&nbsp;     * a segment of the package name. If the specified {@code folder} does not yet exist, it is created during the
&nbsp;     * call of this method.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: The type descriptions will most likely differ from the binary representation of this type.
&nbsp;     * Normally, annotations and intercepted methods are not added to the type descriptions of auxiliary types.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param folder The base target folder for storing this dynamic type and its auxiliary types, if any.
&nbsp;     * @return A map of type descriptions pointing to files with their stored binary representations within {@code folder}.
&nbsp;     * @throws IOException Thrown if the underlying file operations cause an {@code IOException}.
&nbsp;     */
&nbsp;    Map&lt;TypeDescription, File&gt; saveIn(File folder) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Injects the types of this dynamic type into a given &lt;i&gt;jar&lt;/i&gt; file. Any pre-existent type with the same name
&nbsp;     * is overridden during injection. The {@code target} file&#39;s folder must exist prior to calling this method. The
&nbsp;     * file itself is overwritten or created depending on its prior existence.
&nbsp;     *
&nbsp;     * @param sourceJar The original jar file.
&nbsp;     * @param targetJar The {@code source} jar file with the injected contents.
&nbsp;     * @return The {@code target} jar file.
&nbsp;     * @throws IOException If an I/O exception occurs while injecting from the source into the target.
&nbsp;     */
&nbsp;    File inject(File sourceJar, File targetJar) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Injects the types of this dynamic type into a given &lt;i&gt;jar&lt;/i&gt; file. Any pre-existent type with the same name
&nbsp;     * is overridden during injection.
&nbsp;     *
&nbsp;     * @param jar The jar file to replace with an injected version.
&nbsp;     * @return The {@code jar} file.
&nbsp;     * @throws IOException If an I/O exception occurs while injecting into the jar.
&nbsp;     */
&nbsp;    File inject(File jar) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Saves the contents of this dynamic type inside a &lt;i&gt;jar&lt;/i&gt; file. The folder of the given {@code file} must
&nbsp;     * exist prior to calling this method. The jar file is created with a simple manifest that only contains a version
&nbsp;     * number.
&nbsp;     *
&nbsp;     * @param file The target file to which the &lt;i&gt;jar&lt;/i&gt; is written to.
&nbsp;     * @return The given {@code file}.
&nbsp;     * @throws IOException If an I/O exception occurs while writing the file.
&nbsp;     */
&nbsp;    File toJar(File file) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Saves the contents of this dynamic type inside a &lt;i&gt;jar&lt;/i&gt; file. The folder of the given {@code file} must
&nbsp;     * exist prior to calling this method.
&nbsp;     *
&nbsp;     * @param file     The target file to which the &lt;i&gt;jar&lt;/i&gt; is written to.
&nbsp;     * @param manifest The manifest of the created &lt;i&gt;jar&lt;/i&gt;.
&nbsp;     * @return The given {@code file}.
&nbsp;     * @throws IOException If an I/O exception occurs while writing the file.
&nbsp;     */
&nbsp;    File toJar(File file, Manifest manifest) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * A builder for creating a dynamic type.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;     */
&nbsp;    interface Builder&lt;T&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * Applies the supplied {@link AsmVisitorWrapper} onto the {@link net.bytebuddy.jar.asm.ClassVisitor} during building a dynamic type.
&nbsp;         * Using an ASM visitor, it is possible to manipulate byte code directly. Byte Buddy does not validate directly created byte code
&nbsp;         * and it remains the responsibility of the visitor&#39;s implementor to generate legal byte code. If several ASM visitor wrappers
&nbsp;         * are registered, they are applied on top of another in their registration order.
&nbsp;         *
&nbsp;         * @param asmVisitorWrapper The ASM visitor wrapper to apply during
&nbsp;         * @return A new builder that is equal to this builder and applies the ASM visitor wrapper.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; visit(AsmVisitorWrapper asmVisitorWrapper);
&nbsp;
&nbsp;        /**
&nbsp;         * Names the dynamic type by the supplied name. The name needs to be fully qualified and in the binary format (packages separated
&nbsp;         * by dots: {@code foo.Bar}). A type&#39;s package determines what other types are visible to the instrumented type and what methods
&nbsp;         * can be overridden or be represented in method signatures or as field types.
&nbsp;         *
&nbsp;         * @param name The fully qualified name of the generated class in a binary format.
&nbsp;         * @return A new builder that is equal to this builder but with the instrumented type named by the supplied name.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; name(String name);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied modifiers as the modifiers of the instrumented type.
&nbsp;         *
&nbsp;         * @param modifierContributor The modifiers of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied modifiers applied onto the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; modifiers(ModifierContributor.ForType... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied modifiers as the modifiers of the instrumented type.
&nbsp;         *
&nbsp;         * @param modifierContributors The modifiers of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied modifiers applied onto the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; modifiers(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied modifiers as the modifiers of the instrumented type.
&nbsp;         *
&nbsp;         * @param modifiers The modifiers of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied modifiers applied onto the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; modifiers(int modifiers);
&nbsp;
&nbsp;        /**
&nbsp;         * Merges the supplied modifier contributors with the modifiers of the instrumented type and defines them as the instrumented
&nbsp;         * type&#39;s new modifiers.
&nbsp;         *
&nbsp;         * @param modifierContributor The modifiers of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied modifiers merged into the instrumented type&#39;s modifiers.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; merge(ModifierContributor.ForType... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Merges the supplied modifier contributors with the modifiers of the instrumented type and defines them as the instrumented
&nbsp;         * type&#39;s new modifiers.
&nbsp;         *
&nbsp;         * @param modifierContributors The modifiers of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied modifiers merged into the instrumented type&#39;s modifiers.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; merge(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Applies the given type attribute appender onto the instrumented type. Using a type attribute appender, it is possible to append
&nbsp;         * any type of meta data to a type, not only Java {@link Annotation}s.
&nbsp;         *
&nbsp;         * @param typeAttributeAppender The type attribute appender to apply.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied type attribute appender applied to the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; attribute(TypeAttributeAppender typeAttributeAppender);
&nbsp;
&nbsp;        /**
&nbsp;         * Annotates the instrumented type with the supplied annotations.
&nbsp;         *
&nbsp;         * @param annotation The annotations to add to the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the annotations added to the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; annotateType(Annotation... annotation);
&nbsp;
&nbsp;        /**
&nbsp;         * Annotates the instrumented type with the supplied annotations.
&nbsp;         *
&nbsp;         * @param annotations The annotations to add to the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the annotations added to the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; annotateType(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;        /**
&nbsp;         * Annotates the instrumented type with the supplied annotations.
&nbsp;         *
&nbsp;         * @param annotation The annotations to add to the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the annotations added to the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; annotateType(AnnotationDescription... annotation);
&nbsp;
&nbsp;        /**
&nbsp;         * Annotates the instrumented type with the supplied annotations.
&nbsp;         *
&nbsp;         * @param annotations The annotations to add to the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the annotations added to the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; annotateType(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Implements the supplied interfaces for the instrumented type. Optionally, it is possible to define the
&nbsp;         * methods that are defined by the interfaces or the interfaces&#39; super interfaces. This excludes methods that
&nbsp;         * are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link Class} values are implemented
&nbsp;         * as raw types if they declare type variables or an owner type.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param interfaceType The interface types to implement.
&nbsp;         * @return A new builder that is equal to this builder but with the interfaces implemented by the instrumented type.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition.Optional&lt;T&gt; implement(Type... interfaceType);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Implements the supplied interfaces for the instrumented type. Optionally, it is possible to define the
&nbsp;         * methods that are defined by the interfaces or the interfaces&#39; super interfaces. This excludes methods that
&nbsp;         * are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link Class} values are implemented
&nbsp;         * as raw types if they declare type variables or an owner type.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param interfaceTypes The interface types to implement.
&nbsp;         * @return A new builder that is equal to this builder but with the interfaces implemented by the instrumented type.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition.Optional&lt;T&gt; implement(List&lt;? extends Type&gt; interfaceTypes);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Implements the supplied interfaces for the instrumented type. Optionally, it is possible to define the
&nbsp;         * methods that are defined by the interfaces or the interfaces&#39; super interfaces. This excludes methods that
&nbsp;         * are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link TypeDescription} values are
&nbsp;         * implemented as raw types if they declare type variables or an owner type.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param interfaceType The interface types to implement.
&nbsp;         * @return A new builder that is equal to this builder but with the interfaces implemented by the instrumented type.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition.Optional&lt;T&gt; implement(TypeDefinition... interfaceType);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Implements the supplied interfaces for the instrumented type. Optionally, it is possible to define the
&nbsp;         * methods that are defined by the interfaces or the interfaces&#39; super interfaces. This excludes methods that
&nbsp;         * are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link TypeDescription} values are
&nbsp;         * implemented as raw types if they declare type variables or an owner type.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param interfaceTypes The interface types to implement.
&nbsp;         * @return A new builder that is equal to this builder but with the interfaces implemented by the instrumented type.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition.Optional&lt;T&gt; implement(Collection&lt;? extends TypeDefinition&gt; interfaceTypes);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Executes the supplied byte code appender within the beginning of the instrumented type&#39;s type initializer. The
&nbsp;         * supplied byte code appender &lt;b&gt;must not return&lt;/b&gt; from the method. If several byte code appenders are supplied,
&nbsp;         * they are executed within their application order.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * This method should only be used for preparing an instrumented type with a specific configuration. Normally,
&nbsp;         * a byte code appender is applied via Byte Buddy&#39;s standard API by invoking {@link Builder#invokable(ElementMatcher)}
&nbsp;         * using the {@link net.bytebuddy.matcher.ElementMatchers#isTypeInitializer()} matcher.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param byteCodeAppender The byte code appender to execute within the instrumented type&#39;s type initializer.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied byte code appender being executed within
&nbsp;         * the instrumented type&#39;s type initializer.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; initializer(ByteCodeAppender byteCodeAppender);
&nbsp;
&nbsp;        /**
&nbsp;         * Executes the supplied loaded type initializer when loading the created instrumented type. If several loaded
&nbsp;         * type initializers are supplied, each loaded type initializer is executed in its registration order.
&nbsp;         *
&nbsp;         * @param loadedTypeInitializer The loaded type initializer to execute upon loading the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied loaded type initializer executed upon
&nbsp;         * loading the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; initializer(LoadedTypeInitializer loadedTypeInitializer);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied type variable without any bounds as a type variable of the instrumented type.
&nbsp;         *
&nbsp;         * @param symbol The type variable&#39;s symbol.
&nbsp;         * @return A new builder that is equal to this builder but with the given type variable defined for the instrumented type.
&nbsp;         */
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String symbol);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied type variable with the given bound as a type variable of the instrumented type.
&nbsp;         *
&nbsp;         * @param symbol The type variable&#39;s symbol.
&nbsp;         * @param bound  The type variable&#39;s upper bounds. Can also be {@link net.bytebuddy.dynamic.TargetType} if the bound type
&nbsp;         *               should be equal to the currently instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the given type variable defined for the instrumented type.
&nbsp;         */
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String symbol, Type... bound);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied type variable with the given bound as a type variable of the instrumented type.
&nbsp;         *
&nbsp;         * @param symbol The type variable&#39;s symbol.
&nbsp;         * @param bounds The type variable&#39;s upper bounds. Can also be {@link net.bytebuddy.dynamic.TargetType} if the bound type
&nbsp;         *               should be equal to the currently instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the given type variable defined for the instrumented type.
&nbsp;         */
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String symbol, List&lt;? extends Type&gt; bounds);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied type variable with the given bound as a type variable of the instrumented type.
&nbsp;         *
&nbsp;         * @param symbol The type variable&#39;s symbol.
&nbsp;         * @param bound  The type variable&#39;s upper bounds. Can also be {@link net.bytebuddy.dynamic.TargetType} if the bound type
&nbsp;         *               should be equal to the currently instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the given type variable defined for the instrumented type.
&nbsp;         */
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String symbol, TypeDefinition... bound);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied type variable with the given bound as a type variable of the instrumented type.
&nbsp;         *
&nbsp;         * @param symbol The type variable&#39;s symbol.
&nbsp;         * @param bounds The type variable&#39;s upper bounds. Can also be {@link net.bytebuddy.dynamic.TargetType} if the bound type
&nbsp;         *               should be equal to the currently instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the given type variable defined for the instrumented type.
&nbsp;         */
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds);
&nbsp;
&nbsp;        /**
&nbsp;         * Transforms any type variable that is defined by this type if it is matched by the supplied matcher.
&nbsp;         *
&nbsp;         * @param matcher     The matcher to decide what type variables to transform.
&nbsp;         * @param transformer The transformer to apply to the matched type variables.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied transformer applied to all type variables.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; transform(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher, Transformer&lt;TypeVariableToken&gt; transformer);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified field as a field of the built dynamic type.
&nbsp;         *
&nbsp;         * @param name                The name of the field.
&nbsp;         * @param type                The type of the field. Can also be {@link net.bytebuddy.dynamic.TargetType} if the field type
&nbsp;         *                            should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributor The modifiers of the field.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String name, Type type, ModifierContributor.ForField... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified field as a field of the built dynamic type.
&nbsp;         *
&nbsp;         * @param name                 The name of the field.
&nbsp;         * @param type                 The type of the field. Can also be {@link net.bytebuddy.dynamic.TargetType} if the field type
&nbsp;         *                             should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributors The modifiers of the field.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String name, Type type, Collection&lt;? extends ModifierContributor.ForField&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified field as a field of the built dynamic type.
&nbsp;         *
&nbsp;         * @param name      The name of the field.
&nbsp;         * @param type      The type of the field. Can also be {@link net.bytebuddy.dynamic.TargetType} if the field type
&nbsp;         *                  should be equal to the currently instrumented type.
&nbsp;         * @param modifiers The modifiers of the field.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String name, Type type, int modifiers);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified field as a field of the built dynamic type.
&nbsp;         *
&nbsp;         * @param name                The name of the field.
&nbsp;         * @param type                The type of the field. Can also be {@link net.bytebuddy.dynamic.TargetType} if the field type
&nbsp;         *                            should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributor The modifiers of the field.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String name, TypeDefinition type, ModifierContributor.ForField... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified field as a field of the built dynamic type.
&nbsp;         *
&nbsp;         * @param name                 The name of the field.
&nbsp;         * @param type                 The type of the field. Can also be {@link net.bytebuddy.dynamic.TargetType} if the field type
&nbsp;         *                             should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributors The modifiers of the field.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String name, TypeDefinition type, Collection&lt;? extends ModifierContributor.ForField&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified field as a field of the built dynamic type.
&nbsp;         *
&nbsp;         * @param name      The name of the field.
&nbsp;         * @param type      The type of the field. Can also be {@link net.bytebuddy.dynamic.TargetType} if the field type
&nbsp;         *                  should be equal to the currently instrumented type.
&nbsp;         * @param modifiers The modifiers of the field.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String name, TypeDefinition type, int modifiers);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a field that is similar to the supplied field but without copying any annotations on the field.
&nbsp;         *
&nbsp;         * @param field The field to imitate as a field of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; define(Field field);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a field that is similar to the supplied field but without copying any annotations on the field.
&nbsp;         *
&nbsp;         * @param field The field to imitate as a field of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; define(FieldDescription field);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a private, static, final field for a serial version UID of the given value.
&nbsp;         *
&nbsp;         * @param serialVersionUid The serial version UID to define as a value.
&nbsp;         * @return A new builder that is equal to this builder but with the given type variable defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional&lt;T&gt; serialVersionUid(long serialVersionUid);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a field that is already declared by the instrumented type. This gives opportunity to change that field&#39;s
&nbsp;         * default value, annotations or custom attributes.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the field declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a field is already matched by a previously specified field matcher, the new field definition gets precedence
&nbsp;         * over the previous definition, i.e. the previous field definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what declared fields are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a field&#39;s definition.
&nbsp;         */
&nbsp;        FieldDefinition.Valuable&lt;T&gt; field(ElementMatcher&lt;? super FieldDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a field that is already declared by the instrumented type. This gives opportunity to change that field&#39;s
&nbsp;         * default value, annotations or custom attributes. Using a latent matcher gives opportunity to resolve an
&nbsp;         * {@link ElementMatcher} based on the instrumented type before applying the matcher.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the field declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a field is already matched by a previously specified field matcher, the new field definition gets precedence
&nbsp;         * over the previous definition, i.e. the previous field definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what declared fields are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a field&#39;s definition.
&nbsp;         */
&nbsp;        FieldDefinition.Valuable&lt;T&gt; field(LatentMatcher&lt;? super FieldDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Specifies to exclude any method that is matched by the supplied matcher from instrumentation. Previously supplied matchers
&nbsp;         * remain valid after supplying a new matcher, i.e. any method that is matched by a previously supplied matcher is always ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When ignoring a type, previously registered matchers are applied before this matcher. If a previous matcher indicates that a type
&nbsp;         * is to be ignored, this matcher is no longer executed.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param ignoredMethods The matcher for determining what methods to exclude from instrumentation.
&nbsp;         * @return A new builder that is equal to this builder but that is excluding any method that is matched by the supplied matcher from
&nbsp;         * instrumentation.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; ignoreAlso(ElementMatcher&lt;? super MethodDescription&gt; ignoredMethods);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Specifies to exclude any method that is matched by the supplied matcher from instrumentation. Previously supplied matchers
&nbsp;         * remain valid after supplying a new matcher, i.e. any method that is matched by a previously supplied matcher is always ignored.
&nbsp;         * Using a latent matcher gives opportunity to resolve an {@link ElementMatcher} based on the instrumented type before applying the
&nbsp;         * matcher.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When ignoring a type, previously registered matchers are applied before this matcher. If a previous matcher indicates that a type
&nbsp;         * is to be ignored, this matcher is no longer executed.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param ignoredMethods The matcher for determining what methods to exclude from instrumentation.
&nbsp;         * @return A new builder that is equal to this builder but that is excluding any method that is matched by the supplied matcher from
&nbsp;         * instrumentation.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; ignoreAlso(LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified method to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param name                The name of the method.
&nbsp;         * @param returnType          The method&#39;s return type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the return type
&nbsp;         *                            should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributor The method&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the method, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String name, Type returnType, ModifierContributor.ForMethod... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified method to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param name                 The name of the method.
&nbsp;         * @param returnType           The method&#39;s return type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the return type
&nbsp;         *                             should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributors The method&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the method, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String name, Type returnType, Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified method to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param name       The name of the method.
&nbsp;         * @param returnType The method&#39;s return type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the return type
&nbsp;         *                   should be equal to the currently instrumented type.
&nbsp;         * @param modifiers  The method&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the method, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String name, Type returnType, int modifiers);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified method to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param name                The name of the method.
&nbsp;         * @param returnType          The method&#39;s return type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the return type
&nbsp;         *                            should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributor The method&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the method, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String name, TypeDefinition returnType, ModifierContributor.ForMethod... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified method to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param name                 The name of the method.
&nbsp;         * @param returnType           The method&#39;s return type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the return type
&nbsp;         *                             should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributors The method&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the method, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String name, TypeDefinition returnType, Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified method to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param name       The name of the method.
&nbsp;         * @param returnType The method&#39;s return type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the return type
&nbsp;         *                   should be equal to the currently instrumented type.
&nbsp;         * @param modifiers  The method&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the method, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String name, TypeDefinition returnType, int modifiers);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified constructor to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param modifierContributor The constructor&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the constructor, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineConstructor(ModifierContributor.ForMethod... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified constructor to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param modifierContributors The constructor&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the constructor, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineConstructor(Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified constructor to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param modifiers The constructor&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the constructor, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineConstructor(int modifiers);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a method that is similar to the supplied method but without copying any annotations of the method or method parameters.
&nbsp;         *
&nbsp;         * @param method The method to imitate as a method of the instrumented type.
&nbsp;         * @return A builder that allows for defining an implementation for the method.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; define(Method method);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a constructor that is similar to the supplied constructor but without copying any annotations of the constructor or
&nbsp;         * constructor parameters.
&nbsp;         *
&nbsp;         * @param constructor The constructor to imitate as a method of the instrumented type.
&nbsp;         * @return A builder that allows for defining an implementation for the constructor.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; define(Constructor&lt;?&gt; constructor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a method or constructor that is similar to the supplied method description but without copying any annotations of
&nbsp;         * the method/constructor or method/constructor parameters.
&nbsp;         *
&nbsp;         * @param methodDescription The method description to imitate as a method or constructor of the instrumented type.
&nbsp;         * @return A builder that allows for defining an implementation for the method or constructor.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; define(MethodDescription methodDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a Java bean property with the specified name.
&nbsp;         *
&nbsp;         * @param name The name of the property.
&nbsp;         * @param type The property type.
&nbsp;         * @return A builder that defines the specified property where the field holding the property can be refined by subsequent steps.
&nbsp;         */
&nbsp;        FieldDefinition.Optional&lt;T&gt; defineProperty(String name, Type type);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a Java bean property with the specified name.
&nbsp;         *
&nbsp;         * @param name     The name of the property.
&nbsp;         * @param type     The property type.
&nbsp;         * @param readOnly {@code true} if the property is read only, i.e. no setter should be defined and the field should be {@code final}.
&nbsp;         * @return A builder that defines the specified property where the field holding the property can be refined by subsequent steps.
&nbsp;         */
&nbsp;        FieldDefinition.Optional&lt;T&gt; defineProperty(String name, Type type, boolean readOnly);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a Java bean property with the specified name.
&nbsp;         *
&nbsp;         * @param name The name of the property.
&nbsp;         * @param type The property type.
&nbsp;         * @return A builder that defines the specified property where the field holding the property can be refined by subsequent steps.
&nbsp;         */
&nbsp;        FieldDefinition.Optional&lt;T&gt; defineProperty(String name, TypeDefinition type);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a Java bean property with the specified name.
&nbsp;         *
&nbsp;         * @param name     The name of the property.
&nbsp;         * @param type     The property type.
&nbsp;         * @param readOnly {@code true} if the property is read only, i.e. no setter should be defined and the field should be {@code final}.
&nbsp;         * @return A builder that defines the specified property where the field holding the property can be refined by subsequent steps.
&nbsp;         */
&nbsp;        FieldDefinition.Optional&lt;T&gt; defineProperty(String name, TypeDefinition type, boolean readOnly);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a method that is already declared or inherited by the instrumented type. This gives opportunity to change or to
&nbsp;         * override that method&#39;s implementation, default value, annotations or custom attributes. It is also possible to make
&nbsp;         * a method abstract.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the method declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a method is already matched by a previously specified matcher, the new method definition gets precedence
&nbsp;         * over the previous definition, i.e. the previous method definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Note that the specified definition does never apply for methods that are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what methods are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a method&#39;s or constructor&#39;s definition.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; method(ElementMatcher&lt;? super MethodDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a constructor that is already declared by the instrumented type. This gives opportunity to change that constructor&#39;s
&nbsp;         * implementation, default value, annotations or custom attributes.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the constructor declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a constructor is already matched by a previously specified matcher, the new constructor definition gets precedence
&nbsp;         * over the previous definition, i.e. the previous constructor definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Note that the specified definition does never apply for methods that are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what constructors are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a method&#39;s or constructor&#39;s definition.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; constructor(ElementMatcher&lt;? super MethodDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a method or constructor that is already declared or inherited by the instrumented type. This gives
&nbsp;         * opportunity to change or to override that method&#39;s or constructor&#39;s implementation, default value, annotations
&nbsp;         * or custom attributes. It is also possible to make a method abstract.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the method or constructor declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a method or constructor is already matched by a previously specified matcher, the new definition gets precedence
&nbsp;         * over the previous definition, i.e. the previous definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Note that the specified definition does never apply for methods that are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: It is possible to instrument the dynamic type&#39;s initializer. Depending on the used {@link TypeResolutionStrategy},
&nbsp;         * the type initializer might be run &lt;b&gt;before&lt;/b&gt; Byte Buddy could apply any {@link LoadedTypeInitializer}s which are
&nbsp;         * responsible for preparing the instrumented type prior to the initializer&#39;s execution. For preparing the type prior to
&nbsp;         * executing the initializer, an {@link TypeResolutionStrategy.Active} resolver must be chosen.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what methods or constructors are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a method&#39;s or constructor&#39;s definition.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; invokable(ElementMatcher&lt;? super MethodDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a method or constructor that is already declared or inherited by the instrumented type. This gives
&nbsp;         * opportunity to change or to override that method&#39;s or constructor&#39;s implementation, default value, annotations
&nbsp;         * or custom attributes. It is also possible to make a method abstract. Using a latent matcher gives opportunity
&nbsp;         * to resolve an {@link ElementMatcher} based on the instrumented type before applying the matcher.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the method or constructor declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a method or constructor is already matched by a previously specified matcher, the new definition gets precedence
&nbsp;         * over the previous definition, i.e. the previous definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Note that the specified definition does never apply for methods that are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: It is possible to instrument the dynamic type&#39;s initializer. Depending on the used {@link TypeResolutionStrategy},
&nbsp;         * the type initializer might be run &lt;b&gt;before&lt;/b&gt; Byte Buddy could apply any {@link LoadedTypeInitializer}s which are
&nbsp;         * responsible for preparing the instrumented type prior to the initializer&#39;s execution. For preparing the type prior to
&nbsp;         * executing the initializer, an {@link TypeResolutionStrategy.Active} resolver must be chosen.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what declared methods or constructors are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a method&#39;s or constructor&#39;s definition.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; invokable(LatentMatcher&lt;? super MethodDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * Implements {@link Object#hashCode()} and {@link Object#equals(Object)} methods for the instrumented type if those
&nbsp;         * methods are not declared as {@code final} by a super class. The implementations do not consider any implementations
&nbsp;         * of a super class and compare a class field by field without considering synthetic fields.
&nbsp;         *
&nbsp;         * @return A new type builder that defines {@link Object#hashCode()} and {@link Object#equals(Object)} methods accordingly.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; withHashCodeEquals();
&nbsp;
&nbsp;        /**
&nbsp;         * Implements a {@link Object#toString()} method for the instrumented type if such a method is not declared as {@code final}
&nbsp;         * by a super class. The implementation prefixes the string with the simple class name and prints each non-synthetic field&#39;s
&nbsp;         * value after the field&#39;s name.
&nbsp;         *
&nbsp;         * @return A new type builder that defines {@link Object#toString()} method accordingly.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; withToString();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Creates the dynamic type this builder represents. If the specified dynamic type is not legal, an {@link IllegalStateException} is thrown.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Other than {@link DynamicType.Builder#make(TypePool)}, this method supplies a context-dependant type pool to the underlying class writer.
&nbsp;         * Supplying a type pool only makes sense if custom byte code is created by adding a custom {@link AsmVisitorWrapper} where ASM might be
&nbsp;         * required to compute stack map frames by processing information over any mentioned type&#39;s class hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * The dynamic type is initialized using a {@link TypeResolutionStrategy.Passive} strategy. Using this strategy, no
&nbsp;         * {@link LoadedTypeInitializer} is run during the execution of the type&#39;s initializer such that no {@link Implementation} used for
&nbsp;         * executing the initializer must rely on such an initializer.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return An unloaded dynamic type representing the type specified by this builder.
&nbsp;         */
&nbsp;        DynamicType.Unloaded&lt;T&gt; make();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Creates the dynamic type this builder represents. If the specified dynamic type is not legal, an {@link IllegalStateException} is thrown.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * The dynamic type is initialized using a {@link TypeResolutionStrategy.Passive} strategy. Using this strategy, no
&nbsp;         * {@link LoadedTypeInitializer} is run during the execution of the type&#39;s initializer such that no {@link Implementation} used for
&nbsp;         * executing the initializer must rely on such an initializer.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param typeResolutionStrategy The type resolution strategy to use for the created type&#39;s initialization.
&nbsp;         * @return An unloaded dynamic type representing the type specified by this builder.
&nbsp;         */
&nbsp;        DynamicType.Unloaded&lt;T&gt; make(TypeResolutionStrategy typeResolutionStrategy);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Creates the dynamic type this builder represents. If the specified dynamic type is not legal, an {@link IllegalStateException} is thrown.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * The dynamic type is initialized using a {@link TypeResolutionStrategy.Passive} strategy. Using this strategy, no
&nbsp;         * {@link LoadedTypeInitializer} is run during the execution of the type&#39;s initializer such that no {@link Implementation} used for
&nbsp;         * executing the initializer must rely on such an initializer.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param typePool A type pool that is used for computing stack map frames by the underlying class writer, if required.
&nbsp;         * @return An unloaded dynamic type representing the type specified by this builder.
&nbsp;         */
&nbsp;        DynamicType.Unloaded&lt;T&gt; make(TypePool typePool);
&nbsp;
&nbsp;        /**
&nbsp;         * Creates the dynamic type this builder represents. If the specified dynamic type is not legal, an {@link IllegalStateException} is thrown.
&nbsp;         *
&nbsp;         * @param typeResolutionStrategy The type resolution strategy to use for the created type&#39;s initialization.
&nbsp;         * @param typePool               A type pool that is used for computing stack map frames by the underlying class writer, if required.
&nbsp;         * @return An unloaded dynamic type representing the type specified by this builder.
&nbsp;         */
&nbsp;        DynamicType.Unloaded&lt;T&gt; make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool);
&nbsp;
&nbsp;        /**
&nbsp;         * A builder for a type variable definition.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;         */
&nbsp;        interface TypeVariableDefinition&lt;S&gt; extends Builder&lt;S&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined type variable with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare on the previously defined type variable.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined type variable.
&nbsp;             */
&nbsp;            TypeVariableDefinition&lt;S&gt; annotateTypeVariable(Annotation... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined type variable with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare on the previously defined type variable.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined type variable.
&nbsp;             */
&nbsp;            TypeVariableDefinition&lt;S&gt; annotateTypeVariable(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined type variable with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare on the previously defined type variable.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined type variable.
&nbsp;             */
&nbsp;            TypeVariableDefinition&lt;S&gt; annotateTypeVariable(AnnotationDescription... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined type variable with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare on the previously defined type variable.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined type variable.
&nbsp;             */
&nbsp;            TypeVariableDefinition&lt;S&gt; annotateTypeVariable(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract base implementation of a type variable definition.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            abstract class AbstractBase&lt;U&gt; extends Builder.AbstractBase.Delegator&lt;U&gt; implements TypeVariableDefinition&lt;U&gt; {
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeVariableDefinition&lt;U&gt; annotateTypeVariable(Annotation... annotation) {
&nbsp;                    return annotateTypeVariable(Arrays.asList(annotation));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeVariableDefinition&lt;U&gt; annotateTypeVariable(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                    return annotateTypeVariable(new AnnotationList.ForLoadedAnnotations(annotations));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeVariableDefinition&lt;U&gt; annotateTypeVariable(AnnotationDescription... annotation) {
&nbsp;                    return annotateTypeVariable(Arrays.asList(annotation));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A builder for a field definition.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;         */
&nbsp;        interface FieldDefinition&lt;S&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched field with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare on the previously defined or matched field.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched field.
&nbsp;             */
&nbsp;            FieldDefinition.Optional&lt;S&gt; annotateField(Annotation... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched field with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare on the previously defined or matched field.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched field.
&nbsp;             */
&nbsp;            FieldDefinition.Optional&lt;S&gt; annotateField(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched field with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare on the previously defined or matched field.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched field.
&nbsp;             */
&nbsp;            FieldDefinition.Optional&lt;S&gt; annotateField(AnnotationDescription... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched field with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare on the previously defined or matched field.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched field.
&nbsp;             */
&nbsp;            FieldDefinition.Optional&lt;S&gt; annotateField(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the supplied attribute appender factory onto the previously defined or matched field.
&nbsp;             *
&nbsp;             * @param fieldAttributeAppenderFactory The field attribute appender factory that should be applied on the
&nbsp;             *                                      previously defined or matched field.
&nbsp;             * @return A new builder that is equal to this builder but with the supplied field attribute appender factory
&nbsp;             * applied to the previously defined or matched field.
&nbsp;             */
&nbsp;            FieldDefinition.Optional&lt;S&gt; attribute(FieldAttributeAppender.Factory fieldAttributeAppenderFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the supplied transformer onto the previously defined or matched field. The transformed
&nbsp;             * field is written &lt;i&gt;as it is&lt;/i&gt; and it not subject to any validations.
&nbsp;             *
&nbsp;             * @param transformer The transformer to apply to the previously defined or matched field.
&nbsp;             * @return A new builder that is equal to this builder but with the supplied field transformer
&nbsp;             * applied to the previously defined or matched field.
&nbsp;             */
&nbsp;            FieldDefinition.Optional&lt;S&gt; transform(Transformer&lt;FieldDescription&gt; transformer);
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for a field definition that allows for defining a value.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface Valuable&lt;U&gt; extends FieldDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Defines the supplied {@code boolean} value as a default value of the previously defined or matched field. The value can only
&nbsp;                 * be set for numeric fields of type {@code boolean}, {@code byte}, {@code short}, {@code char} or {@code int}. For non-boolean
&nbsp;                 * fields, the field&#39;s value is set to {@code 0} for {@code false} or {@code 1} for {@code true}.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: A default value in a Java class file defines a field&#39;s value prior to the class&#39;s initialization. This value
&nbsp;                 * is only visible to code if the field is declared {@code static}. A default value can also be set for non-static fields where
&nbsp;                 * the value is not visible to code. The Java compiler only defines such values for {@code final} fields.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param value The value to define as a default value of the defined field.
&nbsp;                 * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                 * previously defined or matched field.
&nbsp;                 */
&nbsp;                FieldDefinition.Optional&lt;U&gt; value(boolean value);
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Defines the supplied {@code int} value as a default value of the previously defined or matched field. The value can only
&nbsp;                 * be set for numeric fields of type {@code boolean}, {@code byte}, {@code short}, {@code char} or {@code int} where the
&nbsp;                 * value must be within the numeric type&#39;s range. The {@code boolean} type is regarded as a numeric type with the possible
&nbsp;                 * values of {@code 0} and {@code 1} representing {@code false} and {@code true}.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: A default value in a Java class file defines a field&#39;s value prior to the class&#39;s initialization. This value
&nbsp;                 * is only visible to code if the field is declared {@code static}. A default value can also be set for non-static fields where
&nbsp;                 * the value is not visible to code. The Java compiler only defines such values for {@code final} fields.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param value The value to define as a default value of the defined field.
&nbsp;                 * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                 * previously defined or matched field.
&nbsp;                 */
&nbsp;                FieldDefinition.Optional&lt;U&gt; value(int value);
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Defines the supplied {@code long} value as a default value of the previously defined or matched field.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: A default value in a Java class file defines a field&#39;s value prior to the class&#39;s initialization. This value
&nbsp;                 * is only visible to code if the field is declared {@code static}. A default value can also be set for non-static fields where
&nbsp;                 * the value is not visible to code. The Java compiler only defines such values for {@code final} fields.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param value The value to define as a default value of the defined field.
&nbsp;                 * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                 * previously defined or matched field.
&nbsp;                 */
&nbsp;                FieldDefinition.Optional&lt;U&gt; value(long value);
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Defines the supplied {@code float} value as a default value of the previously defined or matched field.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: A default value in a Java class file defines a field&#39;s value prior to the class&#39;s initialization. This value
&nbsp;                 * is only visible to code if the field is declared {@code static}. A default value can also be set for non-static fields where
&nbsp;                 * the value is not visible to code. The Java compiler only defines such values for {@code final} fields.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param value The value to define as a default value of the defined field.
&nbsp;                 * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                 * previously defined or matched field.
&nbsp;                 */
&nbsp;                FieldDefinition.Optional&lt;U&gt; value(float value);
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Defines the supplied {@code double} value as a default value of the previously defined or matched field.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: A default value in a Java class file defines a field&#39;s value prior to the class&#39;s initialization. This value
&nbsp;                 * is only visible to code if the field is declared {@code static}. A default value can also be set for non-static fields where
&nbsp;                 * the value is not visible to code. The Java compiler only defines such values for {@code final} fields.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param value The value to define as a default value of the defined field.
&nbsp;                 * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                 * previously defined or matched field.
&nbsp;                 */
&nbsp;                FieldDefinition.Optional&lt;U&gt; value(double value);
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Defines the supplied {@link String} value as a default value of the previously defined or matched field.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: A default value in a Java class file defines a field&#39;s value prior to the class&#39;s initialization. This value
&nbsp;                 * is only visible to code if the field is declared {@code static}. A default value can also be set for non-static fields where
&nbsp;                 * the value is not visible to code. The Java compiler only defines such values for {@code final} fields.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param value The value to define as a default value of the defined field.
&nbsp;                 * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                 * previously defined or matched field.
&nbsp;                 */
&nbsp;                FieldDefinition.Optional&lt;U&gt; value(String value);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for an optional field definition.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface Optional&lt;U&gt; extends FieldDefinition&lt;U&gt;, Builder&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * A builder for an optional field definition that allows for defining a value.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                interface Valuable&lt;V&gt; extends FieldDefinition.Valuable&lt;V&gt;, Optional&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * An abstract base implementation of an optional field definition that allows for defining a value.
&nbsp;                     *
&nbsp;                     * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                     */
<b class="fc">&nbsp;                    abstract class AbstractBase&lt;U&gt; extends Optional.AbstractBase&lt;U&gt; implements Optional.Valuable&lt;U&gt; {</b>
&nbsp;
&nbsp;                        @Override
&nbsp;                        public FieldDefinition.Optional&lt;U&gt; value(boolean value) {
<b class="nc">&nbsp;                            return defaultValue(value ? 1 : 0);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public FieldDefinition.Optional&lt;U&gt; value(int value) {
<b class="nc">&nbsp;                            return defaultValue(value);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public FieldDefinition.Optional&lt;U&gt; value(long value) {
<b class="fc">&nbsp;                            return defaultValue(value);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public FieldDefinition.Optional&lt;U&gt; value(float value) {
<b class="nc">&nbsp;                            return defaultValue(value);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public FieldDefinition.Optional&lt;U&gt; value(double value) {
<b class="nc">&nbsp;                            return defaultValue(value);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public FieldDefinition.Optional&lt;U&gt; value(String value) {
<b class="nc">&nbsp;                            if (value == null) {</b>
<b class="nc">&nbsp;                                throw new IllegalArgumentException(&quot;Cannot set null as a default value&quot;);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            return defaultValue(value);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Defines the supplied value as a default value of the previously defined or matched field.
&nbsp;                         *
&nbsp;                         * @param defaultValue The value to define as a default value of the defined field.
&nbsp;                         * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                         * previously defined or matched field.
&nbsp;                         */
&nbsp;                        protected abstract FieldDefinition.Optional&lt;U&gt; defaultValue(Object defaultValue);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An adapter for an optional field definition that allows for defining a value.
&nbsp;                         *
&nbsp;                         * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        private abstract static class Adapter&lt;V&gt; extends Optional.Valuable.AbstractBase&lt;V&gt; {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The field attribute appender factory to apply.
&nbsp;                             */
&nbsp;                            protected final FieldAttributeAppender.Factory fieldAttributeAppenderFactory;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The field transformer to apply.
&nbsp;                             */
&nbsp;                            protected final Transformer&lt;FieldDescription&gt; transformer;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The field&#39;s default value or {@code null} if no value is to be defined.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                            protected final Object defaultValue;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new field adapter.
&nbsp;                             *
&nbsp;                             * @param fieldAttributeAppenderFactory The field attribute appender factory to apply.
&nbsp;                             * @param transformer                   The field transformer to apply.
&nbsp;                             * @param defaultValue                  The field&#39;s default value or {@code null} if no value is to be defined.
&nbsp;                             */
&nbsp;                            protected Adapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
&nbsp;                                              Transformer&lt;FieldDescription&gt; transformer,
<b class="fc">&nbsp;                                              Object defaultValue) {</b>
<b class="fc">&nbsp;                                this.fieldAttributeAppenderFactory = fieldAttributeAppenderFactory;</b>
<b class="fc">&nbsp;                                this.transformer = transformer;</b>
<b class="fc">&nbsp;                                this.defaultValue = defaultValue;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public FieldDefinition.Optional&lt;V&gt; attribute(FieldAttributeAppender.Factory fieldAttributeAppenderFactory) {
<b class="nc">&nbsp;                                return materialize(new FieldAttributeAppender.Factory.Compound(this.fieldAttributeAppenderFactory, fieldAttributeAppenderFactory), transformer, defaultValue);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs for Java 6
&nbsp;                            public FieldDefinition.Optional&lt;V&gt; transform(Transformer&lt;FieldDescription&gt; transformer) {
<b class="nc">&nbsp;                                return materialize(fieldAttributeAppenderFactory, new Transformer.Compound&lt;FieldDescription&gt;(this.transformer, transformer), defaultValue);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            protected FieldDefinition.Optional&lt;V&gt; defaultValue(Object defaultValue) {
<b class="fc">&nbsp;                                return materialize(fieldAttributeAppenderFactory, transformer, defaultValue);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new optional field definition for which all of the supplied values are represented.
&nbsp;                             *
&nbsp;                             * @param fieldAttributeAppenderFactory The field attribute appender factory to apply.
&nbsp;                             * @param transformer                   The field transformer to apply.
&nbsp;                             * @param defaultValue                  The field&#39;s default value or {@code null} if no value is to be defined.
&nbsp;                             * @return A new field definition that represents the supplied values.
&nbsp;                             */
&nbsp;                            protected abstract FieldDefinition.Optional&lt;V&gt; materialize(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
&nbsp;                                                                                       Transformer&lt;FieldDescription&gt; transformer,
&nbsp;                                                                                       Object defaultValue);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation for an optional field definition.
&nbsp;                 *
&nbsp;                 * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;U&gt; extends Builder.AbstractBase.Delegator&lt;U&gt; implements FieldDefinition.Optional&lt;U&gt; {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public FieldDefinition.Optional&lt;U&gt; annotateField(Annotation... annotation) {
<b class="nc">&nbsp;                        return annotateField(Arrays.asList(annotation));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public FieldDefinition.Optional&lt;U&gt; annotateField(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                        return annotateField(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public FieldDefinition.Optional&lt;U&gt; annotateField(AnnotationDescription... annotation) {
<b class="nc">&nbsp;                        return annotateField(Arrays.asList(annotation));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A builder for a method definition.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;         */
&nbsp;        interface MethodDefinition&lt;S&gt; extends Builder&lt;S&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateMethod(Annotation... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateMethod(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateMethod(AnnotationDescription... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateMethod(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the parameter of the given index of the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param index      The parameter&#39;s index.
&nbsp;             * @param annotation The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method&#39;s parameter of the given index.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateParameter(int index, Annotation... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the parameter of the given index of the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param index       The parameter&#39;s index.
&nbsp;             * @param annotations The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method&#39;s parameter of the given index.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateParameter(int index, List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the parameter of the given index of the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param index      The parameter&#39;s index.
&nbsp;             * @param annotation The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method&#39;s parameter of the given index.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateParameter(int index, AnnotationDescription... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the parameter of the given index of the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param index       The parameter&#39;s index.
&nbsp;             * @param annotations The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method&#39;s parameter of the given index.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateParameter(int index, Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the supplied method attribute appender factory onto the previously defined or matched method.
&nbsp;             *
&nbsp;             * @param methodAttributeAppenderFactory The method attribute appender factory that should be applied on the
&nbsp;             *                                       previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the supplied method attribute appender factory
&nbsp;             * applied to the previously defined or matched method.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; attribute(MethodAttributeAppender.Factory methodAttributeAppenderFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the supplied transformer onto the previously defined or matched method. The transformed
&nbsp;             * method is written &lt;i&gt;as it is&lt;/i&gt; and it not subject to any validations.
&nbsp;             *
&nbsp;             * @param transformer The transformer to apply to the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the supplied transformer
&nbsp;             * applied to the previously defined or matched method.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; transform(Transformer&lt;MethodDescription&gt; transformer);
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for a method definition with a receiver type.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface ReceiverTypeDefinition&lt;U&gt; extends MethodDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the supplied (annotated) receiver type for the previously defined or matched method.
&nbsp;                 *
&nbsp;                 * @param receiverType The receiver type to define on the previously defined or matched method.
&nbsp;                 * @return A new builder that is equal to this builder but with the given type defined as the
&nbsp;                 * receiver on the previously defined or matched method.
&nbsp;                 */
&nbsp;                MethodDefinition&lt;U&gt; receiverType(AnnotatedElement receiverType);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the supplied (annotated) receiver type for the previously defined or matched method.
&nbsp;                 *
&nbsp;                 * @param receiverType The receiver type to define on the previously defined or matched method.
&nbsp;                 * @return A new builder that is equal to this builder but with the given type defined as the
&nbsp;                 * receiver on the previously defined or matched method.
&nbsp;                 */
&nbsp;                MethodDefinition&lt;U&gt; receiverType(TypeDescription.Generic receiverType);
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation of a method definition that can accept a receiver type.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;V&gt; extends MethodDefinition.AbstractBase&lt;V&gt; implements ReceiverTypeDefinition&lt;V&gt; {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition&lt;V&gt; receiverType(AnnotatedElement receiverType) {
<b class="nc">&nbsp;                        return receiverType(TypeDescription.Generic.AnnotationReader.DISPATCHER.resolve(receiverType));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for defining an implementation of a method.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface ImplementationDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Implements the previously defined or matched method by the supplied implementation. A method interception
&nbsp;                 * is typically implemented in one of the following ways:
&nbsp;                 * &lt;ol&gt;
&nbsp;                 * &lt;li&gt;If a method is declared by the instrumented type and the type builder creates a subclass or redefinition,
&nbsp;                 * any preexisting method is replaced by the given implementation. Any previously defined implementation is lost.&lt;/li&gt;
&nbsp;                 * &lt;li&gt;If a method is declared by the instrumented type and the type builder creates a rebased version of the
&nbsp;                 * instrumented type, the original method is preserved within a private, synthetic method within the instrumented
&nbsp;                 * type. The original method therefore remains invokeable and is treated as the direct super method of the new
&nbsp;                 * method. When rebasing a type, it therefore becomes possible to invoke a non-virtual method&#39;s super method
&nbsp;                 * when a preexisting method body is replaced.&lt;/li&gt;
&nbsp;                 * &lt;li&gt;If a virtual method is inherited from a super type, it is overridden. The overridden method is available
&nbsp;                 * for super method invocation.&lt;/li&gt;
&nbsp;                 * &lt;/ol&gt;
&nbsp;                 *
&nbsp;                 * @param implementation The implementation for implementing the previously defined or matched method.
&nbsp;                 * @return A new builder where the previously defined or matched method is implemented by the
&nbsp;                 * supplied implementation.
&nbsp;                 */
&nbsp;                MethodDefinition.ReceiverTypeDefinition&lt;U&gt; intercept(Implementation implementation);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the previously defined or matched method to be {@code abstract}.
&nbsp;                 *
&nbsp;                 * @return A new builder where the previously defined or matched method is implemented to be abstract.
&nbsp;                 */
&nbsp;                MethodDefinition.ReceiverTypeDefinition&lt;U&gt; withoutCode();
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the previously defined or matched method to return the supplied value as an annotation default value. The
&nbsp;                 * value must be supplied in its unloaded state, i.e. enumerations as {@link net.bytebuddy.description.enumeration.EnumerationDescription},
&nbsp;                 * types as {@link TypeDescription} and annotations as {@link AnnotationDescription}. For supplying loaded types, use
&nbsp;                 * {@link ImplementationDefinition#defaultValue(Object, Class)} must be used.
&nbsp;                 *
&nbsp;                 * @param annotationValue The value to be defined as a default value.
&nbsp;                 * @return A builder where the previously defined or matched method is implemented to return an annotation default value.
&nbsp;                 */
&nbsp;                MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the previously defined or matched method to return the supplied value as an annotation default value. The
&nbsp;                 * value must be supplied in its loaded state paired with the property type of the value.
&nbsp;                 *
&nbsp;                 * @param value The value to be defined as a default value.
&nbsp;                 * @param type  The type of the annotation property.
&nbsp;                 * @param &lt;W&gt;   The type of the annotation property.
&nbsp;                 * @return A builder where the previously defined or matched method is implemented to return an annotation default value.
&nbsp;                 */
&nbsp;                &lt;W&gt; MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(W value, Class&lt;? extends W&gt; type);
&nbsp;
&nbsp;                /**
&nbsp;                 * A builder for optionally defining an implementation of a method.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                interface Optional&lt;V&gt; extends ImplementationDefinition&lt;V&gt;, Builder&lt;V&gt; {
&nbsp;                    /* union type */
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation for a builder optionally defining an implementation of a method.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;V&gt; implements ImplementationDefinition&lt;V&gt; {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public &lt;W&gt; MethodDefinition.ReceiverTypeDefinition&lt;V&gt; defaultValue(W value, Class&lt;? extends W&gt; type) {
<b class="nc">&nbsp;                        return defaultValue(AnnotationDescription.ForLoadedAnnotation.asValue(value, type));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for defining an implementation of a method and optionally defining a type variable.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface TypeVariableDefinition&lt;U&gt; extends ImplementationDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method. The defined method variable does not define any bounds.
&nbsp;                 *
&nbsp;                 * @param symbol The symbol of the type variable.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified type variable.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; typeVariable(String symbol);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param symbol The symbol of the type variable.
&nbsp;                 * @param bound  The bounds of the type variables. Can also be {@link net.bytebuddy.dynamic.TargetType} for any type
&nbsp;                 *               if a bound type should be equal to the currently instrumented type.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified type variable.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; typeVariable(String symbol, Type... bound);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param symbol The symbol of the type variable.
&nbsp;                 * @param bounds The bounds of the type variables. Can also be {@link net.bytebuddy.dynamic.TargetType} for any type
&nbsp;                 *               if a bound type should be equal to the currently instrumented type.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified type variable.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; typeVariable(String symbol, List&lt;? extends Type&gt; bounds);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param symbol The symbol of the type variable.
&nbsp;                 * @param bound  The bounds of the type variables. Can also be {@link net.bytebuddy.dynamic.TargetType} for any type
&nbsp;                 *               if a bound type should be equal to the currently instrumented type.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified type variable.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; typeVariable(String symbol, TypeDefinition... bound);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param symbol The symbol of the type variable.
&nbsp;                 * @param bounds The bounds of the type variables. Can also be {@link net.bytebuddy.dynamic.TargetType} for any type
&nbsp;                 *               if a bound type should be equal to the currently instrumented type.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified type variable.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds);
&nbsp;
&nbsp;                /**
&nbsp;                 * A builder for optionally defining an annotation for a type variable.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                interface Annotatable&lt;V&gt; extends TypeVariableDefinition&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined type variable with the supplied annotations.
&nbsp;                     *
&nbsp;                     * @param annotation The annotations to declare on the previously defined type variable.
&nbsp;                     * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;                     * on the previously defined type variable.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateTypeVariable(Annotation... annotation);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined type variable with the supplied annotations.
&nbsp;                     *
&nbsp;                     * @param annotations The annotations to declare on the previously defined type variable.
&nbsp;                     * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;                     * on the previously defined type variable.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateTypeVariable(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined type variable with the supplied annotations.
&nbsp;                     *
&nbsp;                     * @param annotation The annotations to declare on the previously defined type variable.
&nbsp;                     * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;                     * on the previously defined type variable.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateTypeVariable(AnnotationDescription... annotation);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined type variable with the supplied annotations.
&nbsp;                     *
&nbsp;                     * @param annotations The annotations to declare on the previously defined type variable.
&nbsp;                     * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;                     * on the previously defined type variable.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateTypeVariable(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;                    /**
&nbsp;                     * An abstract base implementation for defining an annotation on a parameter.
&nbsp;                     *
&nbsp;                     * @param &lt;W&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                     */
&nbsp;                    abstract class AbstractBase&lt;W&gt; extends TypeVariableDefinition.AbstractBase&lt;W&gt; implements Annotatable&lt;W&gt; {
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeVariableDefinition.Annotatable&lt;W&gt; annotateTypeVariable(Annotation... annotation) {
&nbsp;                            return annotateTypeVariable(Arrays.asList(annotation));
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeVariableDefinition.Annotatable&lt;W&gt; annotateTypeVariable(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                            return annotateTypeVariable(new AnnotationList.ForLoadedAnnotations(annotations));
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeVariableDefinition.Annotatable&lt;W&gt; annotateTypeVariable(AnnotationDescription... annotation) {
&nbsp;                            return annotateTypeVariable(Arrays.asList(annotation));
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An adapter implementation for an annotatable type variable definition.
&nbsp;                         *
&nbsp;                         * @param &lt;X&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                         */
&nbsp;                        protected abstract static class Adapter&lt;X&gt; extends TypeVariableDefinition.Annotatable.AbstractBase&lt;X&gt; {
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeVariableDefinition.Annotatable&lt;X&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
&nbsp;                                return materialize().typeVariable(symbol, bounds);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; intercept(Implementation implementation) {
&nbsp;                                return materialize().intercept(implementation);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; withoutCode() {
&nbsp;                                return materialize().withoutCode();
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                                return materialize().defaultValue(annotationValue);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public &lt;V&gt; MethodDefinition.ReceiverTypeDefinition&lt;X&gt; defaultValue(V value, Class&lt;? extends V&gt; type) {
&nbsp;                                return materialize().defaultValue(value, type);
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Materializes this instance as a parameter definition with the currently defined properties.
&nbsp;                             *
&nbsp;                             * @return A parameter definition with the currently defined properties.
&nbsp;                             */
&nbsp;                            protected abstract MethodDefinition.ParameterDefinition&lt;X&gt; materialize();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation for defining an implementation of a method and optionally defining a type variable.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;V&gt; extends ImplementationDefinition.AbstractBase&lt;V&gt; implements TypeVariableDefinition&lt;V&gt; {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Annotatable&lt;V&gt; typeVariable(String symbol) {
<b class="nc">&nbsp;                        return typeVariable(symbol, Collections.singletonList(Object.class));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Annotatable&lt;V&gt; typeVariable(String symbol, Type... bound) {
<b class="nc">&nbsp;                        return typeVariable(symbol, Arrays.asList(bound));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Annotatable&lt;V&gt; typeVariable(String symbol, List&lt;? extends Type&gt; bounds) {
<b class="nc">&nbsp;                        return typeVariable(symbol, new TypeList.Generic.ForLoadedTypes(bounds));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Annotatable&lt;V&gt; typeVariable(String symbol, TypeDefinition... bound) {
<b class="nc">&nbsp;                        return typeVariable(symbol, Arrays.asList(bound));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for defining an implementation of a method and optionally defining a type variable or thrown exception.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface ExceptionDefinition&lt;U&gt; extends TypeVariableDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type The type of the exception being declared by the currently defined method.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified exception type.
&nbsp;                 */
&nbsp;                ExceptionDefinition&lt;U&gt; throwing(Type... type);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param types The type of the exception being declared by the currently defined method.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified exception type.
&nbsp;                 */
&nbsp;                ExceptionDefinition&lt;U&gt; throwing(List&lt;? extends Type&gt; types);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type The type of the exception being declared by the currently defined method.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified exception type.
&nbsp;                 */
&nbsp;                ExceptionDefinition&lt;U&gt; throwing(TypeDefinition... type);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param types The type of the exception being declared by the currently defined method.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified exception type.
&nbsp;                 */
&nbsp;                ExceptionDefinition&lt;U&gt; throwing(Collection&lt;? extends TypeDefinition&gt; types);
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation for defining an implementation of a method and optionally defining a type variable or thrown exception.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;V&gt; extends TypeVariableDefinition.AbstractBase&lt;V&gt; implements ExceptionDefinition&lt;V&gt; {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public ExceptionDefinition&lt;V&gt; throwing(Type... type) {
<b class="nc">&nbsp;                        return throwing(Arrays.asList(type));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public ExceptionDefinition&lt;V&gt; throwing(List&lt;? extends Type&gt; types) {
<b class="nc">&nbsp;                        return throwing(new TypeList.Generic.ForLoadedTypes(types));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public ExceptionDefinition&lt;V&gt; throwing(TypeDefinition... type) {
<b class="nc">&nbsp;                        return throwing(Arrays.asList(type));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for defining an implementation of a method and optionally defining a type variable, thrown exception or method parameter.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface ParameterDefinition&lt;U&gt; extends ExceptionDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type                The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                 *                            should be equal to the currently instrumented type.
&nbsp;                 * @param name                The parameter&#39;s name.
&nbsp;                 * @param modifierContributor The parameter&#39;s modifiers.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; withParameter(Type type, String name, ModifierContributor.ForParameter... modifierContributor);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type                 The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                 *                             should be equal to the currently instrumented type.
&nbsp;                 * @param name                 The parameter&#39;s name.
&nbsp;                 * @param modifierContributors The parameter&#39;s modifiers.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; withParameter(Type type, String name, Collection&lt;? extends ModifierContributor.ForParameter&gt; modifierContributors);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type      The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                 *                  should be equal to the currently instrumented type.
&nbsp;                 * @param name      The parameter&#39;s name.
&nbsp;                 * @param modifiers The parameter&#39;s modifiers.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; withParameter(Type type, String name, int modifiers);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type                The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                 *                            should be equal to the currently instrumented type.
&nbsp;                 * @param name                The parameter&#39;s name.
&nbsp;                 * @param modifierContributor The parameter&#39;s modifiers.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; withParameter(TypeDefinition type, String name, ModifierContributor.ForParameter... modifierContributor);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type                 The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                 *                             should be equal to the currently instrumented type.
&nbsp;                 * @param name                 The parameter&#39;s name.
&nbsp;                 * @param modifierContributors The parameter&#39;s modifiers.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; withParameter(TypeDefinition type, String name, Collection&lt;? extends ModifierContributor.ForParameter&gt; modifierContributors);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type      The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                 *                  should be equal to the currently instrumented type.
&nbsp;                 * @param name      The parameter&#39;s name.
&nbsp;                 * @param modifiers The parameter&#39;s modifiers.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; withParameter(TypeDefinition type, String name, int modifiers);
&nbsp;
&nbsp;                /**
&nbsp;                 * A builder for optionally defining an annotation on a parameter.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                interface Annotatable&lt;V&gt; extends ParameterDefinition&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined parameter with the specified annotations.
&nbsp;                     *
&nbsp;                     * @param annotation The annotations to declare on the previously defined parameter.
&nbsp;                     * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                     * the specified annotations.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateParameter(Annotation... annotation);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined parameter with the specified annotations.
&nbsp;                     *
&nbsp;                     * @param annotations The annotations to declare on the previously defined parameter.
&nbsp;                     * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                     * the specified annotations.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateParameter(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined parameter with the specified annotations.
&nbsp;                     *
&nbsp;                     * @param annotation The annotations to declare on the previously defined parameter.
&nbsp;                     * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                     * the specified annotations.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateParameter(AnnotationDescription... annotation);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined parameter with the specified annotations.
&nbsp;                     *
&nbsp;                     * @param annotations The annotations to declare on the previously defined parameter.
&nbsp;                     * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                     * the specified annotations.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateParameter(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;                    /**
&nbsp;                     * An abstract base implementation for defining an annotation on a parameter.
&nbsp;                     *
&nbsp;                     * @param &lt;W&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                     */
&nbsp;                    abstract class AbstractBase&lt;W&gt; extends ParameterDefinition.AbstractBase&lt;W&gt; implements Annotatable&lt;W&gt; {
&nbsp;
&nbsp;                        @Override
&nbsp;                        public ParameterDefinition.Annotatable&lt;W&gt; annotateParameter(Annotation... annotation) {
&nbsp;                            return annotateParameter(Arrays.asList(annotation));
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public ParameterDefinition.Annotatable&lt;W&gt; annotateParameter(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                            return annotateParameter(new AnnotationList.ForLoadedAnnotations(annotations));
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public ParameterDefinition.Annotatable&lt;W&gt; annotateParameter(AnnotationDescription... annotation) {
&nbsp;                            return annotateParameter(Arrays.asList(annotation));
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An adapter implementation for defining an annotation on a parameter.
&nbsp;                         *
&nbsp;                         * @param &lt;X&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                         */
&nbsp;                        protected abstract static class Adapter&lt;X&gt; extends ParameterDefinition.Annotatable.AbstractBase&lt;X&gt; {
&nbsp;
&nbsp;                            @Override
&nbsp;                            public ParameterDefinition.Annotatable&lt;X&gt; withParameter(TypeDefinition type, String name, int modifiers) {
&nbsp;                                return materialize().withParameter(type, name, modifiers);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public ExceptionDefinition&lt;X&gt; throwing(Collection&lt;? extends TypeDefinition&gt; types) {
&nbsp;                                return materialize().throwing(types);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeVariableDefinition.Annotatable&lt;X&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
&nbsp;                                return materialize().typeVariable(symbol, bounds);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; intercept(Implementation implementation) {
&nbsp;                                return materialize().intercept(implementation);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; withoutCode() {
&nbsp;                                return materialize().withoutCode();
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                                return materialize().defaultValue(annotationValue);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public &lt;V&gt; MethodDefinition.ReceiverTypeDefinition&lt;X&gt; defaultValue(V value, Class&lt;? extends V&gt; type) {
&nbsp;                                return materialize().defaultValue(value, type);
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Materializes this instance as a parameter definition with the currently defined properties.
&nbsp;                             *
&nbsp;                             * @return A parameter definition with the currently defined properties.
&nbsp;                             */
&nbsp;                            protected abstract MethodDefinition.ParameterDefinition&lt;X&gt; materialize();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A builder for defining an implementation of a method and optionally defining a type variable, thrown exception or a parameter type.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                interface Simple&lt;V&gt; extends ExceptionDefinition&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                     *
&nbsp;                     * @param type The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                     *             should be equal to the currently instrumented type.
&nbsp;                     * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; withParameter(Type type);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                     *
&nbsp;                     * @param type The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                     *             should be equal to the currently instrumented type.
&nbsp;                     * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; withParameter(TypeDefinition type);
&nbsp;
&nbsp;                    /**
&nbsp;                     * A builder for optionally defining an annotation on a parameter.
&nbsp;                     *
&nbsp;                     * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                     */
&nbsp;                    interface Annotatable&lt;V&gt; extends Simple&lt;V&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Annotates the previously defined parameter with the specified annotations.
&nbsp;                         *
&nbsp;                         * @param annotation The annotations to declare on the previously defined parameter.
&nbsp;                         * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                         * the specified annotations.
&nbsp;                         */
&nbsp;                        Annotatable&lt;V&gt; annotateParameter(Annotation... annotation);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Annotates the previously defined parameter with the specified annotations.
&nbsp;                         *
&nbsp;                         * @param annotations The annotations to declare on the previously defined parameter.
&nbsp;                         * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                         * the specified annotations.
&nbsp;                         */
&nbsp;                        Annotatable&lt;V&gt; annotateParameter(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Annotates the previously defined parameter with the specified annotations.
&nbsp;                         *
&nbsp;                         * @param annotation The annotations to declare on the previously defined parameter.
&nbsp;                         * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                         * the specified annotations.
&nbsp;                         */
&nbsp;                        Annotatable&lt;V&gt; annotateParameter(AnnotationDescription... annotation);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Annotates the previously defined parameter with the specified annotations.
&nbsp;                         *
&nbsp;                         * @param annotations The annotations to declare on the previously defined parameter.
&nbsp;                         * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                         * the specified annotations.
&nbsp;                         */
&nbsp;                        Annotatable&lt;V&gt; annotateParameter(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An abstract base implementation of a simple parameter definition.
&nbsp;                         *
&nbsp;                         * @param &lt;W&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                         */
<b class="fc">&nbsp;                        abstract class AbstractBase&lt;W&gt; extends Simple.AbstractBase&lt;W&gt; implements Annotatable&lt;W&gt; {</b>
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Simple.Annotatable&lt;W&gt; annotateParameter(Annotation... annotation) {
<b class="nc">&nbsp;                                return annotateParameter(Arrays.asList(annotation));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Simple.Annotatable&lt;W&gt; annotateParameter(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                                return annotateParameter(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Simple.Annotatable&lt;W&gt; annotateParameter(AnnotationDescription... annotation) {
<b class="nc">&nbsp;                                return annotateParameter(Arrays.asList(annotation));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * An adapter implementation of a simple parameter definition.
&nbsp;                             *
&nbsp;                             * @param &lt;X&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                             */
<b class="fc">&nbsp;                            protected abstract static class Adapter&lt;X&gt; extends Simple.Annotatable.AbstractBase&lt;X&gt; {</b>
&nbsp;
&nbsp;                                @Override
&nbsp;                                public Simple.Annotatable&lt;X&gt; withParameter(TypeDefinition type) {
<b class="fc">&nbsp;                                    return materialize().withParameter(type);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public ExceptionDefinition&lt;X&gt; throwing(Collection&lt;? extends TypeDefinition&gt; types) {
<b class="nc">&nbsp;                                    return materialize().throwing(types);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public TypeVariableDefinition.Annotatable&lt;X&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
<b class="nc">&nbsp;                                    return materialize().typeVariable(symbol, bounds);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; intercept(Implementation implementation) {
<b class="fc">&nbsp;                                    return materialize().intercept(implementation);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; withoutCode() {
<b class="nc">&nbsp;                                    return materialize().withoutCode();</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="nc">&nbsp;                                    return materialize().defaultValue(annotationValue);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public &lt;V&gt; MethodDefinition.ReceiverTypeDefinition&lt;X&gt; defaultValue(V value, Class&lt;? extends V&gt; type) {
<b class="nc">&nbsp;                                    return materialize().defaultValue(value, type);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Materializes this instance as a simple parameter definition with the currently defined properties.
&nbsp;                                 *
&nbsp;                                 * @return A simple parameter definition with the currently defined properties.
&nbsp;                                 */
&nbsp;                                protected abstract MethodDefinition.ParameterDefinition.Simple&lt;X&gt; materialize();
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An abstract base implementation of an exception definition.
&nbsp;                     *
&nbsp;                     * @param &lt;W&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                     */
<b class="fc">&nbsp;                    abstract class AbstractBase&lt;W&gt; extends ExceptionDefinition.AbstractBase&lt;W&gt; implements Simple&lt;W&gt; {</b>
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Simple.Annotatable&lt;W&gt; withParameter(Type type) {
<b class="nc">&nbsp;                            return withParameter(TypeDefinition.Sort.describe(type));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A builder for defining an implementation of a method and optionally defining a type variable, thrown exception or method parameter.
&nbsp;                 * Implementations allow for the &lt;i&gt;one-by-one&lt;/i&gt; definition of parameters what gives opportunity to annotate parameters in a fluent
&nbsp;                 * style. Doing so, it is optionally possible to define parameter names and modifiers. This can be done for either all or no parameters.
&nbsp;                 * Alternatively, parameters without annotations, names or modifiers can be defined by a single step.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                interface Initial&lt;V&gt; extends ParameterDefinition&lt;V&gt;, Simple&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Defines the specified parameters for the currently defined method.
&nbsp;                     *
&nbsp;                     * @param type The parameter types. Any type can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                     *             should be equal to the currently instrumented type.
&nbsp;                     * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameters.
&nbsp;                     */
&nbsp;                    ExceptionDefinition&lt;V&gt; withParameters(Type... type);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Defines the specified parameters for the currently defined method.
&nbsp;                     *
&nbsp;                     * @param types The parameter types. Any type can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                     *              should be equal to the currently instrumented type.
&nbsp;                     * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameters.
&nbsp;                     */
&nbsp;                    ExceptionDefinition&lt;V&gt; withParameters(List&lt;? extends Type&gt; types);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Defines the specified parameters for the currently defined method.
&nbsp;                     *
&nbsp;                     * @param type The parameter types. Any type can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                     *             should be equal to the currently instrumented type.
&nbsp;                     * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameters.
&nbsp;                     */
&nbsp;                    ExceptionDefinition&lt;V&gt; withParameters(TypeDefinition... type);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Defines the specified parameters for the currently defined method.
&nbsp;                     *
&nbsp;                     * @param types The parameter types. Any type can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                     *              should be equal to the currently instrumented type.
&nbsp;                     * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameters.
&nbsp;                     */
&nbsp;                    ExceptionDefinition&lt;V&gt; withParameters(Collection&lt;? extends TypeDefinition&gt; types);
&nbsp;
&nbsp;                    /**
&nbsp;                     * An abstract base implementation for an initial parameter definition.
&nbsp;                     *
&nbsp;                     * @param &lt;W&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                     */
<b class="fc">&nbsp;                    abstract class AbstractBase&lt;W&gt; extends ParameterDefinition.AbstractBase&lt;W&gt; implements Initial&lt;W&gt; {</b>
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Simple.Annotatable&lt;W&gt; withParameter(Type type) {
<b class="nc">&nbsp;                            return withParameter(TypeDefinition.Sort.describe(type));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public ExceptionDefinition&lt;W&gt; withParameters(Type... type) {
<b class="fc">&nbsp;                            return withParameters(Arrays.asList(type));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public ExceptionDefinition&lt;W&gt; withParameters(List&lt;? extends Type&gt; types) {
<b class="fc">&nbsp;                            return withParameters(new TypeList.Generic.ForLoadedTypes(types));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public ExceptionDefinition&lt;W&gt; withParameters(TypeDefinition... type) {
<b class="nc">&nbsp;                            return withParameters(Arrays.asList(type));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public ExceptionDefinition&lt;W&gt; withParameters(Collection&lt;? extends TypeDefinition&gt; types) {
<b class="fc">&nbsp;                            ParameterDefinition.Simple&lt;W&gt; parameterDefinition = this;</b>
<b class="fc">&nbsp;                            for (TypeDefinition type : types) {</b>
<b class="fc">&nbsp;                                parameterDefinition = parameterDefinition.withParameter(type);</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            return parameterDefinition;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation for defining an implementation of a method and optionally defining a type variable, thrown exception or parameter type.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;V&gt; extends ExceptionDefinition.AbstractBase&lt;V&gt; implements ParameterDefinition&lt;V&gt; {</b>
&nbsp;
&nbsp;                    @Override
&nbsp;                    public ParameterDefinition.Annotatable&lt;V&gt; withParameter(Type type, String name, ModifierContributor.ForParameter... modifierContributor) {
<b class="nc">&nbsp;                        return withParameter(type, name, Arrays.asList(modifierContributor));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public ParameterDefinition.Annotatable&lt;V&gt; withParameter(Type type, String name, Collection&lt;? extends ModifierContributor.ForParameter&gt; modifierContributors) {
<b class="nc">&nbsp;                        return withParameter(type, name, ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public ParameterDefinition.Annotatable&lt;V&gt; withParameter(Type type, String name, int modifiers) {
<b class="nc">&nbsp;                        return withParameter(TypeDefinition.Sort.describe(type), name, modifiers);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public ParameterDefinition.Annotatable&lt;V&gt; withParameter(TypeDefinition type, String name, ModifierContributor.ForParameter... modifierContributor) {
<b class="nc">&nbsp;                        return withParameter(type, name, Arrays.asList(modifierContributor));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public ParameterDefinition.Annotatable&lt;V&gt; withParameter(TypeDefinition type, String name, Collection&lt;? extends ModifierContributor.ForParameter&gt; modifierContributors) {
<b class="nc">&nbsp;                        return withParameter(type, name, ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract base implementation of a method definition.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
<b class="fc">&nbsp;            abstract class AbstractBase&lt;U&gt; extends Builder.AbstractBase.Delegator&lt;U&gt; implements MethodDefinition&lt;U&gt; {</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition&lt;U&gt; annotateMethod(Annotation... annotation) {
<b class="nc">&nbsp;                    return annotateMethod(Arrays.asList(annotation));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition&lt;U&gt; annotateMethod(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                    return annotateMethod(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition&lt;U&gt; annotateMethod(AnnotationDescription... annotation) {
<b class="nc">&nbsp;                    return annotateMethod(Arrays.asList(annotation));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition&lt;U&gt; annotateParameter(int index, Annotation... annotation) {
<b class="nc">&nbsp;                    return annotateParameter(index, Arrays.asList(annotation));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition&lt;U&gt; annotateParameter(int index, List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                    return annotateParameter(index, new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition&lt;U&gt; annotateParameter(int index, AnnotationDescription... annotation) {
<b class="nc">&nbsp;                    return annotateParameter(index, Arrays.asList(annotation));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter implementation of a method definition.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected abstract static class Adapter&lt;V&gt; extends MethodDefinition.ReceiverTypeDefinition.AbstractBase&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The handler that determines how a method is implemented.
&nbsp;                     */
&nbsp;                    protected final MethodRegistry.Handler handler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method attribute appender factory to apply onto the method that is currently being implemented.
&nbsp;                     */
&nbsp;                    protected final MethodAttributeAppender.Factory methodAttributeAppenderFactory;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The transformer to apply onto the method that is currently being implemented.
&nbsp;                     */
&nbsp;                    protected final Transformer&lt;MethodDescription&gt; transformer;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new adapter for a method definition.
&nbsp;                     *
&nbsp;                     * @param handler                        The handler that determines how a method is implemented.
&nbsp;                     * @param methodAttributeAppenderFactory The method attribute appender factory to apply onto the method that is currently being implemented.
&nbsp;                     * @param transformer                    The transformer to apply onto the method that is currently being implemented.
&nbsp;                     */
&nbsp;                    protected Adapter(MethodRegistry.Handler handler,
&nbsp;                                      MethodAttributeAppender.Factory methodAttributeAppenderFactory,
<b class="fc">&nbsp;                                      Transformer&lt;MethodDescription&gt; transformer) {</b>
<b class="fc">&nbsp;                        this.handler = handler;</b>
<b class="fc">&nbsp;                        this.methodAttributeAppenderFactory = methodAttributeAppenderFactory;</b>
<b class="fc">&nbsp;                        this.transformer = transformer;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition&lt;V&gt; attribute(MethodAttributeAppender.Factory methodAttributeAppenderFactory) {
<b class="fc">&nbsp;                        return materialize(handler, new MethodAttributeAppender.Factory.Compound(this.methodAttributeAppenderFactory, methodAttributeAppenderFactory), transformer);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs for Java 6
&nbsp;                    public MethodDefinition&lt;V&gt; transform(Transformer&lt;MethodDescription&gt; transformer) {
<b class="fc">&nbsp;                        return materialize(handler, methodAttributeAppenderFactory, new Transformer.Compound&lt;MethodDescription&gt;(this.transformer, transformer));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Materializes the current builder as a method definition.
&nbsp;                     *
&nbsp;                     * @param handler                        The handler that determines how a method is implemented.
&nbsp;                     * @param methodAttributeAppenderFactory The method attribute appender factory to apply onto the method that is currently being implemented.
&nbsp;                     * @param transformer                    The method transformer to apply onto the method that is currently being implemented.
&nbsp;                     * @return Returns a method definition for the supplied properties.
&nbsp;                     */
&nbsp;                    protected abstract MethodDefinition&lt;V&gt; materialize(MethodRegistry.Handler handler,
&nbsp;                                                                       MethodAttributeAppender.Factory methodAttributeAppenderFactory,
&nbsp;                                                                       Transformer&lt;MethodDescription&gt; transformer);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a dynamic type builder.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase&lt;S&gt; implements Builder&lt;S&gt; {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public Builder&lt;S&gt; annotateType(Annotation... annotation) {
<b class="fc">&nbsp;                return annotateType(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Builder&lt;S&gt; annotateType(List&lt;? extends Annotation&gt; annotations) {
<b class="fc">&nbsp;                return annotateType(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Builder&lt;S&gt; annotateType(AnnotationDescription... annotation) {
<b class="nc">&nbsp;                return annotateType(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Builder&lt;S&gt; modifiers(ModifierContributor.ForType... modifierContributor) {
<b class="fc">&nbsp;                return modifiers(Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Builder&lt;S&gt; modifiers(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors) {
<b class="fc">&nbsp;                return modifiers(ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Builder&lt;S&gt; merge(ModifierContributor.ForType... modifierContributor) {
<b class="nc">&nbsp;                return merge(Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ImplementationDefinition.Optional&lt;S&gt; implement(Type... interfaceType) {
<b class="fc">&nbsp;                return implement(Arrays.asList(interfaceType));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ImplementationDefinition.Optional&lt;S&gt; implement(List&lt;? extends Type&gt; interfaceTypes) {
<b class="fc">&nbsp;                return implement(new TypeList.Generic.ForLoadedTypes(interfaceTypes));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ImplementationDefinition.Optional&lt;S&gt; implement(TypeDefinition... interfaceType) {
<b class="nc">&nbsp;                return implement(Arrays.asList(interfaceType));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeVariableDefinition&lt;S&gt; typeVariable(String symbol) {
<b class="nc">&nbsp;                return typeVariable(symbol, TypeDescription.Generic.OBJECT);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeVariableDefinition&lt;S&gt; typeVariable(String symbol, Type... bound) {
<b class="nc">&nbsp;                return typeVariable(symbol, Arrays.asList(bound));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeVariableDefinition&lt;S&gt; typeVariable(String symbol, List&lt;? extends Type&gt; bounds) {
<b class="nc">&nbsp;                return typeVariable(symbol, new TypeList.Generic.ForLoadedTypes(bounds));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeVariableDefinition&lt;S&gt; typeVariable(String symbol, TypeDefinition... bound) {
<b class="nc">&nbsp;                return typeVariable(symbol, Arrays.asList(bound));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, Type type, ModifierContributor.ForField... modifierContributor) {
<b class="fc">&nbsp;                return defineField(name, type, Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, Type type, Collection&lt;? extends ModifierContributor.ForField&gt; modifierContributors) {
<b class="fc">&nbsp;                return defineField(name, type, ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, Type type, int modifiers) {
<b class="fc">&nbsp;                return defineField(name, TypeDefinition.Sort.describe(type), modifiers);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, TypeDefinition type, ModifierContributor.ForField... modifierContributor) {
<b class="fc">&nbsp;                return defineField(name, type, Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, TypeDefinition type, Collection&lt;? extends ModifierContributor.ForField&gt; modifierContributors) {
<b class="fc">&nbsp;                return defineField(name, type, ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; define(Field field) {
<b class="nc">&nbsp;                return define(new FieldDescription.ForLoadedField(field));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; define(FieldDescription field) {
<b class="nc">&nbsp;                return defineField(field.getName(), field.getType(), field.getModifiers());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Optional&lt;S&gt; serialVersionUid(long serialVersionUid) {
<b class="fc">&nbsp;                return defineField(&quot;serialVersionUID&quot;, long.class, Visibility.PRIVATE, FieldManifestation.FINAL, Ownership.STATIC).value(serialVersionUid);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Valuable&lt;S&gt; field(ElementMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="nc">&nbsp;                return field(new LatentMatcher.Resolved&lt;FieldDescription&gt;(matcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Builder&lt;S&gt; ignoreAlso(ElementMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
<b class="fc">&nbsp;                return ignoreAlso(new LatentMatcher.Resolved&lt;MethodDescription&gt;(ignoredMethods));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, Type returnType, ModifierContributor.ForMethod... modifierContributor) {
<b class="fc">&nbsp;                return defineMethod(name, returnType, Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, Type returnType, Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors) {
<b class="fc">&nbsp;                return defineMethod(name, returnType, ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, Type returnType, int modifiers) {
<b class="fc">&nbsp;                return defineMethod(name, TypeDefinition.Sort.describe(returnType), modifiers);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, TypeDefinition returnType, ModifierContributor.ForMethod... modifierContributor) {
<b class="nc">&nbsp;                return defineMethod(name, returnType, Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, TypeDefinition returnType, Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors) {
<b class="nc">&nbsp;                return defineMethod(name, returnType, ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineConstructor(ModifierContributor.ForMethod... modifierContributor) {
<b class="fc">&nbsp;                return defineConstructor(Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineConstructor(Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors) {
<b class="fc">&nbsp;                return defineConstructor(ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; define(Method method) {
<b class="nc">&nbsp;                return define(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; define(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;                return define(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; define(MethodDescription methodDescription) {
<b class="nc">&nbsp;                MethodDefinition.ParameterDefinition.Initial&lt;S&gt; initialParameterDefinition = methodDescription.isConstructor()</b>
<b class="nc">&nbsp;                        ? defineConstructor(methodDescription.getModifiers())</b>
<b class="nc">&nbsp;                        : defineMethod(methodDescription.getInternalName(), methodDescription.getReturnType(), methodDescription.getModifiers());</b>
<b class="nc">&nbsp;                ParameterList&lt;?&gt; parameterList = methodDescription.getParameters();</b>
&nbsp;                MethodDefinition.ExceptionDefinition&lt;S&gt; exceptionDefinition;
<b class="nc">&nbsp;                if (parameterList.hasExplicitMetaData()) {</b>
<b class="nc">&nbsp;                    MethodDefinition.ParameterDefinition&lt;S&gt; parameterDefinition = initialParameterDefinition;</b>
<b class="nc">&nbsp;                    for (ParameterDescription parameter : parameterList) {</b>
<b class="nc">&nbsp;                        parameterDefinition = parameterDefinition.withParameter(parameter.getType(), parameter.getName(), parameter.getModifiers());</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    exceptionDefinition = parameterDefinition;</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    exceptionDefinition = initialParameterDefinition.withParameters(parameterList.asTypeList());</b>
&nbsp;                }
<b class="nc">&nbsp;                MethodDefinition.TypeVariableDefinition&lt;S&gt; typeVariableDefinition = exceptionDefinition.throwing(methodDescription.getExceptionTypes());</b>
<b class="nc">&nbsp;                for (TypeDescription.Generic typeVariable : methodDescription.getTypeVariables()) {</b>
<b class="nc">&nbsp;                    typeVariableDefinition = typeVariableDefinition.typeVariable(typeVariable.getSymbol(), typeVariable.getUpperBounds());</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return typeVariableDefinition;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Optional&lt;S&gt; defineProperty(String name, Type type) {
<b class="nc">&nbsp;                return defineProperty(name, TypeDefinition.Sort.describe(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Optional&lt;S&gt; defineProperty(String name, Type type, boolean readOnly) {
<b class="nc">&nbsp;                return defineProperty(name, TypeDefinition.Sort.describe(type), readOnly);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Optional&lt;S&gt; defineProperty(String name, TypeDefinition type) {
<b class="nc">&nbsp;                return defineProperty(name, type, false);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDefinition.Optional&lt;S&gt; defineProperty(String name, TypeDefinition type, boolean readOnly) {
<b class="nc">&nbsp;                if (name.isEmpty()) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;A bean property cannot have an empty name&quot;);</b>
<b class="nc">&nbsp;                } else if (type.represents(void.class)) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;A bean property cannot have a void type&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                DynamicType.Builder&lt;S&gt; builder = this;</b>
&nbsp;                FieldManifestation fieldManifestation;
<b class="nc">&nbsp;                if (!readOnly) {</b>
<b class="nc">&nbsp;                    builder = builder</b>
<b class="nc">&nbsp;                            .defineMethod(&quot;set&quot; + Character.toUpperCase(name.charAt(0)) + name.substring(1), void.class, Visibility.PUBLIC)</b>
<b class="nc">&nbsp;                            .withParameters(type)</b>
<b class="nc">&nbsp;                            .intercept(FieldAccessor.ofField(name));</b>
<b class="nc">&nbsp;                    fieldManifestation = FieldManifestation.PLAIN;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    fieldManifestation = FieldManifestation.FINAL;</b>
&nbsp;                }
<b class="nc">&nbsp;                return builder</b>
<b class="nc">&nbsp;                        .defineMethod((type.represents(boolean.class) || type.represents(Boolean.class)</b>
&nbsp;                                ? &quot;is&quot;
<b class="nc">&nbsp;                                : &quot;get&quot;) + Character.toUpperCase(name.charAt(0)) + name.substring(1), type, Visibility.PUBLIC)</b>
<b class="nc">&nbsp;                        .intercept(FieldAccessor.ofField(name))</b>
<b class="nc">&nbsp;                        .defineField(name, type, Visibility.PRIVATE, fieldManifestation);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; method(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;                return invokable(isMethod().and(matcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; constructor(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="nc">&nbsp;                return invokable(isConstructor().and(matcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; invokable(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;                return invokable(new LatentMatcher.Resolved&lt;MethodDescription&gt;(matcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Builder&lt;S&gt; withHashCodeEquals() {
<b class="nc">&nbsp;                return method(isHashCode())</b>
<b class="nc">&nbsp;                        .intercept(HashCodeMethod.usingDefaultOffset().withIgnoredFields(isSynthetic()))</b>
<b class="nc">&nbsp;                        .method(isEquals())</b>
<b class="nc">&nbsp;                        .intercept(EqualsMethod.isolated().withIgnoredFields(isSynthetic()));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Builder&lt;S&gt; withToString() {
<b class="nc">&nbsp;                return method(isToString()).intercept(ToStringMethod.prefixedBySimpleClassName());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Unloaded&lt;S&gt; make(TypePool typePool) {
<b class="nc">&nbsp;                return make(TypeResolutionStrategy.Passive.INSTANCE, typePool);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Unloaded&lt;S&gt; make() {
<b class="fc">&nbsp;                return make(TypeResolutionStrategy.Passive.INSTANCE);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A delegator for a dynamic type builder delegating all invocations to another dynamic type builder.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
<b class="fc">&nbsp;            public abstract static class Delegator&lt;U&gt; extends AbstractBase&lt;U&gt; {</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; visit(AsmVisitorWrapper asmVisitorWrapper) {
<b class="nc">&nbsp;                    return materialize().visit(asmVisitorWrapper);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; initializer(LoadedTypeInitializer loadedTypeInitializer) {
<b class="nc">&nbsp;                    return materialize().initializer(loadedTypeInitializer);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; annotateType(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                    return materialize().annotateType(annotations);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; attribute(TypeAttributeAppender typeAttributeAppender) {
<b class="nc">&nbsp;                    return materialize().attribute(typeAttributeAppender);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; modifiers(int modifiers) {
<b class="nc">&nbsp;                    return materialize().modifiers(modifiers);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; merge(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors) {
<b class="nc">&nbsp;                    return materialize().merge(modifierContributors);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; name(String name) {
<b class="nc">&nbsp;                    return materialize().name(name);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition.ImplementationDefinition.Optional&lt;U&gt; implement(Collection&lt;? extends TypeDefinition&gt; interfaceTypes) {
<b class="fc">&nbsp;                    return materialize().implement(interfaceTypes);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; initializer(ByteCodeAppender byteCodeAppender) {
<b class="nc">&nbsp;                    return materialize().initializer(byteCodeAppender);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; ignoreAlso(ElementMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
<b class="nc">&nbsp;                    return materialize().ignoreAlso(ignoredMethods);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; ignoreAlso(LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
<b class="nc">&nbsp;                    return materialize().ignoreAlso(ignoredMethods);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeVariableDefinition&lt;U&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
<b class="nc">&nbsp;                    return materialize().typeVariable(symbol, bounds);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; transform(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher, Transformer&lt;TypeVariableToken&gt; transformer) {
<b class="nc">&nbsp;                    return materialize().transform(matcher, transformer);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public FieldDefinition.Optional.Valuable&lt;U&gt; defineField(String name, TypeDefinition type, int modifiers) {
<b class="fc">&nbsp;                    return materialize().defineField(name, type, modifiers);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public FieldDefinition.Valuable&lt;U&gt; field(LatentMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="nc">&nbsp;                    return materialize().field(matcher);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition.ParameterDefinition.Initial&lt;U&gt; defineMethod(String name, TypeDefinition returnType, int modifiers) {
<b class="fc">&nbsp;                    return materialize().defineMethod(name, returnType, modifiers);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition.ParameterDefinition.Initial&lt;U&gt; defineConstructor(int modifiers) {
<b class="fc">&nbsp;                    return materialize().defineConstructor(modifiers);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition.ImplementationDefinition&lt;U&gt; invokable(LatentMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;                    return materialize().invokable(matcher);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public DynamicType.Unloaded&lt;U&gt; make() {
<b class="fc">&nbsp;                    return materialize().make();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Unloaded&lt;U&gt; make(TypeResolutionStrategy typeResolutionStrategy) {
<b class="nc">&nbsp;                    return materialize().make(typeResolutionStrategy);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Unloaded&lt;U&gt; make(TypePool typePool) {
<b class="nc">&nbsp;                    return materialize().make(typePool);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Unloaded&lt;U&gt; make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool) {
<b class="nc">&nbsp;                    return materialize().make(typeResolutionStrategy, typePool);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new builder that realizes the current state of the builder.
&nbsp;                 *
&nbsp;                 * @return A new builder that realizes the current state of the builder.
&nbsp;                 */
&nbsp;                protected abstract Builder&lt;U&gt; materialize();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An adapter implementation of a dynamic type builder.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public abstract static class Adapter&lt;U&gt; extends AbstractBase&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type to be created.
&nbsp;                 */
&nbsp;                protected final InstrumentedType.WithFlexibleName instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The current field registry.
&nbsp;                 */
&nbsp;                protected final FieldRegistry fieldRegistry;
&nbsp;
&nbsp;                /**
&nbsp;                 * The current method registry.
&nbsp;                 */
&nbsp;                protected final MethodRegistry methodRegistry;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type attribute appender to apply onto the instrumented type.
&nbsp;                 */
&nbsp;                protected final TypeAttributeAppender typeAttributeAppender;
&nbsp;
&nbsp;                /**
&nbsp;                 * The ASM visitor wrapper to apply onto the class writer.
&nbsp;                 */
&nbsp;                protected final AsmVisitorWrapper asmVisitorWrapper;
&nbsp;
&nbsp;                /**
&nbsp;                 * The class file version to define auxiliary types in.
&nbsp;                 */
&nbsp;                protected final ClassFileVersion classFileVersion;
&nbsp;
&nbsp;                /**
&nbsp;                 * The naming strategy for auxiliary types to apply.
&nbsp;                 */
&nbsp;                protected final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation value filter factory to apply.
&nbsp;                 */
&nbsp;                protected final AnnotationValueFilter.Factory annotationValueFilterFactory;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation retention to apply.
&nbsp;                 */
&nbsp;                protected final AnnotationRetention annotationRetention;
&nbsp;
&nbsp;                /**
&nbsp;                 * The implementation context factory to apply.
&nbsp;                 */
&nbsp;                protected final Implementation.Context.Factory implementationContextFactory;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method graph compiler to use.
&nbsp;                 */
&nbsp;                protected final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;                /**
&nbsp;                 * Determines if a type should be explicitly validated.
&nbsp;                 */
&nbsp;                protected final TypeValidation typeValidation;
&nbsp;
&nbsp;                /**
&nbsp;                 * The class writer strategy to use.
&nbsp;                 */
&nbsp;                protected final ClassWriterStrategy classWriterStrategy;
&nbsp;
&nbsp;                /**
&nbsp;                 * A matcher for identifying methods that should be excluded from instrumentation.
&nbsp;                 */
&nbsp;                protected final LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new default type writer for creating a new type that is not based on an existing class file.
&nbsp;                 *
&nbsp;                 * @param instrumentedType             The instrumented type to be created.
&nbsp;                 * @param fieldRegistry                The current field registry.
&nbsp;                 * @param methodRegistry               The current method registry.
&nbsp;                 * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;                 * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;                 * @param classFileVersion             The class file version to define auxiliary types in.
&nbsp;                 * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;                 * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;                 * @param annotationRetention          The annotation retention to apply.
&nbsp;                 * @param implementationContextFactory The implementation context factory to apply.
&nbsp;                 * @param methodGraphCompiler          The method graph compiler to use.
&nbsp;                 * @param typeValidation               Determines if a type should be explicitly validated.
&nbsp;                 * @param classWriterStrategy          The class writer strategy to use.
&nbsp;                 * @param ignoredMethods               A matcher for identifying methods that should be excluded from instrumentation.
&nbsp;                 */
&nbsp;                protected Adapter(InstrumentedType.WithFlexibleName instrumentedType,
&nbsp;                                  FieldRegistry fieldRegistry,
&nbsp;                                  MethodRegistry methodRegistry,
&nbsp;                                  TypeAttributeAppender typeAttributeAppender,
&nbsp;                                  AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                                  ClassFileVersion classFileVersion,
&nbsp;                                  AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                  AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                  AnnotationRetention annotationRetention,
&nbsp;                                  Implementation.Context.Factory implementationContextFactory,
&nbsp;                                  MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                  TypeValidation typeValidation,
&nbsp;                                  ClassWriterStrategy classWriterStrategy,
<b class="fc">&nbsp;                                  LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods) {</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                    this.fieldRegistry = fieldRegistry;</b>
<b class="fc">&nbsp;                    this.methodRegistry = methodRegistry;</b>
<b class="fc">&nbsp;                    this.typeAttributeAppender = typeAttributeAppender;</b>
<b class="fc">&nbsp;                    this.asmVisitorWrapper = asmVisitorWrapper;</b>
<b class="fc">&nbsp;                    this.classFileVersion = classFileVersion;</b>
<b class="fc">&nbsp;                    this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;</b>
<b class="fc">&nbsp;                    this.annotationValueFilterFactory = annotationValueFilterFactory;</b>
<b class="fc">&nbsp;                    this.annotationRetention = annotationRetention;</b>
<b class="fc">&nbsp;                    this.implementationContextFactory = implementationContextFactory;</b>
<b class="fc">&nbsp;                    this.methodGraphCompiler = methodGraphCompiler;</b>
<b class="fc">&nbsp;                    this.typeValidation = typeValidation;</b>
<b class="fc">&nbsp;                    this.classWriterStrategy = classWriterStrategy;</b>
<b class="fc">&nbsp;                    this.ignoredMethods = ignoredMethods;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public FieldDefinition.Optional.Valuable&lt;U&gt; defineField(String name, TypeDefinition type, int modifiers) {
<b class="fc">&nbsp;                    return new FieldDefinitionAdapter(new FieldDescription.Token(name, modifiers, type.asGenericType()));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public FieldDefinition.Valuable&lt;U&gt; field(LatentMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="nc">&nbsp;                    return new FieldMatchAdapter(matcher);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition.ParameterDefinition.Initial&lt;U&gt; defineMethod(String name, TypeDefinition returnType, int modifiers) {
<b class="fc">&nbsp;                    return new MethodDefinitionAdapter(new MethodDescription.Token(name, modifiers, returnType.asGenericType()));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition.ParameterDefinition.Initial&lt;U&gt; defineConstructor(int modifiers) {
<b class="fc">&nbsp;                    return new MethodDefinitionAdapter(new MethodDescription.Token(modifiers));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition.ImplementationDefinition&lt;U&gt; invokable(LatentMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;                    return new MethodMatchAdapter(matcher);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDefinition.ImplementationDefinition.Optional&lt;U&gt; implement(Collection&lt;? extends TypeDefinition&gt; interfaceTypes) {
<b class="fc">&nbsp;                    return new OptionalMethodMatchAdapter(new TypeList.Generic.Explicit(new ArrayList&lt;TypeDefinition&gt;(interfaceTypes)));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs for Java 6
&nbsp;                public Builder&lt;U&gt; ignoreAlso(LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
<b class="fc">&nbsp;                    return materialize(instrumentedType,</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            classWriterStrategy,
&nbsp;                            new LatentMatcher.Disjunction&lt;MethodDescription&gt;(this.ignoredMethods, ignoredMethods));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; initializer(ByteCodeAppender byteCodeAppender) {
<b class="nc">&nbsp;                    return materialize(instrumentedType.withInitializer(byteCodeAppender),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; initializer(LoadedTypeInitializer loadedTypeInitializer) {
<b class="nc">&nbsp;                    return materialize(instrumentedType.withInitializer(loadedTypeInitializer),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; name(String name) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withName(name),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; modifiers(int modifiers) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withModifiers(modifiers),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; merge(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors) {
<b class="nc">&nbsp;                    return materialize(instrumentedType.withModifiers(ModifierContributor.Resolver.of(modifierContributors).resolve(instrumentedType.getModifiers())),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeVariableDefinition&lt;U&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
<b class="nc">&nbsp;                    return new TypeVariableDefinitionAdapter(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList&lt;TypeDefinition&gt;(bounds))));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; transform(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher, Transformer&lt;TypeVariableToken&gt; transformer) {
<b class="nc">&nbsp;                    return materialize(instrumentedType.withTypeVariables(matcher, transformer),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; attribute(TypeAttributeAppender typeAttributeAppender) {
<b class="nc">&nbsp;                    return materialize(instrumentedType,</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            new TypeAttributeAppender.Compound(this.typeAttributeAppender, typeAttributeAppender),
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; annotateType(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withAnnotations(new ArrayList&lt;AnnotationDescription&gt;(annotations)),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Builder&lt;U&gt; visit(AsmVisitorWrapper asmVisitorWrapper) {
<b class="nc">&nbsp;                    return materialize(instrumentedType,</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            new AsmVisitorWrapper.Compound(this.asmVisitorWrapper, asmVisitorWrapper),
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Materializes the supplied state of a dynamic type builder.
&nbsp;                 *
&nbsp;                 * @param instrumentedType             The instrumented type.
&nbsp;                 * @param fieldRegistry                The current field registry.
&nbsp;                 * @param methodRegistry               The current method registry.
&nbsp;                 * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;                 * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;                 * @param classFileVersion             The class file version to define auxiliary types in.
&nbsp;                 * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;                 * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;                 * @param annotationRetention          The annotation retention to apply.
&nbsp;                 * @param implementationContextFactory The implementation context factory to apply.
&nbsp;                 * @param methodGraphCompiler          The method graph compiler to use.
&nbsp;                 * @param typeValidation               The type validation state.
&nbsp;                 * @param classWriterStrategy          The class writer strategy to use.
&nbsp;                 * @param ignoredMethods               A matcher for identifying methods that should be excluded from instrumentation.
&nbsp;                 * @return A type builder that represents the supplied arguments.
&nbsp;                 */
&nbsp;                protected abstract Builder&lt;U&gt; materialize(InstrumentedType.WithFlexibleName instrumentedType,
&nbsp;                                                          FieldRegistry fieldRegistry,
&nbsp;                                                          MethodRegistry methodRegistry,
&nbsp;                                                          TypeAttributeAppender typeAttributeAppender,
&nbsp;                                                          AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                                                          ClassFileVersion classFileVersion,
&nbsp;                                                          AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                                          AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                          AnnotationRetention annotationRetention,
&nbsp;                                                          Implementation.Context.Factory implementationContextFactory,
&nbsp;                                                          MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                                          TypeValidation typeValidation,
&nbsp;                                                          ClassWriterStrategy classWriterStrategy,
&nbsp;                                                          LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods);
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for defining a new type variable for the instrumented type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class TypeVariableDefinitionAdapter extends TypeVariableDefinition.AbstractBase&lt;U&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The current definition of the type variable.
&nbsp;                     */
&nbsp;                    private final TypeVariableToken token;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new type variable definition adapter.
&nbsp;                     *
&nbsp;                     * @param token The current definition of the type variable.
&nbsp;                     */
&nbsp;                    protected TypeVariableDefinitionAdapter(TypeVariableToken token) {
&nbsp;                        this.token = token;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeVariableDefinition&lt;U&gt; annotateTypeVariable(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                        return new TypeVariableDefinitionAdapter(new TypeVariableToken(token.getSymbol(),
&nbsp;                                token.getBounds(),
&nbsp;                                CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations))));
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Builder&lt;U&gt; materialize() {
&nbsp;                        return Adapter.this.materialize(instrumentedType.withTypeVariable(token),
&nbsp;                                fieldRegistry,
&nbsp;                                methodRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for defining a new field.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class FieldDefinitionAdapter extends FieldDefinition.Optional.Valuable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The token representing the current field definition.
&nbsp;                     */
&nbsp;                    private final FieldDescription.Token token;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new field definition adapter.
&nbsp;                     *
&nbsp;                     * @param token The token representing the current field definition.
&nbsp;                     */
&nbsp;                    protected FieldDefinitionAdapter(FieldDescription.Token token) {
<b class="fc">&nbsp;                        this(FieldAttributeAppender.ForInstrumentedField.INSTANCE,</b>
<b class="fc">&nbsp;                                Transformer.NoOp.&lt;FieldDescription&gt;make(),</b>
&nbsp;                                FieldDescription.NO_DEFAULT_VALUE,
&nbsp;                                token);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new field definition adapter.
&nbsp;                     *
&nbsp;                     * @param fieldAttributeAppenderFactory The field attribute appender factory to apply.
&nbsp;                     * @param transformer                   The field transformer to apply.
&nbsp;                     * @param defaultValue                  The field&#39;s default value or {@code null} if no value is to be defined.
&nbsp;                     * @param token                         The token representing the current field definition.
&nbsp;                     */
&nbsp;                    protected FieldDefinitionAdapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
&nbsp;                                                     Transformer&lt;FieldDescription&gt; transformer,
&nbsp;                                                     Object defaultValue,
<b class="fc">&nbsp;                                                     FieldDescription.Token token) {</b>
<b class="fc">&nbsp;                        super(fieldAttributeAppenderFactory, transformer, defaultValue);</b>
<b class="fc">&nbsp;                        this.token = token;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Optional&lt;U&gt; annotateField(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                        return new FieldDefinitionAdapter(fieldAttributeAppenderFactory, transformer, defaultValue, new FieldDescription.Token(token.getName(),</b>
<b class="nc">&nbsp;                                token.getModifiers(),</b>
<b class="nc">&nbsp;                                token.getType(),</b>
<b class="nc">&nbsp;                                CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations))));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                        return Builder.AbstractBase.Adapter.this.materialize(instrumentedType.withField(token),</b>
<b class="fc">&nbsp;                                fieldRegistry.prepend(new LatentMatcher.ForFieldToken(token), fieldAttributeAppenderFactory, defaultValue, transformer),</b>
&nbsp;                                methodRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Optional&lt;U&gt; materialize(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
&nbsp;                                                      Transformer&lt;FieldDescription&gt; transformer,
&nbsp;                                                      Object defaultValue) {
<b class="fc">&nbsp;                        return new FieldDefinitionAdapter(fieldAttributeAppenderFactory, transformer, defaultValue, token);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for matching an existing field.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class FieldMatchAdapter extends FieldDefinition.Optional.Valuable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The matcher for any fields to apply this matcher to.
&nbsp;                     */
&nbsp;                    private final LatentMatcher&lt;? super FieldDescription&gt; matcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new field match adapter.
&nbsp;                     *
&nbsp;                     * @param matcher The matcher for any fields to apply this matcher to.
&nbsp;                     */
&nbsp;                    protected FieldMatchAdapter(LatentMatcher&lt;? super FieldDescription&gt; matcher) {
&nbsp;                        this(FieldAttributeAppender.NoOp.INSTANCE,
&nbsp;                                Transformer.NoOp.&lt;FieldDescription&gt;make(),
&nbsp;                                FieldDescription.NO_DEFAULT_VALUE,
&nbsp;                                matcher);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new field match adapter.
&nbsp;                     *
&nbsp;                     * @param fieldAttributeAppenderFactory The field attribute appender factory to apply.
&nbsp;                     * @param transformer                   The field transformer to apply.
&nbsp;                     * @param defaultValue                  The field&#39;s default value or {@code null} if no value is to be defined.
&nbsp;                     * @param matcher                       The matcher for any fields to apply this matcher to.
&nbsp;                     */
&nbsp;                    protected FieldMatchAdapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
&nbsp;                                                Transformer&lt;FieldDescription&gt; transformer,
&nbsp;                                                Object defaultValue,
&nbsp;                                                LatentMatcher&lt;? super FieldDescription&gt; matcher) {
&nbsp;                        super(fieldAttributeAppenderFactory, transformer, defaultValue);
&nbsp;                        this.matcher = matcher;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Optional&lt;U&gt; annotateField(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                        return attribute(new FieldAttributeAppender.Explicit(new ArrayList&lt;AnnotationDescription&gt;(annotations)));
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Builder&lt;U&gt; materialize() {
&nbsp;                        return Builder.AbstractBase.Adapter.this.materialize(instrumentedType,
&nbsp;                                fieldRegistry.prepend(matcher, fieldAttributeAppenderFactory, defaultValue, transformer),
&nbsp;                                methodRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Optional&lt;U&gt; materialize(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
&nbsp;                                                      Transformer&lt;FieldDescription&gt; transformer,
&nbsp;                                                      Object defaultValue) {
&nbsp;                        return new FieldMatchAdapter(fieldAttributeAppenderFactory, transformer, defaultValue, matcher);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for defining a new method.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;                protected class MethodDefinitionAdapter extends MethodDefinition.ParameterDefinition.Initial.AbstractBase&lt;U&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token representing the currently defined method.
&nbsp;                     */
&nbsp;                    private final MethodDescription.Token token;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new method definition adapter.
&nbsp;                     *
&nbsp;                     * @param token A token representing the currently defined method.
&nbsp;                     */
<b class="fc">&nbsp;                    protected MethodDefinitionAdapter(MethodDescription.Token token) {</b>
<b class="fc">&nbsp;                        this.token = token;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition.ParameterDefinition.Annotatable&lt;U&gt; withParameter(TypeDefinition type, String name, int modifiers) {
<b class="nc">&nbsp;                        return new ParameterAnnotationAdapter(new ParameterDescription.Token(type.asGenericType(), name, modifiers));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Simple.Annotatable&lt;U&gt; withParameter(TypeDefinition type) {
<b class="fc">&nbsp;                        return new SimpleParameterAnnotationAdapter(new ParameterDescription.Token(type.asGenericType()));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition.ExceptionDefinition&lt;U&gt; throwing(Collection&lt;? extends TypeDefinition&gt; types) {
<b class="nc">&nbsp;                        return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),</b>
<b class="nc">&nbsp;                                token.getModifiers(),</b>
<b class="nc">&nbsp;                                token.getTypeVariableTokens(),</b>
<b class="nc">&nbsp;                                token.getReturnType(),</b>
<b class="nc">&nbsp;                                token.getParameterTokens(),</b>
<b class="nc">&nbsp;                                CompoundList.of(token.getExceptionTypes(), new TypeList.Generic.Explicit(new ArrayList&lt;TypeDefinition&gt;(types))),</b>
<b class="nc">&nbsp;                                token.getAnnotations(),</b>
<b class="nc">&nbsp;                                token.getDefaultValue(),</b>
<b class="nc">&nbsp;                                token.getReceiverType()));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition.TypeVariableDefinition.Annotatable&lt;U&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
<b class="nc">&nbsp;                        return new TypeVariableAnnotationAdapter(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList&lt;TypeDefinition&gt;(bounds))));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; intercept(Implementation implementation) {
<b class="fc">&nbsp;                        return materialize(new MethodRegistry.Handler.ForImplementation(implementation));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; withoutCode() {
<b class="nc">&nbsp;                        return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),</b>
<b class="nc">&nbsp;                                ModifierContributor.Resolver.of(MethodManifestation.ABSTRACT).resolve(token.getModifiers()),</b>
<b class="nc">&nbsp;                                token.getTypeVariableTokens(),</b>
<b class="nc">&nbsp;                                token.getReturnType(),</b>
<b class="nc">&nbsp;                                token.getParameterTokens(),</b>
<b class="nc">&nbsp;                                token.getExceptionTypes(),</b>
<b class="nc">&nbsp;                                token.getAnnotations(),</b>
<b class="nc">&nbsp;                                token.getDefaultValue(),</b>
<b class="nc">&nbsp;                                token.getReceiverType())).materialize(MethodRegistry.Handler.ForAbstractMethod.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="nc">&nbsp;                        return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),</b>
<b class="nc">&nbsp;                                ModifierContributor.Resolver.of(MethodManifestation.ABSTRACT).resolve(token.getModifiers()),</b>
<b class="nc">&nbsp;                                token.getTypeVariableTokens(),</b>
<b class="nc">&nbsp;                                token.getReturnType(),</b>
<b class="nc">&nbsp;                                token.getParameterTokens(),</b>
<b class="nc">&nbsp;                                token.getExceptionTypes(),</b>
<b class="nc">&nbsp;                                token.getAnnotations(),</b>
&nbsp;                                annotationValue,
<b class="nc">&nbsp;                                token.getReceiverType())).materialize(new MethodRegistry.Handler.ForAnnotationValue(annotationValue));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Materializes the given handler as the implementation.
&nbsp;                     *
&nbsp;                     * @param handler The handler for implementing the method.
&nbsp;                     * @return A method definition for the given handler.
&nbsp;                     */
&nbsp;                    private MethodDefinition.ReceiverTypeDefinition&lt;U&gt; materialize(MethodRegistry.Handler handler) {
<b class="fc">&nbsp;                        return new AnnotationAdapter(handler);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An adapter for defining a new type variable for the currently defined method.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class TypeVariableAnnotationAdapter extends MethodDefinition.TypeVariableDefinition.Annotatable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The currently defined type variable.
&nbsp;                         */
&nbsp;                        private final TypeVariableToken token;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new type variable annotation adapter.
&nbsp;                         *
&nbsp;                         * @param token The currently defined type variable.
&nbsp;                         */
&nbsp;                        protected TypeVariableAnnotationAdapter(TypeVariableToken token) {
&nbsp;                            this.token = token;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected MethodDefinition.ParameterDefinition&lt;U&gt; materialize() {
&nbsp;                            return new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(),
&nbsp;                                    MethodDefinitionAdapter.this.token.getModifiers(),
&nbsp;                                    CompoundList.of(MethodDefinitionAdapter.this.token.getTypeVariableTokens(), token),
&nbsp;                                    MethodDefinitionAdapter.this.token.getReturnType(),
&nbsp;                                    MethodDefinitionAdapter.this.token.getParameterTokens(),
&nbsp;                                    MethodDefinitionAdapter.this.token.getExceptionTypes(),
&nbsp;                                    MethodDefinitionAdapter.this.token.getAnnotations(),
&nbsp;                                    MethodDefinitionAdapter.this.token.getDefaultValue(),
&nbsp;                                    MethodDefinitionAdapter.this.token.getReceiverType()));
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Annotatable&lt;U&gt; annotateTypeVariable(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                            return new TypeVariableAnnotationAdapter(new TypeVariableToken(token.getSymbol(),
&nbsp;                                    token.getBounds(),
&nbsp;                                    CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations))));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotation adapter for a parameter definition.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class ParameterAnnotationAdapter extends MethodDefinition.ParameterDefinition.Annotatable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The token of the currently defined parameter.
&nbsp;                         */
&nbsp;                        private final ParameterDescription.Token token;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new parameter annotation adapter.
&nbsp;                         *
&nbsp;                         * @param token The token of the currently defined parameter.
&nbsp;                         */
&nbsp;                        protected ParameterAnnotationAdapter(ParameterDescription.Token token) {
&nbsp;                            this.token = token;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public MethodDefinition.ParameterDefinition.Annotatable&lt;U&gt; annotateParameter(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                            return new ParameterAnnotationAdapter(new ParameterDescription.Token(token.getType(),
&nbsp;                                    CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations)),
&nbsp;                                    token.getName(),
&nbsp;                                    token.getModifiers()));
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected MethodDefinition.ParameterDefinition&lt;U&gt; materialize() {
&nbsp;                            return new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(),
&nbsp;                                    MethodDefinitionAdapter.this.token.getModifiers(),
&nbsp;                                    MethodDefinitionAdapter.this.token.getTypeVariableTokens(),
&nbsp;                                    MethodDefinitionAdapter.this.token.getReturnType(),
&nbsp;                                    CompoundList.of(MethodDefinitionAdapter.this.token.getParameterTokens(), token),
&nbsp;                                    MethodDefinitionAdapter.this.token.getExceptionTypes(),
&nbsp;                                    MethodDefinitionAdapter.this.token.getAnnotations(),
&nbsp;                                    MethodDefinitionAdapter.this.token.getDefaultValue(),
&nbsp;                                    MethodDefinitionAdapter.this.token.getReceiverType()));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotation adapter for a simple parameter definition.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class SimpleParameterAnnotationAdapter extends MethodDefinition.ParameterDefinition.Simple.Annotatable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The token of the currently defined parameter.
&nbsp;                         */
&nbsp;                        private final ParameterDescription.Token token;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new simple parameter annotation adapter.
&nbsp;                         *
&nbsp;                         * @param token The token of the currently defined parameter.
&nbsp;                         */
<b class="fc">&nbsp;                        protected SimpleParameterAnnotationAdapter(ParameterDescription.Token token) {</b>
<b class="fc">&nbsp;                            this.token = token;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public MethodDefinition.ParameterDefinition.Simple.Annotatable&lt;U&gt; annotateParameter(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                            return new SimpleParameterAnnotationAdapter(new ParameterDescription.Token(token.getType(),</b>
<b class="nc">&nbsp;                                    CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations)),</b>
<b class="nc">&nbsp;                                    token.getName(),</b>
<b class="nc">&nbsp;                                    token.getModifiers()));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected MethodDefinition.ParameterDefinition.Simple&lt;U&gt; materialize() {
<b class="fc">&nbsp;                            return new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getModifiers(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getTypeVariableTokens(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getReturnType(),</b>
<b class="fc">&nbsp;                                    CompoundList.of(MethodDefinitionAdapter.this.token.getParameterTokens(), token),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getExceptionTypes(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getAnnotations(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getDefaultValue(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getReceiverType()));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotation adapter for a method definition.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class AnnotationAdapter extends MethodDefinition.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation adapter.
&nbsp;                         *
&nbsp;                         * @param handler The handler that determines how a method is implemented.
&nbsp;                         */
&nbsp;                        protected AnnotationAdapter(MethodRegistry.Handler handler) {
<b class="fc">&nbsp;                            this(handler,</b>
&nbsp;                                    MethodAttributeAppender.ForInstrumentedMethod.INCLUDING_RECEIVER,
<b class="fc">&nbsp;                                    Transformer.NoOp.&lt;MethodDescription&gt;make());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation adapter.
&nbsp;                         *
&nbsp;                         * @param handler                        The handler that determines how a method is implemented.
&nbsp;                         * @param methodAttributeAppenderFactory The method attribute appender factory to apply onto the method that is currently being implemented.
&nbsp;                         * @param transformer                    The method transformer to apply onto the method that is currently being implemented.
&nbsp;                         */
&nbsp;                        protected AnnotationAdapter(MethodRegistry.Handler handler,
&nbsp;                                                    MethodAttributeAppender.Factory methodAttributeAppenderFactory,
<b class="fc">&nbsp;                                                    Transformer&lt;MethodDescription&gt; transformer) {</b>
<b class="fc">&nbsp;                            super(handler, methodAttributeAppenderFactory, transformer);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public MethodDefinition&lt;U&gt; receiverType(TypeDescription.Generic receiverType) {
<b class="nc">&nbsp;                            return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),</b>
<b class="nc">&nbsp;                                    token.getModifiers(),</b>
<b class="nc">&nbsp;                                    token.getTypeVariableTokens(),</b>
<b class="nc">&nbsp;                                    token.getReturnType(),</b>
<b class="nc">&nbsp;                                    token.getParameterTokens(),</b>
<b class="nc">&nbsp;                                    token.getExceptionTypes(),</b>
<b class="nc">&nbsp;                                    token.getAnnotations(),</b>
<b class="nc">&nbsp;                                    token.getDefaultValue(),</b>
&nbsp;                                    receiverType)).new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public MethodDefinition&lt;U&gt; annotateMethod(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                            return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),</b>
<b class="nc">&nbsp;                                    token.getModifiers(),</b>
<b class="nc">&nbsp;                                    token.getTypeVariableTokens(),</b>
<b class="nc">&nbsp;                                    token.getReturnType(),</b>
<b class="nc">&nbsp;                                    token.getParameterTokens(),</b>
<b class="nc">&nbsp;                                    token.getExceptionTypes(),</b>
<b class="nc">&nbsp;                                    CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations)),</b>
<b class="nc">&nbsp;                                    token.getDefaultValue(),</b>
<b class="nc">&nbsp;                                    token.getReceiverType())).new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public MethodDefinition&lt;U&gt; annotateParameter(int index, Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                            List&lt;ParameterDescription.Token&gt; parameterTokens = new ArrayList&lt;ParameterDescription.Token&gt;(token.getParameterTokens());</b>
<b class="nc">&nbsp;                            parameterTokens.set(index, new ParameterDescription.Token(token.getParameterTokens().get(index).getType(),</b>
<b class="nc">&nbsp;                                    CompoundList.of(token.getParameterTokens().get(index).getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations)),</b>
<b class="nc">&nbsp;                                    token.getParameterTokens().get(index).getName(),</b>
<b class="nc">&nbsp;                                    token.getParameterTokens().get(index).getModifiers()));</b>
<b class="nc">&nbsp;                            return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),</b>
<b class="nc">&nbsp;                                    token.getModifiers(),</b>
<b class="nc">&nbsp;                                    token.getTypeVariableTokens(),</b>
<b class="nc">&nbsp;                                    token.getReturnType(),</b>
&nbsp;                                    parameterTokens,
<b class="nc">&nbsp;                                    token.getExceptionTypes(),</b>
<b class="nc">&nbsp;                                    token.getAnnotations(),</b>
<b class="nc">&nbsp;                                    token.getDefaultValue(),</b>
<b class="nc">&nbsp;                                    token.getReceiverType())).new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected MethodDefinition&lt;U&gt; materialize(MethodRegistry.Handler handler,
&nbsp;                                                                  MethodAttributeAppender.Factory methodAttributeAppenderFactory,
&nbsp;                                                                  Transformer&lt;MethodDescription&gt; transformer) {
<b class="nc">&nbsp;                            return new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                            return Builder.AbstractBase.Adapter.this.materialize(instrumentedType.withMethod(token),</b>
&nbsp;                                    fieldRegistry,
<b class="fc">&nbsp;                                    methodRegistry.prepend(new LatentMatcher.ForMethodToken(token),</b>
&nbsp;                                            handler,
&nbsp;                                            methodAttributeAppenderFactory,
&nbsp;                                            transformer),
&nbsp;                                    typeAttributeAppender,
&nbsp;                                    asmVisitorWrapper,
&nbsp;                                    classFileVersion,
&nbsp;                                    auxiliaryTypeNamingStrategy,
&nbsp;                                    annotationValueFilterFactory,
&nbsp;                                    annotationRetention,
&nbsp;                                    implementationContextFactory,
&nbsp;                                    methodGraphCompiler,
&nbsp;                                    typeValidation,
&nbsp;                                    classWriterStrategy,
&nbsp;                                    ignoredMethods);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for matching an existing method.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;                protected class MethodMatchAdapter extends MethodDefinition.ImplementationDefinition.AbstractBase&lt;U&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method matcher of this adapter.
&nbsp;                     */
&nbsp;                    private final LatentMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new method match adapter.
&nbsp;                     *
&nbsp;                     * @param matcher The method matcher of this adapter.
&nbsp;                     */
<b class="fc">&nbsp;                    protected MethodMatchAdapter(LatentMatcher&lt;? super MethodDescription&gt; matcher) {</b>
<b class="fc">&nbsp;                        this.matcher = matcher;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; intercept(Implementation implementation) {
<b class="fc">&nbsp;                        return materialize(new MethodRegistry.Handler.ForImplementation(implementation));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; withoutCode() {
<b class="nc">&nbsp;                        return materialize(MethodRegistry.Handler.ForAbstractMethod.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="nc">&nbsp;                        return materialize(new MethodRegistry.Handler.ForAnnotationValue(annotationValue));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Materializes the method definition with the supplied handler.
&nbsp;                     *
&nbsp;                     * @param handler The handler that implements any method matched by this instances matcher.
&nbsp;                     * @return A method definition where any matched method is implemented by the supplied handler.
&nbsp;                     */
&nbsp;                    private MethodDefinition.ReceiverTypeDefinition&lt;U&gt; materialize(MethodRegistry.Handler handler) {
<b class="fc">&nbsp;                        return new AnnotationAdapter(handler);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotation adapter for implementing annotations during a method definition.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class AnnotationAdapter extends MethodDefinition.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation adapter.
&nbsp;                         *
&nbsp;                         * @param handler The handler that determines how a method is implemented.
&nbsp;                         */
&nbsp;                        protected AnnotationAdapter(MethodRegistry.Handler handler) {
<b class="fc">&nbsp;                            this(handler, MethodAttributeAppender.NoOp.INSTANCE, Transformer.NoOp.&lt;MethodDescription&gt;make());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation adapter.
&nbsp;                         *
&nbsp;                         * @param handler                        The handler that determines how a method is implemented.
&nbsp;                         * @param methodAttributeAppenderFactory The method attribute appender factory to apply onto the method that is currently being implemented.
&nbsp;                         * @param transformer                    The method transformer to apply onto the method that is currently being implemented.
&nbsp;                         */
&nbsp;                        protected AnnotationAdapter(MethodRegistry.Handler handler,
&nbsp;                                                    MethodAttributeAppender.Factory methodAttributeAppenderFactory,
<b class="fc">&nbsp;                                                    Transformer&lt;MethodDescription&gt; transformer) {</b>
<b class="fc">&nbsp;                            super(handler, methodAttributeAppenderFactory, transformer);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public MethodDefinition&lt;U&gt; receiverType(TypeDescription.Generic receiverType) {
<b class="nc">&nbsp;                            return new AnnotationAdapter(handler,</b>
&nbsp;                                    new MethodAttributeAppender.Factory.Compound(methodAttributeAppenderFactory, new MethodAttributeAppender.ForReceiverType(receiverType)),
&nbsp;                                    transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public MethodDefinition&lt;U&gt; annotateMethod(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                            return new AnnotationAdapter(handler,</b>
&nbsp;                                    new MethodAttributeAppender.Factory.Compound(methodAttributeAppenderFactory, new MethodAttributeAppender.Explicit(new ArrayList&lt;AnnotationDescription&gt;(annotations))),
&nbsp;                                    transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public MethodDefinition&lt;U&gt; annotateParameter(int index, Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                            return new AnnotationAdapter(handler,</b>
&nbsp;                                    new MethodAttributeAppender.Factory.Compound(methodAttributeAppenderFactory, new MethodAttributeAppender.Explicit(index, new ArrayList&lt;AnnotationDescription&gt;(annotations))),
&nbsp;                                    transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected MethodDefinition&lt;U&gt; materialize(MethodRegistry.Handler handler,
&nbsp;                                                                  MethodAttributeAppender.Factory methodAttributeAppenderFactory,
&nbsp;                                                                  Transformer&lt;MethodDescription&gt; transformer) {
<b class="fc">&nbsp;                            return new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                            return Builder.AbstractBase.Adapter.this.materialize(instrumentedType,</b>
&nbsp;                                    fieldRegistry,
<b class="fc">&nbsp;                                    methodRegistry.prepend(matcher, handler, methodAttributeAppenderFactory, transformer),</b>
&nbsp;                                    typeAttributeAppender,
&nbsp;                                    asmVisitorWrapper,
&nbsp;                                    classFileVersion,
&nbsp;                                    auxiliaryTypeNamingStrategy,
&nbsp;                                    annotationValueFilterFactory,
&nbsp;                                    annotationRetention,
&nbsp;                                    implementationContextFactory,
&nbsp;                                    methodGraphCompiler,
&nbsp;                                    typeValidation,
&nbsp;                                    classWriterStrategy,
&nbsp;                                    ignoredMethods);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for optionally matching methods defined by declared interfaces.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class OptionalMethodMatchAdapter extends Builder.AbstractBase.Delegator&lt;U&gt; implements MethodDefinition.ImplementationDefinition.Optional&lt;U&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The interfaces whose methods are optionally matched.
&nbsp;                     */
&nbsp;                    private final TypeList.Generic interfaces;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new optional method match adapter.
&nbsp;                     *
&nbsp;                     * @param interfaces The interfaces whose methods are optionally matched.
&nbsp;                     */
<b class="fc">&nbsp;                    protected OptionalMethodMatchAdapter(TypeList.Generic interfaces) {</b>
<b class="fc">&nbsp;                        this.interfaces = interfaces;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                        return Adapter.this.materialize(instrumentedType.withInterfaces(interfaces),</b>
&nbsp;                                fieldRegistry,
&nbsp;                                methodRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; intercept(Implementation implementation) {
<b class="fc">&nbsp;                        return interfaceType().intercept(implementation);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; withoutCode() {
<b class="nc">&nbsp;                        return interfaceType().withoutCode();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="nc">&nbsp;                        return interfaceType().defaultValue(annotationValue);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public &lt;V&gt; MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(V value, Class&lt;? extends V&gt; type) {
<b class="nc">&nbsp;                        return interfaceType().defaultValue(value, type);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns a matcher for the interfaces&#39; methods.
&nbsp;                     *
&nbsp;                     * @return A matcher for the interfaces&#39; methods.
&nbsp;                     */
&nbsp;                    private MethodDefinition.ImplementationDefinition&lt;U&gt; interfaceType() {
<b class="fc">&nbsp;                        ElementMatcher.Junction&lt;TypeDescription&gt; elementMatcher = none();</b>
<b class="fc">&nbsp;                        for (TypeDescription typeDescription : interfaces.asErasures()) {</b>
<b class="fc">&nbsp;                            elementMatcher = elementMatcher.or(isSuperTypeOf(typeDescription));</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return materialize().invokable(isDeclaredBy(isInterface().and(elementMatcher)));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A dynamic type that has not yet been loaded by a given {@link java.lang.ClassLoader}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The most specific known loaded type that is implemented by this dynamic type, usually the
&nbsp;     *            type itself, an interface or the direct super class.
&nbsp;     */
&nbsp;    interface Unloaded&lt;T&gt; extends DynamicType {
&nbsp;
&nbsp;        /**
&nbsp;         * Attempts to load this dynamic type including all of its auxiliary types, if any. If the class loader
&nbsp;         * is the bootstrap class loader, a new class loader is created for loading those types. If the class loader
&nbsp;         * is an instance of {@link InjectionClassLoader}, the class is injected. And otherwise, the types are injected
&nbsp;         * into the provided class loader.
&nbsp;         *
&nbsp;         * @param classLoader The class loader to use for this class loading.
&nbsp;         * @return This dynamic type in its loaded state.
&nbsp;         */
&nbsp;        Loaded&lt;T&gt; load(ClassLoader classLoader);
&nbsp;
&nbsp;        /**
&nbsp;         * Attempts to load this dynamic type including all of its auxiliary types, if any.
&nbsp;         *
&nbsp;         * @param classLoader          The class loader to use for this class loading.
&nbsp;         * @param classLoadingStrategy The class loader strategy which should be used for this class loading.
&nbsp;         * @param &lt;S&gt;                  The least specific type of class loader this strategy can apply to.
&nbsp;         * @return This dynamic type in its loaded state.
&nbsp;         * @see net.bytebuddy.dynamic.loading.ClassLoadingStrategy.Default
&nbsp;         */
&nbsp;        &lt;S extends ClassLoader&gt; Loaded&lt;T&gt; load(S classLoader, ClassLoadingStrategy&lt;? super S&gt; classLoadingStrategy);
&nbsp;
&nbsp;        /**
&nbsp;         * Includes the provided dynamic types as auxiliary types of this instance.
&nbsp;         *
&nbsp;         * @param dynamicType The dynamic types to include.
&nbsp;         * @return A copy of this unloaded dynamic type which includes the provided dynamic types.
&nbsp;         */
&nbsp;        Unloaded&lt;T&gt; include(DynamicType... dynamicType);
&nbsp;
&nbsp;        /**
&nbsp;         * Includes the provided dynamic types as auxiliary types of this instance.
&nbsp;         *
&nbsp;         * @param dynamicTypes The dynamic types to include.
&nbsp;         * @return A copy of this unloaded dynamic type which includes the provided dynamic types.
&nbsp;         */
&nbsp;        Unloaded&lt;T&gt; include(List&lt;? extends DynamicType&gt; dynamicTypes);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A dynamic type that has been loaded into the running instance of the Java virtual machine.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The most specific known loaded type that is implemented by this dynamic type, usually the
&nbsp;     *            type itself, an interface or the direct super class.
&nbsp;     */
&nbsp;    interface Loaded&lt;T&gt; extends DynamicType {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the loaded main class.
&nbsp;         *
&nbsp;         * @return A loaded class representation of this dynamic type.
&nbsp;         */
&nbsp;        Class&lt;? extends T&gt; getLoaded();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Returns a map of all loaded auxiliary types to this dynamic type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: The type descriptions will most likely differ from the binary representation of this type.
&nbsp;         * Normally, annotations and intercepted methods are not added to the type descriptions of auxiliary types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return A mapping from the fully qualified names of all auxiliary types to their loaded class representations.
&nbsp;         */
&nbsp;        Map&lt;TypeDescription, Class&lt;?&gt;&gt; getLoadedAuxiliaryTypes();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A default implementation of a dynamic type.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Default implements DynamicType {
&nbsp;
&nbsp;        /**
&nbsp;         * The file name extension for Java class files.
&nbsp;         */
&nbsp;        private static final String CLASS_FILE_EXTENSION = &quot;.class&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The default version of a jar file manifest.
&nbsp;         */
&nbsp;        private static final String MANIFEST_VERSION = &quot;1.0&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The size of a writing buffer.
&nbsp;         */
&nbsp;        private static final int BUFFER_SIZE = 1024;
&nbsp;
&nbsp;        /**
&nbsp;         * A convenience index for the beginning of an array to improve the readability of the code.
&nbsp;         */
&nbsp;        private static final int FROM_BEGINNING = 0;
&nbsp;
&nbsp;        /**
&nbsp;         * A convenience representative of an {@link java.io.InputStream}&#39;s end to improve the readability of the code.
&nbsp;         */
&nbsp;        private static final int END_OF_FILE = -1;
&nbsp;
&nbsp;        /**
&nbsp;         * A suffix for temporary files.
&nbsp;         */
&nbsp;        private static final String TEMP_SUFFIX = &quot;tmp&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * A type description of this dynamic type.
&nbsp;         */
&nbsp;        protected final TypeDescription typeDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * The byte array representing this dynamic type.
&nbsp;         */
&nbsp;        protected final byte[] binaryRepresentation;
&nbsp;
&nbsp;        /**
&nbsp;         * The loaded type initializer for this dynamic type.
&nbsp;         */
&nbsp;        protected final LoadedTypeInitializer loadedTypeInitializer;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of auxiliary types for this dynamic type.
&nbsp;         */
&nbsp;        protected final List&lt;? extends DynamicType&gt; auxiliaryTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new dynamic type.
&nbsp;         *
&nbsp;         * @param typeDescription       A description of this dynamic type.
&nbsp;         * @param binaryRepresentation  A byte array containing the binary representation of this dynamic type. The array must not be modified.
&nbsp;         * @param loadedTypeInitializer The loaded type initializer of this dynamic type.
&nbsp;         * @param auxiliaryTypes        The auxiliary type required for this dynamic type.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP2&quot;, justification = &quot;The array is not to be modified by contract&quot;)
&nbsp;        public Default(TypeDescription typeDescription,
&nbsp;                       byte[] binaryRepresentation,
&nbsp;                       LoadedTypeInitializer loadedTypeInitializer,
<b class="fc">&nbsp;                       List&lt;? extends DynamicType&gt; auxiliaryTypes) {</b>
<b class="fc">&nbsp;            this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;            this.binaryRepresentation = binaryRepresentation;</b>
<b class="fc">&nbsp;            this.loadedTypeInitializer = loadedTypeInitializer;</b>
<b class="fc">&nbsp;            this.auxiliaryTypes = auxiliaryTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getTypeDescription() {
<b class="fc">&nbsp;            return typeDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Map&lt;TypeDescription, byte[]&gt; getAllTypes() {
<b class="fc">&nbsp;            Map&lt;TypeDescription, byte[]&gt; allTypes = new LinkedHashMap&lt;TypeDescription, byte[]&gt;();</b>
<b class="fc">&nbsp;            allTypes.put(typeDescription, binaryRepresentation);</b>
<b class="fc">&nbsp;            for (DynamicType auxiliaryType : auxiliaryTypes) {</b>
<b class="fc">&nbsp;                allTypes.putAll(auxiliaryType.getAllTypes());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return allTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Map&lt;TypeDescription, LoadedTypeInitializer&gt; getLoadedTypeInitializers() {
<b class="fc">&nbsp;            Map&lt;TypeDescription, LoadedTypeInitializer&gt; classLoadingCallbacks = new HashMap&lt;TypeDescription, LoadedTypeInitializer&gt;();</b>
<b class="fc">&nbsp;            for (DynamicType auxiliaryType : auxiliaryTypes) {</b>
<b class="fc">&nbsp;                classLoadingCallbacks.putAll(auxiliaryType.getLoadedTypeInitializers());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            classLoadingCallbacks.put(typeDescription, loadedTypeInitializer);</b>
<b class="fc">&nbsp;            return classLoadingCallbacks;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean hasAliveLoadedTypeInitializers() {
<b class="nc">&nbsp;            for (LoadedTypeInitializer loadedTypeInitializer : getLoadedTypeInitializers().values()) {</b>
<b class="nc">&nbsp;                if (loadedTypeInitializer.isAlive()) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP&quot;, justification = &quot;The array is not to be modified by contract&quot;)
&nbsp;        public byte[] getBytes() {
<b class="nc">&nbsp;            return binaryRepresentation;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Map&lt;TypeDescription, byte[]&gt; getAuxiliaryTypes() {
<b class="nc">&nbsp;            Map&lt;TypeDescription, byte[]&gt; auxiliaryTypes = new HashMap&lt;TypeDescription, byte[]&gt;();</b>
<b class="nc">&nbsp;            for (DynamicType auxiliaryType : this.auxiliaryTypes) {</b>
<b class="nc">&nbsp;                auxiliaryTypes.put(auxiliaryType.getTypeDescription(), auxiliaryType.getBytes());</b>
<b class="nc">&nbsp;                auxiliaryTypes.putAll(auxiliaryType.getAuxiliaryTypes());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return auxiliaryTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Map&lt;TypeDescription, File&gt; saveIn(File folder) throws IOException {
<b class="nc">&nbsp;            Map&lt;TypeDescription, File&gt; savedFiles = new HashMap&lt;TypeDescription, File&gt;();</b>
<b class="nc">&nbsp;            File target = new File(folder, typeDescription.getName().replace(&#39;.&#39;, File.separatorChar) + CLASS_FILE_EXTENSION);</b>
<b class="nc">&nbsp;            if (target.getParentFile() != null &amp;&amp; !target.getParentFile().isDirectory() &amp;&amp; !target.getParentFile().mkdirs()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Could not create directory: &quot; + target.getParentFile());</b>
&nbsp;            }
<b class="nc">&nbsp;            OutputStream outputStream = new FileOutputStream(target);</b>
&nbsp;            try {
<b class="nc">&nbsp;                outputStream.write(binaryRepresentation);</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                outputStream.close();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            savedFiles.put(typeDescription, target);</b>
<b class="nc">&nbsp;            for (DynamicType auxiliaryType : auxiliaryTypes) {</b>
<b class="nc">&nbsp;                savedFiles.putAll(auxiliaryType.saveIn(folder));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return savedFiles;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public File inject(File sourceJar, File targetJar) throws IOException {
<b class="nc">&nbsp;            JarInputStream jarInputStream = new JarInputStream(new BufferedInputStream(new FileInputStream(sourceJar)));</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (!targetJar.isFile() &amp;&amp; !targetJar.createNewFile()) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Could not create file: &quot; + targetJar);</b>
&nbsp;                }
<b class="nc">&nbsp;                Manifest manifest = jarInputStream.getManifest();</b>
<b class="nc">&nbsp;                JarOutputStream jarOutputStream = manifest == null</b>
&nbsp;                        ? new JarOutputStream(new FileOutputStream(targetJar))
&nbsp;                        : new JarOutputStream(new FileOutputStream(targetJar), manifest);
&nbsp;                try {
<b class="nc">&nbsp;                    Map&lt;TypeDescription, byte[]&gt; rawAuxiliaryTypes = getAuxiliaryTypes();</b>
<b class="nc">&nbsp;                    Map&lt;String, byte[]&gt; files = new HashMap&lt;String, byte[]&gt;();</b>
<b class="nc">&nbsp;                    for (Map.Entry&lt;TypeDescription, byte[]&gt; entry : rawAuxiliaryTypes.entrySet()) {</b>
<b class="nc">&nbsp;                        files.put(entry.getKey().getInternalName() + CLASS_FILE_EXTENSION, entry.getValue());</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    files.put(typeDescription.getInternalName() + CLASS_FILE_EXTENSION, binaryRepresentation);</b>
&nbsp;                    JarEntry jarEntry;
<b class="nc">&nbsp;                    while ((jarEntry = jarInputStream.getNextJarEntry()) != null) {</b>
<b class="nc">&nbsp;                        byte[] replacement = files.remove(jarEntry.getName());</b>
<b class="nc">&nbsp;                        if (replacement == null) {</b>
<b class="nc">&nbsp;                            jarOutputStream.putNextEntry(jarEntry);</b>
<b class="nc">&nbsp;                            byte[] buffer = new byte[BUFFER_SIZE];</b>
&nbsp;                            int index;
<b class="nc">&nbsp;                            while ((index = jarInputStream.read(buffer)) != END_OF_FILE) {</b>
<b class="nc">&nbsp;                                jarOutputStream.write(buffer, FROM_BEGINNING, index);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } else {</b>
<b class="nc">&nbsp;                            jarOutputStream.putNextEntry(new JarEntry(jarEntry.getName()));</b>
<b class="nc">&nbsp;                            jarOutputStream.write(replacement);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        jarInputStream.closeEntry();</b>
<b class="nc">&nbsp;                        jarOutputStream.closeEntry();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    for (Map.Entry&lt;String, byte[]&gt; entry : files.entrySet()) {</b>
<b class="nc">&nbsp;                        jarOutputStream.putNextEntry(new JarEntry(entry.getKey()));</b>
<b class="nc">&nbsp;                        jarOutputStream.write(entry.getValue());</b>
<b class="nc">&nbsp;                        jarOutputStream.closeEntry();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    jarOutputStream.close();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                jarInputStream.close();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return targetJar;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public File inject(File jar) throws IOException {
<b class="nc">&nbsp;            File temporary = inject(jar, File.createTempFile(jar.getName(), TEMP_SUFFIX));</b>
&nbsp;            try {
<b class="nc">&nbsp;                InputStream jarInputStream = new BufferedInputStream(new FileInputStream(temporary));</b>
&nbsp;                try {
<b class="nc">&nbsp;                    OutputStream jarOutputStream = new BufferedOutputStream(new FileOutputStream(jar));</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        byte[] buffer = new byte[BUFFER_SIZE];</b>
&nbsp;                        int index;
<b class="nc">&nbsp;                        while ((index = jarInputStream.read(buffer)) != END_OF_FILE) {</b>
<b class="nc">&nbsp;                            jarOutputStream.write(buffer, FROM_BEGINNING, index);</b>
&nbsp;                        }
&nbsp;                    } finally {
<b class="nc">&nbsp;                        jarOutputStream.close();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    jarInputStream.close();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                if (!temporary.delete()) {</b>
<b class="nc">&nbsp;                    temporary.deleteOnExit();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return jar;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public File toJar(File file) throws IOException {
<b class="nc">&nbsp;            Manifest manifest = new Manifest();</b>
<b class="nc">&nbsp;            manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, MANIFEST_VERSION);</b>
<b class="nc">&nbsp;            return toJar(file, manifest);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public File toJar(File file, Manifest manifest) throws IOException {
<b class="nc">&nbsp;            if (!file.isFile() &amp;&amp; !file.createNewFile()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Could not create file: &quot; + file);</b>
&nbsp;            }
<b class="nc">&nbsp;            JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(file), manifest);</b>
&nbsp;            try {
<b class="nc">&nbsp;                for (Map.Entry&lt;TypeDescription, byte[]&gt; entry : getAuxiliaryTypes().entrySet()) {</b>
<b class="nc">&nbsp;                    outputStream.putNextEntry(new JarEntry(entry.getKey().getInternalName() + CLASS_FILE_EXTENSION));</b>
<b class="nc">&nbsp;                    outputStream.write(entry.getValue());</b>
<b class="nc">&nbsp;                    outputStream.closeEntry();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                outputStream.putNextEntry(new JarEntry(typeDescription.getInternalName() + CLASS_FILE_EXTENSION));</b>
<b class="nc">&nbsp;                outputStream.write(binaryRepresentation);</b>
<b class="nc">&nbsp;                outputStream.closeEntry();</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                outputStream.close();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return file;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A default implementation of an unloaded dynamic type.
&nbsp;         *
&nbsp;         * @param &lt;T&gt; The most specific known loaded type that is implemented by this dynamic type, usually the
&nbsp;         *            type itself, an interface or the direct super class.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        public static class Unloaded&lt;T&gt; extends Default implements DynamicType.Unloaded&lt;T&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The type resolution strategy to use for initializing the dynamic type.
&nbsp;             */
&nbsp;            private final TypeResolutionStrategy.Resolved typeResolutionStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new unloaded representation of a dynamic type.
&nbsp;             *
&nbsp;             * @param typeDescription        A description of this dynamic type.
&nbsp;             * @param binaryRepresentation   An array of byte of the binary representation of this dynamic type.
&nbsp;             * @param loadedTypeInitializer  The type initializer of this dynamic type.
&nbsp;             * @param auxiliaryTypes         The auxiliary types that are required for this dynamic type.
&nbsp;             * @param typeResolutionStrategy The type resolution strategy to use for initializing the dynamic type.
&nbsp;             */
&nbsp;            public Unloaded(TypeDescription typeDescription,
&nbsp;                            byte[] binaryRepresentation,
&nbsp;                            LoadedTypeInitializer loadedTypeInitializer,
&nbsp;                            List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                            TypeResolutionStrategy.Resolved typeResolutionStrategy) {
<b class="fc">&nbsp;                super(typeDescription, binaryRepresentation, loadedTypeInitializer, auxiliaryTypes);</b>
<b class="fc">&nbsp;                this.typeResolutionStrategy = typeResolutionStrategy;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public DynamicType.Loaded&lt;T&gt; load(ClassLoader classLoader) {
<b class="nc">&nbsp;                return classLoader instanceof InjectionClassLoader &amp;&amp; !((InjectionClassLoader) classLoader).isSealed()</b>
<b class="nc">&nbsp;                        ? load((InjectionClassLoader) classLoader, InjectionClassLoader.Strategy.INSTANCE)</b>
<b class="nc">&nbsp;                        : load(classLoader, ClassLoadingStrategy.Default.WRAPPER);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public &lt;S extends ClassLoader&gt; DynamicType.Loaded&lt;T&gt; load(S classLoader, ClassLoadingStrategy&lt;? super S&gt; classLoadingStrategy) {
<b class="fc">&nbsp;                return new Default.Loaded&lt;T&gt;(typeDescription,</b>
&nbsp;                        binaryRepresentation,
&nbsp;                        loadedTypeInitializer,
&nbsp;                        auxiliaryTypes,
<b class="fc">&nbsp;                        typeResolutionStrategy.initialize(this, classLoader, classLoadingStrategy));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public DynamicType.Unloaded&lt;T&gt; include(DynamicType... dynamicType) {
<b class="nc">&nbsp;                return include(Arrays.asList(dynamicType));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public DynamicType.Unloaded&lt;T&gt; include(List&lt;? extends DynamicType&gt; dynamicType) {
<b class="nc">&nbsp;                return new Default.Unloaded&lt;T&gt;(typeDescription,</b>
&nbsp;                        binaryRepresentation,
&nbsp;                        loadedTypeInitializer,
<b class="nc">&nbsp;                        CompoundList.of(auxiliaryTypes, dynamicType),</b>
&nbsp;                        typeResolutionStrategy);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A default implementation of a loaded dynamic type.
&nbsp;         *
&nbsp;         * @param &lt;T&gt; The most specific known loaded type that is implemented by this dynamic type, usually the
&nbsp;         *            type itself, an interface or the direct super class.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class Loaded&lt;T&gt; extends Default implements DynamicType.Loaded&lt;T&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The loaded types for the given loaded dynamic type.
&nbsp;             */
&nbsp;            private final Map&lt;TypeDescription, Class&lt;?&gt;&gt; loadedTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new representation of a loaded dynamic type.
&nbsp;             *
&nbsp;             * @param typeDescription       A description of this dynamic type.
&nbsp;             * @param typeByte              An array of byte of the binary representation of this dynamic type.
&nbsp;             * @param loadedTypeInitializer The type initializer of this dynamic type.
&nbsp;             * @param auxiliaryTypes        The auxiliary types that are required for this dynamic type.
&nbsp;             * @param loadedTypes           A map of loaded types for this dynamic type and all its auxiliary types.
&nbsp;             */
&nbsp;            protected Loaded(TypeDescription typeDescription,
&nbsp;                             byte[] typeByte,
&nbsp;                             LoadedTypeInitializer loadedTypeInitializer,
&nbsp;                             List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                             Map&lt;TypeDescription, Class&lt;?&gt;&gt; loadedTypes) {
<b class="fc">&nbsp;                super(typeDescription, typeByte, loadedTypeInitializer, auxiliaryTypes);</b>
<b class="fc">&nbsp;                this.loadedTypes = loadedTypes;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            public Class&lt;? extends T&gt; getLoaded() {
<b class="fc">&nbsp;                return (Class&lt;? extends T&gt;) loadedTypes.get(typeDescription);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Map&lt;TypeDescription, Class&lt;?&gt;&gt; getLoadedAuxiliaryTypes() {
<b class="nc">&nbsp;                Map&lt;TypeDescription, Class&lt;?&gt;&gt; loadedAuxiliaryTypes = new HashMap&lt;TypeDescription, Class&lt;?&gt;&gt;(</b>
&nbsp;                        loadedTypes);
<b class="nc">&nbsp;                loadedAuxiliaryTypes.remove(typeDescription);</b>
<b class="nc">&nbsp;                return loadedAuxiliaryTypes;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
