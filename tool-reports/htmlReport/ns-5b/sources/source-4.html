


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > InstrumentedType</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic.scaffold</a>
</div>

<h1>Coverage Summary for Class: InstrumentedType (net.bytebuddy.dynamic.scaffold)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">InstrumentedType$Default</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (21/35)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0,9%
  </span>
  <span class="absValue">
    (2/232)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16,8%
  </span>
  <span class="absValue">
    (45/268)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedType$Factory</td>
  </tr>
  <tr>
    <td class="name">InstrumentedType$Factory$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedType$Factory$Default$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6,2%
  </span>
  <span class="absValue">
    (1/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedType$Factory$Default$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedType$Prepareable</td>
  </tr>
  <tr>
    <td class="name">InstrumentedType$WithFlexibleName</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    61,9%
  </span>
  <span class="absValue">
    (26/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0,9%
  </span>
  <span class="absValue">
    (2/232)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    19,3%
  </span>
  <span class="absValue">
    (57/296)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.dynamic.scaffold;
&nbsp;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.modifier.ModifierContributor;
&nbsp;import net.bytebuddy.description.type.PackageDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeVariableToken;
&nbsp;import net.bytebuddy.dynamic.Transformer;
&nbsp;import net.bytebuddy.implementation.LoadedTypeInitializer;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;
&nbsp;import java.lang.annotation.ElementType;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.is;
&nbsp;
&nbsp;/**
&nbsp; * Implementations of this interface represent an instrumented type that is subject to change. Implementations
&nbsp; * should however be immutable and return new instance when its builder methods are invoked.
&nbsp; */
&nbsp;public interface InstrumentedType extends TypeDescription {
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new instrumented type that includes a new field.
&nbsp;     *
&nbsp;     * @param token A token that represents the field&#39;s shape. This token must represent types in their detached state.
&nbsp;     * @return A new instrumented type that is equal to this instrumented type but with the additional field.
&nbsp;     */
&nbsp;    InstrumentedType withField(FieldDescription.Token token);
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new instrumented type that includes a new method or constructor.
&nbsp;     *
&nbsp;     * @param token A token that represents the method&#39;s shape. This token must represent types in their detached state.
&nbsp;     * @return A new instrumented type that is equal to this instrumented type but with the additional method.
&nbsp;     */
&nbsp;    InstrumentedType withMethod(MethodDescription.Token token);
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new instrumented type with changed modifiers.
&nbsp;     *
&nbsp;     * @param modifiers The instrumented type&#39;s modifiers.
&nbsp;     * @return A new instrumented type that is equal to this instrumented type but with the given modifiers.
&nbsp;     */
&nbsp;    InstrumentedType withModifiers(int modifiers);
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new instrumented type with the given interfaces implemented.
&nbsp;     *
&nbsp;     * @param interfaceTypes The interface types to implement.
&nbsp;     * @return A new instrumented type that is equal to this instrumented type but with the given interfaces implemented.
&nbsp;     */
&nbsp;    InstrumentedType withInterfaces(TypeList.Generic interfaceTypes);
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new instrumented type with the given type variable defined.
&nbsp;     *
&nbsp;     * @param typeVariable The type variable to declare.
&nbsp;     * @return A new instrumented type that is equal to this instrumented type but with the given type variable declared.
&nbsp;     */
&nbsp;    InstrumentedType withTypeVariable(TypeVariableToken typeVariable);
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new instrumented type with the given annotations.
&nbsp;     *
&nbsp;     * @param annotationDescriptions The annotations to add to the instrumented type.
&nbsp;     * @return A new instrumented type that is equal to this instrumented type but annotated with the given annotations
&nbsp;     */
&nbsp;    InstrumentedType withAnnotations(List&lt;? extends AnnotationDescription&gt; annotationDescriptions);
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new instrumented type that includes the given {@link net.bytebuddy.implementation.LoadedTypeInitializer}.
&nbsp;     *
&nbsp;     * @param loadedTypeInitializer The type initializer to include.
&nbsp;     * @return A new instrumented type that is equal to this instrumented type but with the additional type initializer.
&nbsp;     */
&nbsp;    InstrumentedType withInitializer(LoadedTypeInitializer loadedTypeInitializer);
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new instrumented type that executes the given initializer in the instrumented type&#39;s
&nbsp;     * type initializer.
&nbsp;     *
&nbsp;     * @param byteCodeAppender The byte code to add to the type initializer.
&nbsp;     * @return A new instrumented type that is equal to this instrumented type but with the given stack manipulation
&nbsp;     * attached to its type initializer.
&nbsp;     */
&nbsp;    InstrumentedType withInitializer(ByteCodeAppender byteCodeAppender);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the {@link net.bytebuddy.implementation.LoadedTypeInitializer}s that were registered
&nbsp;     * for this instrumented type.
&nbsp;     *
&nbsp;     * @return The registered loaded type initializers for this instrumented type.
&nbsp;     */
&nbsp;    LoadedTypeInitializer getLoadedTypeInitializer();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this instrumented type&#39;s type initializer.
&nbsp;     *
&nbsp;     * @return This instrumented type&#39;s type initializer.
&nbsp;     */
&nbsp;    TypeInitializer getTypeInitializer();
&nbsp;
&nbsp;    /**
&nbsp;     * Validates the instrumented type to define a legal Java type.
&nbsp;     *
&nbsp;     * @return This instrumented type as a non-modifiable type description.
&nbsp;     */
&nbsp;    TypeDescription validated();
&nbsp;
&nbsp;    /**
&nbsp;     * Implementations represent an {@link InstrumentedType} with a flexible name.
&nbsp;     */
&nbsp;    interface WithFlexibleName extends InstrumentedType {
&nbsp;
&nbsp;        @Override
&nbsp;        WithFlexibleName withField(FieldDescription.Token token);
&nbsp;
&nbsp;        @Override
&nbsp;        WithFlexibleName withMethod(MethodDescription.Token token);
&nbsp;
&nbsp;        @Override
&nbsp;        WithFlexibleName withModifiers(int modifiers);
&nbsp;
&nbsp;        @Override
&nbsp;        WithFlexibleName withInterfaces(TypeList.Generic interfaceTypes);
&nbsp;
&nbsp;        @Override
&nbsp;        WithFlexibleName withTypeVariable(TypeVariableToken typeVariable);
&nbsp;
&nbsp;        @Override
&nbsp;        WithFlexibleName withAnnotations(List&lt;? extends AnnotationDescription&gt; annotationDescriptions);
&nbsp;
&nbsp;        @Override
&nbsp;        WithFlexibleName withInitializer(LoadedTypeInitializer loadedTypeInitializer);
&nbsp;
&nbsp;        @Override
&nbsp;        WithFlexibleName withInitializer(ByteCodeAppender byteCodeAppender);
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new instrumented type with a changed name.
&nbsp;         *
&nbsp;         * @param name The name of the instrumented type.
&nbsp;         * @return A new instrumented type that has the given name.
&nbsp;         */
&nbsp;        WithFlexibleName withName(String name);
&nbsp;
&nbsp;        /**
&nbsp;         * Applies a transformation onto all existing type variables of this instrumented type. A transformation is potentially unsafe
&nbsp;         * and it is the responsibility of the supplier to return a valid type variable token from the transformer.
&nbsp;         *
&nbsp;         * @param matcher     The matcher to decide what type variables to transform.
&nbsp;         * @param transformer The transformer to apply on all matched type variables.
&nbsp;         * @return A new instrumented type with all matched type variables transformed.
&nbsp;         */
&nbsp;        WithFlexibleName withTypeVariables(ElementMatcher&lt;? super Generic&gt; matcher, Transformer&lt;TypeVariableToken&gt; transformer);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implementations are able to prepare an {@link InstrumentedType}.
&nbsp;     */
&nbsp;    interface Prepareable {
&nbsp;
&nbsp;        /**
&nbsp;         * Prepares a given instrumented type.
&nbsp;         *
&nbsp;         * @param instrumentedType The instrumented type in its current form.
&nbsp;         * @return The prepared instrumented type.
&nbsp;         */
&nbsp;        InstrumentedType prepare(InstrumentedType instrumentedType);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A factory for creating an {@link InstrumentedType}.
&nbsp;     */
&nbsp;    interface Factory {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an instrumented type that represents the provided type.
&nbsp;         *
&nbsp;         * @param typeDescription The type to represent.
&nbsp;         * @return An appropriate instrumented type.
&nbsp;         */
&nbsp;        InstrumentedType.WithFlexibleName represent(TypeDescription typeDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new instrumented type as a subclass.
&nbsp;         *
&nbsp;         * @param name       The type&#39;s name.
&nbsp;         * @param modifiers  The type&#39;s modifiers.
&nbsp;         * @param superClass The type&#39;s super class.
&nbsp;         * @return A new instrumented type representing a subclass of the given parameters.
&nbsp;         */
&nbsp;        InstrumentedType.WithFlexibleName subclass(String name, int modifiers, TypeDescription.Generic superClass);
&nbsp;
&nbsp;        /**
&nbsp;         * Default implementations of instrumented type factories.
&nbsp;         */
<b class="fc">&nbsp;        enum Default implements Factory {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an instrumented type that allows to modify represented types.
&nbsp;             */
<b class="fc">&nbsp;            MODIFIABLE {</b>
&nbsp;                @Override
&nbsp;                public InstrumentedType.WithFlexibleName represent(TypeDescription typeDescription) {
<b class="nc">&nbsp;                    return new InstrumentedType.Default(typeDescription.getName(),</b>
<b class="nc">&nbsp;                            typeDescription.getModifiers(),</b>
<b class="nc">&nbsp;                            typeDescription.getSuperClass(),</b>
<b class="nc">&nbsp;                            typeDescription.getTypeVariables().asTokenList(is(typeDescription)),</b>
<b class="nc">&nbsp;                            typeDescription.getInterfaces().accept(Generic.Visitor.Substitutor.ForDetachment.of(typeDescription)),</b>
<b class="nc">&nbsp;                            typeDescription.getDeclaredFields().asTokenList(is(typeDescription)),</b>
<b class="nc">&nbsp;                            typeDescription.getDeclaredMethods().asTokenList(is(typeDescription)),</b>
<b class="nc">&nbsp;                            typeDescription.getDeclaredAnnotations(),</b>
&nbsp;                            TypeInitializer.None.INSTANCE,
&nbsp;                            LoadedTypeInitializer.NoOp.INSTANCE,
<b class="nc">&nbsp;                            typeDescription.getDeclaringType(),</b>
<b class="nc">&nbsp;                            typeDescription.getEnclosingMethod(),</b>
<b class="nc">&nbsp;                            typeDescription.getEnclosingType(),</b>
<b class="nc">&nbsp;                            typeDescription.getDeclaredTypes(),</b>
<b class="nc">&nbsp;                            typeDescription.isMemberClass(),</b>
<b class="nc">&nbsp;                            typeDescription.isAnonymousClass(),</b>
<b class="nc">&nbsp;                            typeDescription.isLocalClass());</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an instrumented type that does not allow to modify represented types.
&nbsp;             */
<b class="fc">&nbsp;            FROZEN {</b>
&nbsp;                @Override
&nbsp;                public InstrumentedType.WithFlexibleName represent(TypeDescription typeDescription) {
<b class="nc">&nbsp;                    return new Frozen(typeDescription, LoadedTypeInitializer.NoOp.INSTANCE);</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            @Override
&nbsp;            public InstrumentedType.WithFlexibleName subclass(String name, int modifiers, TypeDescription.Generic superClass) {
<b class="fc">&nbsp;                return new InstrumentedType.Default(name,</b>
&nbsp;                        modifiers,
&nbsp;                        superClass,
<b class="fc">&nbsp;                        Collections.&lt;TypeVariableToken&gt;emptyList(),</b>
<b class="fc">&nbsp;                        Collections.&lt;Generic&gt;emptyList(),</b>
<b class="fc">&nbsp;                        Collections.&lt;FieldDescription.Token&gt;emptyList(),</b>
<b class="fc">&nbsp;                        Collections.&lt;MethodDescription.Token&gt;emptyList(),</b>
<b class="fc">&nbsp;                        Collections.&lt;AnnotationDescription&gt;emptyList(),</b>
&nbsp;                        TypeInitializer.None.INSTANCE,
&nbsp;                        LoadedTypeInitializer.NoOp.INSTANCE,
&nbsp;                        TypeDescription.UNDEFINED,
&nbsp;                        MethodDescription.UNDEFINED,
&nbsp;                        TypeDescription.UNDEFINED,
<b class="fc">&nbsp;                        Collections.&lt;TypeDescription&gt;emptyList(),</b>
&nbsp;                        false,
&nbsp;                        false,
&nbsp;                        false);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A default implementation of an instrumented type.
&nbsp;     */
&nbsp;    class Default extends AbstractBase.OfSimpleType implements InstrumentedType.WithFlexibleName {
&nbsp;
&nbsp;        /**
&nbsp;         * A set containing all keywords of the Java programming language.
&nbsp;         */
<b class="fc">&nbsp;        private static final Set&lt;String&gt; KEYWORDS = new HashSet&lt;String&gt;(Arrays.asList(</b>
&nbsp;                &quot;abstract&quot;, &quot;continue&quot;, &quot;for&quot;, &quot;new&quot;, &quot;switch&quot;, &quot;assert&quot;, &quot;default&quot;, &quot;goto&quot;, &quot;package&quot;, &quot;synchronized&quot;, &quot;boolean&quot;,
&nbsp;                &quot;do&quot;, &quot;if&quot;, &quot;private&quot;, &quot;this&quot;, &quot;break&quot;, &quot;double&quot;, &quot;implements&quot;, &quot;protected&quot;, &quot;throw&quot;, &quot;byte&quot;, &quot;else&quot;, &quot;import&quot;,
&nbsp;                &quot;public&quot;, &quot;throws&quot;, &quot;case&quot;, &quot;enum&quot;, &quot;instanceof&quot;, &quot;return&quot;, &quot;transient&quot;, &quot;catch&quot;, &quot;extends&quot;, &quot;int&quot;, &quot;short&quot;,
&nbsp;                &quot;try&quot;, &quot;char&quot;, &quot;final&quot;, &quot;interface&quot;, &quot;static&quot;, &quot;void&quot;, &quot;class&quot;, &quot;finally&quot;, &quot;long&quot;, &quot;strictfp&quot;, &quot;volatile&quot;,
&nbsp;                &quot;const&quot;, &quot;float&quot;, &quot;native&quot;, &quot;super&quot;, &quot;while&quot;
&nbsp;        ));
&nbsp;
&nbsp;        /**
&nbsp;         * The binary name of the instrumented type.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The modifiers of the instrumented type.
&nbsp;         */
&nbsp;        private final int modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * The generic super type of the instrumented type.
&nbsp;         */
&nbsp;        private final Generic superClass;
&nbsp;
&nbsp;        /**
&nbsp;         * The instrumented type&#39;s type variables in their tokenized form.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeVariableToken&gt; typeVariables;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of interfaces of the instrumented type.
&nbsp;         */
&nbsp;        private final List&lt;? extends Generic&gt; interfaceTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of field tokens describing the fields of the instrumented type.
&nbsp;         */
&nbsp;        private final List&lt;? extends FieldDescription.Token&gt; fieldTokens;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of method tokens describing the methods of the instrumented type.
&nbsp;         */
&nbsp;        private final List&lt;? extends MethodDescription.Token&gt; methodTokens;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of annotations of the annotated type.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; annotationDescriptions;
&nbsp;
&nbsp;        /**
&nbsp;         * The type initializer of the instrumented type.
&nbsp;         */
&nbsp;        private final TypeInitializer typeInitializer;
&nbsp;
&nbsp;        /**
&nbsp;         * The loaded type initializer of the instrumented type.
&nbsp;         */
&nbsp;        private final LoadedTypeInitializer loadedTypeInitializer;
&nbsp;
&nbsp;        /**
&nbsp;         * The declaring type of the instrumented type or {@code null} if no such type exists.
&nbsp;         */
&nbsp;        private final TypeDescription declaringType;
&nbsp;
&nbsp;        /**
&nbsp;         * The enclosing method of the instrumented type or {@code null} if no such type exists.
&nbsp;         */
&nbsp;        private final MethodDescription enclosingMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * The enclosing type of the instrumented type or {@code null} if no such type exists.
&nbsp;         */
&nbsp;        private final TypeDescription enclosingType;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of types that are declared by this type.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeDescription&gt; declaredTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if this type is a member class.
&nbsp;         */
&nbsp;        private final boolean memberClass;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if this type is a anonymous class.
&nbsp;         */
&nbsp;        private final boolean anonymousClass;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if this type is a local class.
&nbsp;         */
&nbsp;        private final boolean localClass;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new instrumented type.
&nbsp;         *
&nbsp;         * @param name                   The binary name of the instrumented type.
&nbsp;         * @param modifiers              The modifiers of the instrumented type.
&nbsp;         * @param typeVariables          The instrumented type&#39;s type variables in their tokenized form.
&nbsp;         * @param superClass             The generic super type of the instrumented type.
&nbsp;         * @param interfaceTypes         A list of interfaces of the instrumented type.
&nbsp;         * @param fieldTokens            A list of field tokens describing the fields of the instrumented type.
&nbsp;         * @param methodTokens           A list of method tokens describing the methods of the instrumented type.
&nbsp;         * @param annotationDescriptions A list of annotations of the annotated type.
&nbsp;         * @param typeInitializer        The type initializer of the instrumented type.
&nbsp;         * @param loadedTypeInitializer  The loaded type initializer of the instrumented type.
&nbsp;         * @param declaringType          The declaring type of the instrumented type or {@code null} if no such type exists.
&nbsp;         * @param enclosingMethod        The enclosing method of the instrumented type or {@code null} if no such type exists.
&nbsp;         * @param enclosingType          The enclosing type of the instrumented type or {@code null} if no such type exists.
&nbsp;         * @param declaredTypes          A list of types that are declared by this type.
&nbsp;         * @param memberClass            {@code true} if this type is a member class.
&nbsp;         * @param anonymousClass         {@code true} if this type is a anonymous class.
&nbsp;         * @param localClass             {@code true} if this type is a local class.
&nbsp;         */
&nbsp;        protected Default(String name,
&nbsp;                          int modifiers,
&nbsp;                          Generic superClass,
&nbsp;                          List&lt;? extends TypeVariableToken&gt; typeVariables,
&nbsp;                          List&lt;? extends Generic&gt; interfaceTypes,
&nbsp;                          List&lt;? extends FieldDescription.Token&gt; fieldTokens,
&nbsp;                          List&lt;? extends MethodDescription.Token&gt; methodTokens,
&nbsp;                          List&lt;? extends AnnotationDescription&gt; annotationDescriptions,
&nbsp;                          TypeInitializer typeInitializer,
&nbsp;                          LoadedTypeInitializer loadedTypeInitializer,
&nbsp;                          TypeDescription declaringType,
&nbsp;                          MethodDescription enclosingMethod,
&nbsp;                          TypeDescription enclosingType,
&nbsp;                          List&lt;? extends TypeDescription&gt; declaredTypes,
&nbsp;                          boolean memberClass,
&nbsp;                          boolean anonymousClass,
<b class="fc">&nbsp;                          boolean localClass) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.modifiers = modifiers;</b>
<b class="fc">&nbsp;            this.typeVariables = typeVariables;</b>
<b class="fc">&nbsp;            this.superClass = superClass;</b>
<b class="fc">&nbsp;            this.interfaceTypes = interfaceTypes;</b>
<b class="fc">&nbsp;            this.fieldTokens = fieldTokens;</b>
<b class="fc">&nbsp;            this.methodTokens = methodTokens;</b>
<b class="fc">&nbsp;            this.annotationDescriptions = annotationDescriptions;</b>
<b class="fc">&nbsp;            this.typeInitializer = typeInitializer;</b>
<b class="fc">&nbsp;            this.loadedTypeInitializer = loadedTypeInitializer;</b>
<b class="fc">&nbsp;            this.declaringType = declaringType;</b>
<b class="fc">&nbsp;            this.enclosingMethod = enclosingMethod;</b>
<b class="fc">&nbsp;            this.enclosingType = enclosingType;</b>
<b class="fc">&nbsp;            this.declaredTypes = declaredTypes;</b>
<b class="fc">&nbsp;            this.memberClass = memberClass;</b>
<b class="fc">&nbsp;            this.anonymousClass = anonymousClass;</b>
<b class="fc">&nbsp;            this.localClass = localClass;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new instrumented type.
&nbsp;         *
&nbsp;         * @param name                The type&#39;s name.
&nbsp;         * @param superClass          The type&#39;s super class.
&nbsp;         * @param modifierContributor The type&#39;s modifiers.
&nbsp;         * @return An appropriate instrumented type.
&nbsp;         */
&nbsp;        public static InstrumentedType of(String name, TypeDescription.Generic superClass, ModifierContributor.ForType... modifierContributor) {
<b class="nc">&nbsp;            return of(name, superClass, ModifierContributor.Resolver.of(modifierContributor).resolve());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new instrumented type.
&nbsp;         *
&nbsp;         * @param name       The type&#39;s name.
&nbsp;         * @param superClass The type&#39;s super class.
&nbsp;         * @param modifiers  The type&#39;s modifiers.
&nbsp;         * @return An appropriate instrumented type.
&nbsp;         */
&nbsp;        public static InstrumentedType of(String name, TypeDescription.Generic superClass, int modifiers) {
<b class="nc">&nbsp;            return Factory.Default.MODIFIABLE.subclass(name, modifiers, superClass);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withModifiers(int modifiers) {
<b class="fc">&nbsp;            return new Default(name,</b>
&nbsp;                    modifiers,
&nbsp;                    superClass,
&nbsp;                    typeVariables,
&nbsp;                    interfaceTypes,
&nbsp;                    fieldTokens,
&nbsp;                    methodTokens,
&nbsp;                    annotationDescriptions,
&nbsp;                    typeInitializer,
&nbsp;                    loadedTypeInitializer,
&nbsp;                    declaringType,
&nbsp;                    enclosingMethod,
&nbsp;                    enclosingType,
&nbsp;                    declaredTypes,
&nbsp;                    memberClass,
&nbsp;                    anonymousClass,
&nbsp;                    localClass);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withField(FieldDescription.Token token) {
<b class="fc">&nbsp;            return new Default(this.name,</b>
&nbsp;                    modifiers,
&nbsp;                    superClass,
&nbsp;                    typeVariables,
&nbsp;                    interfaceTypes,
<b class="fc">&nbsp;                    CompoundList.of(fieldTokens, token.accept(Generic.Visitor.Substitutor.ForDetachment.of(this))),</b>
&nbsp;                    methodTokens,
&nbsp;                    annotationDescriptions,
&nbsp;                    typeInitializer,
&nbsp;                    loadedTypeInitializer,
&nbsp;                    declaringType,
&nbsp;                    enclosingMethod,
&nbsp;                    enclosingType,
&nbsp;                    declaredTypes,
&nbsp;                    memberClass,
&nbsp;                    anonymousClass,
&nbsp;                    localClass);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withMethod(MethodDescription.Token token) {
<b class="fc">&nbsp;            return new Default(name,</b>
&nbsp;                    modifiers,
&nbsp;                    superClass,
&nbsp;                    typeVariables,
&nbsp;                    interfaceTypes,
&nbsp;                    fieldTokens,
<b class="fc">&nbsp;                    CompoundList.of(methodTokens, token.accept(Generic.Visitor.Substitutor.ForDetachment.of(this))),</b>
&nbsp;                    annotationDescriptions,
&nbsp;                    typeInitializer,
&nbsp;                    loadedTypeInitializer,
&nbsp;                    declaringType,
&nbsp;                    enclosingMethod,
&nbsp;                    enclosingType,
&nbsp;                    declaredTypes,
&nbsp;                    memberClass,
&nbsp;                    anonymousClass,
&nbsp;                    localClass);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withInterfaces(TypeList.Generic interfaceTypes) {
<b class="fc">&nbsp;            return new Default(name,</b>
&nbsp;                    modifiers,
&nbsp;                    superClass,
&nbsp;                    typeVariables,
<b class="fc">&nbsp;                    CompoundList.of(this.interfaceTypes, interfaceTypes.accept(Generic.Visitor.Substitutor.ForDetachment.of(this))),</b>
&nbsp;                    fieldTokens,
&nbsp;                    methodTokens,
&nbsp;                    annotationDescriptions,
&nbsp;                    typeInitializer,
&nbsp;                    loadedTypeInitializer,
&nbsp;                    declaringType,
&nbsp;                    enclosingMethod,
&nbsp;                    enclosingType,
&nbsp;                    declaredTypes,
&nbsp;                    memberClass,
&nbsp;                    anonymousClass,
&nbsp;                    localClass);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withAnnotations(List&lt;? extends AnnotationDescription&gt; annotationDescriptions) {
<b class="fc">&nbsp;            return new Default(name,</b>
&nbsp;                    modifiers,
&nbsp;                    superClass,
&nbsp;                    typeVariables,
&nbsp;                    interfaceTypes,
&nbsp;                    fieldTokens,
&nbsp;                    methodTokens,
<b class="fc">&nbsp;                    CompoundList.of(this.annotationDescriptions, annotationDescriptions),</b>
&nbsp;                    typeInitializer,
&nbsp;                    loadedTypeInitializer,
&nbsp;                    declaringType,
&nbsp;                    enclosingMethod,
&nbsp;                    enclosingType,
&nbsp;                    declaredTypes,
&nbsp;                    memberClass,
&nbsp;                    anonymousClass,
&nbsp;                    localClass);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withTypeVariable(TypeVariableToken typeVariable) {
<b class="nc">&nbsp;            return new Default(name,</b>
&nbsp;                    modifiers,
&nbsp;                    superClass,
<b class="nc">&nbsp;                    CompoundList.of(typeVariables, typeVariable.accept(Generic.Visitor.Substitutor.ForDetachment.of(this))),</b>
&nbsp;                    interfaceTypes,
&nbsp;                    fieldTokens,
&nbsp;                    methodTokens,
&nbsp;                    annotationDescriptions,
&nbsp;                    typeInitializer,
&nbsp;                    loadedTypeInitializer,
&nbsp;                    declaringType,
&nbsp;                    enclosingMethod,
&nbsp;                    enclosingType,
&nbsp;                    declaredTypes,
&nbsp;                    memberClass,
&nbsp;                    anonymousClass,
&nbsp;                    localClass);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withName(String name) {
<b class="fc">&nbsp;            return new Default(name,</b>
&nbsp;                    modifiers,
&nbsp;                    superClass,
&nbsp;                    typeVariables,
&nbsp;                    interfaceTypes,
&nbsp;                    fieldTokens,
&nbsp;                    methodTokens,
&nbsp;                    annotationDescriptions,
&nbsp;                    typeInitializer,
&nbsp;                    loadedTypeInitializer,
&nbsp;                    declaringType,
&nbsp;                    enclosingMethod,
&nbsp;                    enclosingType,
&nbsp;                    declaredTypes,
&nbsp;                    memberClass,
&nbsp;                    anonymousClass,
&nbsp;                    localClass);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withTypeVariables(ElementMatcher&lt;? super Generic&gt; matcher, Transformer&lt;TypeVariableToken&gt; transformer) {
<b class="nc">&nbsp;            List&lt;TypeVariableToken&gt; typeVariables = new ArrayList&lt;TypeVariableToken&gt;(this.typeVariables.size());</b>
<b class="nc">&nbsp;            int index = 0;</b>
<b class="nc">&nbsp;            for (TypeVariableToken typeVariableToken : this.typeVariables) {</b>
<b class="nc">&nbsp;                typeVariables.add(matcher.matches(getTypeVariables().get(index++))</b>
<b class="nc">&nbsp;                        ? transformer.transform(this, typeVariableToken)</b>
&nbsp;                        : typeVariableToken);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return new Default(name,</b>
&nbsp;                    modifiers,
&nbsp;                    superClass,
&nbsp;                    typeVariables,
&nbsp;                    interfaceTypes,
&nbsp;                    fieldTokens,
&nbsp;                    methodTokens,
&nbsp;                    annotationDescriptions,
&nbsp;                    typeInitializer,
&nbsp;                    loadedTypeInitializer,
&nbsp;                    declaringType,
&nbsp;                    enclosingMethod,
&nbsp;                    enclosingType,
&nbsp;                    declaredTypes,
&nbsp;                    memberClass,
&nbsp;                    anonymousClass,
&nbsp;                    localClass);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withInitializer(LoadedTypeInitializer loadedTypeInitializer) {
<b class="nc">&nbsp;            return new Default(name,</b>
&nbsp;                    modifiers,
&nbsp;                    superClass,
&nbsp;                    typeVariables,
&nbsp;                    interfaceTypes,
&nbsp;                    fieldTokens,
&nbsp;                    methodTokens,
&nbsp;                    annotationDescriptions,
&nbsp;                    typeInitializer,
&nbsp;                    new LoadedTypeInitializer.Compound(this.loadedTypeInitializer, loadedTypeInitializer),
&nbsp;                    declaringType,
&nbsp;                    enclosingMethod,
&nbsp;                    enclosingType,
&nbsp;                    declaredTypes,
&nbsp;                    memberClass,
&nbsp;                    anonymousClass,
&nbsp;                    localClass);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withInitializer(ByteCodeAppender byteCodeAppender) {
<b class="nc">&nbsp;            return new Default(name,</b>
&nbsp;                    modifiers,
&nbsp;                    superClass,
&nbsp;                    typeVariables,
&nbsp;                    interfaceTypes,
&nbsp;                    fieldTokens,
&nbsp;                    methodTokens,
&nbsp;                    annotationDescriptions,
<b class="nc">&nbsp;                    typeInitializer.expandWith(byteCodeAppender),</b>
&nbsp;                    loadedTypeInitializer,
&nbsp;                    declaringType,
&nbsp;                    enclosingMethod,
&nbsp;                    enclosingType,
&nbsp;                    declaredTypes,
&nbsp;                    memberClass,
&nbsp;                    anonymousClass,
&nbsp;                    localClass);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public LoadedTypeInitializer getLoadedTypeInitializer() {
<b class="fc">&nbsp;            return loadedTypeInitializer;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeInitializer getTypeInitializer() {
<b class="fc">&nbsp;            return typeInitializer;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodDescription getEnclosingMethod() {
<b class="nc">&nbsp;            return enclosingMethod;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getEnclosingType() {
<b class="fc">&nbsp;            return enclosingType;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList getDeclaredTypes() {
<b class="nc">&nbsp;            return new TypeList.Explicit(declaredTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAnonymousClass() {
<b class="nc">&nbsp;            return anonymousClass;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isLocalClass() {
<b class="nc">&nbsp;            return localClass;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isMemberClass() {
<b class="nc">&nbsp;            return memberClass;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PackageDescription getPackage() {
<b class="fc">&nbsp;            int packageIndex = name.lastIndexOf(&#39;.&#39;);</b>
<b class="pc">&nbsp;            return new PackageDescription.Simple(packageIndex == -1</b>
&nbsp;                    ? EMPTY_NAME
<b class="fc">&nbsp;                    : name.substring(0, packageIndex));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(annotationDescriptions);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return declaringType;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Generic getSuperClass() {
<b class="pc">&nbsp;            return superClass == null</b>
&nbsp;                    ? Generic.UNDEFINED
<b class="fc">&nbsp;                    : new Generic.LazyProjection.WithResolvedErasure(superClass, Generic.Visitor.Substitutor.ForAttachment.of(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;            return new TypeList.Generic.ForDetachedTypes.WithResolvedErasure(interfaceTypes, TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;            return new FieldList.ForTokens(this, fieldTokens);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;            return new MethodList.ForTokens(this, methodTokens);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;            return TypeList.Generic.ForDetachedTypes.attachVariables(this, typeVariables);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return modifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription validated() {
<b class="nc">&nbsp;            if (!isValidIdentifier(getName().split(&quot;\\.&quot;))) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Illegal type name: &quot; + getName() + &quot; for &quot; + this);</b>
<b class="nc">&nbsp;            } else if ((getModifiers() &amp; ~ModifierContributor.ForType.MASK) != EMPTY_MASK) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Illegal modifiers &quot; + getModifiers() + &quot; for &quot; + this);</b>
<b class="nc">&nbsp;            } else if (isPackageType() &amp;&amp; getModifiers() != PackageDescription.PACKAGE_MODIFIERS) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Illegal modifiers &quot; + getModifiers() + &quot; for package &quot; + this);</b>
&nbsp;            }
<b class="nc">&nbsp;            TypeDescription.Generic superClass = getSuperClass();</b>
<b class="nc">&nbsp;            if (superClass != null) {</b>
<b class="nc">&nbsp;                if (!superClass.accept(Generic.Visitor.Validator.SUPER_CLASS)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal super class &quot; + superClass + &quot; for &quot; + this);</b>
<b class="nc">&nbsp;                } else if (!superClass.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal type annotations on super class &quot; + superClass + &quot; for &quot; + this);</b>
<b class="nc">&nbsp;                } else if (!superClass.asErasure().isVisibleTo(this)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Invisible super type &quot; + superClass + &quot; for &quot; + this);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            Set&lt;TypeDescription&gt; interfaceErasures = new HashSet&lt;TypeDescription&gt;();</b>
<b class="nc">&nbsp;            for (TypeDescription.Generic interfaceType : getInterfaces()) {</b>
<b class="nc">&nbsp;                if (!interfaceType.accept(Generic.Visitor.Validator.INTERFACE)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal interface &quot; + interfaceType + &quot; for &quot; + this);</b>
<b class="nc">&nbsp;                } else if (!interfaceType.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal type annotations on interface &quot; + interfaceType + &quot; for &quot; + this);</b>
<b class="nc">&nbsp;                } else if (!interfaceErasures.add(interfaceType.asErasure())) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Already implemented interface &quot; + interfaceType + &quot; for &quot; + this);</b>
<b class="nc">&nbsp;                } else if (!interfaceType.asErasure().isVisibleTo(this)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Invisible interface type &quot; + interfaceType + &quot; for &quot; + this);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            TypeList.Generic typeVariables = getTypeVariables();</b>
<b class="nc">&nbsp;            if (!typeVariables.isEmpty() &amp;&amp; isAssignableTo(Throwable.class)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot define throwable &quot; + this + &quot; to be generic&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            Set&lt;String&gt; typeVariableNames = new HashSet&lt;String&gt;();</b>
<b class="nc">&nbsp;            for (TypeDescription.Generic typeVariable : typeVariables) {</b>
<b class="nc">&nbsp;                String variableSymbol = typeVariable.getSymbol();</b>
<b class="nc">&nbsp;                if (!typeVariableNames.add(variableSymbol)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Duplicate type variable symbol &#39;&quot; + typeVariable + &quot;&#39; for &quot; + this);</b>
<b class="nc">&nbsp;                } else if (!isValidIdentifier(variableSymbol)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal type variable name &#39;&quot; + typeVariable + &quot;&#39; for &quot; + this);</b>
<b class="nc">&nbsp;                } else if (!Generic.Visitor.Validator.ForTypeAnnotations.ofFormalTypeVariable(typeVariable)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal type annotation on &#39;&quot; + typeVariable + &quot;&#39; for &quot; + this);</b>
&nbsp;                }
<b class="nc">&nbsp;                boolean interfaceBound = false;</b>
<b class="nc">&nbsp;                Set&lt;TypeDescription.Generic&gt; bounds = new HashSet&lt;Generic&gt;();</b>
<b class="nc">&nbsp;                for (TypeDescription.Generic bound : typeVariable.getUpperBounds()) {</b>
<b class="nc">&nbsp;                    if (!bound.accept(Generic.Visitor.Validator.TYPE_VARIABLE)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Illegal type variable bound &quot; + bound + &quot; of &quot; + typeVariable + &quot; for &quot; + this);</b>
<b class="nc">&nbsp;                    } else if (!bound.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Illegal type annotations on type variable &quot; + bound + &quot; for &quot; + this);</b>
<b class="nc">&nbsp;                    } else if (!bounds.add(bound)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Duplicate bound &quot; + bound + &quot; of &quot; + typeVariable + &quot; for &quot; + this);</b>
<b class="nc">&nbsp;                    } else if (interfaceBound &amp;&amp; (bound.getSort().isTypeVariable() || !bound.isInterface())) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Illegal interface bound &quot; + bound + &quot; of &quot; + typeVariable + &quot; for &quot; + this);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    interfaceBound = true;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (!interfaceBound) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Type variable &quot; + typeVariable + &quot; for &quot; + this + &quot; does not define at least one bound&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            Set&lt;TypeDescription&gt; typeAnnotationTypes = new HashSet&lt;TypeDescription&gt;();</b>
<b class="nc">&nbsp;            for (AnnotationDescription annotationDescription : getDeclaredAnnotations()) {</b>
<b class="nc">&nbsp;                if (!annotationDescription.getElementTypes().contains(ElementType.TYPE)</b>
<b class="nc">&nbsp;                        &amp;&amp; !(isAnnotation() &amp;&amp; annotationDescription.getElementTypes().contains(ElementType.ANNOTATION_TYPE))</b>
<b class="nc">&nbsp;                        &amp;&amp; !(isPackageType() &amp;&amp; annotationDescription.getElementTypes().contains(ElementType.PACKAGE))) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot add &quot; + annotationDescription + &quot; on &quot; + this);</b>
<b class="nc">&nbsp;                } else if (!typeAnnotationTypes.add(annotationDescription.getAnnotationType())) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Duplicate annotation &quot; + annotationDescription + &quot; for &quot; + this);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            Set&lt;FieldDescription.SignatureToken&gt; fieldSignatureTokens = new HashSet&lt;FieldDescription.SignatureToken&gt;();</b>
<b class="nc">&nbsp;            for (FieldDescription.InDefinedShape fieldDescription : getDeclaredFields()) {</b>
<b class="nc">&nbsp;                String fieldName = fieldDescription.getName();</b>
<b class="nc">&nbsp;                if (!fieldSignatureTokens.add(fieldDescription.asSignatureToken())) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Duplicate field definition for &quot; + fieldDescription);</b>
<b class="nc">&nbsp;                } else if (!isValidIdentifier(fieldName)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal field name for &quot; + fieldDescription);</b>
<b class="nc">&nbsp;                } else if ((fieldDescription.getModifiers() &amp; ~ModifierContributor.ForField.MASK) != EMPTY_MASK) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal field modifiers &quot; + fieldDescription.getModifiers() + &quot; for &quot; + fieldDescription);</b>
&nbsp;                }
<b class="nc">&nbsp;                Generic fieldType = fieldDescription.getType();</b>
<b class="nc">&nbsp;                if (!fieldType.accept(Generic.Visitor.Validator.FIELD)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal field type &quot; + fieldType + &quot; for &quot; + fieldDescription);</b>
<b class="nc">&nbsp;                } else if (!fieldType.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal type annotations on &quot; + fieldType + &quot; for &quot; + this);</b>
<b class="nc">&nbsp;                } else if (!fieldDescription.isSynthetic() &amp;&amp; !fieldType.asErasure().isVisibleTo(this)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Invisible field type &quot; + fieldDescription.getType() + &quot; for &quot; + fieldDescription);</b>
&nbsp;                }
<b class="nc">&nbsp;                Set&lt;TypeDescription&gt; fieldAnnotationTypes = new HashSet&lt;TypeDescription&gt;();</b>
<b class="nc">&nbsp;                for (AnnotationDescription annotationDescription : fieldDescription.getDeclaredAnnotations()) {</b>
<b class="nc">&nbsp;                    if (!annotationDescription.getElementTypes().contains(ElementType.FIELD)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot add &quot; + annotationDescription + &quot; on &quot; + fieldDescription);</b>
<b class="nc">&nbsp;                    } else if (!fieldAnnotationTypes.add(annotationDescription.getAnnotationType())) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Duplicate annotation &quot; + annotationDescription + &quot; for &quot; + fieldDescription);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            Set&lt;MethodDescription.SignatureToken&gt; methodSignatureTokens = new HashSet&lt;MethodDescription.SignatureToken&gt;();</b>
<b class="nc">&nbsp;            for (MethodDescription.InDefinedShape methodDescription : getDeclaredMethods()) {</b>
<b class="nc">&nbsp;                if (!methodSignatureTokens.add(methodDescription.asSignatureToken())) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Duplicate method signature for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                } else if ((methodDescription.getModifiers() &amp; ~ModifierContributor.ForMethod.MASK) != 0) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal modifiers &quot; + methodDescription.getModifiers() + &quot; for &quot; + methodDescription);</b>
&nbsp;                }
<b class="nc">&nbsp;                Set&lt;String&gt; methodTypeVariableNames = new HashSet&lt;String&gt;();</b>
<b class="nc">&nbsp;                for (TypeDescription.Generic typeVariable : methodDescription.getTypeVariables()) {</b>
<b class="nc">&nbsp;                    String variableSymbol = typeVariable.getSymbol();</b>
<b class="nc">&nbsp;                    if (!methodTypeVariableNames.add(variableSymbol)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Duplicate type variable symbol &#39;&quot; + typeVariable + &quot;&#39; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                    } else if (!isValidIdentifier(variableSymbol)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Illegal type variable name &#39;&quot; + typeVariable + &quot;&#39; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                    } else if (!Generic.Visitor.Validator.ForTypeAnnotations.ofFormalTypeVariable(typeVariable)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Illegal type annotation on &#39;&quot; + typeVariable + &quot;&#39; for &quot; + methodDescription);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    boolean interfaceBound = false;</b>
<b class="nc">&nbsp;                    Set&lt;TypeDescription.Generic&gt; bounds = new HashSet&lt;Generic&gt;();</b>
<b class="nc">&nbsp;                    for (TypeDescription.Generic bound : typeVariable.getUpperBounds()) {</b>
<b class="nc">&nbsp;                        if (!bound.accept(Generic.Visitor.Validator.TYPE_VARIABLE)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Illegal type variable bound &quot; + bound + &quot; of &quot; + typeVariable + &quot; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                        } else if (!bound.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Illegal type annotations on bound &quot; + bound + &quot; of &quot; + typeVariable + &quot; for &quot; + this);</b>
<b class="nc">&nbsp;                        } else if (!bounds.add(bound)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Duplicate bound &quot; + bound + &quot; of &quot; + typeVariable + &quot; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                        } else if (interfaceBound &amp;&amp; (bound.getSort().isTypeVariable() || !bound.isInterface())) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Illegal interface bound &quot; + bound + &quot; of &quot; + typeVariable + &quot; for &quot; + methodDescription);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        interfaceBound = true;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    if (!interfaceBound) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Type variable &quot; + typeVariable + &quot; for &quot; + methodDescription + &quot; does not define at least one bound&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                Generic returnType = methodDescription.getReturnType();</b>
<b class="nc">&nbsp;                if (methodDescription.isTypeInitializer()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal explicit declaration of a type initializer by &quot; + this);</b>
<b class="nc">&nbsp;                } else if (methodDescription.isConstructor()) {</b>
<b class="nc">&nbsp;                    if (!returnType.represents(void.class)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;A constructor must return void &quot; + methodDescription);</b>
<b class="nc">&nbsp;                    } else if (!returnType.getDeclaredAnnotations().isEmpty()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;The void non-type must not be annotated for &quot; + methodDescription);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (!isValidIdentifier(methodDescription.getInternalName())) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal method name &quot; + returnType + &quot; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                } else if (!returnType.accept(Generic.Visitor.Validator.METHOD_RETURN)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal return type &quot; + returnType + &quot; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                } else if (!returnType.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal type annotations return type &quot; + returnType + &quot; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                } else if (!methodDescription.isSynthetic() &amp;&amp; !methodDescription.getReturnType().asErasure().isVisibleTo(this)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Invisible return type &quot; + methodDescription.getReturnType() + &quot; for &quot; + methodDescription);</b>
&nbsp;                }
<b class="nc">&nbsp;                Set&lt;String&gt; parameterNames = new HashSet&lt;String&gt;();</b>
<b class="nc">&nbsp;                for (ParameterDescription.InDefinedShape parameterDescription : methodDescription.getParameters()) {</b>
<b class="nc">&nbsp;                    Generic parameterType = parameterDescription.getType();</b>
<b class="nc">&nbsp;                    if (!parameterType.accept(Generic.Visitor.Validator.METHOD_PARAMETER)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Illegal parameter type of &quot; + parameterDescription + &quot; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                    } else if (!parameterType.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Illegal type annotations return type &quot; + parameterType + &quot; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                    } else if (!methodDescription.isSynthetic() &amp;&amp; !parameterType.asErasure().isVisibleTo(this)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Invisible parameter type of &quot; + parameterDescription + &quot; for &quot; + methodDescription);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (parameterDescription.isNamed()) {</b>
<b class="nc">&nbsp;                        String parameterName = parameterDescription.getName();</b>
<b class="nc">&nbsp;                        if (!parameterNames.add(parameterName)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Duplicate parameter name of &quot; + parameterDescription + &quot; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                        } else if (!isValidIdentifier(parameterName)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Illegal parameter name of &quot; + parameterDescription + &quot; for &quot; + methodDescription);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    if (parameterDescription.hasModifiers() &amp;&amp; (parameterDescription.getModifiers() &amp; ~ModifierContributor.ForParameter.MASK) != EMPTY_MASK) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Illegal modifiers of &quot; + parameterDescription + &quot; for &quot; + methodDescription);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Set&lt;TypeDescription&gt; parameterAnnotationTypes = new HashSet&lt;TypeDescription&gt;();</b>
<b class="nc">&nbsp;                    for (AnnotationDescription annotationDescription : parameterDescription.getDeclaredAnnotations()) {</b>
<b class="nc">&nbsp;                        if (!annotationDescription.getElementTypes().contains(ElementType.PARAMETER)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot add &quot; + annotationDescription + &quot; on &quot; + parameterDescription);</b>
<b class="nc">&nbsp;                        } else if (!parameterAnnotationTypes.add(annotationDescription.getAnnotationType())) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Duplicate annotation &quot; + annotationDescription + &quot; of &quot; + parameterDescription + &quot; for &quot; + methodDescription);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                for (TypeDescription.Generic exceptionType : methodDescription.getExceptionTypes()) {</b>
<b class="nc">&nbsp;                    if (!exceptionType.accept(Generic.Visitor.Validator.EXCEPTION)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Illegal exception type &quot; + exceptionType + &quot; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                    } else if (!exceptionType.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Illegal type annotations on &quot; + exceptionType + &quot; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                    } else if (!methodDescription.isSynthetic() &amp;&amp; !exceptionType.asErasure().isVisibleTo(this)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Invisible exception type &quot; + exceptionType + &quot; for &quot; + methodDescription);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                Set&lt;TypeDescription&gt; methodAnnotationTypes = new HashSet&lt;TypeDescription&gt;();</b>
<b class="nc">&nbsp;                for (AnnotationDescription annotationDescription : methodDescription.getDeclaredAnnotations()) {</b>
<b class="nc">&nbsp;                    if (!annotationDescription.getElementTypes().contains(methodDescription.isMethod() ? ElementType.METHOD : ElementType.CONSTRUCTOR)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot add &quot; + annotationDescription + &quot; on &quot; + methodDescription);</b>
<b class="nc">&nbsp;                    } else if (!methodAnnotationTypes.add(annotationDescription.getAnnotationType())) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Duplicate annotation &quot; + annotationDescription + &quot; for &quot; + methodDescription);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                AnnotationValue&lt;?, ?&gt; defaultValue = methodDescription.getDefaultValue();</b>
<b class="nc">&nbsp;                if (defaultValue != null &amp;&amp; !methodDescription.isDefaultValue(defaultValue)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal default value &quot; + defaultValue + &quot;for &quot; + methodDescription);</b>
&nbsp;                }
<b class="nc">&nbsp;                Generic receiverType = methodDescription.getReceiverType();</b>
<b class="nc">&nbsp;                if (receiverType != null &amp;&amp; !receiverType.accept(Generic.Visitor.Validator.RECEIVER)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal receiver type &quot; + receiverType + &quot; for &quot; + methodDescription);</b>
<b class="nc">&nbsp;                } else if (methodDescription.isStatic()) {</b>
<b class="nc">&nbsp;                    if (receiverType != null) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Static method &quot; + methodDescription + &quot; defines a non-null receiver &quot; + receiverType);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (methodDescription.isConstructor()) {</b>
<b class="nc">&nbsp;                    TypeDescription enclosingType = getEnclosingType();</b>
<b class="nc">&nbsp;                    if (receiverType == null || !receiverType.asErasure().equals(enclosingType == null ? this : enclosingType)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Constructor &quot; + methodDescription + &quot; defines an illegal receiver &quot; + receiverType);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (/* methodDescription.isMethod() */ receiverType == null || !equals(receiverType.asErasure())) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Method &quot; + methodDescription + &quot; defines an illegal receiver &quot; + receiverType);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if an array of identifiers is a valid compound Java identifier.
&nbsp;         *
&nbsp;         * @param identifier an array of potentially invalid Java identifiers.
&nbsp;         * @return {@code true} if all identifiers are valid and the array is not empty.
&nbsp;         */
&nbsp;        private static boolean isValidIdentifier(String[] identifier) {
<b class="nc">&nbsp;            if (identifier.length == 0) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (String part : identifier) {</b>
<b class="nc">&nbsp;                if (!isValidIdentifier(part)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if a Java identifier is valid.
&nbsp;         *
&nbsp;         * @param identifier The identifier to check for validity.
&nbsp;         * @return {@code true} if the given identifier is valid.
&nbsp;         */
&nbsp;        private static boolean isValidIdentifier(String identifier) {
<b class="nc">&nbsp;            if (KEYWORDS.contains(identifier) || identifier.isEmpty() || !Character.isJavaIdentifierStart(identifier.charAt(0))) {</b>
<b class="nc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            } else if (identifier.equals(PackageDescription.PACKAGE_CLASS_NAME)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (int index = 1; index &lt; identifier.length(); index++) {</b>
<b class="nc">&nbsp;                if (!Character.isJavaIdentifierPart(identifier.charAt(index))) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A frozen representation of an instrumented type of which the structure must not be modified.
&nbsp;     */
&nbsp;    class Frozen extends AbstractBase.OfSimpleType implements InstrumentedType.WithFlexibleName {
&nbsp;
&nbsp;        /**
&nbsp;         * The represented type description.
&nbsp;         */
&nbsp;        private final TypeDescription typeDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * The type&#39;s loaded type initializer.
&nbsp;         */
&nbsp;        private final LoadedTypeInitializer loadedTypeInitializer;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new frozen representation of an instrumented type.
&nbsp;         *
&nbsp;         * @param typeDescription       The represented type description.
&nbsp;         * @param loadedTypeInitializer The type&#39;s loaded type initializer.
&nbsp;         */
&nbsp;        protected Frozen(TypeDescription typeDescription, LoadedTypeInitializer loadedTypeInitializer) {
&nbsp;            this.typeDescription = typeDescription;
&nbsp;            this.loadedTypeInitializer = loadedTypeInitializer;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            return typeDescription.getDeclaredAnnotations();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getModifiers() {
&nbsp;            return typeDescription.getModifiers();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return typeDescription.getTypeVariables();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
&nbsp;            return typeDescription.getName();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Generic getSuperClass() {
&nbsp;            return typeDescription.getSuperClass();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            return typeDescription.getInterfaces();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            return typeDescription.getDeclaredFields();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;            return typeDescription.getDeclaredMethods();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAnonymousClass() {
&nbsp;            return typeDescription.isAnonymousClass();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isLocalClass() {
&nbsp;            return typeDescription.isLocalClass();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isMemberClass() {
&nbsp;            return typeDescription.isMemberClass();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PackageDescription getPackage() {
&nbsp;            return typeDescription.getPackage();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            return typeDescription.getEnclosingType();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return typeDescription.getDeclaringType();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            return typeDescription.getDeclaredTypes();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodDescription getEnclosingMethod() {
&nbsp;            return typeDescription.getEnclosingMethod();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getGenericSignature() {
&nbsp;            // Embrace use of native generic signature by direct delegation.
&nbsp;            return typeDescription.getGenericSignature();
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getActualModifiers(boolean superFlag) {
&nbsp;            // Embrace use of native actual modifiers by direct delegation.
&nbsp;            return typeDescription.getActualModifiers(superFlag);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withField(FieldDescription.Token token) {
&nbsp;            throw new IllegalStateException(&quot;Cannot define field for frozen type: &quot; + typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withMethod(MethodDescription.Token token) {
&nbsp;            throw new IllegalStateException(&quot;Cannot define method for frozen type: &quot; + typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withModifiers(int modifiers) {
&nbsp;            throw new IllegalStateException(&quot;Cannot change modifiers for frozen type: &quot; + typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withInterfaces(TypeList.Generic interfaceTypes) {
&nbsp;            throw new IllegalStateException(&quot;Cannot add interfaces for frozen type: &quot; + typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withTypeVariable(TypeVariableToken typeVariable) {
&nbsp;            throw new IllegalStateException(&quot;Cannot define type variable for frozen type: &quot; + typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withAnnotations(List&lt;? extends AnnotationDescription&gt; annotationDescriptions) {
&nbsp;            throw new IllegalStateException(&quot;Cannot add annotation to frozen type: &quot; + typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withInitializer(LoadedTypeInitializer loadedTypeInitializer) {
&nbsp;            return new Frozen(typeDescription, new LoadedTypeInitializer.Compound(this.loadedTypeInitializer, loadedTypeInitializer));
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withInitializer(ByteCodeAppender byteCodeAppender) {
&nbsp;            throw new IllegalStateException(&quot;Cannot add initializer to frozen type: &quot; + typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withName(String name) {
&nbsp;            throw new IllegalStateException(&quot;Cannot change name of frozen type: &quot; + typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public WithFlexibleName withTypeVariables(ElementMatcher&lt;? super Generic&gt; matcher, Transformer&lt;TypeVariableToken&gt; transformer) {
&nbsp;            throw new IllegalStateException(&quot;Cannot add type variables of frozen type: &quot; + typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public LoadedTypeInitializer getLoadedTypeInitializer() {
&nbsp;            return loadedTypeInitializer;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeInitializer getTypeInitializer() {
&nbsp;            return TypeInitializer.None.INSTANCE;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TypeDescription validated() {
&nbsp;            return typeDescription;
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:57</div>
</div>
</body>
</html>
