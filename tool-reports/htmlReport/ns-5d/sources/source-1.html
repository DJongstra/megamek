


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > FieldAccessor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: FieldAccessor (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FieldAccessor</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (4/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76%
  </span>
  <span class="absValue">
    (19/25)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FieldAccessor$AssignerConfigurable</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldLocation</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldLocation$Prepared</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldLocation$Relative</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83,3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldLocation$Relative$Prepared</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85,7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldNameExtractor</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldNameExtractor$ForBeanProperty</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (8/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForImplicitProperty</td>
<td class="coverageStat">
  <span class="percent">
    37,5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    30%
  </span>
  <span class="absValue">
    (3/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForImplicitProperty$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62,5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81,8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$OwnerTypeLocatable</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$PropertyConfigurable</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    67,9%
  </span>
  <span class="absValue">
    (19/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    43,8%
  </span>
  <span class="absValue">
    (14/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70,4%
  </span>
  <span class="absValue">
    (50/71)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.scaffold.FieldLocator;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.jar.asm.MethodVisitor;
&nbsp;
&nbsp;import java.lang.reflect.Field;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * Defines a method to access a given field by following the Java bean conventions for getters and setters:
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;Getter: A method named {@code getFoo()} will be instrumented to read and return the value of a field {@code foo}
&nbsp; * or another field if one was specified explicitly. If a property is of type {@link java.lang.Boolean} or
&nbsp; * {@code boolean}, the name {@code isFoo()} is also permitted.&lt;/li&gt;
&nbsp; * &lt;li&gt;Setter: A method named {@code setFoo(value)} will be instrumented to write the given argument {@code value}
&nbsp; * to a field {@code foo} or to another field if one was specified explicitly.&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Field accessors always implement a getter if a non-{@code void} value is returned from a method and attempt to define a setter
&nbsp; * otherwise. If a field accessor is not explicitly defined as a setter via {@link PropertyConfigurable}, an instrumented
&nbsp; * method must define exactly one parameter. Using the latter API, an explicit parameter index can be defined and a return
&nbsp; * value can be specified explicitly when {@code void} is not returned.
&nbsp; * &lt;/p&gt;
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
&nbsp;public abstract class FieldAccessor implements Implementation {
&nbsp;
&nbsp;    /**
&nbsp;     * The field&#39;s location.
&nbsp;     */
&nbsp;    protected final FieldLocation fieldLocation;
&nbsp;
&nbsp;    /**
&nbsp;     * The assigner to use.
&nbsp;     */
&nbsp;    protected final Assigner assigner;
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     */
&nbsp;    protected final Assigner.Typing typing;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new field accessor.
&nbsp;     *
&nbsp;     * @param fieldLocation The field&#39;s location.
&nbsp;     * @param assigner      The assigner to use.
&nbsp;     * @param typing        Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     */
<b class="fc">&nbsp;    protected FieldAccessor(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;        this.fieldLocation = fieldLocation;</b>
<b class="fc">&nbsp;        this.assigner = assigner;</b>
<b class="fc">&nbsp;        this.typing = typing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a field accessor where any access is targeted to a field named {@code name}.
&nbsp;     *
&nbsp;     * @param name The name of the field to be accessed.
&nbsp;     * @return A field accessor for a field of a given name.
&nbsp;     */
&nbsp;    public static OwnerTypeLocatable ofField(String name) {
<b class="nc">&nbsp;        return of(new FieldNameExtractor.ForFixedValue(name));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a field accessor where any access is targeted to a field that matches the methods
&nbsp;     * name with the Java specification for bean properties, i.e. a method {@code getFoo} or {@code setFoo(value)}
&nbsp;     * will either read or write a field named {@code foo}.
&nbsp;     *
&nbsp;     * @return A field accessor that follows the Java naming conventions for bean properties.
&nbsp;     */
&nbsp;    public static OwnerTypeLocatable ofBeanProperty() {
<b class="fc">&nbsp;        return of(FieldNameExtractor.ForBeanProperty.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a custom strategy for determining the field that is accessed by this field accessor.
&nbsp;     *
&nbsp;     * @param fieldNameExtractor The field name extractor to use.
&nbsp;     * @return A field accessor using the given field name extractor.
&nbsp;     */
&nbsp;    public static OwnerTypeLocatable of(FieldNameExtractor fieldNameExtractor) {
<b class="fc">&nbsp;        return new ForImplicitProperty(new FieldLocation.Relative(fieldNameExtractor));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a field accessor where the specified field is accessed. The field must be within the hierarchy of the instrumented type.
&nbsp;     *
&nbsp;     * @param field The field being accessed.
&nbsp;     * @return A field accessor for the given field.
&nbsp;     */
&nbsp;    public static AssignerConfigurable of(Field field) {
<b class="nc">&nbsp;        return of(new FieldDescription.ForLoadedField(field));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a field accessor where the specified field is accessed. The field must be within the hierarchy of the instrumented type.
&nbsp;     *
&nbsp;     * @param fieldDescription The field being accessed.
&nbsp;     * @return A field accessor for the given field.
&nbsp;     */
&nbsp;    public static AssignerConfigurable of(FieldDescription fieldDescription) {
<b class="nc">&nbsp;        return new ForImplicitProperty(new FieldLocation.Absolute(fieldDescription));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a getter getter.
&nbsp;     *
&nbsp;     * @param fieldDescription   The field to read the value from.
&nbsp;     * @param instrumentedMethod The getter method.
&nbsp;     * @return A stack manipulation that gets the field&#39;s value.
&nbsp;     */
&nbsp;    protected StackManipulation getter(FieldDescription fieldDescription, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;        return access(fieldDescription, instrumentedMethod, new StackManipulation.Compound(FieldAccess.forField(fieldDescription).read(),</b>
<b class="fc">&nbsp;                assigner.assign(fieldDescription.getType(), instrumentedMethod.getReturnType(), typing)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a setter instruction.
&nbsp;     *
&nbsp;     * @param fieldDescription     The field to set a value for.
&nbsp;     * @param parameterDescription The parameter for what value is to be set.
&nbsp;     * @return A stack manipulation that sets the field&#39;s value.
&nbsp;     */
&nbsp;    protected StackManipulation setter(FieldDescription fieldDescription, ParameterDescription parameterDescription) {
<b class="pc">&nbsp;        if (fieldDescription.isFinal() &amp;&amp; parameterDescription.getDeclaringMethod().isMethod()) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Cannot set final field &quot; + fieldDescription + &quot; from &quot; + parameterDescription.getDeclaringMethod());</b>
&nbsp;        }
<b class="fc">&nbsp;        return access(fieldDescription,</b>
<b class="fc">&nbsp;                parameterDescription.getDeclaringMethod(),</b>
<b class="fc">&nbsp;                new StackManipulation.Compound(MethodVariableAccess.load(parameterDescription),</b>
<b class="fc">&nbsp;                        assigner.assign(parameterDescription.getType(), fieldDescription.getType(), typing),</b>
<b class="fc">&nbsp;                        FieldAccess.forField(fieldDescription).write()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks a field access and loads the {@code this} instance if necessary.
&nbsp;     *
&nbsp;     * @param fieldDescription   The field to get a value
&nbsp;     * @param instrumentedMethod The instrumented method.
&nbsp;     * @param fieldAccess        A stack manipulation describing the field access.
&nbsp;     * @return An appropriate stack manipulation.
&nbsp;     */
&nbsp;    private StackManipulation access(FieldDescription fieldDescription, MethodDescription instrumentedMethod, StackManipulation fieldAccess) {
<b class="pc">&nbsp;        if (!fieldAccess.isValid()) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Incompatible type of &quot; + fieldDescription + &quot; and &quot; + instrumentedMethod);</b>
<b class="pc">&nbsp;        } else if (instrumentedMethod.isStatic() &amp;&amp; !fieldDescription.isStatic()) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Cannot call instance field &quot; + fieldDescription + &quot; from static method &quot; + instrumentedMethod);</b>
&nbsp;        }
<b class="pc">&nbsp;        return new StackManipulation.Compound(fieldDescription.isStatic()</b>
&nbsp;                ? StackManipulation.Trivial.INSTANCE
<b class="fc">&nbsp;                : MethodVariableAccess.loadThis(), fieldAccess);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;        return instrumentedType;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field location represents an identified field description which depends on the instrumented type and method.
&nbsp;     */
&nbsp;    protected interface FieldLocation {
&nbsp;
&nbsp;        /**
&nbsp;         * Specifies a field locator factory to use.
&nbsp;         *
&nbsp;         * @param fieldLocatorFactory The field locator factory to use.
&nbsp;         * @return An appropriate field location.
&nbsp;         */
&nbsp;        FieldLocation with(FieldLocator.Factory fieldLocatorFactory);
&nbsp;
&nbsp;        /**
&nbsp;         * A prepared field location.
&nbsp;         *
&nbsp;         * @param instrumentedType The instrumented type.
&nbsp;         * @return A prepared field location.
&nbsp;         */
&nbsp;        Prepared prepare(TypeDescription instrumentedType);
&nbsp;
&nbsp;        /**
&nbsp;         * A prepared field location.
&nbsp;         */
&nbsp;        interface Prepared {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the field description to use.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @return The resolved field description.
&nbsp;             */
&nbsp;            FieldDescription resolve(MethodDescription instrumentedMethod);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An absolute field description representing a previously resolved field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Absolute implements FieldLocation, Prepared {
&nbsp;
&nbsp;            /**
&nbsp;             * The field description.
&nbsp;             */
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an absolute field location.
&nbsp;             *
&nbsp;             * @param fieldDescription The field description.
&nbsp;             */
&nbsp;            protected Absolute(FieldDescription fieldDescription) {
&nbsp;                this.fieldDescription = fieldDescription;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldLocation with(FieldLocator.Factory fieldLocatorFactory) {
&nbsp;                throw new IllegalStateException(&quot;Cannot specify a field locator factory for an absolute field location&quot;);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Prepared prepare(TypeDescription instrumentedType) {
&nbsp;                if (!instrumentedType.isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {
&nbsp;                    throw new IllegalStateException(fieldDescription + &quot; is not declared by &quot; + instrumentedType);
&nbsp;                } else if (!fieldDescription.isVisibleTo(instrumentedType)) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot access &quot; + fieldDescription + &quot; from &quot; + instrumentedType);
&nbsp;                }
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDescription resolve(MethodDescription instrumentedMethod) {
&nbsp;                return fieldDescription;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A relative field location where a field is located dynamically.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Relative implements FieldLocation {
&nbsp;
&nbsp;            /**
&nbsp;             * The field name extractor to use.
&nbsp;             */
&nbsp;            private final FieldNameExtractor fieldNameExtractor;
&nbsp;
&nbsp;            /**
&nbsp;             * The field locator factory to use.
&nbsp;             */
&nbsp;            private final FieldLocator.Factory fieldLocatorFactory;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new relative field location.
&nbsp;             *
&nbsp;             * @param fieldNameExtractor The field name extractor to use.
&nbsp;             */
&nbsp;            protected Relative(FieldNameExtractor fieldNameExtractor) {
<b class="fc">&nbsp;                this(fieldNameExtractor, FieldLocator.ForClassHierarchy.Factory.INSTANCE);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new relative field location.
&nbsp;             *
&nbsp;             * @param fieldNameExtractor  The field name extractor to use.
&nbsp;             * @param fieldLocatorFactory The field locator factory to use.
&nbsp;             */
<b class="fc">&nbsp;            private Relative(FieldNameExtractor fieldNameExtractor, FieldLocator.Factory fieldLocatorFactory) {</b>
<b class="fc">&nbsp;                this.fieldNameExtractor = fieldNameExtractor;</b>
<b class="fc">&nbsp;                this.fieldLocatorFactory = fieldLocatorFactory;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldLocation with(FieldLocator.Factory fieldLocatorFactory) {
<b class="nc">&nbsp;                return new Relative(fieldNameExtractor, fieldLocatorFactory);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldLocation.Prepared prepare(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return new Prepared(fieldNameExtractor, fieldLocatorFactory.make(instrumentedType));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A prepared version of a field location.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Prepared implements FieldLocation.Prepared {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field name extractor to use.
&nbsp;                 */
&nbsp;                private final FieldNameExtractor fieldNameExtractor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field locator factory to use.
&nbsp;                 */
&nbsp;                private final FieldLocator fieldLocator;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new relative field location.
&nbsp;                 *
&nbsp;                 * @param fieldNameExtractor The field name extractor to use.
&nbsp;                 * @param fieldLocator       The field locator to use.
&nbsp;                 */
<b class="fc">&nbsp;                protected Prepared(FieldNameExtractor fieldNameExtractor, FieldLocator fieldLocator) {</b>
<b class="fc">&nbsp;                    this.fieldNameExtractor = fieldNameExtractor;</b>
<b class="fc">&nbsp;                    this.fieldLocator = fieldLocator;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public FieldDescription resolve(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    FieldLocator.Resolution resolution = fieldLocator.locate(fieldNameExtractor.resolve(instrumentedMethod));</b>
<b class="pc">&nbsp;                    if (!resolution.isResolved()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot resolve field for &quot; + instrumentedMethod + &quot; using &quot; + fieldLocator);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return resolution.getField();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field name extractor is responsible for determining a field name to a method that is implemented
&nbsp;     * to access this method.
&nbsp;     */
&nbsp;    public interface FieldNameExtractor {
&nbsp;
&nbsp;        /**
&nbsp;         * Extracts a field name to be accessed by a getter or setter method.
&nbsp;         *
&nbsp;         * @param methodDescription The method for which a field name is to be determined.
&nbsp;         * @return The name of the field to be accessed by this method.
&nbsp;         */
&nbsp;        String resolve(MethodDescription methodDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * A {@link net.bytebuddy.implementation.FieldAccessor.FieldNameExtractor} that determines a field name
&nbsp;         * according to the rules of Java bean naming conventions.
&nbsp;         */
<b class="fc">&nbsp;        enum ForBeanProperty implements FieldNameExtractor {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public String resolve(MethodDescription methodDescription) {
<b class="fc">&nbsp;                String name = methodDescription.getInternalName();</b>
&nbsp;                int crop;
<b class="pc">&nbsp;                if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {</b>
<b class="fc">&nbsp;                    crop = 3;</b>
<b class="nc">&nbsp;                } else if (name.startsWith(&quot;is&quot;)) {</b>
<b class="nc">&nbsp;                    crop = 2;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new IllegalArgumentException(methodDescription + &quot; does not follow Java bean naming conventions&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                name = name.substring(crop);</b>
<b class="pc">&nbsp;                if (name.length() == 0) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(methodDescription + &quot; does not specify a bean name&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return Character.toLowerCase(name.charAt(0)) + name.substring(1);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A field name extractor that returns a fixed value.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForFixedValue implements FieldNameExtractor {
&nbsp;
&nbsp;            /**
&nbsp;             * The name to return.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new field name extractor for a fixed value.
&nbsp;             *
&nbsp;             * @param name The name to return.
&nbsp;             */
&nbsp;            protected ForFixedValue(String name) {
&nbsp;                this.name = name;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String resolve(MethodDescription methodDescription) {
&nbsp;                return name;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field accessor that allows to define the access to be a field write of a given argument.
&nbsp;     */
&nbsp;    public interface PropertyConfigurable extends Implementation {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a field accessor for the described field that serves as a setter for the supplied parameter index. The instrumented
&nbsp;         * method must return {@code void} or a chained instrumentation must be supplied.
&nbsp;         *
&nbsp;         * @param index The index of the parameter for which to set the field&#39;s value.
&nbsp;         * @return An instrumentation that sets the parameter&#39;s value to the described field.
&nbsp;         */
&nbsp;        Implementation.Composable setsArgumentAt(int index);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field accessor that can be configured to use a given assigner and runtime type use configuration.
&nbsp;     */
&nbsp;    public interface AssignerConfigurable extends PropertyConfigurable {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a field accessor that is identical to this field accessor but uses the given assigner
&nbsp;         * and runtime type use configuration.
&nbsp;         *
&nbsp;         * @param assigner The assigner to use.
&nbsp;         * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @return This field accessor with the given assigner and runtime type use configuration.
&nbsp;         */
&nbsp;        PropertyConfigurable withAssigner(Assigner assigner, Assigner.Typing typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field accessor that can be configured to locate a field in a specific manner.
&nbsp;     */
&nbsp;    public interface OwnerTypeLocatable extends AssignerConfigurable {
&nbsp;
&nbsp;        /**
&nbsp;         * Determines that a field should only be considered when it was defined in a given type.
&nbsp;         *
&nbsp;         * @param type The type to be considered.
&nbsp;         * @return This field accessor which will only considered fields that are defined in the given type.
&nbsp;         */
&nbsp;        AssignerConfigurable in(Class&lt;?&gt; type);
&nbsp;
&nbsp;        /**
&nbsp;         * Determines that a field should only be considered when it was defined in a given type.
&nbsp;         *
&nbsp;         * @param typeDescription A description of the type to be considered.
&nbsp;         * @return This field accessor which will only considered fields that are defined in the given type.
&nbsp;         */
&nbsp;        AssignerConfigurable in(TypeDescription typeDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * Determines that a field should only be considered when it was identified by a field locator that is
&nbsp;         * produced by the given factory.
&nbsp;         *
&nbsp;         * @param fieldLocatorFactory A factory that will produce a field locator that will be used to find locate
&nbsp;         *                            a field to be accessed.
&nbsp;         * @return This field accessor which will only considered fields that are defined in the given type.
&nbsp;         */
&nbsp;        AssignerConfigurable in(FieldLocator.Factory fieldLocatorFactory);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field accessor for an implicit property where a getter or setter property is inferred from the signature.
&nbsp;     */
&nbsp;    protected static class ForImplicitProperty extends FieldAccessor implements OwnerTypeLocatable {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a field accessor for an implicit property.
&nbsp;         *
&nbsp;         * @param fieldLocation The field&#39;s location.
&nbsp;         */
&nbsp;        protected ForImplicitProperty(FieldLocation fieldLocation) {
<b class="fc">&nbsp;            this(fieldLocation, Assigner.DEFAULT, Assigner.Typing.STATIC);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a field accessor for an implicit property.
&nbsp;         *
&nbsp;         * @param fieldLocation The field&#39;s location.
&nbsp;         * @param assigner      The assigner to use.
&nbsp;         * @param typing        The typing to use.
&nbsp;         */
&nbsp;        private ForImplicitProperty(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;            super(fieldLocation, assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return new Appender(fieldLocation.prepare(implementationTarget.getInstrumentedType()));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Composable setsArgumentAt(int index) {
<b class="nc">&nbsp;            if (index &lt; 0) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;A parameter index cannot be negative: &quot; + index);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new ForParameterSetter(fieldLocation, assigner, typing, index);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PropertyConfigurable withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;            return new ForImplicitProperty(fieldLocation, assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AssignerConfigurable in(Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return in(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AssignerConfigurable in(TypeDescription typeDescription) {
<b class="nc">&nbsp;            return in(new FieldLocator.ForExactType.Factory(typeDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AssignerConfigurable in(FieldLocator.Factory fieldLocatorFactory) {
<b class="nc">&nbsp;            return new ForImplicitProperty(fieldLocation.with(fieldLocatorFactory), assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An byte code appender for an field accessor implementation.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;        protected class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;            /**
&nbsp;             * The field&#39;s location.
&nbsp;             */
&nbsp;            private final FieldLocation.Prepared fieldLocation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new byte code appender for a field accessor implementation.
&nbsp;             *
&nbsp;             * @param fieldLocation The field&#39;s location.
&nbsp;             */
<b class="fc">&nbsp;            protected Appender(FieldLocation.Prepared fieldLocation) {</b>
<b class="fc">&nbsp;                this.fieldLocation = fieldLocation;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="pc">&nbsp;                if (!instrumentedMethod.isMethod()) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(instrumentedMethod + &quot; does not describe a field getter or setter&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                FieldDescription fieldDescription = fieldLocation.resolve(instrumentedMethod);</b>
&nbsp;                StackManipulation implementation;
<b class="fc">&nbsp;                if (!instrumentedMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                    implementation = new StackManipulation.Compound(getter(fieldDescription, instrumentedMethod), MethodReturn.of(instrumentedMethod.getReturnType()));</b>
<b class="pc">&nbsp;                } else if (instrumentedMethod.getReturnType().represents(void.class) &amp;&amp; instrumentedMethod.getParameters().size() == 1) {</b>
<b class="fc">&nbsp;                    implementation = new StackManipulation.Compound(setter(fieldDescription, instrumentedMethod.getParameters().get(0)), MethodReturn.VOID);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Method &quot; + implementationContext + &quot; is no bean property&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Size(implementation.apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field accessor that sets a parameters value of a given index.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class ForParameterSetter extends FieldAccessor implements Implementation.Composable {
&nbsp;
&nbsp;        /**
&nbsp;         * The targeted parameter index.
&nbsp;         */
&nbsp;        private final int index;
&nbsp;
&nbsp;        /**
&nbsp;         * The termination handler to apply.
&nbsp;         */
&nbsp;        private final TerminationHandler terminationHandler;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new field accessor.
&nbsp;         *
&nbsp;         * @param fieldLocation The field&#39;s location.
&nbsp;         * @param assigner      The assigner to use.
&nbsp;         * @param typing        Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @param index         The targeted parameter index.
&nbsp;         */
&nbsp;        protected ForParameterSetter(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing, int index) {
&nbsp;            this(fieldLocation, assigner, typing, index, TerminationHandler.RETURNING);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new field accessor.
&nbsp;         *
&nbsp;         * @param fieldLocation      The field&#39;s location.
&nbsp;         * @param assigner           The assigner to use.
&nbsp;         * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @param index              The targeted parameter index.
&nbsp;         * @param terminationHandler The termination handler to apply.
&nbsp;         */
&nbsp;        private ForParameterSetter(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing, int index, TerminationHandler terminationHandler) {
&nbsp;            super(fieldLocation, assigner, typing);
&nbsp;            this.index = index;
&nbsp;            this.terminationHandler = terminationHandler;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
&nbsp;            return new Appender(fieldLocation.prepare(implementationTarget.getInstrumentedType()));
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Implementation andThen(Implementation implementation) {
&nbsp;            return new Compound(new ForParameterSetter(fieldLocation,
&nbsp;                    assigner,
&nbsp;                    typing,
&nbsp;                    index, TerminationHandler.NON_OPERATIONAL), implementation);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Composable andThen(Composable implementation) {
&nbsp;            return new Compound.Composable(new ForParameterSetter(fieldLocation,
&nbsp;                    assigner,
&nbsp;                    typing,
&nbsp;                    index, TerminationHandler.NON_OPERATIONAL), implementation);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A termination handler is responsible for handling a field accessor&#39;s return.
&nbsp;         */
&nbsp;        protected enum TerminationHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code void} or throws an exception if this is not the return type of the instrumented method.
&nbsp;             */
&nbsp;            RETURNING {
&nbsp;                @Override
&nbsp;                protected StackManipulation resolve(MethodDescription instrumentedMethod) {
&nbsp;                    if (!instrumentedMethod.getReturnType().represents(void.class)) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot implement setter with return value for &quot; + instrumentedMethod);
&nbsp;                    }
&nbsp;                    return MethodReturn.VOID;
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * Does not return from the method at all.
&nbsp;             */
&nbsp;            NON_OPERATIONAL {
&nbsp;                @Override
&nbsp;                protected StackManipulation resolve(MethodDescription instrumentedMethod) {
&nbsp;                    return StackManipulation.Trivial.INSTANCE;
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the return instruction.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @return An appropriate stack manipulation.
&nbsp;             */
&nbsp;            protected abstract StackManipulation resolve(MethodDescription instrumentedMethod);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An appender for a field accessor that sets a parameter of a given index.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;        protected class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;            /**
&nbsp;             * The field&#39;s location.
&nbsp;             */
&nbsp;            private final FieldLocation.Prepared fieldLocation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new byte code appender for a field accessor implementation.
&nbsp;             *
&nbsp;             * @param fieldLocation The field&#39;s location.
&nbsp;             */
&nbsp;            protected Appender(FieldLocation.Prepared fieldLocation) {
&nbsp;                this.fieldLocation = fieldLocation;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
&nbsp;                if (instrumentedMethod.getParameters().size() &lt;= index) {
&nbsp;                    throw new IllegalStateException(instrumentedMethod + &quot; does not define a parameter with index &quot; + index);
&nbsp;                } else {
&nbsp;                    return new Size(new StackManipulation.Compound(
&nbsp;                            setter(fieldLocation.resolve(instrumentedMethod), instrumentedMethod.getParameters().get(index)),
&nbsp;                            terminationHandler.resolve(instrumentedMethod)
&nbsp;                    ).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
