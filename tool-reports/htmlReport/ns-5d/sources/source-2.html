


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Implementation</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: Implementation (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">Implementation$Composable</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (12/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72,7%
  </span>
  <span class="absValue">
    (48/66)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$AbstractPropertyAccessorMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$AccessorMethod</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92,3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$AccessorMethodDelegation</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$CacheValueField</td>
<td class="coverageStat">
  <span class="percent">
    83,3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88,9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$DelegationRecord</td>
<td class="coverageStat">
  <span class="percent">
    77,8%
  </span>
  <span class="absValue">
    (7/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84,6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$FieldCacheEntry</td>
<td class="coverageStat">
  <span class="percent">
    57,1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (8/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$FieldGetterDelegation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$FieldSetterDelegation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$ExtractableView</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$ExtractableView$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Factory</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    30%
  </span>
  <span class="absValue">
    (3/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$Illegal</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62,5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83,3%
  </span>
  <span class="absValue">
    (15/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase$DefaultMethodInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase$DefaultMethodInvocation$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase$DefaultMethodInvocation$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$Factory</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    72,1%
  </span>
  <span class="absValue">
    (62/86)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    39,1%
  </span>
  <span class="absValue">
    (25/64)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68,9%
  </span>
  <span class="absValue">
    (144/209)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeInitializer;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeWriter;
&nbsp;import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import net.bytebuddy.jar.asm.ClassVisitor;
&nbsp;import net.bytebuddy.jar.asm.FieldVisitor;
&nbsp;import net.bytebuddy.jar.asm.MethodVisitor;
&nbsp;import net.bytebuddy.jar.asm.Opcodes;
&nbsp;
&nbsp;import java.util.*;
&nbsp;
&nbsp;/**
&nbsp; * An implementation is responsible for implementing methods of a dynamically created type as byte code. An
&nbsp; * implementation is applied in two stages:
&nbsp; * &lt;ol&gt;
&nbsp; * &lt;li&gt;The implementation is able to prepare an instrumented type by adding fields and/or helper methods that are
&nbsp; * required for the methods implemented by this implementation. Furthermore,
&nbsp; * {@link LoadedTypeInitializer}s  and byte code for the type initializer can be registered for the instrumented
&nbsp; * type.&lt;/li&gt;
&nbsp; * &lt;li&gt;Any implementation is required to supply a byte code appender that is responsible for providing the byte code
&nbsp; * to the instrumented methods that were delegated to this implementation. This byte code appender is also
&nbsp; * be responsible for providing implementations for the methods added in step &lt;i&gt;1&lt;/i&gt;.&lt;/li&gt;
&nbsp; * &lt;/ol&gt;
&nbsp; * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp; * An implementation should provide meaningful implementations of both {@link java.lang.Object#equals(Object)}
&nbsp; * and {@link Object#hashCode()} if it wants to avoid to be used twice within the creation of a dynamic type. For two
&nbsp; * equal implementations only one will be applied on the creation of a dynamic type.
&nbsp; */
&nbsp;public interface Implementation extends InstrumentedType.Prepareable {
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a byte code appender that determines the implementation of the instrumented type&#39;s methods.
&nbsp;     *
&nbsp;     * @param implementationTarget The target of the current implementation.
&nbsp;     * @return A byte code appender for implementing methods delegated to this implementation. This byte code appender
&nbsp;     * is also responsible for handling methods that were added by this implementation on the call to
&nbsp;     * {@link Implementation#prepare(InstrumentedType)}.
&nbsp;     */
&nbsp;    ByteCodeAppender appender(Target implementationTarget);
&nbsp;
&nbsp;    /**
&nbsp;     * Represents an implementation that can be chained together with another implementation.
&nbsp;     */
&nbsp;    interface Composable extends Implementation {
&nbsp;
&nbsp;        /**
&nbsp;         * Appends the supplied implementation to this implementation.
&nbsp;         *
&nbsp;         * @param implementation The subsequent implementation.
&nbsp;         * @return An implementation that combines this implementation with the provided one.
&nbsp;         */
&nbsp;        Implementation andThen(Implementation implementation);
&nbsp;
&nbsp;        /**
&nbsp;         * Appends the supplied composable implementation to this implementation.
&nbsp;         *
&nbsp;         * @param implementation The subsequent composable implementation.
&nbsp;         * @return A composable implementation that combines this implementation with the provided one.
&nbsp;         */
&nbsp;        Composable andThen(Composable implementation);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents an type-specific method invocation on the current instrumented type which is not legal from outside
&nbsp;     * the type such as a super method or default method invocation. Legal instances of special method invocations must
&nbsp;     * be equal to one another if they represent the same invocation target.
&nbsp;     */
&nbsp;    interface SpecialMethodInvocation extends StackManipulation {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the method that represents this special method invocation. This method can be different even for
&nbsp;         * equal special method invocations, dependant on the method that was used to request such an invocation by the
&nbsp;         * means of a {@link Implementation.Target}.
&nbsp;         *
&nbsp;         * @return The method description that describes this instances invocation target.
&nbsp;         */
&nbsp;        MethodDescription getMethodDescription();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the target type the represented method is invoked on.
&nbsp;         *
&nbsp;         * @return The type the represented method is invoked on.
&nbsp;         */
&nbsp;        TypeDescription getTypeDescription();
&nbsp;
&nbsp;        /**
&nbsp;         * A canonical implementation of an illegal {@link Implementation.SpecialMethodInvocation}.
&nbsp;         */
<b class="fc">&nbsp;        enum Illegal implements SpecialMethodInvocation {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isValid() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot implement an undefined method&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription getMethodDescription() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;An illegal special method invocation must not be applied&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription getTypeDescription() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;An illegal special method invocation must not be applied&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a valid special method invocation.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase implements SpecialMethodInvocation {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isValid() {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return 31 * getMethodDescription().asSignatureToken().hashCode() + getTypeDescription().hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
<b class="nc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="nc">&nbsp;                } else if (!(other instanceof SpecialMethodInvocation)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                SpecialMethodInvocation specialMethodInvocation = (SpecialMethodInvocation) other;</b>
<b class="nc">&nbsp;                return getMethodDescription().asSignatureToken().equals(specialMethodInvocation.getMethodDescription().asSignatureToken())</b>
<b class="nc">&nbsp;                        &amp;&amp; getTypeDescription().equals(specialMethodInvocation.getTypeDescription());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A canonical implementation of a {@link SpecialMethodInvocation}.
&nbsp;         */
&nbsp;        class Simple extends SpecialMethodInvocation.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The method description that is represented by this legal special method invocation.
&nbsp;             */
&nbsp;            private final MethodDescription methodDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The type description that is represented by this legal special method invocation.
&nbsp;             */
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * A stack manipulation representing the method&#39;s invocation on the type description.
&nbsp;             */
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new legal special method invocation.
&nbsp;             *
&nbsp;             * @param methodDescription The method that represents the special method invocation.
&nbsp;             * @param typeDescription   The type on which the method should be invoked on by an {@code INVOKESPECIAL}
&nbsp;             *                          invocation.
&nbsp;             * @param stackManipulation The stack manipulation that represents this special method invocation.
&nbsp;             */
<b class="fc">&nbsp;            protected Simple(MethodDescription methodDescription, TypeDescription typeDescription, StackManipulation stackManipulation) {</b>
<b class="fc">&nbsp;                this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                this.stackManipulation = stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a special method invocation for a given invocation target.
&nbsp;             *
&nbsp;             * @param methodDescription The method that represents the special method invocation.
&nbsp;             * @param typeDescription   The type on which the method should be invoked on by an {@code INVOKESPECIAL}
&nbsp;             *                          invocation.
&nbsp;             * @return A special method invocation representing a legal invocation if the method can be invoked
&nbsp;             * specially on the target type or an illegal invocation if this is not possible.
&nbsp;             */
&nbsp;            public static SpecialMethodInvocation of(MethodDescription methodDescription, TypeDescription typeDescription) {
<b class="fc">&nbsp;                StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).special(typeDescription);</b>
<b class="fc">&nbsp;                return stackManipulation.isValid()</b>
&nbsp;                        ? new Simple(methodDescription, typeDescription, stackManipulation)
&nbsp;                        : SpecialMethodInvocation.Illegal.INSTANCE;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription getMethodDescription() {
<b class="fc">&nbsp;                return methodDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription getTypeDescription() {
<b class="fc">&nbsp;                return typeDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                return stackManipulation.apply(methodVisitor, implementationContext);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The target of an implementation. Implementation targets must be immutable and can be queried without altering
&nbsp;     * the implementation result. An implementation target provides information on the type that is to be created
&nbsp;     * where it is the implementation&#39;s responsibility to cache expensive computations, especially such computations
&nbsp;     * that require reflective look-up.
&nbsp;     */
&nbsp;    interface Target {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a description of the instrumented type.
&nbsp;         *
&nbsp;         * @return A description of the instrumented type.
&nbsp;         */
&nbsp;        TypeDescription getInstrumentedType();
&nbsp;
&nbsp;        /**
&nbsp;         * Identifies the origin type of an implementation. The origin type describes the type that is subject to
&nbsp;         * any form of enhancement. If a subclass of a given type is generated, the base type of this subclass
&nbsp;         * describes the origin type. If a given type is redefined or rebased, the origin type is described by the
&nbsp;         * instrumented type itself.
&nbsp;         *
&nbsp;         * @return The origin type of this implementation.
&nbsp;         */
&nbsp;        TypeDefinition getOriginType();
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a special method invocation for invoking the super method of the given method.
&nbsp;         *
&nbsp;         * @param token A token of the method that is to be invoked as a super method.
&nbsp;         * @return The corresponding special method invocation which might be illegal if the requested invocation is not legal.
&nbsp;         */
&nbsp;        SpecialMethodInvocation invokeSuper(MethodDescription.SignatureToken token);
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a special method invocation for invoking a default method with the given token. The default method call must
&nbsp;         * not be ambiguous or an illegal special method invocation is returned.
&nbsp;         *
&nbsp;         * @param token A token of the method that is to be invoked as a default method.
&nbsp;         * @return The corresponding default method invocation which might be illegal if the requested invocation is not legal or ambiguous.
&nbsp;         */
&nbsp;        SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token);
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a special method invocation for invoking a default method.
&nbsp;         *
&nbsp;         * @param targetType The interface on which the default method is to be invoked.
&nbsp;         * @param token      A token that uniquely describes the method to invoke.
&nbsp;         * @return The corresponding special method invocation which might be illegal if the requested invocation is
&nbsp;         * not legal.
&nbsp;         */
&nbsp;        SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token, TypeDescription targetType);
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a dominant method, i.e. if the method token can be invoked as a super method invocation, this invocation is considered dominant.
&nbsp;         * Alternatively, a method invocation is attempted on an interface type as a default method invocation only if this invocation is not ambiguous
&nbsp;         * for several interfaces.
&nbsp;         *
&nbsp;         * @param token The method token representing the method to be invoked.
&nbsp;         * @return A special method invocation for a method representing the method token.
&nbsp;         */
&nbsp;        SpecialMethodInvocation invokeDominant(MethodDescription.SignatureToken token);
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating an {@link Implementation.Target}.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an implementation target.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @param methodGraph      A method graph of the instrumented type.
&nbsp;             * @param classFileVersion The type&#39;s class file version.
&nbsp;             * @return An implementation target for the instrumented type.
&nbsp;             */
&nbsp;            Target make(TypeDescription instrumentedType, MethodGraph.Linked methodGraph, ClassFileVersion classFileVersion);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation for an {@link Implementation.Target}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        abstract class AbstractBase implements Target {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            protected final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type&#39;s method graph.
&nbsp;             */
&nbsp;            protected final MethodGraph.Linked methodGraph;
&nbsp;
&nbsp;            /**
&nbsp;             * The default method invocation mode to apply.
&nbsp;             */
&nbsp;            protected final DefaultMethodInvocation defaultMethodInvocation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new implementation target.
&nbsp;             *
&nbsp;             * @param instrumentedType        The instrumented type.
&nbsp;             * @param methodGraph             The instrumented type&#39;s method graph.
&nbsp;             * @param defaultMethodInvocation The default method invocation mode to apply.
&nbsp;             */
<b class="fc">&nbsp;            protected AbstractBase(TypeDescription instrumentedType, MethodGraph.Linked methodGraph, DefaultMethodInvocation defaultMethodInvocation) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                this.methodGraph = methodGraph;</b>
<b class="fc">&nbsp;                this.defaultMethodInvocation = defaultMethodInvocation;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription getInstrumentedType() {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token) {
<b class="fc">&nbsp;                SpecialMethodInvocation specialMethodInvocation = SpecialMethodInvocation.Illegal.INSTANCE;</b>
<b class="fc">&nbsp;                for (TypeDescription interfaceType : instrumentedType.getInterfaces().asErasures()) {</b>
<b class="fc">&nbsp;                    SpecialMethodInvocation invocation = invokeDefault(token, interfaceType);</b>
<b class="pc">&nbsp;                    if (invocation.isValid()) {</b>
<b class="nc">&nbsp;                        if (specialMethodInvocation.isValid()) {</b>
<b class="nc">&nbsp;                            return SpecialMethodInvocation.Illegal.INSTANCE;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            specialMethodInvocation = invocation;</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return specialMethodInvocation;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token, TypeDescription targetType) {
<b class="fc">&nbsp;                return defaultMethodInvocation.apply(methodGraph.getInterfaceGraph(targetType).locate(token), targetType);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public SpecialMethodInvocation invokeDominant(MethodDescription.SignatureToken token) {
<b class="fc">&nbsp;                SpecialMethodInvocation specialMethodInvocation = invokeSuper(token);</b>
<b class="fc">&nbsp;                return specialMethodInvocation.isValid()</b>
&nbsp;                        ? specialMethodInvocation
<b class="fc">&nbsp;                        : invokeDefault(token);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if default method invocations are possible.
&nbsp;             */
<b class="fc">&nbsp;            protected enum DefaultMethodInvocation {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Permits default method invocations, if an interface declaring a default method is possible.
&nbsp;                 */
<b class="fc">&nbsp;                ENABLED {</b>
&nbsp;                    @Override
&nbsp;                    protected SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType) {
<b class="fc">&nbsp;                        return node.getSort().isUnique()</b>
<b class="fc">&nbsp;                                ? SpecialMethodInvocation.Simple.of(node.getRepresentative(), targetType)</b>
&nbsp;                                : SpecialMethodInvocation.Illegal.INSTANCE;
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Does not permit default method invocations.
&nbsp;                 */
<b class="fc">&nbsp;                DISABLED {</b>
&nbsp;                    @Override
&nbsp;                    protected SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType) {
<b class="nc">&nbsp;                        return SpecialMethodInvocation.Illegal.INSTANCE;</b>
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a default method invocation depending on the class file version permitting such calls.
&nbsp;                 *
&nbsp;                 * @param classFileVersion The class file version to resolve for.
&nbsp;                 * @return A suitable default method invocation mode.
&nbsp;                 */
&nbsp;                public static DefaultMethodInvocation of(ClassFileVersion classFileVersion) {
<b class="pc">&nbsp;                    return classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8)</b>
&nbsp;                            ? ENABLED
&nbsp;                            : DISABLED;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a default method invocation for a given node.
&nbsp;                 *
&nbsp;                 * @param node       The node representing the default method call.
&nbsp;                 * @param targetType The target type defining the default method.
&nbsp;                 * @return A suitable special method invocation.
&nbsp;                 */
&nbsp;                protected abstract SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The context for an implementation application. An implementation context represents a mutable data structure
&nbsp;     * where any registration is irrevocable. Calling methods on an implementation context should be considered equally
&nbsp;     * sensitive as calling a {@link net.bytebuddy.jar.asm.MethodVisitor}. As such, an implementation context and a
&nbsp;     * {@link net.bytebuddy.jar.asm.MethodVisitor} are complementary for creating an new Java type.
&nbsp;     */
&nbsp;    interface Context extends MethodAccessorFactory {
&nbsp;
&nbsp;        /**
&nbsp;         * Registers an auxiliary type as required for the current implementation. Registering a type will cause the
&nbsp;         * creation of this type even if this type is not effectively used for the current implementation.
&nbsp;         *
&nbsp;         * @param auxiliaryType The auxiliary type that is required for the current implementation.
&nbsp;         * @return A description of the registered auxiliary type.
&nbsp;         */
&nbsp;        TypeDescription register(AuxiliaryType auxiliaryType);
&nbsp;
&nbsp;        /**
&nbsp;         * Caches a single value by storing it in form of a {@code private}, {@code final} and {@code static} field.
&nbsp;         * By caching values, expensive instance creations can be avoided and object identity can be preserved.
&nbsp;         * The field is initiated in a generated class&#39;s static initializer.
&nbsp;         *
&nbsp;         * @param fieldValue A stack manipulation for creating the value that is to be cached in a {@code static} field.
&nbsp;         *                   After executing the stack manipulation, exactly one value must be put onto the operand
&nbsp;         *                   stack which is assignable to the given {@code fieldType}.
&nbsp;         * @param fieldType  The type of the field for storing the cached value. This field&#39;s type determines the value
&nbsp;         *                   that is put onto the operand stack by this method&#39;s returned stack manipulation.
&nbsp;         * @return A description of a field that was defined on the instrumented type which contains the given value.
&nbsp;         */
&nbsp;        FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType);
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the instrumented type of the current implementation. The instrumented type is exposed with the intend of allowing optimal
&nbsp;         * byte code generation and not for implementing checks or changing the behavior of a {@link StackManipulation}.
&nbsp;         *
&nbsp;         * @return The instrumented type of the current implementation.
&nbsp;         */
&nbsp;        TypeDescription getInstrumentedType();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the class file version of the currently created dynamic type.
&nbsp;         *
&nbsp;         * @return The class file version of the currently created dynamic type.
&nbsp;         */
&nbsp;        ClassFileVersion getClassFileVersion();
&nbsp;
&nbsp;        /**
&nbsp;         * Represents an extractable view of an {@link Implementation.Context} which
&nbsp;         * allows the retrieval of any registered auxiliary type.
&nbsp;         */
&nbsp;        interface ExtractableView extends Context {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if this implementation context permits the registration of any implicit type initializers.
&nbsp;             *
&nbsp;             * @return {@code true} if this implementation context permits the registration of any implicit type initializers.
&nbsp;             */
&nbsp;            boolean isEnabled();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns any {@link net.bytebuddy.implementation.auxiliary.AuxiliaryType} that was registered
&nbsp;             * with this {@link Implementation.Context}.
&nbsp;             *
&nbsp;             * @return A list of all manifested registered auxiliary types.
&nbsp;             */
&nbsp;            List&lt;DynamicType&gt; getAuxiliaryTypes();
&nbsp;
&nbsp;            /**
&nbsp;             * Writes any information that was registered with an {@link Implementation.Context}
&nbsp;             * to the provided class visitor. This contains any fields for value caching, any accessor method and it
&nbsp;             * writes the type initializer. The type initializer must therefore never be written manually.
&nbsp;             *
&nbsp;             * @param drain                        The drain to write the type initializer to.
&nbsp;             * @param classVisitor                 The class visitor to which the extractable view is to be written.
&nbsp;             * @param annotationValueFilterFactory The annotation value filter factory to apply when writing annotation.
&nbsp;             */
&nbsp;            void drain(TypeInitializer.Drain drain, ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract base implementation of an extractable view of an implementation context.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            abstract class AbstractBase implements ExtractableView {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                protected final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The class file version of the dynamic type.
&nbsp;                 */
&nbsp;                protected final ClassFileVersion classFileVersion;
&nbsp;
&nbsp;                /**
&nbsp;                 * Create a new extractable view.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @param classFileVersion The class file version of the dynamic type.
&nbsp;                 */
<b class="fc">&nbsp;                protected AbstractBase(TypeDescription instrumentedType, ClassFileVersion classFileVersion) {</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                    this.classFileVersion = classFileVersion;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription getInstrumentedType() {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public ClassFileVersion getClassFileVersion() {
<b class="fc">&nbsp;                    return classFileVersion;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating a new implementation context.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new implementation context.
&nbsp;             *
&nbsp;             * @param instrumentedType            The description of the type that is currently subject of creation.
&nbsp;             * @param auxiliaryTypeNamingStrategy The naming strategy for naming an auxiliary type.
&nbsp;             * @param typeInitializer             The type initializer of the created instrumented type.
&nbsp;             * @param classFileVersion            The class file version of the created class.
&nbsp;             * @param auxiliaryClassFileVersion   The class file version of any auxiliary classes.
&nbsp;             * @return An implementation context in its extractable view.
&nbsp;             */
&nbsp;            ExtractableView make(TypeDescription instrumentedType,
&nbsp;                                 AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                 TypeInitializer typeInitializer,
&nbsp;                                 ClassFileVersion classFileVersion,
&nbsp;                                 ClassFileVersion auxiliaryClassFileVersion);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An implementation context that does not allow for any injections into the static initializer block. This can be useful when
&nbsp;         * redefining a class when it is not allowed to add methods to a class what is an implicit requirement when copying the static
&nbsp;         * initializer block into another method.
&nbsp;         */
&nbsp;        class Disabled extends ExtractableView.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new disabled implementation context.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @param classFileVersion The class file version to create the class in.
&nbsp;             */
&nbsp;            protected Disabled(TypeDescription instrumentedType, ClassFileVersion classFileVersion) {
&nbsp;                super(instrumentedType, classFileVersion);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isEnabled() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public List&lt;DynamicType&gt; getAuxiliaryTypes() {
&nbsp;                return Collections.emptyList();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void drain(TypeInitializer.Drain drain, ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                drain.apply(classVisitor, TypeInitializer.None.INSTANCE, this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription register(AuxiliaryType auxiliaryType) {
&nbsp;                throw new IllegalStateException(&quot;Registration of auxiliary types was disabled: &quot; + auxiliaryType);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription.InDefinedShape registerAccessorFor(SpecialMethodInvocation specialMethodInvocation, AccessType accessType) {
&nbsp;                throw new IllegalStateException(&quot;Registration of method accessors was disabled: &quot; + specialMethodInvocation.getMethodDescription());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription.InDefinedShape registerGetterFor(FieldDescription fieldDescription, AccessType accessType) {
&nbsp;                throw new IllegalStateException(&quot;Registration of field accessor was disabled: &quot; + fieldDescription);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription.InDefinedShape registerSetterFor(FieldDescription fieldDescription, AccessType accessType) {
&nbsp;                throw new IllegalStateException(&quot;Registration of field accessor was disabled: &quot; + fieldDescription);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType) {
&nbsp;                throw new IllegalStateException(&quot;Field values caching was disabled: &quot; + fieldType);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a {@link net.bytebuddy.implementation.Implementation.Context.Disabled}.
&nbsp;             */
&nbsp;            public enum Factory implements Context.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                @Override
&nbsp;                public ExtractableView make(TypeDescription instrumentedType,
&nbsp;                                            AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                            TypeInitializer typeInitializer,
&nbsp;                                            ClassFileVersion classFileVersion,
&nbsp;                                            ClassFileVersion auxiliaryClassFileVersion) {
&nbsp;                    if (typeInitializer.isDefined()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot define type initializer which was explicitly disabled: &quot; + typeInitializer);
&nbsp;                    }
&nbsp;                    return new Disabled(instrumentedType, classFileVersion);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A default implementation of an {@link Implementation.Context.ExtractableView}
&nbsp;         * which serves as its own {@link MethodAccessorFactory}.
&nbsp;         */
&nbsp;        class Default extends ExtractableView.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The name suffix to be appended to an accessor method.
&nbsp;             */
&nbsp;            public static final String ACCESSOR_METHOD_SUFFIX = &quot;accessor&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The name prefix to be prepended to a field storing a cached value.
&nbsp;             */
&nbsp;            public static final String FIELD_CACHE_PREFIX = &quot;cachedValue&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The naming strategy for naming auxiliary types that are registered.
&nbsp;             */
&nbsp;            private final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The type initializer of the created instrumented type.
&nbsp;             */
&nbsp;            private final TypeInitializer typeInitializer;
&nbsp;
&nbsp;            /**
&nbsp;             * The class file version to use for auxiliary classes.
&nbsp;             */
&nbsp;            private final ClassFileVersion auxiliaryClassFileVersion;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of special method invocations to their accessor methods that each invoke their mapped invocation.
&nbsp;             */
&nbsp;            private final Map&lt;SpecialMethodInvocation, DelegationRecord&gt; registeredAccessorMethods;
&nbsp;
&nbsp;            /**
&nbsp;             * The registered getters.
&nbsp;             */
&nbsp;            private final Map&lt;FieldDescription, DelegationRecord&gt; registeredGetters;
&nbsp;
&nbsp;            /**
&nbsp;             * The registered setters.
&nbsp;             */
&nbsp;            private final Map&lt;FieldDescription, DelegationRecord&gt; registeredSetters;
&nbsp;
&nbsp;            /**
&nbsp;             * A map of registered auxiliary types to their dynamic type representation.
&nbsp;             */
&nbsp;            private final Map&lt;AuxiliaryType, DynamicType&gt; auxiliaryTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * A map of already registered field caches to their field representation.
&nbsp;             */
&nbsp;            private final Map&lt;FieldCacheEntry, FieldDescription.InDefinedShape&gt; registeredFieldCacheEntries;
&nbsp;
&nbsp;            /**
&nbsp;             * A set of registered field cache entries.
&nbsp;             */
&nbsp;            private final Set&lt;FieldDescription.InDefinedShape&gt; registeredFieldCacheFields;
&nbsp;
&nbsp;            /**
&nbsp;             * A random suffix to append to the names of accessor methods.
&nbsp;             */
&nbsp;            private final String suffix;
&nbsp;
&nbsp;            /**
&nbsp;             * If {@code false}, the type initializer for this instance was already drained what prohibits the registration of additional cached field values.
&nbsp;             */
&nbsp;            private boolean fieldCacheCanAppendEntries;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default implementation context.
&nbsp;             *
&nbsp;             * @param instrumentedType            The description of the type that is currently subject of creation.
&nbsp;             * @param classFileVersion            The class file version of the created class.
&nbsp;             * @param auxiliaryTypeNamingStrategy The naming strategy for naming an auxiliary type.
&nbsp;             * @param typeInitializer             The type initializer of the created instrumented type.
&nbsp;             * @param auxiliaryClassFileVersion   The class file version to use for auxiliary classes.
&nbsp;             */
&nbsp;            protected Default(TypeDescription instrumentedType,
&nbsp;                              ClassFileVersion classFileVersion,
&nbsp;                              AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                              TypeInitializer typeInitializer,
&nbsp;                              ClassFileVersion auxiliaryClassFileVersion) {
<b class="fc">&nbsp;                super(instrumentedType, classFileVersion);</b>
<b class="fc">&nbsp;                this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;</b>
<b class="fc">&nbsp;                this.typeInitializer = typeInitializer;</b>
<b class="fc">&nbsp;                this.auxiliaryClassFileVersion = auxiliaryClassFileVersion;</b>
<b class="fc">&nbsp;                registeredAccessorMethods = new HashMap&lt;SpecialMethodInvocation, DelegationRecord&gt;();</b>
<b class="fc">&nbsp;                registeredGetters = new HashMap&lt;FieldDescription, DelegationRecord&gt;();</b>
<b class="fc">&nbsp;                registeredSetters = new HashMap&lt;FieldDescription, DelegationRecord&gt;();</b>
<b class="fc">&nbsp;                auxiliaryTypes = new HashMap&lt;AuxiliaryType, DynamicType&gt;();</b>
<b class="fc">&nbsp;                registeredFieldCacheEntries = new HashMap&lt;FieldCacheEntry, FieldDescription.InDefinedShape&gt;();</b>
<b class="fc">&nbsp;                registeredFieldCacheFields = new HashSet&lt;FieldDescription.InDefinedShape&gt;();</b>
<b class="fc">&nbsp;                suffix = RandomString.make();</b>
<b class="fc">&nbsp;                fieldCacheCanAppendEntries = true;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isEnabled() {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription.InDefinedShape registerAccessorFor(SpecialMethodInvocation specialMethodInvocation, AccessType accessType) {
<b class="fc">&nbsp;                DelegationRecord record = registeredAccessorMethods.get(specialMethodInvocation);</b>
<b class="pc">&nbsp;                record = record == null</b>
&nbsp;                        ? new AccessorMethodDelegation(instrumentedType, suffix, accessType, specialMethodInvocation)
<b class="nc">&nbsp;                        : record.with(accessType);</b>
<b class="fc">&nbsp;                registeredAccessorMethods.put(specialMethodInvocation, record);</b>
<b class="fc">&nbsp;                return record.getMethod();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription.InDefinedShape registerGetterFor(FieldDescription fieldDescription, AccessType accessType) {
<b class="nc">&nbsp;                DelegationRecord record = registeredGetters.get(fieldDescription);</b>
<b class="nc">&nbsp;                record = record == null</b>
&nbsp;                        ? new FieldGetterDelegation(instrumentedType, suffix, accessType, fieldDescription)
<b class="nc">&nbsp;                        : record.with(accessType);</b>
<b class="nc">&nbsp;                registeredGetters.put(fieldDescription, record);</b>
<b class="nc">&nbsp;                return record.getMethod();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription.InDefinedShape registerSetterFor(FieldDescription fieldDescription, AccessType accessType) {
<b class="nc">&nbsp;                DelegationRecord record = registeredSetters.get(fieldDescription);</b>
<b class="nc">&nbsp;                record = record == null</b>
&nbsp;                        ? new FieldSetterDelegation(instrumentedType, suffix, accessType, fieldDescription)
<b class="nc">&nbsp;                        : record.with(accessType);</b>
<b class="nc">&nbsp;                registeredSetters.put(fieldDescription, record);</b>
<b class="nc">&nbsp;                return record.getMethod();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription register(AuxiliaryType auxiliaryType) {
<b class="fc">&nbsp;                DynamicType dynamicType = auxiliaryTypes.get(auxiliaryType);</b>
<b class="pc">&nbsp;                if (dynamicType == null) {</b>
<b class="fc">&nbsp;                    dynamicType = auxiliaryType.make(auxiliaryTypeNamingStrategy.name(instrumentedType), auxiliaryClassFileVersion, this);</b>
<b class="fc">&nbsp;                    auxiliaryTypes.put(auxiliaryType, dynamicType);</b>
&nbsp;                }
<b class="fc">&nbsp;                return dynamicType.getTypeDescription();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public List&lt;DynamicType&gt; getAuxiliaryTypes() {
<b class="fc">&nbsp;                return new ArrayList&lt;DynamicType&gt;(auxiliaryTypes.values());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType) {
<b class="fc">&nbsp;                FieldCacheEntry fieldCacheEntry = new FieldCacheEntry(fieldValue, fieldType);</b>
<b class="fc">&nbsp;                FieldDescription.InDefinedShape fieldCache = registeredFieldCacheEntries.get(fieldCacheEntry);</b>
<b class="pc">&nbsp;                if (fieldCache != null) {</b>
<b class="nc">&nbsp;                    return fieldCache;</b>
&nbsp;                }
<b class="pc">&nbsp;                if (!fieldCacheCanAppendEntries) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cached values cannot be registered after defining the type initializer for &quot; + instrumentedType);</b>
&nbsp;                }
<b class="fc">&nbsp;                int hashCode = fieldValue.hashCode();</b>
&nbsp;                do {
<b class="fc">&nbsp;                    fieldCache = new CacheValueField(instrumentedType, fieldType.asGenericType(), suffix, hashCode++);</b>
<b class="pc">&nbsp;                } while (!registeredFieldCacheFields.add(fieldCache));</b>
<b class="fc">&nbsp;                registeredFieldCacheEntries.put(fieldCacheEntry, fieldCache);</b>
<b class="fc">&nbsp;                return fieldCache;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void drain(TypeInitializer.Drain drain,
&nbsp;                              ClassVisitor classVisitor,
&nbsp;                              AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="fc">&nbsp;                fieldCacheCanAppendEntries = false;</b>
<b class="fc">&nbsp;                TypeInitializer typeInitializer = this.typeInitializer;</b>
<b class="fc">&nbsp;                for (Map.Entry&lt;FieldCacheEntry, FieldDescription.InDefinedShape&gt; entry : registeredFieldCacheEntries.entrySet()) {</b>
<b class="fc">&nbsp;                    FieldVisitor fieldVisitor = classVisitor.visitField(entry.getValue().getModifiers(),</b>
<b class="fc">&nbsp;                            entry.getValue().getInternalName(),</b>
<b class="fc">&nbsp;                            entry.getValue().getDescriptor(),</b>
<b class="fc">&nbsp;                            entry.getValue().getGenericSignature(),</b>
&nbsp;                            FieldDescription.NO_DEFAULT_VALUE);
<b class="pc">&nbsp;                    if (fieldVisitor != null) {</b>
<b class="fc">&nbsp;                        fieldVisitor.visitEnd();</b>
<b class="fc">&nbsp;                        typeInitializer = typeInitializer.expandWith(entry.getKey().storeIn(entry.getValue()));</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                drain.apply(classVisitor, typeInitializer, this);</b>
<b class="fc">&nbsp;                for (TypeWriter.MethodPool.Record record : registeredAccessorMethods.values()) {</b>
<b class="fc">&nbsp;                    record.apply(classVisitor, this, annotationValueFilterFactory);</b>
<b class="fc">&nbsp;                }</b>
<b class="pc">&nbsp;                for (TypeWriter.MethodPool.Record record : registeredGetters.values()) {</b>
<b class="nc">&nbsp;                    record.apply(classVisitor, this, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                }</b>
<b class="pc">&nbsp;                for (TypeWriter.MethodPool.Record record : registeredSetters.values()) {</b>
<b class="nc">&nbsp;                    record.apply(classVisitor, this, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A description of a field that stores a cached value.
&nbsp;             */
&nbsp;            protected static class CacheValueField extends FieldDescription.InDefinedShape.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type of the cache&#39;s field.
&nbsp;                 */
&nbsp;                private final TypeDescription.Generic fieldType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new cache value field.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @param fieldType        The type of the cache&#39;s field.
&nbsp;                 * @param suffix           The suffix to use for the cache field&#39;s name.
&nbsp;                 * @param hashCode         The hash value of the field&#39;s value for creating a unique field name.
&nbsp;                 */
<b class="fc">&nbsp;                protected CacheValueField(TypeDescription instrumentedType, TypeDescription.Generic fieldType, String suffix, int hashCode) {</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                    this.fieldType = fieldType;</b>
<b class="fc">&nbsp;                    name = FIELD_CACHE_PREFIX + &quot;$&quot; + suffix + &quot;$&quot; + RandomString.hashOf(hashCode);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription.Generic getType() {
<b class="fc">&nbsp;                    return fieldType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int getModifiers() {
<b class="pc">&nbsp;                    return Opcodes.ACC_SYNTHETIC | Opcodes.ACC_FINAL | Opcodes.ACC_STATIC | (instrumentedType.isInterface()</b>
&nbsp;                            ? Opcodes.ACC_PUBLIC
&nbsp;                            : Opcodes.ACC_PRIVATE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getName() {
<b class="fc">&nbsp;                    return name;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A field cache entry for uniquely identifying a cached field. A cached field is described by the stack
&nbsp;             * manipulation that loads the field&#39;s value onto the operand stack and the type of the field.
&nbsp;             */
&nbsp;            protected static class FieldCacheEntry implements StackManipulation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field value that is represented by this field cache entry.
&nbsp;                 */
&nbsp;                private final StackManipulation fieldValue;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field type that is represented by this field cache entry.
&nbsp;                 */
&nbsp;                private final TypeDescription fieldType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field cache entry.
&nbsp;                 *
&nbsp;                 * @param fieldValue The field value that is represented by this field cache entry.
&nbsp;                 * @param fieldType  The field type that is represented by this field cache entry.
&nbsp;                 */
<b class="fc">&nbsp;                protected FieldCacheEntry(StackManipulation fieldValue, TypeDescription fieldType) {</b>
<b class="fc">&nbsp;                    this.fieldValue = fieldValue;</b>
<b class="fc">&nbsp;                    this.fieldType = fieldType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a stack manipulation where the represented value is stored in the given field.
&nbsp;                 *
&nbsp;                 * @param fieldDescription A static field in which the value is to be stored.
&nbsp;                 * @return A byte code appender that represents this storage.
&nbsp;                 */
&nbsp;                protected ByteCodeAppender storeIn(FieldDescription fieldDescription) {
<b class="fc">&nbsp;                    return new ByteCodeAppender.Simple(this, FieldAccess.forField(fieldDescription).write());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the field type that is represented by this field cache entry.
&nbsp;                 *
&nbsp;                 * @return The field type that is represented by this field cache entry.
&nbsp;                 */
&nbsp;                protected TypeDescription getFieldType() {
<b class="nc">&nbsp;                    return fieldType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isValid() {
<b class="nc">&nbsp;                    return fieldValue.isValid();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                    return fieldValue.apply(methodVisitor, implementationContext);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean equals(Object other) {
<b class="nc">&nbsp;                    if (this == other) {</b>
<b class="nc">&nbsp;                        return true;</b>
<b class="nc">&nbsp;                    } else if (other == null || getClass() != other.getClass()) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    FieldCacheEntry fieldCacheEntry = (FieldCacheEntry) other;</b>
<b class="nc">&nbsp;                    return fieldValue.equals(fieldCacheEntry.fieldValue) &amp;&amp; fieldType.equals(fieldCacheEntry.fieldType);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int hashCode() {
<b class="fc">&nbsp;                    int result = fieldValue.hashCode();</b>
<b class="fc">&nbsp;                    result = 31 * result + fieldType.hashCode();</b>
<b class="fc">&nbsp;                    return result;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A base implementation of a method that accesses a property of an instrumented type.
&nbsp;             */
<b class="fc">&nbsp;            protected abstract static class AbstractPropertyAccessorMethod extends MethodDescription.InDefinedShape.AbstractBase {</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public int getModifiers() {
<b class="pc">&nbsp;                    return Opcodes.ACC_SYNTHETIC | getBaseModifiers() | (getDeclaringType().isInterface()</b>
&nbsp;                            ? Opcodes.ACC_PUBLIC
&nbsp;                            : Opcodes.ACC_FINAL);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the base modifiers, i.e. the modifiers that define the accessed property&#39;s features.
&nbsp;                 *
&nbsp;                 * @return Returns the base modifiers of the represented methods.
&nbsp;                 */
&nbsp;                protected abstract int getBaseModifiers();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A description of an accessor method to access another method from outside the instrumented type.
&nbsp;             */
&nbsp;            protected static class AccessorMethod extends AbstractPropertyAccessorMethod {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method that is being accessed.
&nbsp;                 */
&nbsp;                private final MethodDescription methodDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the method.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new accessor method.
&nbsp;                 *
&nbsp;                 * @param instrumentedType  The instrumented type.
&nbsp;                 * @param methodDescription The method that is being accessed.
&nbsp;                 * @param suffix            The suffix to append to the accessor method&#39;s name.
&nbsp;                 */
<b class="fc">&nbsp;                protected AccessorMethod(TypeDescription instrumentedType, MethodDescription methodDescription, String suffix) {</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                    this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                    name = methodDescription.getInternalName() + &quot;$&quot; + ACCESSOR_METHOD_SUFFIX + &quot;$&quot; + suffix;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;                    return methodDescription.getReturnType().asRawType();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;                    return new ParameterList.Explicit.ForTypes(this, methodDescription.getParameters().asTypeList().asRawTypes());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;                    return methodDescription.getExceptionTypes().asRawTypes();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="nc">&nbsp;                    return AnnotationValue.UNDEFINED;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;                    return new TypeList.Generic.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int getBaseModifiers() {
<b class="pc">&nbsp;                    return methodDescription.isStatic()</b>
&nbsp;                            ? Opcodes.ACC_STATIC
&nbsp;                            : EMPTY_MASK;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getInternalName() {
<b class="fc">&nbsp;                    return name;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A description of a field getter method.
&nbsp;             */
&nbsp;            protected static class FieldGetter extends AbstractPropertyAccessorMethod {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field for which a getter is described.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the getter method.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field getter.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @param fieldDescription The field for which a getter is described.
&nbsp;                 * @param suffix           The name suffix for the field getter method.
&nbsp;                 */
&nbsp;                protected FieldGetter(TypeDescription instrumentedType, FieldDescription fieldDescription, String suffix) {
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                    name = fieldDescription.getName() + &quot;$&quot; + ACCESSOR_METHOD_SUFFIX + &quot;$&quot; + suffix;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription.Generic getReturnType() {
&nbsp;                    return fieldDescription.getType().asRawType();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                    return new ParameterList.Empty&lt;ParameterDescription.InDefinedShape&gt;();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getExceptionTypes() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                    return AnnotationValue.UNDEFINED;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected int getBaseModifiers() {
&nbsp;                    return fieldDescription.isStatic()
&nbsp;                            ? Opcodes.ACC_STATIC
&nbsp;                            : EMPTY_MASK;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getInternalName() {
&nbsp;                    return name;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A description of a field setter method.
&nbsp;             */
&nbsp;            protected static class FieldSetter extends AbstractPropertyAccessorMethod {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field for which a setter is described.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field setter.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field setter.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @param fieldDescription The field for which a setter is described.
&nbsp;                 * @param suffix           The name suffix for the field setter method.
&nbsp;                 */
&nbsp;                protected FieldSetter(TypeDescription instrumentedType, FieldDescription fieldDescription, String suffix) {
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                    name = fieldDescription.getName() + &quot;$&quot; + ACCESSOR_METHOD_SUFFIX + &quot;$&quot; + suffix;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription.Generic getReturnType() {
&nbsp;                    return TypeDescription.Generic.VOID;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                    return new ParameterList.Explicit.ForTypes(this, Collections.singletonList(fieldDescription.getType().asRawType()));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getExceptionTypes() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                    return AnnotationValue.UNDEFINED;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected int getBaseModifiers() {
&nbsp;                    return fieldDescription.isStatic()
&nbsp;                            ? Opcodes.ACC_STATIC
&nbsp;                            : EMPTY_MASK;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getInternalName() {
&nbsp;                    return name;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract method pool entry that delegates the implementation of a method to itself.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected abstract static class DelegationRecord extends TypeWriter.MethodPool.Record.ForDefinedMethod implements ByteCodeAppender {
&nbsp;
&nbsp;                /**
&nbsp;                 * The delegation method.
&nbsp;                 */
&nbsp;                protected final MethodDescription.InDefinedShape methodDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The record&#39;s visibility.
&nbsp;                 */
&nbsp;                protected final Visibility visibility;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new delegation record.
&nbsp;                 *
&nbsp;                 * @param methodDescription The delegation method.
&nbsp;                 * @param visibility        The method&#39;s actual visibility.
&nbsp;                 */
<b class="fc">&nbsp;                protected DelegationRecord(MethodDescription.InDefinedShape methodDescription, Visibility visibility) {</b>
<b class="fc">&nbsp;                    this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                    this.visibility = visibility;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns this delegation record with the minimal visibility represented by the supplied access type.
&nbsp;                 *
&nbsp;                 * @param accessType The access type to enforce.
&nbsp;                 * @return A new version of this delegation record with the minimal implied visibility.
&nbsp;                 */
&nbsp;                protected abstract DelegationRecord with(AccessType accessType);
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDescription.InDefinedShape getMethod() {
<b class="fc">&nbsp;                    return methodDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Sort getSort() {
<b class="fc">&nbsp;                    return Sort.IMPLEMENTED;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Visibility getVisibility() {
<b class="fc">&nbsp;                    return visibility;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void applyHead(MethodVisitor methodVisitor) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public void applyBody(MethodVisitor methodVisitor, Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="fc">&nbsp;                    methodVisitor.visitCode();</b>
<b class="fc">&nbsp;                    Size size = applyCode(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                    methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public Size applyCode(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                    return apply(methodVisitor, implementationContext, getMethod());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeWriter.MethodPool.Record prepend(ByteCodeAppender byteCodeAppender) {
<b class="nc">&nbsp;                    throw new UnsupportedOperationException(&quot;Cannot prepend code to a delegation for &quot; + methodDescription);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation of a {@link TypeWriter.MethodPool.Record} for implementing
&nbsp;             * an accessor method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class AccessorMethodDelegation extends DelegationRecord {
&nbsp;
&nbsp;                /**
&nbsp;                 * The stack manipulation that represents the requested special method invocation.
&nbsp;                 */
&nbsp;                private final StackManipulation accessorMethodInvocation;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a delegation to an accessor method.
&nbsp;                 *
&nbsp;                 * @param instrumentedType        The instrumented type.
&nbsp;                 * @param suffix                  The suffix to append to the method.
&nbsp;                 * @param accessType              The access type.
&nbsp;                 * @param specialMethodInvocation The actual method&#39;s invocation.
&nbsp;                 */
&nbsp;                protected AccessorMethodDelegation(TypeDescription instrumentedType,
&nbsp;                                                   String suffix,
&nbsp;                                                   AccessType accessType,
&nbsp;                                                   SpecialMethodInvocation specialMethodInvocation) {
<b class="fc">&nbsp;                    this(new AccessorMethod(instrumentedType, specialMethodInvocation.getMethodDescription(), suffix),</b>
<b class="fc">&nbsp;                            accessType.getVisibility(),</b>
&nbsp;                            specialMethodInvocation);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a delegation to an accessor method.
&nbsp;                 *
&nbsp;                 * @param methodDescription        The accessor method.
&nbsp;                 * @param visibility               The method&#39;s visibility.
&nbsp;                 * @param accessorMethodInvocation The actual method&#39;s invocation.
&nbsp;                 */
&nbsp;                private AccessorMethodDelegation(MethodDescription.InDefinedShape methodDescription,
&nbsp;                                                 Visibility visibility,
&nbsp;                                                 StackManipulation accessorMethodInvocation) {
<b class="fc">&nbsp;                    super(methodDescription, visibility);</b>
<b class="fc">&nbsp;                    this.accessorMethodInvocation = accessorMethodInvocation;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected DelegationRecord with(AccessType accessType) {
<b class="nc">&nbsp;                    return new AccessorMethodDelegation(methodDescription, visibility.expandTo(accessType.getVisibility()), accessorMethodInvocation);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(),</b>
&nbsp;                            accessorMethodInvocation,
<b class="fc">&nbsp;                            MethodReturn.of(instrumentedMethod.getReturnType())</b>
<b class="fc">&nbsp;                    ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                    return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation for a field getter.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class FieldGetterDelegation extends DelegationRecord {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field to read from.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field getter implementation.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @param suffix           The suffix to use for the setter method.
&nbsp;                 * @param accessType       The method&#39;s access type.
&nbsp;                 * @param fieldDescription The field to write to.
&nbsp;                 */
&nbsp;                protected FieldGetterDelegation(TypeDescription instrumentedType, String suffix, AccessType accessType, FieldDescription fieldDescription) {
<b class="nc">&nbsp;                    this(new FieldGetter(instrumentedType, fieldDescription, suffix), accessType.getVisibility(), fieldDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field getter implementation.
&nbsp;                 *
&nbsp;                 * @param methodDescription The delegation method.
&nbsp;                 * @param visibility        The delegation method&#39;s visibility.
&nbsp;                 * @param fieldDescription  The field to read.
&nbsp;                 */
&nbsp;                private FieldGetterDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, FieldDescription fieldDescription) {
<b class="nc">&nbsp;                    super(methodDescription, visibility);</b>
<b class="nc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected DelegationRecord with(AccessType accessType) {
<b class="nc">&nbsp;                    return new FieldGetterDelegation(methodDescription, visibility.expandTo(accessType.getVisibility()), fieldDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                    StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                            fieldDescription.isStatic()</b>
&nbsp;                                    ? StackManipulation.Trivial.INSTANCE
<b class="nc">&nbsp;                                    : MethodVariableAccess.loadThis(),</b>
<b class="nc">&nbsp;                            FieldAccess.forField(fieldDescription).read(),</b>
<b class="nc">&nbsp;                            MethodReturn.of(fieldDescription.getType())</b>
<b class="nc">&nbsp;                    ).apply(methodVisitor, implementationContext);</b>
<b class="nc">&nbsp;                    return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation for a field setter.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class FieldSetterDelegation extends DelegationRecord {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field to write to.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field setter implementation.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @param suffix           The suffix to use for the setter method.
&nbsp;                 * @param accessType       The method&#39;s access type.
&nbsp;                 * @param fieldDescription The field to write to.
&nbsp;                 */
&nbsp;                protected FieldSetterDelegation(TypeDescription instrumentedType, String suffix, AccessType accessType, FieldDescription fieldDescription) {
<b class="nc">&nbsp;                    this(new FieldSetter(instrumentedType, fieldDescription, suffix), accessType.getVisibility(), fieldDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field setter.
&nbsp;                 *
&nbsp;                 * @param methodDescription The field accessor method.
&nbsp;                 * @param visibility        The delegation method&#39;s visibility.
&nbsp;                 * @param fieldDescription  The field to write to.
&nbsp;                 */
&nbsp;                private FieldSetterDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, FieldDescription fieldDescription) {
<b class="nc">&nbsp;                    super(methodDescription, visibility);</b>
<b class="nc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected DelegationRecord with(AccessType accessType) {
<b class="nc">&nbsp;                    return new FieldSetterDelegation(methodDescription, visibility.expandTo(accessType.getVisibility()), fieldDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                    StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                            MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(),</b>
<b class="nc">&nbsp;                            FieldAccess.forField(fieldDescription).write(),</b>
&nbsp;                            MethodReturn.VOID
<b class="nc">&nbsp;                    ).apply(methodVisitor, implementationContext);</b>
<b class="nc">&nbsp;                    return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a {@link net.bytebuddy.implementation.Implementation.Context.Default}.
&nbsp;             */
<b class="fc">&nbsp;            public enum Factory implements ExtractableView.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public ExtractableView make(TypeDescription instrumentedType,
&nbsp;                                            AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                            TypeInitializer typeInitializer,
&nbsp;                                            ClassFileVersion classFileVersion,
&nbsp;                                            ClassFileVersion auxiliaryClassFileVersion) {
<b class="fc">&nbsp;                    return new Default(instrumentedType, classFileVersion, auxiliaryTypeNamingStrategy, typeInitializer, auxiliaryClassFileVersion);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A compound implementation that allows to combine several implementations.
&nbsp;     * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp;     * Note that the combination of two implementation might break the contract for implementing
&nbsp;     * {@link java.lang.Object#equals(Object)} and {@link Object#hashCode()} as described for
&nbsp;     * {@link Implementation}.
&nbsp;     *
&nbsp;     * @see Implementation
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Compound implements Implementation {
&nbsp;
&nbsp;        /**
&nbsp;         * All implementation that are represented by this compound implementation.
&nbsp;         */
&nbsp;        private final List&lt;Implementation&gt; implementations;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new immutable compound implementation.
&nbsp;         *
&nbsp;         * @param implementation The implementations to combine in their order.
&nbsp;         */
&nbsp;        public Compound(Implementation... implementation) {
&nbsp;            this(Arrays.asList(implementation));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new immutable compound implementation.
&nbsp;         *
&nbsp;         * @param implementations The implementations to combine in their order.
&nbsp;         */
&nbsp;        public Compound(List&lt;? extends Implementation&gt; implementations) {
&nbsp;            this.implementations = new ArrayList&lt;Implementation&gt;();
&nbsp;            for (Implementation implementation : implementations) {
&nbsp;                if (implementation instanceof Compound.Composable) {
&nbsp;                    this.implementations.addAll(((Compound.Composable) implementation).implementations);
&nbsp;                    this.implementations.add(((Compound.Composable) implementation).composable);
&nbsp;                } else if (implementation instanceof Compound) {
&nbsp;                    this.implementations.addAll(((Compound) implementation).implementations);
&nbsp;                } else {
&nbsp;                    this.implementations.add(implementation);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;            for (Implementation implementation : implementations) {
&nbsp;                instrumentedType = implementation.prepare(instrumentedType);
&nbsp;            }
&nbsp;            return instrumentedType;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
&nbsp;            ByteCodeAppender[] byteCodeAppender = new ByteCodeAppender[implementations.size()];
&nbsp;            int index = 0;
&nbsp;            for (Implementation implementation : implementations) {
&nbsp;                byteCodeAppender[index++] = implementation.appender(implementationTarget);
&nbsp;            }
&nbsp;            return new ByteCodeAppender.Compound(byteCodeAppender);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A compound implementation that allows to combine several implementations and that is {@link Implementation.Composable}.
&nbsp;         * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp;         * Note that the combination of two implementation might break the contract for implementing
&nbsp;         * {@link java.lang.Object#equals(Object)} and {@link Object#hashCode()} as described for
&nbsp;         * {@link Implementation}.
&nbsp;         *
&nbsp;         * @see Implementation
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        public static class Composable implements Implementation.Composable {
&nbsp;
&nbsp;            /**
&nbsp;             * The composable implementation that is applied last.
&nbsp;             */
&nbsp;            private final Implementation.Composable composable;
&nbsp;
&nbsp;            /**
&nbsp;             * All implementation that are represented by this compound implementation.
&nbsp;             */
&nbsp;            private final List&lt;Implementation&gt; implementations;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound composable.
&nbsp;             *
&nbsp;             * @param implementation An implementation that is represented by this compound implementation prior to the composable.
&nbsp;             * @param composable     The composable implementation that is applied last.
&nbsp;             */
&nbsp;            public Composable(Implementation implementation, Implementation.Composable composable) {
&nbsp;                this(Collections.singletonList(implementation), composable);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound composable.
&nbsp;             *
&nbsp;             * @param implementations All implementation that are represented by this compound implementation excluding the composable.
&nbsp;             * @param composable      The composable implementation that is applied last.
&nbsp;             */
&nbsp;            public Composable(List&lt;? extends Implementation&gt; implementations, Implementation.Composable composable) {
&nbsp;                this.implementations = new ArrayList&lt;Implementation&gt;();
&nbsp;                for (Implementation implementation : implementations) {
&nbsp;                    if (implementation instanceof Compound.Composable) {
&nbsp;                        this.implementations.addAll(((Compound.Composable) implementation).implementations);
&nbsp;                        this.implementations.add(((Compound.Composable) implementation).composable);
&nbsp;                    } else if (implementation instanceof Compound) {
&nbsp;                        this.implementations.addAll(((Compound) implementation).implementations);
&nbsp;                    } else {
&nbsp;                        this.implementations.add(implementation);
&nbsp;                    }
&nbsp;                }
&nbsp;                if (composable instanceof Compound.Composable) {
&nbsp;                    this.implementations.addAll(((Compound.Composable) composable).implementations);
&nbsp;                    this.composable = ((Compound.Composable) composable).composable;
&nbsp;                } else {
&nbsp;                    this.composable = composable;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                for (Implementation implementation : implementations) {
&nbsp;                    instrumentedType = implementation.prepare(instrumentedType);
&nbsp;                }
&nbsp;                return composable.prepare(instrumentedType);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public ByteCodeAppender appender(Target implementationTarget) {
&nbsp;                ByteCodeAppender[] byteCodeAppender = new ByteCodeAppender[implementations.size() + 1];
&nbsp;                int index = 0;
&nbsp;                for (Implementation implementation : implementations) {
&nbsp;                    byteCodeAppender[index++] = implementation.appender(implementationTarget);
&nbsp;                }
&nbsp;                byteCodeAppender[index] = composable.appender(implementationTarget);
&nbsp;                return new ByteCodeAppender.Compound(byteCodeAppender);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Implementation andThen(Implementation implementation) {
&nbsp;                return new Compound(CompoundList.of(implementations, composable.andThen(implementation)));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Implementation.Composable andThen(Implementation.Composable implementation) {
&nbsp;                return new Compound.Composable(implementations, composable.andThen(implementation));
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A simple implementation that does not register any members with the instrumented type.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Simple implements Implementation {
&nbsp;
&nbsp;        /**
&nbsp;         * The byte code appender to emmit.
&nbsp;         */
&nbsp;        private final ByteCodeAppender byteCodeAppender;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new simple implementation for the given byte code appenders.
&nbsp;         *
&nbsp;         * @param byteCodeAppender The byte code appenders to apply in their order of application.
&nbsp;         */
&nbsp;        public Simple(ByteCodeAppender... byteCodeAppender) {
&nbsp;            this.byteCodeAppender = new ByteCodeAppender.Compound(byteCodeAppender);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new simple instrumentation for the given stack manipulations which are summarized in a
&nbsp;         * byte code appender that defines any requested method by these manipulations.
&nbsp;         *
&nbsp;         * @param stackManipulation The stack manipulation to apply in their order of application.
&nbsp;         */
&nbsp;        public Simple(StackManipulation... stackManipulation) {
&nbsp;            byteCodeAppender = new ByteCodeAppender.Simple(stackManipulation);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;            return instrumentedType;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
&nbsp;            return byteCodeAppender;
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
