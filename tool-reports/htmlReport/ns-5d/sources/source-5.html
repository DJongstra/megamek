


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MethodCall</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: MethodCall (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodCall</td>
<td class="coverageStat">
  <span class="percent">
    21,6%
  </span>
  <span class="absValue">
    (8/37)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14,7%
  </span>
  <span class="absValue">
    (5/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25,3%
  </span>
  <span class="absValue">
    (23/91)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MethodCall$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91,3%
  </span>
  <span class="absValue">
    (21/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$Factory</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodParameter$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83,3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForContextualInvocation</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28,6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForVirtualInvocation$WithImplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodLocator</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodLocator$ForExplicitMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForSelfOrStaticInvocation</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22,2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71,4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$WithoutSpecifiedTarget</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (2/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (4/12)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    44,3%
  </span>
  <span class="absValue">
    (31/70)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (19/76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    47,4%
  </span>
  <span class="absValue">
    (90/190)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.scaffold.FieldLocator;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.implementation.bytecode.*;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayFactory;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.*;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.JavaConstant;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import net.bytebuddy.jar.asm.MethodVisitor;
&nbsp;import net.bytebuddy.jar.asm.Opcodes;
&nbsp;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.Callable;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.named;
&nbsp;
&nbsp;/**
&nbsp; * This {@link Implementation} allows the invocation of a specified method while
&nbsp; * providing explicit arguments to this method.
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
&nbsp;public class MethodCall implements Implementation.Composable {
&nbsp;
&nbsp;    /**
&nbsp;     * The method locator to use.
&nbsp;     */
&nbsp;    protected final MethodLocator methodLocator;
&nbsp;
&nbsp;    /**
&nbsp;     * The target handler to use.
&nbsp;     */
&nbsp;    protected final TargetHandler targetHandler;
&nbsp;
&nbsp;    /**
&nbsp;     * The argument loader to load arguments onto the operand stack in their application order.
&nbsp;     */
&nbsp;    protected final List&lt;ArgumentLoader.Factory&gt; argumentLoaders;
&nbsp;
&nbsp;    /**
&nbsp;     * The method invoker to use.
&nbsp;     */
&nbsp;    protected final MethodInvoker methodInvoker;
&nbsp;
&nbsp;    /**
&nbsp;     * The termination handler to use.
&nbsp;     */
&nbsp;    protected final TerminationHandler terminationHandler;
&nbsp;
&nbsp;    /**
&nbsp;     * The assigner to use.
&nbsp;     */
&nbsp;    protected final Assigner assigner;
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     */
&nbsp;    protected final Assigner.Typing typing;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new method call implementation.
&nbsp;     *
&nbsp;     * @param methodLocator      The method locator to use.
&nbsp;     * @param targetHandler      The target handler to use.
&nbsp;     * @param argumentLoaders    The argument loader to load arguments onto the operand stack in
&nbsp;     *                           their application order.
&nbsp;     * @param methodInvoker      The method invoker to use.
&nbsp;     * @param terminationHandler The termination handler to use.
&nbsp;     * @param assigner           The assigner to use.
&nbsp;     * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     */
&nbsp;    protected MethodCall(MethodLocator methodLocator,
&nbsp;                         TargetHandler targetHandler,
&nbsp;                         List&lt;ArgumentLoader.Factory&gt; argumentLoaders,
&nbsp;                         MethodInvoker methodInvoker,
&nbsp;                         TerminationHandler terminationHandler,
&nbsp;                         Assigner assigner,
<b class="fc">&nbsp;                         Assigner.Typing typing) {</b>
<b class="fc">&nbsp;        this.methodLocator = methodLocator;</b>
<b class="fc">&nbsp;        this.targetHandler = targetHandler;</b>
<b class="fc">&nbsp;        this.argumentLoaders = argumentLoaders;</b>
<b class="fc">&nbsp;        this.methodInvoker = methodInvoker;</b>
<b class="fc">&nbsp;        this.terminationHandler = terminationHandler;</b>
<b class="fc">&nbsp;        this.assigner = assigner;</b>
<b class="fc">&nbsp;        this.typing = typing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the given method. Without further specification, the method is invoked without any arguments on
&nbsp;     * the instance of the instrumented class or statically, if the given method is {@code static}.
&nbsp;     *
&nbsp;     * @param method The method to invoke.
&nbsp;     * @return A method call implementation that invokes the given method without providing any arguments.
&nbsp;     */
&nbsp;    public static WithoutSpecifiedTarget invoke(Method method) {
<b class="fc">&nbsp;        return invoke(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the given constructor on the instance of the instrumented type.
&nbsp;     *
&nbsp;     * @param constructor The constructor to invoke.
&nbsp;     * @return A method call implementation that invokes the given constructor without providing any arguments.
&nbsp;     */
&nbsp;    public static WithoutSpecifiedTarget invoke(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;        return invoke(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the given method. If the method description describes a constructor, it is automatically invoked as
&nbsp;     * a special method invocation on the instance of the instrumented type. The same is true for {@code private}
&nbsp;     * methods. Finally, {@code static} methods are invoked statically.
&nbsp;     *
&nbsp;     * @param methodDescription The method to invoke.
&nbsp;     * @return A method call implementation that invokes the given method without providing any arguments.
&nbsp;     */
&nbsp;    public static WithoutSpecifiedTarget invoke(MethodDescription methodDescription) {
<b class="fc">&nbsp;        return invoke(new MethodLocator.ForExplicitMethod(methodDescription));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes a unique virtual method of the instrumented type that is matched by the specified matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to identify the method to invoke.
&nbsp;     * @return A method call for the uniquely identified method.
&nbsp;     */
&nbsp;    public static WithoutSpecifiedTarget invoke(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="nc">&nbsp;        return invoke(matcher, MethodGraph.Compiler.DEFAULT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes a unique virtual method of the instrumented type that is matched by the specified matcher.
&nbsp;     *
&nbsp;     * @param matcher             The matcher to identify the method to invoke.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A method call for the uniquely identified method.
&nbsp;     */
&nbsp;    public static WithoutSpecifiedTarget invoke(ElementMatcher&lt;? super MethodDescription&gt; matcher, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return invoke(new MethodLocator.ForElementMatcher(matcher, methodGraphCompiler));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes a method using the provided method locator.
&nbsp;     *
&nbsp;     * @param methodLocator The method locator to apply for locating the method to invoke given the instrumented
&nbsp;     *                      method.
&nbsp;     * @return A method call implementation that uses the provided method locator for resolving the method
&nbsp;     * to be invoked.
&nbsp;     */
&nbsp;    public static WithoutSpecifiedTarget invoke(MethodLocator methodLocator) {
<b class="fc">&nbsp;        return new WithoutSpecifiedTarget(methodLocator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the instrumented method recursively. Invoking this method on the same instance causes a {@link StackOverflowError} due to
&nbsp;     * infinite recursion.
&nbsp;     *
&nbsp;     * @return A method call that invokes the method being instrumented.
&nbsp;     */
&nbsp;    public static WithoutSpecifiedTarget invokeSelf() {
<b class="nc">&nbsp;        return new WithoutSpecifiedTarget(MethodLocator.ForInstrumentedMethod.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the instrumented method as a super method call on the instance itself. This is a shortcut for {@code invokeSelf().onSuper()}.
&nbsp;     *
&nbsp;     * @return A method call that invokes the method being instrumented as a super method call.
&nbsp;     */
&nbsp;    public static MethodCall invokeSuper() {
<b class="nc">&nbsp;        return invokeSelf().onSuper();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements a method by invoking the provided {@link Callable}. The return value of the provided object is casted to the implemented method&#39;s
&nbsp;     * return type, if necessary.
&nbsp;     *
&nbsp;     * @param callable The callable to invoke when a method is intercepted.
&nbsp;     * @return A composable method implementation that invokes the given callable.
&nbsp;     */
&nbsp;    public static Composable call(Callable&lt;?&gt; callable) {
&nbsp;        try {
<b class="nc">&nbsp;            return invoke(Callable.class.getMethod(&quot;call&quot;)).on(callable, Callable.class).withAssigner(Assigner.DEFAULT, Assigner.Typing.DYNAMIC);</b>
<b class="nc">&nbsp;        } catch (NoSuchMethodException exception) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Could not locate Callable::call method&quot;, exception);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements a method by invoking the provided {@link Runnable}. If the instrumented method returns a value, {@code null} is returned.
&nbsp;     *
&nbsp;     * @param runnable The runnable to invoke when a method is intercepted.
&nbsp;     * @return A composable method implementation that invokes the given runnable.
&nbsp;     */
&nbsp;    public static Composable run(Runnable runnable) {
&nbsp;        try {
<b class="nc">&nbsp;            return invoke(Runnable.class.getMethod(&quot;run&quot;)).on(runnable, Runnable.class).withAssigner(Assigner.DEFAULT, Assigner.Typing.DYNAMIC);</b>
<b class="nc">&nbsp;        } catch (NoSuchMethodException exception) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Could not locate Runnable::run method&quot;, exception);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the given constructor in order to create an instance.
&nbsp;     *
&nbsp;     * @param constructor The constructor to invoke.
&nbsp;     * @return A method call that invokes the given constructor without providing any arguments.
&nbsp;     */
&nbsp;    public static MethodCall construct(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;        return construct(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the given constructor in order to create an instance.
&nbsp;     *
&nbsp;     * @param methodDescription A description of the constructor to invoke.
&nbsp;     * @return A method call that invokes the given constructor without providing any arguments.
&nbsp;     */
&nbsp;    public static MethodCall construct(MethodDescription methodDescription) {
<b class="nc">&nbsp;        if (!methodDescription.isConstructor()) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Not a constructor: &quot; + methodDescription);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new MethodCall(new MethodLocator.ForExplicitMethod(methodDescription),</b>
&nbsp;                TargetHandler.ForConstructingInvocation.INSTANCE,
<b class="nc">&nbsp;                Collections.&lt;ArgumentLoader.Factory&gt;emptyList(),</b>
&nbsp;                MethodInvoker.ForContextualInvocation.INSTANCE,
&nbsp;                TerminationHandler.RETURNING,
&nbsp;                Assigner.DEFAULT,
&nbsp;                Assigner.Typing.STATIC);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a number of arguments to be handed to the method that is being invoked by this implementation. Any
&nbsp;     * wrapper type instances for primitive values, instances of {@link java.lang.String} or {@code null} are loaded
&nbsp;     * directly onto the operand stack. This might corrupt referential identity for these values. Any other values
&nbsp;     * are stored within a {@code static} field that is added to the instrumented type.
&nbsp;     *
&nbsp;     * @param argument The arguments to provide to the method that is being called in their order.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(Object... argument) {
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(argument.length);</b>
<b class="nc">&nbsp;        for (Object anArgument : argument) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(ArgumentLoader.ForStackManipulation.of(anArgument));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the given types to be provided as arguments to the invoked method where the represented types
&nbsp;     * are stored in the generated class&#39;s constant pool.
&nbsp;     *
&nbsp;     * @param typeDescription The type descriptions to provide as arguments.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(TypeDescription... typeDescription) {
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(typeDescription.length);</b>
<b class="nc">&nbsp;        for (TypeDescription aTypeDescription : typeDescription) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(ClassConstant.of(aTypeDescription), Class.class));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the given enumeration values to be provided as arguments to the invoked method where the values
&nbsp;     * are read from the enumeration class on demand.
&nbsp;     *
&nbsp;     * @param enumerationDescription The enumeration descriptions to provide as arguments.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(EnumerationDescription... enumerationDescription) {
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(enumerationDescription.length);</b>
<b class="nc">&nbsp;        for (EnumerationDescription anEnumerationDescription : enumerationDescription) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(FieldAccess.forEnumeration(anEnumerationDescription), anEnumerationDescription.getEnumerationType()));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the given Java instances to be provided as arguments to the invoked method where the given
&nbsp;     * instances are stored in the generated class&#39;s constant pool.
&nbsp;     *
&nbsp;     * @param javaConstant The Java instances to provide as arguments.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(JavaConstant... javaConstant) {
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(javaConstant.length);</b>
<b class="nc">&nbsp;        for (JavaConstant aJavaConstant : javaConstant) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(aJavaConstant.asStackManipulation(), aJavaConstant.getType()));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a number of arguments to be handed to the method that is being invoked by this implementation. Any
&nbsp;     * value is stored within a field in order to preserve referential identity. As an exception, the {@code null}
&nbsp;     * value is not stored within a field.
&nbsp;     *
&nbsp;     * @param argument The arguments to provide to the method that is being called in their order.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall withReference(Object... argument) {
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(argument.length);</b>
<b class="nc">&nbsp;        for (Object anArgument : argument) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(anArgument == null</b>
&nbsp;                    ? ArgumentLoader.ForNullConstant.INSTANCE
&nbsp;                    : new ArgumentLoader.ForInstance.Factory(anArgument));
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a number of arguments of the instrumented method by their parameter indices to be handed
&nbsp;     * to the invoked method as an argument.
&nbsp;     *
&nbsp;     * @param index The parameter indices of the instrumented method to be handed to the invoked method as an
&nbsp;     *              argument in their order. The indices are zero-based.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall withArgument(int... index) {
<b class="fc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(index.length);</b>
<b class="fc">&nbsp;        for (int anIndex : index) {</b>
<b class="pc">&nbsp;            if (anIndex &lt; 0) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Negative index: &quot; + anIndex);</b>
&nbsp;            }
<b class="fc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForMethodParameter.Factory(anIndex));</b>
&nbsp;        }
<b class="fc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds all arguments of the instrumented method as arguments to the invoked method to this method call.
&nbsp;     *
&nbsp;     * @return A method call that hands all arguments of the instrumented method to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall withAllArguments() {
<b class="nc">&nbsp;        return with(ArgumentLoader.ForMethodParameter.OfInstrumentedMethod.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds an array containing all arguments of the instrumented method to this method call.
&nbsp;     *
&nbsp;     * @return A method call that adds an array containing all arguments of the instrumented method to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall withArgumentArray() {
<b class="nc">&nbsp;        return with(ArgumentLoader.ForMethodParameterArray.ForInstrumentedMethod.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a method call where the parameter with {@code index} is expected to be an array and where each element of the array
&nbsp;     * is expected to represent an argument for the method being invoked.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This is typically used in combination with dynamic type assignments which is activated via
&nbsp;     * {@link MethodCall#withAssigner(Assigner, Assigner.Typing)} using a {@link Assigner.Typing#DYNAMIC}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param index The index of the parameter.
&nbsp;     * @return A method call that loads {@code size} elements from the array handed to the instrumented method as argument {@code index}.
&nbsp;     */
&nbsp;    public MethodCall withArgumentArrayElements(int index) {
<b class="nc">&nbsp;        if (index &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;A parameter index cannot be negative: &quot; + index);</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(new ArgumentLoader.ForMethodParameterArrayElement.OfInvokedMethod(index));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a method call where the parameter with {@code index} is expected to be an array and where {@code size} elements are loaded
&nbsp;     * from the array as arguments for the invoked method.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This is typically used in combination with dynamic type assignments which is activated via
&nbsp;     * {@link MethodCall#withAssigner(Assigner, Assigner.Typing)} using a {@link Assigner.Typing#DYNAMIC}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param index The index of the parameter.
&nbsp;     * @param size  The amount of elements to load from the array.
&nbsp;     * @return A method call that loads {@code size} elements from the array handed to the instrumented method as argument {@code index}.
&nbsp;     */
&nbsp;    public MethodCall withArgumentArrayElements(int index, int size) {
<b class="nc">&nbsp;        return withArgumentArrayElements(index, 0, size);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a method call where the parameter with {@code index} is expected to be an array and where {@code size} elements are loaded
&nbsp;     * from the array as arguments for the invoked method. The first element is loaded from index {@code start}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This is typically used in combination with dynamic type assignments which is activated via
&nbsp;     * {@link MethodCall#withAssigner(Assigner, Assigner.Typing)} using a {@link Assigner.Typing#DYNAMIC}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param index The index of the parameter.
&nbsp;     * @param start The first array index to consider.
&nbsp;     * @param size  The amount of elements to load from the array with increasing index from {@code start}.
&nbsp;     * @return A method call that loads {@code size} elements from the array handed to the instrumented method as argument {@code index}.
&nbsp;     */
&nbsp;    public MethodCall withArgumentArrayElements(int index, int start, int size) {
<b class="nc">&nbsp;        if (index &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;A parameter index cannot be negative: &quot; + index);</b>
<b class="nc">&nbsp;        } else if (start &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;An array index cannot be negative: &quot; + start);</b>
<b class="nc">&nbsp;        } else if (size == 0) {</b>
<b class="nc">&nbsp;            return this;</b>
<b class="nc">&nbsp;        } else if (size &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Size cannot be negative: &quot; + size);</b>
&nbsp;        }
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(size);</b>
<b class="nc">&nbsp;        for (int position = 0; position &lt; size; position++) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForMethodParameterArrayElement.OfParameter(index, start + position));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Assigns the {@code this} reference to the next parameter.
&nbsp;     *
&nbsp;     * @return This method call where the next parameter is a assigned a reference to the {@code this} reference
&nbsp;     * of the instance of the intercepted method.
&nbsp;     */
&nbsp;    public MethodCall withThis() {
<b class="nc">&nbsp;        return with(ArgumentLoader.ForThisReference.Factory.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Assigns the {@link java.lang.Class} value of the instrumented type.
&nbsp;     *
&nbsp;     * @return This method call where the next parameter is a assigned a reference to the {@link java.lang.Class}
&nbsp;     * value of the instrumented type.
&nbsp;     */
&nbsp;    public MethodCall withOwnType() {
<b class="nc">&nbsp;        return with(ArgumentLoader.ForInstrumentedType.Factory.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a method call which fetches a value from a list of existing fields.
&nbsp;     *
&nbsp;     * @param name The names of the fields.
&nbsp;     * @return A method call which assigns the next parameters to the values of the given fields.
&nbsp;     */
&nbsp;    public MethodCall withField(String... name) {
<b class="nc">&nbsp;        return withField(FieldLocator.ForClassHierarchy.Factory.INSTANCE, name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a method call which fetches a value from a list of existing fields.
&nbsp;     *
&nbsp;     * @param fieldLocatorFactory The field locator factory to use.
&nbsp;     * @param name                The names of the fields.
&nbsp;     * @return A method call which assigns the next parameters to the values of the given fields.
&nbsp;     */
&nbsp;    public MethodCall withField(FieldLocator.Factory fieldLocatorFactory, String... name) {
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(name.length);</b>
<b class="nc">&nbsp;        for (String aName : name) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForField.Factory(aName, fieldLocatorFactory));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a stack manipulation as an assignment to the next parameter.
&nbsp;     *
&nbsp;     * @param stackManipulation The stack manipulation loading the value.
&nbsp;     * @param type              The type of the argument being loaded.
&nbsp;     * @return A method call that adds the stack manipulation as the next argument to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(StackManipulation stackManipulation, Type type) {
<b class="nc">&nbsp;        return with(stackManipulation, TypeDefinition.Sort.describe(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a stack manipulation as an assignment to the next parameter.
&nbsp;     *
&nbsp;     * @param stackManipulation The stack manipulation loading the value.
&nbsp;     * @param typeDefinition    The type of the argument being loaded.
&nbsp;     * @return A method call that adds the stack manipulation as the next argument to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(StackManipulation stackManipulation, TypeDefinition typeDefinition) {
<b class="nc">&nbsp;        return with(new ArgumentLoader.ForStackManipulation(stackManipulation, typeDefinition));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a method call that resolves arguments by the supplied argument loader factories.
&nbsp;     *
&nbsp;     * @param argumentLoader The argument loaders to apply to the subsequent arguments of the
&nbsp;     * @return A method call that adds the arguments of the supplied argument loaders to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(ArgumentLoader.Factory... argumentLoader) {
<b class="nc">&nbsp;        return with(Arrays.asList(argumentLoader));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a method call that resolves arguments by the supplied argument loader factories.
&nbsp;     *
&nbsp;     * @param argumentLoaders The argument loaders to apply to the subsequent arguments of the
&nbsp;     * @return A method call that adds the arguments of the supplied argument loaders to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(List&lt;? extends ArgumentLoader.Factory&gt; argumentLoaders) {
<b class="fc">&nbsp;        return new MethodCall(methodLocator,</b>
&nbsp;                targetHandler,
<b class="fc">&nbsp;                CompoundList.of(this.argumentLoaders, argumentLoaders),</b>
&nbsp;                methodInvoker,
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines an assigner to be used for assigning values to the parameters of the invoked method. This assigner
&nbsp;     * is also used for assigning the invoked method&#39;s return value to the return type of the instrumented method,
&nbsp;     * if this method is not chained with
&nbsp;     * {@link net.bytebuddy.implementation.MethodCall#andThen(Implementation)} such
&nbsp;     * that a return value of this method call is discarded.
&nbsp;     *
&nbsp;     * @param assigner The assigner to use.
&nbsp;     * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     * @return This method call using the provided assigner.
&nbsp;     */
&nbsp;    public Implementation.Composable withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;        return new MethodCall(methodLocator,</b>
&nbsp;                targetHandler,
&nbsp;                argumentLoaders,
&nbsp;                methodInvoker,
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Implementation andThen(Implementation implementation) {
<b class="nc">&nbsp;        return new Implementation.Compound(new MethodCall(methodLocator,</b>
&nbsp;                targetHandler,
&nbsp;                argumentLoaders,
&nbsp;                methodInvoker,
&nbsp;                TerminationHandler.DROPPING,
&nbsp;                assigner,
&nbsp;                typing), implementation);
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Composable andThen(Composable implementation) {
<b class="nc">&nbsp;        return new Implementation.Compound.Composable(new MethodCall(methodLocator,</b>
&nbsp;                targetHandler,
&nbsp;                argumentLoaders,
&nbsp;                methodInvoker,
&nbsp;                TerminationHandler.DROPPING,
&nbsp;                assigner,
&nbsp;                typing), implementation);
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;        for (ArgumentLoader.Factory argumentLoader : argumentLoaders) {</b>
<b class="fc">&nbsp;            instrumentedType = argumentLoader.prepare(instrumentedType);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return targetHandler.prepare(instrumentedType);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;        return new Appender(implementationTarget);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method locator is responsible for identifying the method that is to be invoked
&nbsp;     * by a {@link net.bytebuddy.implementation.MethodCall}.
&nbsp;     */
&nbsp;    public interface MethodLocator {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the method to be invoked.
&nbsp;         *
&nbsp;         * @param instrumentedType   The instrumented type.
&nbsp;         * @param instrumentedMethod The method being instrumented.
&nbsp;         * @return The method to invoke.
&nbsp;         */
&nbsp;        MethodDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * A method locator that simply returns the intercepted method.
&nbsp;         */
&nbsp;        enum ForInstrumentedMethod implements MethodLocator {
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                return instrumentedMethod;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a given method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForExplicitMethod implements MethodLocator {
&nbsp;
&nbsp;            /**
&nbsp;             * The method to be invoked.
&nbsp;             */
&nbsp;            private final MethodDescription methodDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new method locator for a given method.
&nbsp;             *
&nbsp;             * @param methodDescription The method to be invoked.
&nbsp;             */
<b class="fc">&nbsp;            protected ForExplicitMethod(MethodDescription methodDescription) {</b>
<b class="fc">&nbsp;                this.methodDescription = methodDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return methodDescription;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A method locator that identifies a unique virtual method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForElementMatcher implements MethodLocator {
&nbsp;
&nbsp;            /**
&nbsp;             * The matcher to use.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * The method graph compiler to use.
&nbsp;             */
&nbsp;            private final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new method locator for an element matcher.
&nbsp;             *
&nbsp;             * @param matcher             The matcher to use.
&nbsp;             * @param methodGraphCompiler The method graph compiler to use.
&nbsp;             */
&nbsp;            protected ForElementMatcher(ElementMatcher&lt;? super MethodDescription&gt; matcher, MethodGraph.Compiler methodGraphCompiler) {
&nbsp;                this.matcher = matcher;
&nbsp;                this.methodGraphCompiler = methodGraphCompiler;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                MethodList&lt;?&gt; candidates = methodGraphCompiler.compile(instrumentedType).listNodes().asMethodList().filter(matcher);
&nbsp;                if (candidates.size() == 1) {
&nbsp;                    return candidates.getOnly();
&nbsp;                } else {
&nbsp;                    throw new IllegalStateException(instrumentedType + &quot; does not define exactly one virtual method for &quot; + matcher);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An argument loader is responsible for loading an argument for an invoked method
&nbsp;     * onto the operand stack.
&nbsp;     */
&nbsp;    public interface ArgumentLoader {
&nbsp;
&nbsp;        /**
&nbsp;         * Loads the argument that is represented by this instance onto the operand stack.
&nbsp;         *
&nbsp;         * @param target   The target parameter.
&nbsp;         * @param assigner The assigner to be used.
&nbsp;         * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @return The stack manipulation that loads the represented argument onto the stack.
&nbsp;         */
&nbsp;        StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing);
&nbsp;
&nbsp;        /**
&nbsp;         * A factory that produces {@link ArgumentLoader}s for a given instrumented method.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Prepares the instrumented type in order to allow the loading of the represented argument.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @return The prepared instrumented type.
&nbsp;             */
&nbsp;            InstrumentedType prepare(InstrumentedType instrumentedType);
&nbsp;
&nbsp;            /**
&nbsp;             * Creates any number of argument loaders for an instrumentation.
&nbsp;             *
&nbsp;             * @param instrumentedType   The instrumented type.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param invokedMethod      The invoked method.
&nbsp;             * @return Any number of argument loaders to supply for the method call.
&nbsp;             */
&nbsp;            List&lt;ArgumentLoader&gt; make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription invokedMethod);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An argument loader that loads the {@code null} value onto the operand stack.
&nbsp;         */
&nbsp;        enum ForNullConstant implements ArgumentLoader, Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            @Override
&nbsp;            public List&lt;ArgumentLoader&gt; make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                return Collections.&lt;ArgumentLoader&gt;singletonList(this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                if (target.getType().isPrimitive()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign null to &quot; + target);
&nbsp;                }
&nbsp;                return NullConstant.INSTANCE;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                return instrumentedType;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An argument loader that assigns the {@code this} reference to a parameter.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForThisReference implements ArgumentLoader {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader that supplies the {@code this} instance as an argument.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             */
&nbsp;            public ForThisReference(TypeDescription instrumentedType) {
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(
&nbsp;                        MethodVariableAccess.loadThis(),
&nbsp;                        assigner.assign(instrumentedType.asGenericType(), target.getType(), typing));
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + instrumentedType + &quot; to &quot; + target);
&nbsp;                }
&nbsp;                return stackManipulation;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an argument loader that supplies the {@code this} value as an argument.
&nbsp;             */
&nbsp;            public enum Factory implements ArgumentLoader.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                @Override
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public List&lt;ArgumentLoader&gt; make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    if (instrumentedMethod.isStatic()) {
&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; is static and cannot supply an invoker instance&quot;);
&nbsp;                    }
&nbsp;                    return Collections.&lt;ArgumentLoader&gt;singletonList(new ForThisReference(instrumentedType));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads the instrumented type onto the operand stack.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForInstrumentedType implements ArgumentLoader {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader for supporting the instrumented type as a type constant as an argument.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             */
&nbsp;            public ForInstrumentedType(TypeDescription instrumentedType) {
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(
&nbsp;                        ClassConstant.of(instrumentedType),
&nbsp;                        assigner.assign(TypeDescription.Generic.OfNonGenericType.ForLoadedType.CLASS, target.getType(), typing));
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign Class value to &quot; + target);
&nbsp;                }
&nbsp;                return stackManipulation;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an argument loader that supplies the instrumented type as an argument.
&nbsp;             */
&nbsp;            public enum Factory implements ArgumentLoader.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                @Override
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public List&lt;ArgumentLoader&gt; make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    return Collections.&lt;ArgumentLoader&gt;singletonList(new ForInstrumentedType(instrumentedType));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads a parameter of the instrumented method onto the operand stack.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForMethodParameter implements ArgumentLoader {
&nbsp;
&nbsp;            /**
&nbsp;             * The index of the parameter to be loaded onto the operand stack.
&nbsp;             */
&nbsp;            private final int index;
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented method.
&nbsp;             */
&nbsp;            private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader for a parameter of the instrumented method.
&nbsp;             *
&nbsp;             * @param index              The index of the parameter to be loaded onto the operand stack.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             */
<b class="fc">&nbsp;            public ForMethodParameter(int index, MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                this.index = index;</b>
<b class="fc">&nbsp;                this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                ParameterDescription parameterDescription = instrumentedMethod.getParameters().get(index);</b>
<b class="fc">&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                        MethodVariableAccess.load(parameterDescription),</b>
<b class="fc">&nbsp;                        assigner.assign(parameterDescription.getType(), target.getType(), typing));</b>
<b class="pc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + parameterDescription + &quot; to &quot; + target + &quot; for &quot; + instrumentedMethod);</b>
&nbsp;                }
<b class="fc">&nbsp;                return stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for argument loaders that supplies all arguments of the instrumented method as arguments.
&nbsp;             */
&nbsp;            protected enum OfInstrumentedMethod implements ArgumentLoader.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                @Override
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public List&lt;ArgumentLoader&gt; make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    List&lt;ArgumentLoader&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader&gt;(instrumentedMethod.getParameters().size());
&nbsp;                    for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {
&nbsp;                        argumentLoaders.add(new ForMethodParameter(parameterDescription.getIndex(), instrumentedMethod));
&nbsp;                    }
&nbsp;                    return argumentLoaders;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an argument loader that supplies a method parameter as an argument.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements ArgumentLoader.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The index of the parameter to be loaded onto the operand stack.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for an argument loader that supplies a method parameter as an argument.
&nbsp;                 *
&nbsp;                 * @param index The index of the parameter to supply.
&nbsp;                 */
<b class="fc">&nbsp;                public Factory(int index) {</b>
<b class="fc">&nbsp;                    this.index = index;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public List&lt;ArgumentLoader&gt; make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="pc">&nbsp;                    if (index &gt;= instrumentedMethod.getParameters().size()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; does not have a parameter with index &quot; + index);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return Collections.&lt;ArgumentLoader&gt;singletonList(new ForMethodParameter(index, instrumentedMethod));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads an array containing all arguments of a method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForMethodParameterArray implements ArgumentLoader {
&nbsp;
&nbsp;            /**
&nbsp;             * The parameters to load.
&nbsp;             */
&nbsp;            private final ParameterList&lt;?&gt; parameters;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader that loads the supplied parameters onto the operand stack.
&nbsp;             *
&nbsp;             * @param parameters The parameters to load.
&nbsp;             */
&nbsp;            public ForMethodParameterArray(ParameterList&lt;?&gt; parameters) {
&nbsp;                this.parameters = parameters;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                TypeDescription.Generic componentType;
&nbsp;                if (target.getType().represents(Object.class)) {
&nbsp;                    componentType = TypeDescription.Generic.OBJECT;
&nbsp;                } else if (target.getType().isArray()) {
&nbsp;                    componentType = target.getType().getComponentType();
&nbsp;                } else {
&nbsp;                    throw new IllegalStateException();
&nbsp;                }
&nbsp;                List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(parameters.size());
&nbsp;                for (ParameterDescription parameter : parameters) {
&nbsp;                    StackManipulation stackManipulation = new StackManipulation.Compound(
&nbsp;                            MethodVariableAccess.load(parameter),
&nbsp;                            assigner.assign(parameter.getType(), componentType, typing)
&nbsp;                    );
&nbsp;                    if (stackManipulation.isValid()) {
&nbsp;                        stackManipulations.add(stackManipulation);
&nbsp;                    } else {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + parameter + &quot; to &quot; + componentType);
&nbsp;                    }
&nbsp;                }
&nbsp;                return new StackManipulation.Compound(ArrayFactory.forType(componentType).withValues(stackManipulations));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory that creates an arguments loader that loads all parameters of the instrumented method contained in an array.
&nbsp;             */
&nbsp;            public enum ForInstrumentedMethod implements ArgumentLoader.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                @Override
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public List&lt;ArgumentLoader&gt; make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    return Collections.&lt;ArgumentLoader&gt;singletonList(new ForMethodParameterArray(instrumentedMethod.getParameters()));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An argument loader that loads an element of a parameter of an array type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForMethodParameterArrayElement implements ArgumentLoader {
&nbsp;
&nbsp;            /**
&nbsp;             * The parameter to load the array from.
&nbsp;             */
&nbsp;            private final ParameterDescription parameterDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The array index to load.
&nbsp;             */
&nbsp;            private final int index;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader for a parameter of the instrumented method where an array element is assigned to the invoked method.
&nbsp;             *
&nbsp;             * @param parameterDescription The parameter from which to load an array element.
&nbsp;             * @param index                The array index to load.
&nbsp;             */
&nbsp;            public ForMethodParameterArrayElement(ParameterDescription parameterDescription, int index) {
&nbsp;                this.parameterDescription = parameterDescription;
&nbsp;                this.index = index;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(
&nbsp;                        MethodVariableAccess.load(parameterDescription),
&nbsp;                        IntegerConstant.forValue(index),
&nbsp;                        ArrayAccess.of(parameterDescription.getType().getComponentType()).load(),
&nbsp;                        assigner.assign(parameterDescription.getType().getComponentType(), target.getType(), typing)
&nbsp;                );
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + parameterDescription.getType().getComponentType() + &quot; to &quot; + target);
&nbsp;                }
&nbsp;                return stackManipulation;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader for an array element that of a specific parameter.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfParameter implements ArgumentLoader.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * The array index to load.
&nbsp;                 */
&nbsp;                private final int arrayIndex;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for an argument loader that loads a given parameter&#39;s array value.
&nbsp;                 *
&nbsp;                 * @param index      The index of the parameter.
&nbsp;                 * @param arrayIndex The array index to load.
&nbsp;                 */
&nbsp;                public OfParameter(int index, int arrayIndex) {
&nbsp;                    this.index = index;
&nbsp;                    this.arrayIndex = arrayIndex;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public List&lt;ArgumentLoader&gt; make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    if (instrumentedMethod.getParameters().size() &lt;= index) {
&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; does not declare a parameter with index &quot; + index);
&nbsp;                    } else if (!instrumentedMethod.getParameters().get(index).getType().isArray()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot access an item from non-array parameter &quot; + instrumentedMethod.getParameters().get(index));
&nbsp;                    }
&nbsp;                    return Collections.&lt;ArgumentLoader&gt;singletonList(new ForMethodParameterArrayElement(instrumentedMethod.getParameters().get(index), arrayIndex));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument loader factory that loads an array element from a parameter for each argument of the invoked method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfInvokedMethod implements ArgumentLoader.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an argument loader factory for an invoked method.
&nbsp;                 *
&nbsp;                 * @param index The parameter index.
&nbsp;                 */
&nbsp;                public OfInvokedMethod(int index) {
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public List&lt;ArgumentLoader&gt; make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    if (instrumentedMethod.getParameters().size() &lt;= index) {
&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; does not declare a parameter with index &quot; + index);
&nbsp;                    } else if (!instrumentedMethod.getParameters().get(index).getType().isArray()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot access an item from non-array parameter &quot; + instrumentedMethod.getParameters().get(index));
&nbsp;                    }
&nbsp;                    List&lt;ArgumentLoader&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader&gt;(instrumentedMethod.getParameters().size());
&nbsp;                    for (int index = 0; index &lt; invokedMethod.getParameters().size(); index++) {
&nbsp;                        argumentLoaders.add(new ForMethodParameterArrayElement(instrumentedMethod.getParameters().get(this.index), index++));
&nbsp;                    }
&nbsp;                    return argumentLoaders;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads a value onto the operand stack that is stored in a static field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForInstance implements ArgumentLoader {
&nbsp;
&nbsp;            /**
&nbsp;             * The description of the field.
&nbsp;             */
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader that supplies the value of a static field as an argument.
&nbsp;             *
&nbsp;             * @param fieldDescription The description of the field.
&nbsp;             */
&nbsp;            public ForInstance(FieldDescription fieldDescription) {
&nbsp;                this.fieldDescription = fieldDescription;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(
&nbsp;                        FieldAccess.forField(fieldDescription).read(),
&nbsp;                        assigner.assign(fieldDescription.getType(), target.getType(), typing));
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + fieldDescription.getType() + &quot; to &quot; + target);
&nbsp;                }
&nbsp;                return stackManipulation;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory that supplies the value of a static field as an argument.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements ArgumentLoader.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name prefix of the field to store the argument.
&nbsp;                 */
&nbsp;                private static final String FIELD_PREFIX = &quot;methodCall&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * The value to be stored in the field.
&nbsp;                 */
&nbsp;                private final Object value;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.IGNORE)
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory that loads the value of a static field as an argument.
&nbsp;                 *
&nbsp;                 * @param value The value to supply as an argument.
&nbsp;                 */
&nbsp;                public Factory(Object value) {
&nbsp;                    this.value = value;
&nbsp;                    name = FIELD_PREFIX + &quot;$&quot; + RandomString.make();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType
&nbsp;                            .withField(new FieldDescription.Token(name,
&nbsp;                                    Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
&nbsp;                                    TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(value.getClass())))
&nbsp;                            .withInitializer(new LoadedTypeInitializer.ForStaticField(name, value));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public List&lt;ArgumentLoader&gt; make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    return Collections.&lt;ArgumentLoader&gt;singletonList(new ForInstance(instrumentedType.getDeclaredFields().filter(named(name)).getOnly()));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads the value of an existing field onto the operand stack.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForField implements ArgumentLoader {
&nbsp;
&nbsp;            /**
&nbsp;             * The field containing the loaded value.
&nbsp;             */
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented method.
&nbsp;             */
&nbsp;            private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new argument loader for loading an existing field.
&nbsp;             *
&nbsp;             * @param fieldDescription   The field containing the loaded value.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             */
&nbsp;            public ForField(FieldDescription fieldDescription, MethodDescription instrumentedMethod) {
&nbsp;                this.fieldDescription = fieldDescription;
&nbsp;                this.instrumentedMethod = instrumentedMethod;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                if (!fieldDescription.isStatic() &amp;&amp; instrumentedMethod.isStatic()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot access non-static &quot; + fieldDescription + &quot; from &quot; + instrumentedMethod);
&nbsp;                }
&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(
&nbsp;                        fieldDescription.isStatic()
&nbsp;                                ? StackManipulation.Trivial.INSTANCE
&nbsp;                                : MethodVariableAccess.loadThis(),
&nbsp;                        FieldAccess.forField(fieldDescription).read(),
&nbsp;                        assigner.assign(fieldDescription.getType(), target.getType(), typing)
&nbsp;                );
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + fieldDescription + &quot; to &quot; + target);
&nbsp;                }
&nbsp;                return stackManipulation;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an argument loaded that loads the value of an existing field as an argument.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements ArgumentLoader.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field locator to use.
&nbsp;                 */
&nbsp;                private final FieldLocator.Factory fieldLocatorFactory;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument loader for an existing field.
&nbsp;                 *
&nbsp;                 * @param name                The name of the field.
&nbsp;                 * @param fieldLocatorFactory The field locator to use.
&nbsp;                 */
&nbsp;                public Factory(String name, FieldLocator.Factory fieldLocatorFactory) {
&nbsp;                    this.name = name;
&nbsp;                    this.fieldLocatorFactory = fieldLocatorFactory;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                    return instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public List&lt;ArgumentLoader&gt; make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                    FieldLocator.Resolution resolution = fieldLocatorFactory.make(instrumentedType).locate(name);
&nbsp;                    if (!resolution.isResolved()) {
&nbsp;                        throw new IllegalStateException(&quot;Could not locate field &#39;&quot; + name + &quot;&#39; on &quot; + instrumentedType);
&nbsp;                    }
&nbsp;                    return Collections.&lt;ArgumentLoader&gt;singletonList(new ForField(resolution.getField(), instrumentedMethod));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads a stack manipulation resulting in a specific type as an argument.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForStackManipulation implements ArgumentLoader, Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation to load.
&nbsp;             */
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            /**
&nbsp;             * The type of the resulting value.
&nbsp;             */
&nbsp;            private final TypeDefinition typeDefinition;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader that loads a stack manipulation as an argument.
&nbsp;             *
&nbsp;             * @param stackManipulation The stack manipulation to load.
&nbsp;             * @param type              The type of the resulting value.
&nbsp;             */
&nbsp;            public ForStackManipulation(StackManipulation stackManipulation, Type type) {
&nbsp;                this(stackManipulation, TypeDescription.Generic.Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader that loads a stack manipulation as an argument.
&nbsp;             *
&nbsp;             * @param stackManipulation The stack manipulation to load.
&nbsp;             * @param typeDefinition    The type of the resulting value.
&nbsp;             */
&nbsp;            public ForStackManipulation(StackManipulation stackManipulation, TypeDefinition typeDefinition) {
&nbsp;                this.stackManipulation = stackManipulation;
&nbsp;                this.typeDefinition = typeDefinition;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader that loads the supplied value as a constant. If the value cannot be represented
&nbsp;             * in the constant pool, a field is created to store the value.
&nbsp;             *
&nbsp;             * @param value The value to load as an argument or {@code null}.
&nbsp;             * @return An appropriate argument loader.
&nbsp;             */
&nbsp;            public static ArgumentLoader.Factory of(Object value) {
&nbsp;                if (value == null) {
&nbsp;                    return ForNullConstant.INSTANCE;
&nbsp;                } else if (value instanceof String) {
&nbsp;                    return new ForStackManipulation(new TextConstant((String) value), String.class);
&nbsp;                } else if (value instanceof Boolean) {
&nbsp;                    return new ForStackManipulation(IntegerConstant.forValue((Boolean) value), boolean.class);
&nbsp;                } else if (value instanceof Byte) {
&nbsp;                    return new ForStackManipulation(IntegerConstant.forValue((Byte) value), byte.class);
&nbsp;                } else if (value instanceof Short) {
&nbsp;                    return new ForStackManipulation(IntegerConstant.forValue((Short) value), short.class);
&nbsp;                } else if (value instanceof Character) {
&nbsp;                    return new ForStackManipulation(IntegerConstant.forValue((Character) value), char.class);
&nbsp;                } else if (value instanceof Integer) {
&nbsp;                    return new ForStackManipulation(IntegerConstant.forValue((Integer) value), int.class);
&nbsp;                } else if (value instanceof Long) {
&nbsp;                    return new ForStackManipulation(LongConstant.forValue((Long) value), long.class);
&nbsp;                } else if (value instanceof Float) {
&nbsp;                    return new ForStackManipulation(FloatConstant.forValue((Float) value), float.class);
&nbsp;                } else if (value instanceof Double) {
&nbsp;                    return new ForStackManipulation(DoubleConstant.forValue((Double) value), double.class);
&nbsp;                } else if (value instanceof Class) {
&nbsp;                    return new ForStackManipulation(ClassConstant.of(TypeDescription.ForLoadedType.of((Class&lt;?&gt;) value)), Class.class);
&nbsp;                } else if (JavaType.METHOD_HANDLE.getTypeStub().isInstance(value)) {
&nbsp;                    return new ForStackManipulation(JavaConstant.MethodHandle.ofLoaded(value).asStackManipulation(), JavaType.METHOD_HANDLE.getTypeStub());
&nbsp;                } else if (JavaType.METHOD_TYPE.getTypeStub().isInstance(value)) {
&nbsp;                    return new ForStackManipulation(JavaConstant.MethodType.ofLoaded(value).asStackManipulation(), JavaType.METHOD_TYPE.getTypeStub());
&nbsp;                } else if (value instanceof Enum&lt;?&gt;) {
&nbsp;                    EnumerationDescription enumerationDescription = new EnumerationDescription.ForLoadedEnumeration((Enum&lt;?&gt;) value);
&nbsp;                    return new ForStackManipulation(FieldAccess.forEnumeration(enumerationDescription), enumerationDescription.getEnumerationType());
&nbsp;                } else {
&nbsp;                    return new ForInstance.Factory(value);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                return instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public List&lt;ArgumentLoader&gt; make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
&nbsp;                return Collections.&lt;ArgumentLoader&gt;singletonList(this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                StackManipulation assigment = assigner.assign(typeDefinition.asGenericType(), target.getType(), typing);
&nbsp;                if (!assigment.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + target + &quot; to &quot; + typeDefinition);
&nbsp;                }
&nbsp;                return new StackManipulation.Compound(stackManipulation, assigment);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A target handler is responsible for invoking a method for a
&nbsp;     * {@link net.bytebuddy.implementation.MethodCall}.
&nbsp;     */
&nbsp;    protected interface TargetHandler extends InstrumentedType.Prepareable {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a stack manipulation that represents the method&#39;s invocation.
&nbsp;         *
&nbsp;         * @param invokedMethod      The method to be invoked.
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @param instrumentedType   The instrumented type.  @return A stack manipulation that invokes the method.
&nbsp;         * @param assigner           The assigner to use.
&nbsp;         * @param typing             The typing to apply.
&nbsp;         * @return A stack manipulation that loads the method target onto the operand stack.
&nbsp;         */
&nbsp;        StackManipulation resolve(MethodDescription invokedMethod,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  TypeDescription instrumentedType,
&nbsp;                                  Assigner assigner,
&nbsp;                                  Assigner.Typing typing);
&nbsp;
&nbsp;        /**
&nbsp;         * A target handler that invokes a method either on the instance of the instrumented
&nbsp;         * type or as a static method.
&nbsp;         */
<b class="fc">&nbsp;        enum ForSelfOrStaticInvocation implements TargetHandler {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(MethodDescription invokedMethod,
&nbsp;                                             MethodDescription instrumentedMethod,
&nbsp;                                             TypeDescription instrumentedType,
&nbsp;                                             Assigner assigner,
&nbsp;                                             Assigner.Typing typing) {
<b class="nc">&nbsp;                if (instrumentedMethod.isStatic() &amp;&amp; !invokedMethod.isStatic() &amp;&amp; !invokedMethod.isConstructor()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; from &quot; + instrumentedMethod);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                        invokedMethod.isStatic()</b>
&nbsp;                                ? StackManipulation.Trivial.INSTANCE
<b class="nc">&nbsp;                                : MethodVariableAccess.loadThis(),</b>
<b class="nc">&nbsp;                        invokedMethod.isConstructor()</b>
&nbsp;                                ? Duplication.SINGLE
&nbsp;                                : StackManipulation.Trivial.INSTANCE
&nbsp;                );
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a method in order to construct a new instance.
&nbsp;         */
&nbsp;        enum ForConstructingInvocation implements TargetHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(MethodDescription invokedMethod,
&nbsp;                                             MethodDescription instrumentedMethod,
&nbsp;                                             TypeDescription instrumentedType,
&nbsp;                                             Assigner assigner,
&nbsp;                                             Assigner.Typing typing) {
&nbsp;                return new StackManipulation.Compound(TypeCreation.of(invokedMethod.getDeclaringType().asErasure()), Duplication.SINGLE);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                return instrumentedType;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A target handler that invokes a method on an instance that is stored in a static field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForValue implements TargetHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * The name prefix of the field to store the instance.
&nbsp;             */
&nbsp;            private static final String FIELD_PREFIX = &quot;invocationTarget&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The target on which the method is to be invoked.
&nbsp;             */
&nbsp;            private final Object target;
&nbsp;
&nbsp;            /**
&nbsp;             * The type of the field.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic fieldType;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the field to store the target.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.IGNORE)
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new target handler for a static field.
&nbsp;             *
&nbsp;             * @param target    The target on which the method is to be invoked.
&nbsp;             * @param fieldType The type of the field.
&nbsp;             */
&nbsp;            protected ForValue(Object target, TypeDescription.Generic fieldType) {
&nbsp;                this.target = target;
&nbsp;                this.fieldType = fieldType;
&nbsp;                name = FIELD_PREFIX + &quot;$&quot; + RandomString.make();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(MethodDescription invokedMethod,
&nbsp;                                             MethodDescription instrumentedMethod,
&nbsp;                                             TypeDescription instrumentedType,
&nbsp;                                             Assigner assigner,
&nbsp;                                             Assigner.Typing typing) {
&nbsp;                StackManipulation stackManipulation = assigner.assign(fieldType, invokedMethod.getDeclaringType().asGenericType(), typing);
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + fieldType);
&nbsp;                }
&nbsp;                return new StackManipulation.Compound(
&nbsp;                        FieldAccess.forField(instrumentedType.getDeclaredFields().filter(named(name)).getOnly()).read(),
&nbsp;                        stackManipulation
&nbsp;                );
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                return instrumentedType
&nbsp;                        .withField(new FieldDescription.Token(name,
&nbsp;                                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_VOLATILE | Opcodes.ACC_SYNTHETIC,
&nbsp;                                fieldType))
&nbsp;                        .withInitializer(new LoadedTypeInitializer.ForStaticField(name, target));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a target handler that stores the instance to invoke a method on in an instance field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForField implements TargetHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the field.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * The field locator factory to use.
&nbsp;             */
&nbsp;            private final FieldLocator.Factory fieldLocatorFactory;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new target handler for storing a method invocation target in an
&nbsp;             * instance field.
&nbsp;             *
&nbsp;             * @param name                The name of the field.
&nbsp;             * @param fieldLocatorFactory The field locator factory to use.
&nbsp;             */
&nbsp;            protected ForField(String name, FieldLocator.Factory fieldLocatorFactory) {
&nbsp;                this.name = name;
&nbsp;                this.fieldLocatorFactory = fieldLocatorFactory;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(MethodDescription invokedMethod, MethodDescription instrumentedMethod, TypeDescription instrumentedType, Assigner assigner, Assigner.Typing typing) {
&nbsp;                FieldLocator.Resolution resolution = fieldLocatorFactory.make(instrumentedType).locate(name);
&nbsp;                if (!resolution.isResolved()) {
&nbsp;                    throw new IllegalStateException(&quot;Could not locate field name &quot; + name + &quot; on &quot; + instrumentedType);
&nbsp;                } else if (!resolution.getField().isStatic() &amp;&amp; !instrumentedType.isAssignableTo(resolution.getField().getDeclaringType().asErasure())) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot access &quot; + resolution.getField() + &quot; from &quot; + instrumentedType);
&nbsp;                } else if (!invokedMethod.isInvokableOn(resolution.getField().getType().asErasure())) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + resolution.getField());
&nbsp;                } else if (!invokedMethod.isAccessibleTo(instrumentedType)) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot access &quot; + invokedMethod + &quot; from &quot; + instrumentedType);
&nbsp;                }
&nbsp;                StackManipulation stackManipulation = assigner.assign(resolution.getField().getType(), invokedMethod.getDeclaringType().asGenericType(), typing);
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + resolution.getField());
&nbsp;                }
&nbsp;                return new StackManipulation.Compound(invokedMethod.isStatic()
&nbsp;                        ? StackManipulation.Trivial.INSTANCE
&nbsp;                        : MethodVariableAccess.loadThis(), FieldAccess.forField(resolution.getField()).read(), stackManipulation);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                return instrumentedType;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A target handler that loads the parameter of the given index as the target object.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForMethodParameter implements TargetHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * The index of the instrumented method&#39;s parameter that is the target of the method invocation.
&nbsp;             */
&nbsp;            private final int index;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new target handler for the instrumented method&#39;s argument.
&nbsp;             *
&nbsp;             * @param index The index of the instrumented method&#39;s parameter that is the target of the method invocation.
&nbsp;             */
<b class="fc">&nbsp;            protected ForMethodParameter(int index) {</b>
<b class="fc">&nbsp;                this.index = index;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(MethodDescription invokedMethod,
&nbsp;                                             MethodDescription instrumentedMethod,
&nbsp;                                             TypeDescription instrumentedType,
&nbsp;                                             Assigner assigner,
&nbsp;                                             Assigner.Typing typing) {
<b class="pc">&nbsp;                if (instrumentedMethod.getParameters().size() &lt; index) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(instrumentedMethod + &quot; does not have a parameter with index &quot; + index);</b>
&nbsp;                }
<b class="fc">&nbsp;                ParameterDescription parameterDescription = instrumentedMethod.getParameters().get(index);</b>
<b class="fc">&nbsp;                StackManipulation stackManipulation = assigner.assign(parameterDescription.getType(), invokedMethod.getDeclaringType().asGenericType(), typing);</b>
<b class="pc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + parameterDescription.getType());</b>
&nbsp;                }
<b class="fc">&nbsp;                return new StackManipulation.Compound(MethodVariableAccess.load(parameterDescription), stackManipulation);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method invoker is responsible for creating a method invocation that is to be applied by a
&nbsp;     * {@link net.bytebuddy.implementation.MethodCall}.
&nbsp;     */
&nbsp;    protected interface MethodInvoker {
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the method.
&nbsp;         *
&nbsp;         * @param invokedMethod        The method to be invoked.
&nbsp;         * @param implementationTarget The implementation target of the instrumented instance.
&nbsp;         * @return A stack manipulation that represents the method invocation.
&nbsp;         */
&nbsp;        StackManipulation invoke(MethodDescription invokedMethod, Target implementationTarget);
&nbsp;
&nbsp;        /**
&nbsp;         * Applies a contextual invocation of the provided method, i.e. a static invocation for static methods,
&nbsp;         * a special invocation for constructors and private methods and a virtual invocation for any other method.
&nbsp;         */
<b class="fc">&nbsp;        enum ForContextualInvocation implements MethodInvoker {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation invoke(MethodDescription invokedMethod, Target implementationTarget) {
<b class="nc">&nbsp;                if (invokedMethod.isVirtual() &amp;&amp; !invokedMethod.isInvokableOn(implementationTarget.getInstrumentedType())) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + implementationTarget.getInstrumentedType());</b>
&nbsp;                }
<b class="nc">&nbsp;                return invokedMethod.isVirtual()</b>
<b class="nc">&nbsp;                        ? MethodInvocation.invoke(invokedMethod).virtual(implementationTarget.getInstrumentedType())</b>
<b class="nc">&nbsp;                        : MethodInvocation.invoke(invokedMethod);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Applies a virtual invocation on a given type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForVirtualInvocation implements MethodInvoker {
&nbsp;
&nbsp;            /**
&nbsp;             * The type description to virtually invoke the method upon.
&nbsp;             */
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new method invoking for a virtual method invocation.
&nbsp;             *
&nbsp;             * @param typeDescription The type description to virtually invoke the method upon.
&nbsp;             */
&nbsp;            protected ForVirtualInvocation(TypeDescription typeDescription) {
&nbsp;                this.typeDescription = typeDescription;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new method invoking for a virtual method invocation.
&nbsp;             *
&nbsp;             * @param type The type to virtually invoke the method upon.
&nbsp;             */
&nbsp;            protected ForVirtualInvocation(Class&lt;?&gt; type) {
&nbsp;                this(TypeDescription.ForLoadedType.of(type));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation invoke(MethodDescription invokedMethod, Target implementationTarget) {
&nbsp;                if (!invokedMethod.isVirtual()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; virtually&quot;);
&nbsp;                } else if (!invokedMethod.isInvokableOn(typeDescription.asErasure())) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + typeDescription);
&nbsp;                } else if (!typeDescription.asErasure().isAccessibleTo(implementationTarget.getInstrumentedType())) {
&nbsp;                    throw new IllegalStateException(typeDescription + &quot; is not accessible to &quot; + implementationTarget.getInstrumentedType());
&nbsp;                }
&nbsp;                return MethodInvocation.invoke(invokedMethod).virtual(typeDescription.asErasure());
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method invoker for a virtual method that uses an implicit target type.
&nbsp;             */
<b class="fc">&nbsp;            public enum WithImplicitType implements MethodInvoker {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public StackManipulation invoke(MethodDescription invokedMethod, Target implementationTarget) {
<b class="pc">&nbsp;                    if (!invokedMethod.isVirtual()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; virtually&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return MethodInvocation.invoke(invokedMethod);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Applies a super method invocation of the provided method.
&nbsp;         */
&nbsp;        enum ForSuperMethodInvocation implements MethodInvoker {
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation invoke(MethodDescription invokedMethod, Target implementationTarget) {
&nbsp;                if (implementationTarget.getInstrumentedType().getSuperClass() == null) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke super method for &quot; + implementationTarget.getInstrumentedType());
&nbsp;                } else if (!invokedMethod.isInvokableOn(implementationTarget.getOriginType().asErasure())) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; as super method of &quot; + implementationTarget.getInstrumentedType());
&nbsp;                }
&nbsp;                StackManipulation stackManipulation = implementationTarget.invokeDominant(invokedMethod.asSignatureToken());
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; as a super method&quot;);
&nbsp;                }
&nbsp;                return stackManipulation;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a method as a Java 8 default method.
&nbsp;         */
&nbsp;        enum ForDefaultMethodInvocation implements MethodInvoker {
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            @Override
&nbsp;            public StackManipulation invoke(MethodDescription invokedMethod, Target implementationTarget) {
&nbsp;                if (!invokedMethod.isInvokableOn(implementationTarget.getInstrumentedType())) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; as default method of &quot; + implementationTarget.getInstrumentedType());
&nbsp;                }
&nbsp;                StackManipulation stackManipulation = implementationTarget.invokeDefault(invokedMethod.asSignatureToken(), invokedMethod.getDeclaringType().asErasure());
&nbsp;                if (!stackManipulation.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + implementationTarget.getInstrumentedType());
&nbsp;                }
&nbsp;                return stackManipulation;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A termination handler is responsible to handle the return value of a method that is invoked via a
&nbsp;     * {@link net.bytebuddy.implementation.MethodCall}.
&nbsp;     */
<b class="fc">&nbsp;    protected enum TerminationHandler {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A termination handler that returns the invoked method&#39;s return value.
&nbsp;         */
<b class="fc">&nbsp;        RETURNING {</b>
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="pc">&nbsp;                StackManipulation stackManipulation = assigner.assign(invokedMethod.isConstructor()</b>
<b class="nc">&nbsp;                        ? invokedMethod.getDeclaringType().asGenericType()</b>
<b class="fc">&nbsp;                        : invokedMethod.getReturnType(), instrumentedMethod.getReturnType(), typing);</b>
<b class="pc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot return &quot; + invokedMethod.getReturnType() + &quot; from &quot; + instrumentedMethod);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new StackManipulation.Compound(stackManipulation, MethodReturn.of(instrumentedMethod.getReturnType()));</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A termination handler that drops the invoked method&#39;s return value.
&nbsp;         */
<b class="fc">&nbsp;        DROPPING {</b>
&nbsp;            @Override
&nbsp;            protected StackManipulation resolve(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                return Removal.of(invokedMethod.isConstructor()</b>
<b class="nc">&nbsp;                        ? invokedMethod.getDeclaringType()</b>
<b class="nc">&nbsp;                        : invokedMethod.getReturnType());</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a stack manipulation that handles the method return.
&nbsp;         *
&nbsp;         * @param invokedMethod      The method that was invoked by the method call.
&nbsp;         * @param instrumentedMethod The method being intercepted.
&nbsp;         * @param assigner           The assigner to be used.
&nbsp;         * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @return A stack manipulation that handles the method return.
&nbsp;         */
&nbsp;        protected abstract StackManipulation resolve(MethodDescription invokedMethod,
&nbsp;                                                     MethodDescription instrumentedMethod,
&nbsp;                                                     Assigner assigner,
&nbsp;                                                     Assigner.Typing typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a {@link net.bytebuddy.implementation.MethodCall} that invokes a method without specifying
&nbsp;     * an invocation method. Some methods can for example be invoked both virtually or as a super method invocation.
&nbsp;     * Similarly, interface methods can be invoked virtually or as an explicit invocation of a default method. If
&nbsp;     * no explicit invocation type is set, a method is always invoked virtually unless the method
&nbsp;     * represents a static methods or a constructor.
&nbsp;     */
&nbsp;    public static class WithoutSpecifiedTarget extends MethodCall {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new method call without a specified target.
&nbsp;         *
&nbsp;         * @param methodLocator The method locator to use.
&nbsp;         */
&nbsp;        protected WithoutSpecifiedTarget(MethodLocator methodLocator) {
<b class="fc">&nbsp;            super(methodLocator,</b>
&nbsp;                    TargetHandler.ForSelfOrStaticInvocation.INSTANCE,
<b class="fc">&nbsp;                    Collections.&lt;ArgumentLoader.Factory&gt;emptyList(),</b>
&nbsp;                    MethodInvoker.ForContextualInvocation.INSTANCE,
&nbsp;                    TerminationHandler.RETURNING,
&nbsp;                    Assigner.DEFAULT,
&nbsp;                    Assigner.Typing.STATIC);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the specified method on the given instance.
&nbsp;         *
&nbsp;         * @param target The object on which the method is to be invoked upon.
&nbsp;         * @return A method call that invokes the provided method on the given object.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public MethodCall on(Object target) {
<b class="nc">&nbsp;            return on(target, (Class) target.getClass());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the specified method on the given instance.
&nbsp;         *
&nbsp;         * @param target The object on which the method is to be invoked upon.
&nbsp;         * @param type   The object&#39;s type.
&nbsp;         * @param &lt;T&gt;    The type of the object.
&nbsp;         * @return A method call that invokes the provided method on the given object.
&nbsp;         */
&nbsp;        public &lt;T&gt; MethodCall on(T target, Class&lt;? super T&gt; type) {
<b class="nc">&nbsp;            return new MethodCall(methodLocator,</b>
<b class="nc">&nbsp;                    new TargetHandler.ForValue(target, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(type)),</b>
&nbsp;                    argumentLoaders,
&nbsp;                    new MethodInvoker.ForVirtualInvocation(type),
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the specified method on the instrumented method&#39;s argument of the given index.
&nbsp;         *
&nbsp;         * @param index The index of the method&#39;s argument on which the specified method should be invoked.
&nbsp;         * @return A method call that invokes the provided method on the given method argument.
&nbsp;         */
&nbsp;        public MethodCall onArgument(int index) {
<b class="pc">&nbsp;            if (index &lt; 0) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;An argument index cannot be negative: &quot; + index);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new MethodCall(methodLocator,</b>
&nbsp;                    new TargetHandler.ForMethodParameter(index),
&nbsp;                    argumentLoaders,
&nbsp;                    MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a method on the object stored in the specified field.
&nbsp;         *
&nbsp;         * @param name The name of the field.
&nbsp;         * @return A method call that invokes the given method on an instance that is read from a field.
&nbsp;         */
&nbsp;        public MethodCall onField(String name) {
<b class="nc">&nbsp;            return onField(name, FieldLocator.ForClassHierarchy.Factory.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a method on the object stored in the specified field.
&nbsp;         *
&nbsp;         * @param name                The name of the field.
&nbsp;         * @param fieldLocatorFactory The field locator factory to use for locating the field.
&nbsp;         * @return A method call that invokes the given method on an instance that is read from a field.
&nbsp;         */
&nbsp;        public MethodCall onField(String name, FieldLocator.Factory fieldLocatorFactory) {
<b class="nc">&nbsp;            return new MethodCall(methodLocator,</b>
&nbsp;                    new TargetHandler.ForField(name, fieldLocatorFactory),
&nbsp;                    argumentLoaders,
&nbsp;                    MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the given method by a super method invocation on the instance of the instrumented type.
&nbsp;         * Note that the super method is resolved depending on the type of implementation when this method is called.
&nbsp;         * In case that a subclass is created, the super type is invoked. If a type is rebased, the rebased method
&nbsp;         * is invoked if such a method exists.
&nbsp;         *
&nbsp;         * @return A method call where the given method is invoked as a super method invocation.
&nbsp;         */
&nbsp;        public MethodCall onSuper() {
<b class="nc">&nbsp;            return new MethodCall(methodLocator,</b>
&nbsp;                    TargetHandler.ForSelfOrStaticInvocation.INSTANCE,
&nbsp;                    argumentLoaders,
&nbsp;                    MethodInvoker.ForSuperMethodInvocation.INSTANCE,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the given method by a Java 8default method invocation on the instance of the instrumented type.
&nbsp;         *
&nbsp;         * @return A method call where the given method is invoked as a super method invocation.
&nbsp;         */
&nbsp;        public MethodCall onDefault() {
<b class="nc">&nbsp;            return new MethodCall(methodLocator,</b>
&nbsp;                    TargetHandler.ForSelfOrStaticInvocation.INSTANCE,
&nbsp;                    argumentLoaders,
&nbsp;                    MethodInvoker.ForDefaultMethodInvocation.INSTANCE,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The appender being used to implement a {@link net.bytebuddy.implementation.MethodCall}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;    protected class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The implementation target of the current implementation.
&nbsp;         */
&nbsp;        private final Target implementationTarget;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new appender.
&nbsp;         *
&nbsp;         * @param implementationTarget The implementation target of the current implementation.
&nbsp;         */
<b class="fc">&nbsp;        protected Appender(Target implementationTarget) {</b>
<b class="fc">&nbsp;            this.implementationTarget = implementationTarget;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            MethodDescription invokedMethod = methodLocator.resolve(implementationTarget.getInstrumentedType(), instrumentedMethod);</b>
<b class="pc">&nbsp;            if (!invokedMethod.isVisibleTo(implementationTarget.getInstrumentedType())) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; from &quot; + implementationContext.getInstrumentedType());</b>
&nbsp;            }
<b class="fc">&nbsp;            List&lt;ArgumentLoader&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader&gt;(MethodCall.this.argumentLoaders.size());</b>
<b class="fc">&nbsp;            for (ArgumentLoader.Factory argumentLoader : MethodCall.this.argumentLoaders) {</b>
<b class="fc">&nbsp;                argumentLoaders.addAll(argumentLoader.make(implementationTarget.getInstrumentedType(), instrumentedMethod, invokedMethod));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            ParameterList&lt;?&gt; parameters = invokedMethod.getParameters();</b>
<b class="pc">&nbsp;            if (parameters.size() != argumentLoaders.size()) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(invokedMethod + &quot; does not take &quot; + argumentLoaders.size() + &quot; arguments&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            Iterator&lt;? extends ParameterDescription&gt; parameterIterator = parameters.iterator();</b>
<b class="fc">&nbsp;            List&lt;StackManipulation&gt; argumentInstructions = new ArrayList&lt;StackManipulation&gt;(argumentLoaders.size());</b>
<b class="fc">&nbsp;            for (ArgumentLoader argumentLoader : argumentLoaders) {</b>
<b class="fc">&nbsp;                argumentInstructions.add(argumentLoader.resolve(parameterIterator.next(), assigner, typing));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            StackManipulation.Size size = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                    targetHandler.resolve(invokedMethod, instrumentedMethod, implementationTarget.getInstrumentedType(), assigner, typing),</b>
&nbsp;                    new StackManipulation.Compound(argumentInstructions),
<b class="fc">&nbsp;                    methodInvoker.invoke(invokedMethod, implementationTarget),</b>
<b class="fc">&nbsp;                    terminationHandler.resolve(invokedMethod, instrumentedMethod, assigner, typing)</b>
<b class="fc">&nbsp;            ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;            return new Size(size.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
