


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TargetMethodAnnotationDrivenBinder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation.bind.annotation</a>
</div>

<h1>Coverage Summary for Class: TargetMethodAnnotationDrivenBinder (net.bytebuddy.implementation.bind.annotation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TargetMethodAnnotationDrivenBinder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TargetMethodAnnotationDrivenBinder$DelegationProcessor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (8/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88,9%
  </span>
  <span class="absValue">
    (16/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetMethodAnnotationDrivenBinder$DelegationProcessor$Handler</td>
  </tr>
  <tr>
    <td class="name">TargetMethodAnnotationDrivenBinder$DelegationProcessor$Handler$Bound</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88,9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetMethodAnnotationDrivenBinder$DelegationProcessor$Handler$Unbound</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetMethodAnnotationDrivenBinder$ParameterBinder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetMethodAnnotationDrivenBinder$ParameterBinder$ForFieldBinding</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20,8%
  </span>
  <span class="absValue">
    (5/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (8/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TargetMethodAnnotationDrivenBinder$Record</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82,4%
  </span>
  <span class="absValue">
    (14/17)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (16/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46%
  </span>
  <span class="absValue">
    (23/50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (60/80)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.implementation.bind.annotation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.scaffold.FieldLocator;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.bind.MethodDelegationBinder;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.*;
&nbsp;import net.bytebuddy.utility.JavaConstant;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.isGetter;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.isSetter;
&nbsp;
&nbsp;/**
&nbsp; * This {@link net.bytebuddy.implementation.bind.MethodDelegationBinder} binds
&nbsp; * method by analyzing annotations found on the &lt;i&gt;target&lt;/i&gt; method that is subject to a method binding.
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
&nbsp;public class TargetMethodAnnotationDrivenBinder implements MethodDelegationBinder {
&nbsp;
&nbsp;    /**
&nbsp;     * The processor for performing an actual method delegation.
&nbsp;     */
&nbsp;    private final DelegationProcessor delegationProcessor;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new target method annotation-driven binder.
&nbsp;     *
&nbsp;     * @param delegationProcessor The delegation processor to use.
&nbsp;     */
<b class="fc">&nbsp;    protected TargetMethodAnnotationDrivenBinder(DelegationProcessor delegationProcessor) {</b>
<b class="fc">&nbsp;        this.delegationProcessor = delegationProcessor;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new method delegation binder that binds method based on annotations found on the target method.
&nbsp;     *
&nbsp;     * @param parameterBinders A list of parameter binder delegates. Each such delegate is responsible for creating a
&nbsp;     *                         {@link net.bytebuddy.implementation.bind.MethodDelegationBinder.ParameterBinding}
&nbsp;     *                         for a specific annotation.
&nbsp;     * @return An appropriate method delegation binder.
&nbsp;     */
&nbsp;    public static MethodDelegationBinder of(List&lt;? extends ParameterBinder&lt;?&gt;&gt; parameterBinders) {
<b class="fc">&nbsp;        return new TargetMethodAnnotationDrivenBinder(DelegationProcessor.of(parameterBinders));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public MethodDelegationBinder.Record compile(MethodDescription candidate) {
<b class="pc">&nbsp;        if (IgnoreForBinding.Verifier.check(candidate)) {</b>
<b class="nc">&nbsp;            return MethodDelegationBinder.Record.Illegal.INSTANCE;</b>
&nbsp;        }
<b class="fc">&nbsp;        List&lt;DelegationProcessor.Handler&gt; handlers = new ArrayList&lt;DelegationProcessor.Handler&gt;(candidate.getParameters().size());</b>
<b class="fc">&nbsp;        for (ParameterDescription parameterDescription : candidate.getParameters()) {</b>
<b class="fc">&nbsp;            handlers.add(delegationProcessor.prepare(parameterDescription));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return new Record(candidate, handlers, RuntimeType.Verifier.check(candidate));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A compiled record of a target method annotation-driven binder.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class Record implements MethodDelegationBinder.Record {
&nbsp;
&nbsp;        /**
&nbsp;         * The candidate method.
&nbsp;         */
&nbsp;        private final MethodDescription candidate;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of handlers for each parameter.
&nbsp;         */
&nbsp;        private final List&lt;DelegationProcessor.Handler&gt; handlers;
&nbsp;
&nbsp;        /**
&nbsp;         * The typing to apply.
&nbsp;         */
&nbsp;        private final Assigner.Typing typing;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a default compiled method delegation binder.
&nbsp;         *
&nbsp;         * @param candidate The candidate method.
&nbsp;         * @param handlers  A list of handlers for each parameter.
&nbsp;         * @param typing    The typing to apply.
&nbsp;         */
<b class="fc">&nbsp;        protected Record(MethodDescription candidate, List&lt;DelegationProcessor.Handler&gt; handlers, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;            this.candidate = candidate;</b>
<b class="fc">&nbsp;            this.handlers = handlers;</b>
<b class="fc">&nbsp;            this.typing = typing;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodBinding bind(Implementation.Target implementationTarget,
&nbsp;                                  MethodDescription source,
&nbsp;                                  MethodDelegationBinder.TerminationHandler terminationHandler,
&nbsp;                                  MethodInvoker methodInvoker,
&nbsp;                                  Assigner assigner) {
<b class="pc">&nbsp;            if (!candidate.isAccessibleTo(implementationTarget.getInstrumentedType())) {</b>
<b class="nc">&nbsp;                return MethodBinding.Illegal.INSTANCE;</b>
&nbsp;            }
<b class="fc">&nbsp;            StackManipulation methodTermination = terminationHandler.resolve(assigner, typing, source, candidate);</b>
<b class="pc">&nbsp;            if (!methodTermination.isValid()) {</b>
<b class="nc">&nbsp;                return MethodBinding.Illegal.INSTANCE;</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodBinding.Builder methodDelegationBindingBuilder = new MethodBinding.Builder(methodInvoker, candidate);</b>
<b class="fc">&nbsp;            for (DelegationProcessor.Handler handler : handlers) {</b>
<b class="fc">&nbsp;                ParameterBinding&lt;?&gt; parameterBinding = handler.bind(source, implementationTarget, assigner);</b>
<b class="pc">&nbsp;                if (!parameterBinding.isValid() || !methodDelegationBindingBuilder.append(parameterBinding)) {</b>
<b class="fc">&nbsp;                    return MethodBinding.Illegal.INSTANCE;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return methodDelegationBindingBuilder.build(methodTermination);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return candidate.toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A parameter binder is used as a delegate for binding a parameter according to a particular annotation type found
&nbsp;     * on this parameter.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The {@link java.lang.annotation.Annotation#annotationType()} handled by this parameter binder.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION&quot;, justification = &quot;Safe initialization is implied&quot;)
&nbsp;    public interface ParameterBinder&lt;T extends Annotation&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The default parameter binders to be used.
&nbsp;         */
<b class="fc">&nbsp;        List&lt;ParameterBinder&lt;?&gt;&gt; DEFAULTS = Collections.unmodifiableList(Arrays.&lt;TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt;asList(</b>
&nbsp;                Argument.Binder.INSTANCE,
&nbsp;                AllArguments.Binder.INSTANCE,
&nbsp;                Origin.Binder.INSTANCE,
&nbsp;                This.Binder.INSTANCE,
&nbsp;                Super.Binder.INSTANCE,
&nbsp;                Default.Binder.INSTANCE,
&nbsp;                SuperCall.Binder.INSTANCE,
&nbsp;                DefaultCall.Binder.INSTANCE,
&nbsp;                SuperMethod.Binder.INSTANCE,
&nbsp;                DefaultMethod.Binder.INSTANCE,
&nbsp;                FieldValue.Binder.INSTANCE,
&nbsp;                StubValue.Binder.INSTANCE,
&nbsp;                Empty.Binder.INSTANCE));
&nbsp;
&nbsp;        /**
&nbsp;         * The annotation type that is handled by this parameter binder.
&nbsp;         *
&nbsp;         * @return The {@link java.lang.annotation.Annotation#annotationType()} handled by this parameter binder.
&nbsp;         */
&nbsp;        Class&lt;T&gt; getHandledType();
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a parameter binding for the given target parameter.
&nbsp;         *
&nbsp;         * @param annotation           The annotation that was cause for the delegation to this argument binder.
&nbsp;         * @param source               The intercepted source method.
&nbsp;         * @param target               Tge target parameter that is subject to be bound to
&nbsp;         *                             intercepting the {@code source} method.
&nbsp;         * @param implementationTarget The target of the current implementation that is subject to this binding.
&nbsp;         * @param assigner             An assigner that can be used for applying the binding.
&nbsp;         * @param typing               The typing to apply.
&nbsp;         * @return A parameter binding for the requested target method parameter.
&nbsp;         */
&nbsp;        ParameterBinding&lt;?&gt; bind(AnnotationDescription.Loadable&lt;T&gt; annotation,
&nbsp;                                 MethodDescription source,
&nbsp;                                 ParameterDescription target,
&nbsp;                                 Implementation.Target implementationTarget,
&nbsp;                                 Assigner assigner,
&nbsp;                                 Assigner.Typing typing);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Implements a parameter binder that binds a fixed value to a parameter with a given annotation.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * This binder is only capable to store values that can either be expressed as Java byte code or as a constant pool value. This
&nbsp;         * includes primitive types, {@link String} values, {@link Class} values which can also be expressed as {@link TypeDescription}
&nbsp;         * instances or method handles and method types for classes of a version at least of Java 7. The latter instances can also be
&nbsp;         * expressed as unloaded {@link JavaConstant} representations.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: When supplying a method handle or a method type, all types that are implied must be visible to the instrumented
&nbsp;         * type or an {@link IllegalAccessException} will be thrown at runtime.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param &lt;S&gt; The bound annotation&#39;s type.
&nbsp;         */
&nbsp;        abstract class ForFixedValue&lt;S extends Annotation&gt; implements ParameterBinder&lt;S&gt; {
&nbsp;
&nbsp;            @Override
&nbsp;            public ParameterBinding&lt;?&gt; bind(AnnotationDescription.Loadable&lt;S&gt; annotation,
&nbsp;                                            MethodDescription source,
&nbsp;                                            ParameterDescription target,
&nbsp;                                            Implementation.Target implementationTarget,
&nbsp;                                            Assigner assigner,
&nbsp;                                            Assigner.Typing typing) {
&nbsp;                Object value = bind(annotation, source, target);
&nbsp;                if (value == null) {
&nbsp;                    return new ParameterBinding.Anonymous(DefaultValue.of(target.getType()));
&nbsp;                }
&nbsp;                StackManipulation stackManipulation;
&nbsp;                TypeDescription suppliedType;
&nbsp;                if (value instanceof Boolean) {
&nbsp;                    stackManipulation = IntegerConstant.forValue((Boolean) value);
&nbsp;                    suppliedType = TypeDescription.ForLoadedType.of(boolean.class);
&nbsp;                } else if (value instanceof Byte) {
&nbsp;                    stackManipulation = IntegerConstant.forValue((Byte) value);
&nbsp;                    suppliedType = TypeDescription.ForLoadedType.of(byte.class);
&nbsp;                } else if (value instanceof Short) {
&nbsp;                    stackManipulation = IntegerConstant.forValue((Short) value);
&nbsp;                    suppliedType = TypeDescription.ForLoadedType.of(short.class);
&nbsp;                } else if (value instanceof Character) {
&nbsp;                    stackManipulation = IntegerConstant.forValue((Character) value);
&nbsp;                    suppliedType = TypeDescription.ForLoadedType.of(char.class);
&nbsp;                } else if (value instanceof Integer) {
&nbsp;                    stackManipulation = IntegerConstant.forValue((Integer) value);
&nbsp;                    suppliedType = TypeDescription.ForLoadedType.of(int.class);
&nbsp;                } else if (value instanceof Long) {
&nbsp;                    stackManipulation = LongConstant.forValue((Long) value);
&nbsp;                    suppliedType = TypeDescription.ForLoadedType.of(long.class);
&nbsp;                } else if (value instanceof Float) {
&nbsp;                    stackManipulation = FloatConstant.forValue((Float) value);
&nbsp;                    suppliedType = TypeDescription.ForLoadedType.of(float.class);
&nbsp;                } else if (value instanceof Double) {
&nbsp;                    stackManipulation = DoubleConstant.forValue((Double) value);
&nbsp;                    suppliedType = TypeDescription.ForLoadedType.of(double.class);
&nbsp;                } else if (value instanceof String) {
&nbsp;                    stackManipulation = new TextConstant((String) value);
&nbsp;                    suppliedType = TypeDescription.STRING;
&nbsp;                } else if (value instanceof Class) {
&nbsp;                    stackManipulation = ClassConstant.of(TypeDescription.ForLoadedType.of((Class&lt;?&gt;) value));
&nbsp;                    suppliedType = TypeDescription.CLASS;
&nbsp;                } else if (value instanceof TypeDescription) {
&nbsp;                    stackManipulation = ClassConstant.of((TypeDescription) value);
&nbsp;                    suppliedType = TypeDescription.CLASS;
&nbsp;                } else if (JavaType.METHOD_HANDLE.getTypeStub().isInstance(value)) {
&nbsp;                    stackManipulation = JavaConstant.MethodHandle.ofLoaded(value).asStackManipulation();
&nbsp;                    suppliedType = JavaType.METHOD_HANDLE.getTypeStub();
&nbsp;                } else if (value instanceof JavaConstant.MethodHandle) {
&nbsp;                    stackManipulation = new JavaConstantValue((JavaConstant.MethodHandle) value);
&nbsp;                    suppliedType = JavaType.METHOD_HANDLE.getTypeStub();
&nbsp;                } else if (JavaType.METHOD_TYPE.getTypeStub().isInstance(value)) {
&nbsp;                    stackManipulation = new JavaConstantValue(JavaConstant.MethodType.ofLoaded(value));
&nbsp;                    suppliedType = JavaType.METHOD_HANDLE.getTypeStub();
&nbsp;                } else if (value instanceof JavaConstant.MethodType) {
&nbsp;                    stackManipulation = new JavaConstantValue((JavaConstant.MethodType) value);
&nbsp;                    suppliedType = JavaType.METHOD_HANDLE.getTypeStub();
&nbsp;                } else {
&nbsp;                    throw new IllegalStateException(&quot;Not able to save in class&#39;s constant pool: &quot; + value);
&nbsp;                }
&nbsp;                return new ParameterBinding.Anonymous(new StackManipulation.Compound(
&nbsp;                        stackManipulation,
&nbsp;                        assigner.assign(suppliedType.asGenericType(), target.getType(), typing)
&nbsp;                ));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a value for the given annotation on a parameter that is processed by a {@link net.bytebuddy.implementation.MethodDelegation}.
&nbsp;             *
&nbsp;             * @param annotation The annotation that triggered this binding.
&nbsp;             * @param source     The method for which a delegation is currently bound.
&nbsp;             * @param target     The parameter for which a value is bound.
&nbsp;             * @return The constant pool value that is bound to this parameter or {@code null} for binding this value.
&nbsp;             */
&nbsp;            protected abstract Object bind(AnnotationDescription.Loadable&lt;S&gt; annotation, MethodDescription source, ParameterDescription target);
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * A parameter binder that binds a fixed value to a parameter annotation when using a {@link net.bytebuddy.implementation.MethodDelegation}.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * This binder is only capable to store
&nbsp;             * values that can either be expressed as Java byte code or as a constant pool value. This includes primitive types, {@link String} values,
&nbsp;             * {@link Class} values which can also be expressed as {@link TypeDescription} instances or method handles and method types for classes of
&nbsp;             * a version at least of Java 7. The latter instances can also be expressed as unloaded {@link JavaConstant} representations.
&nbsp;             * &lt;/p&gt;
&nbsp;             *
&nbsp;             * @param &lt;U&gt; The bound annotation&#39;s type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfConstant&lt;U extends Annotation&gt; extends ForFixedValue&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type of the annotation that is bound by this binder.
&nbsp;                 */
&nbsp;                private final Class&lt;U&gt; type;
&nbsp;
&nbsp;                /**
&nbsp;                 * The value that is assigned to any annotated parameter.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final Object value;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a binder for binding a fixed value to a parameter annotated with the given annotation.
&nbsp;                 *
&nbsp;                 * @param type  The type of the annotation that is bound by this binder.
&nbsp;                 * @param value The value that is assigned to any annotated parameter.
&nbsp;                 */
&nbsp;                protected OfConstant(Class&lt;U&gt; type, Object value) {
&nbsp;                    this.type = type;
&nbsp;                    this.value = value;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a binder for binding a fixed value to a given annotation.
&nbsp;                 *
&nbsp;                 * @param type  The type of the annotation that is bound by this binder.
&nbsp;                 * @param value The value that is assigned to any annotated parameter.
&nbsp;                 * @param &lt;V&gt;   The bound annotation&#39;s type.
&nbsp;                 * @return A parameter binder that binds the given annotation to the supplied value.
&nbsp;                 */
&nbsp;                public static &lt;V extends Annotation&gt; ParameterBinder&lt;V&gt; of(Class&lt;V&gt; type, Object value) {
&nbsp;                    return new OfConstant&lt;V&gt;(type, value);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Class&lt;U&gt; getHandledType() {
&nbsp;                    return type;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Object bind(AnnotationDescription.Loadable&lt;U&gt; annotation, MethodDescription source, ParameterDescription target) {
&nbsp;                    return value;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A parameter binder that binds a field&#39;s value.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; The {@link java.lang.annotation.Annotation#annotationType()} handled by this parameter binder.
&nbsp;         */
<b class="fc">&nbsp;        abstract class ForFieldBinding&lt;S extends Annotation&gt; implements ParameterBinder&lt;S&gt; {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a name should be extracted from an accessor method.
&nbsp;             */
&nbsp;            protected static final String BEAN_PROPERTY = &quot;&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a field locator for a potential accessor method.
&nbsp;             *
&nbsp;             * @param fieldLocator      The field locator to use.
&nbsp;             * @param methodDescription The method description that is the potential accessor.
&nbsp;             * @return A resolution for a field locator.
&nbsp;             */
&nbsp;            private static FieldLocator.Resolution resolveAccessor(FieldLocator fieldLocator, MethodDescription methodDescription) {
&nbsp;                String fieldName;
<b class="nc">&nbsp;                if (isSetter().matches(methodDescription)) {</b>
<b class="nc">&nbsp;                    fieldName = methodDescription.getInternalName().substring(3);</b>
<b class="nc">&nbsp;                } else if (isGetter().matches(methodDescription)) {</b>
<b class="nc">&nbsp;                    fieldName = methodDescription.getInternalName().substring(methodDescription.getInternalName().startsWith(&quot;is&quot;) ? 2 : 3);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return FieldLocator.Resolution.Illegal.INSTANCE;</b>
&nbsp;                }
<b class="nc">&nbsp;                return fieldLocator.locate(Character.toLowerCase(fieldName.charAt(0)) + fieldName.substring(1));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public ParameterBinding&lt;?&gt; bind(AnnotationDescription.Loadable&lt;S&gt; annotation,
&nbsp;                                            MethodDescription source,
&nbsp;                                            ParameterDescription target,
&nbsp;                                            Implementation.Target implementationTarget,
&nbsp;                                            Assigner assigner,
&nbsp;                                            Assigner.Typing typing) {
<b class="pc">&nbsp;                if (!declaringType(annotation).represents(void.class)) {</b>
<b class="nc">&nbsp;                    if (declaringType(annotation).isPrimitive() || declaringType(annotation).isArray()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;A primitive type or array type cannot declare a field: &quot; + source);</b>
<b class="nc">&nbsp;                    } else if (!implementationTarget.getInstrumentedType().isAssignableTo(declaringType(annotation))) {</b>
<b class="nc">&nbsp;                        return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
<b class="pc">&nbsp;                FieldLocator fieldLocator = declaringType(annotation).represents(void.class)</b>
<b class="fc">&nbsp;                        ? new FieldLocator.ForClassHierarchy(implementationTarget.getInstrumentedType())</b>
<b class="nc">&nbsp;                        : new FieldLocator.ForExactType(declaringType(annotation), implementationTarget.getInstrumentedType());</b>
<b class="pc">&nbsp;                FieldLocator.Resolution resolution = fieldName(annotation).equals(BEAN_PROPERTY)</b>
<b class="nc">&nbsp;                        ? resolveAccessor(fieldLocator, source)</b>
<b class="fc">&nbsp;                        : fieldLocator.locate(fieldName(annotation));</b>
<b class="pc">&nbsp;                return resolution.isResolved() &amp;&amp; !(source.isStatic() &amp;&amp; !resolution.getField().isStatic())</b>
<b class="fc">&nbsp;                        ? bind(resolution.getField(), annotation, source, target, implementationTarget, assigner)</b>
&nbsp;                        : ParameterBinding.Illegal.INSTANCE;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Extracts the field name from an annotation.
&nbsp;             *
&nbsp;             * @param annotation The annotation from which to extract the field name.
&nbsp;             * @return The field name defined by the handled annotation.
&nbsp;             */
&nbsp;            protected abstract String fieldName(AnnotationDescription.Loadable&lt;S&gt; annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Extracts the declaring type from an annotation.
&nbsp;             *
&nbsp;             * @param annotation The annotation from which to extract the declaring type.
&nbsp;             * @return The declaring type defined by the handled annotation.
&nbsp;             */
&nbsp;            protected abstract TypeDescription declaringType(AnnotationDescription.Loadable&lt;S&gt; annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameter binding for the given target parameter.
&nbsp;             *
&nbsp;             * @param fieldDescription     The field for which this binder binds a value.
&nbsp;             * @param annotation           The annotation that was cause for the delegation to this argument binder.
&nbsp;             * @param source               The intercepted source method.
&nbsp;             * @param target               Tge target parameter that is subject to be bound to
&nbsp;             *                             intercepting the {@code source} method.
&nbsp;             * @param implementationTarget The target of the current implementation that is subject to this binding.
&nbsp;             * @param assigner             An assigner that can be used for applying the binding.
&nbsp;             * @return A parameter binding for the requested target method parameter.
&nbsp;             */
&nbsp;            protected abstract ParameterBinding&lt;?&gt; bind(FieldDescription fieldDescription,
&nbsp;                                                        AnnotationDescription.Loadable&lt;S&gt; annotation,
&nbsp;                                                        MethodDescription source,
&nbsp;                                                        ParameterDescription target,
&nbsp;                                                        Implementation.Target implementationTarget,
&nbsp;                                                        Assigner assigner);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A delegation processor is a helper class for a
&nbsp;     * {@link net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder}
&nbsp;     * for performing its actual logic. By outsourcing this logic to this helper class, a cleaner implementation
&nbsp;     * can be provided.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class DelegationProcessor {
&nbsp;
&nbsp;        /**
&nbsp;         * A map of registered annotation types to the binder that is responsible for binding a parameter
&nbsp;         * that is annotated with the given annotation.
&nbsp;         */
&nbsp;        private final Map&lt;? extends TypeDescription, ? extends ParameterBinder&lt;?&gt;&gt; parameterBinders;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new delegation processor.
&nbsp;         *
&nbsp;         * @param parameterBinders A mapping of parameter binders by their handling type.
&nbsp;         */
<b class="fc">&nbsp;        protected DelegationProcessor(Map&lt;? extends TypeDescription, ? extends ParameterBinder&lt;?&gt;&gt; parameterBinders) {</b>
<b class="fc">&nbsp;            this.parameterBinders = parameterBinders;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new delegation processor.
&nbsp;         *
&nbsp;         * @param parameterBinders A list of parameter binder delegates. Each such delegate is responsible for creating
&nbsp;         *                         a {@link net.bytebuddy.implementation.bind.MethodDelegationBinder.ParameterBinding}
&nbsp;         *                         for a specific annotation.
&nbsp;         * @return A corresponding delegation processor.
&nbsp;         */
&nbsp;        protected static DelegationProcessor of(List&lt;? extends ParameterBinder&lt;?&gt;&gt; parameterBinders) {
<b class="fc">&nbsp;            Map&lt;TypeDescription, ParameterBinder&lt;?&gt;&gt; parameterBinderMap = new HashMap&lt;TypeDescription, ParameterBinder&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;            for (ParameterBinder&lt;?&gt; parameterBinder : parameterBinders) {</b>
<b class="pc">&nbsp;                if (parameterBinderMap.put(TypeDescription.ForLoadedType.of(parameterBinder.getHandledType()), parameterBinder) != null) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Attempt to bind two handlers to &quot; + parameterBinder.getHandledType());</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new DelegationProcessor(parameterBinderMap);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Locates a handler which is responsible for processing the given parameter. If no explicit handler can
&nbsp;         * be located, a fallback handler is provided.
&nbsp;         *
&nbsp;         * @param target The target parameter being handled.
&nbsp;         * @return A handler for processing the parameter with the given annotations.
&nbsp;         */
&nbsp;        protected Handler prepare(ParameterDescription target) {
<b class="fc">&nbsp;            Assigner.Typing typing = RuntimeType.Verifier.check(target);</b>
<b class="fc">&nbsp;            Handler handler = new Handler.Unbound(target, typing);</b>
<b class="fc">&nbsp;            for (AnnotationDescription annotation : target.getDeclaredAnnotations()) {</b>
<b class="fc">&nbsp;                ParameterBinder&lt;?&gt; parameterBinder = parameterBinders.get(annotation.getAnnotationType());</b>
<b class="pc">&nbsp;                if (parameterBinder != null &amp;&amp; handler.isBound()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Ambiguous binding for parameter annotated with two handled annotation types&quot;);</b>
<b class="pc">&nbsp;                } else if (parameterBinder != null /* &amp;&amp; !handler.isBound() */) {</b>
<b class="fc">&nbsp;                    handler = Handler.Bound.of(target, parameterBinder, annotation, typing);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return handler;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A handler is responsible for processing a parameter&#39;s binding.
&nbsp;         */
&nbsp;        protected interface Handler {
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates if this handler was explicitly bound.
&nbsp;             *
&nbsp;             * @return {@code true} if this handler was explicitly bound.
&nbsp;             */
&nbsp;            boolean isBound();
&nbsp;
&nbsp;            /**
&nbsp;             * Handles a parameter binding.
&nbsp;             *
&nbsp;             * @param source               The intercepted source method.
&nbsp;             * @param implementationTarget The target of the current implementation.
&nbsp;             * @param assigner             The assigner to use.
&nbsp;             * @return A parameter binding that reflects the given arguments.
&nbsp;             */
&nbsp;            ParameterBinding&lt;?&gt; bind(MethodDescription source, Implementation.Target implementationTarget, Assigner assigner);
&nbsp;
&nbsp;            /**
&nbsp;             * An unbound handler is a fallback for returning an illegal binding for parameters for which no parameter
&nbsp;             * binder could be located.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Unbound implements Handler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The target parameter being handled.
&nbsp;                 */
&nbsp;                private final ParameterDescription target;
&nbsp;
&nbsp;                /**
&nbsp;                 * The typing to apply.
&nbsp;                 */
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new unbound handler.
&nbsp;                 *
&nbsp;                 * @param target The target parameter being handled.
&nbsp;                 * @param typing The typing to apply.
&nbsp;                 */
<b class="fc">&nbsp;                protected Unbound(ParameterDescription target, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                    this.target = target;</b>
<b class="fc">&nbsp;                    this.typing = typing;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isBound() {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public ParameterBinding&lt;?&gt; bind(MethodDescription source, Implementation.Target implementationTarget, Assigner assigner) {
<b class="nc">&nbsp;                    return Argument.Binder.INSTANCE.bind(AnnotationDescription.ForLoadedAnnotation.&lt;Argument&gt;of(new DefaultArgument(target.getIndex())),</b>
&nbsp;                            source,
&nbsp;                            target,
&nbsp;                            implementationTarget,
&nbsp;                            assigner,
&nbsp;                            typing);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A default implementation of an {@link net.bytebuddy.implementation.bind.annotation.Argument} annotation.
&nbsp;                 */
&nbsp;                protected static class DefaultArgument implements Argument {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the value annotation parameter.
&nbsp;                     */
&nbsp;                    private static final String VALUE = &quot;value&quot;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the value binding mechanic parameter.
&nbsp;                     */
&nbsp;                    private static final String BINDING_MECHANIC = &quot;bindingMechanic&quot;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The index of the source method parameter to be bound.
&nbsp;                     */
&nbsp;                    private final int parameterIndex;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new instance of an argument annotation.
&nbsp;                     *
&nbsp;                     * @param parameterIndex The index of the source method parameter to be bound.
&nbsp;                     */
&nbsp;                    protected DefaultArgument(int parameterIndex) {
&nbsp;                        this.parameterIndex = parameterIndex;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int value() {
&nbsp;                        return parameterIndex;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public BindingMechanic bindingMechanic() {
&nbsp;                        return BindingMechanic.UNIQUE;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Class&lt;Argument&gt; annotationType() {
&nbsp;                        return Argument.class;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean equals(Object other) {
&nbsp;                        return this == other || other instanceof Argument &amp;&amp; parameterIndex == ((Argument) other).value();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int hashCode() {
&nbsp;                        return ((127 * BINDING_MECHANIC.hashCode()) ^ BindingMechanic.UNIQUE.hashCode())
&nbsp;                                + ((127 * VALUE.hashCode()) ^ parameterIndex);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String toString() {
&nbsp;                        return &quot;@&quot; + Argument.class.getName()
&nbsp;                                + &quot;(bindingMechanic=&quot; + BindingMechanic.UNIQUE.toString()
&nbsp;                                + &quot;, value=&quot; + parameterIndex + &quot;)&quot;;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A bound handler represents an unambiguous parameter binder that was located for a given array of
&nbsp;             * annotations.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The annotation type of a given handler.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Bound&lt;T extends Annotation&gt; implements Handler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The target parameter being handled.
&nbsp;                 */
&nbsp;                private final ParameterDescription target;
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter binder that is actually responsible for binding the parameter.
&nbsp;                 */
&nbsp;                private final ParameterBinder&lt;T&gt; parameterBinder;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation value that lead to the binding of this handler.
&nbsp;                 */
&nbsp;                private final AnnotationDescription.Loadable&lt;T&gt; annotation;
&nbsp;
&nbsp;                /**
&nbsp;                 * The typing to apply.
&nbsp;                 */
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new bound handler.
&nbsp;                 *
&nbsp;                 * @param target          The target parameter being handled.
&nbsp;                 * @param parameterBinder The parameter binder that is actually responsible for binding the parameter.
&nbsp;                 * @param annotation      The annotation value that lead to the binding of this handler.
&nbsp;                 * @param typing          The typing to apply.
&nbsp;                 */
&nbsp;                protected Bound(ParameterDescription target,
&nbsp;                                ParameterBinder&lt;T&gt; parameterBinder,
&nbsp;                                AnnotationDescription.Loadable&lt;T&gt; annotation,
<b class="fc">&nbsp;                                Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                    this.target = target;</b>
<b class="fc">&nbsp;                    this.parameterBinder = parameterBinder;</b>
<b class="fc">&nbsp;                    this.annotation = annotation;</b>
<b class="fc">&nbsp;                    this.typing = typing;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a handler for a given annotation.
&nbsp;                 *
&nbsp;                 * @param target          The target parameter being handled.
&nbsp;                 * @param parameterBinder The parameter binder that should process an annotation.
&nbsp;                 * @param annotation      An annotation instance that can be understood by this parameter binder.
&nbsp;                 * @param typing          The typing to apply.
&nbsp;                 * @return A handler for processing the given annotation.
&nbsp;                 */
&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                protected static Handler of(ParameterDescription target,
&nbsp;                                            ParameterBinder&lt;?&gt; parameterBinder,
&nbsp;                                            AnnotationDescription annotation,
&nbsp;                                            Assigner.Typing typing) {
<b class="fc">&nbsp;                    return new Bound&lt;Annotation&gt;(target,</b>
&nbsp;                            (ParameterBinder&lt;Annotation&gt;) parameterBinder,
<b class="fc">&nbsp;                            (AnnotationDescription.Loadable&lt;Annotation&gt;) annotation.prepare(parameterBinder.getHandledType()),</b>
&nbsp;                            typing);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isBound() {
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public ParameterBinding&lt;?&gt; bind(MethodDescription source, Implementation.Target implementationTarget, Assigner assigner) {
<b class="fc">&nbsp;                    return parameterBinder.bind(annotation,</b>
&nbsp;                            source,
&nbsp;                            target,
&nbsp;                            implementationTarget,
&nbsp;                            assigner,
&nbsp;                            typing);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
