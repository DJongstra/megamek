


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > SymbolTable</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.jar.asm</a>
</div>

<h1>Coverage Summary for Class: SymbolTable (net.bytebuddy.jar.asm)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SymbolTable</td>
<td class="coverageStat">
  <span class="percent">
    47,5%
  </span>
  <span class="absValue">
    (28/59)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    29,5%
  </span>
  <span class="absValue">
    (62/210)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    32,9%
  </span>
  <span class="absValue">
    (120/365)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SymbolTable$Entry</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (32/64)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    29,5%
  </span>
  <span class="absValue">
    (62/210)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    34,1%
  </span>
  <span class="absValue">
    (128/375)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;// ASM: a very small and fast Java bytecode manipulation framework
&nbsp;// Copyright (c) 2000-2011 INRIA, France Telecom
&nbsp;// All rights reserved.
&nbsp;//
&nbsp;// Redistribution and use in source and binary forms, with or without
&nbsp;// modification, are permitted provided that the following conditions
&nbsp;// are met:
&nbsp;// 1. Redistributions of source code must retain the above copyright
&nbsp;//    notice, this list of conditions and the following disclaimer.
&nbsp;// 2. Redistributions in binary form must reproduce the above copyright
&nbsp;//    notice, this list of conditions and the following disclaimer in the
&nbsp;//    documentation and/or other materials provided with the distribution.
&nbsp;// 3. Neither the name of the copyright holders nor the names of its
&nbsp;//    contributors may be used to endorse or promote products derived from
&nbsp;//    this software without specific prior written permission.
&nbsp;//
&nbsp;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
&nbsp;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
&nbsp;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
&nbsp;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
&nbsp;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
&nbsp;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
&nbsp;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
&nbsp;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
&nbsp;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
&nbsp;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
&nbsp;// THE POSSIBILITY OF SUCH DAMAGE.
&nbsp;package net.bytebuddy.jar.asm;
&nbsp;
&nbsp;/**
&nbsp; * The constant pool entries, the BootstrapMethods attribute entries and the (ASM specific) type
&nbsp; * table entries of a class.
&nbsp; *
&nbsp; * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4&quot;&gt;JVMS
&nbsp; *     4.4&lt;/a&gt;
&nbsp; * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23&quot;&gt;JVMS
&nbsp; *     4.7.23&lt;/a&gt;
&nbsp; * @author Eric Bruneton
&nbsp; */
&nbsp;final class SymbolTable {
&nbsp;
&nbsp;  /**
&nbsp;   * An entry of a SymbolTable. This concrete and private subclass of {@link Symbol} adds two fields
&nbsp;   * which are only used inside SymbolTable, to implement hash sets of symbols (in order to avoid
&nbsp;   * duplicate symbols). See {@link #entries}.
&nbsp;   *
&nbsp;   * @author Eric Bruneton
&nbsp;   */
&nbsp;  private static class Entry extends Symbol {
&nbsp;
&nbsp;    /** The hash code of this entry. */
&nbsp;    final int hashCode;
&nbsp;
&nbsp;    /**
&nbsp;     * Another entry (and so on recursively) having the same hash code (modulo the size of {@link
&nbsp;     * #entries}) as this one.
&nbsp;     */
&nbsp;    Entry next;
&nbsp;
&nbsp;    Entry(
&nbsp;        final int index,
&nbsp;        final int tag,
&nbsp;        final String owner,
&nbsp;        final String name,
&nbsp;        final String value,
&nbsp;        final long data,
&nbsp;        final int hashCode) {
<b class="fc">&nbsp;      super(index, tag, owner, name, value, data);</b>
<b class="fc">&nbsp;      this.hashCode = hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    Entry(final int index, final int tag, final String value, final int hashCode) {
<b class="fc">&nbsp;      super(index, tag, /* owner = */ null, /* name = */ null, value, /* data = */ 0);</b>
<b class="fc">&nbsp;      this.hashCode = hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    Entry(final int index, final int tag, final String value, final long data, final int hashCode) {
<b class="nc">&nbsp;      super(index, tag, /* owner = */ null, /* name = */ null, value, data);</b>
<b class="nc">&nbsp;      this.hashCode = hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    Entry(
&nbsp;        final int index, final int tag, final String name, final String value, final int hashCode) {
<b class="fc">&nbsp;      super(index, tag, /* owner = */ null, name, value, /* data = */ 0);</b>
<b class="fc">&nbsp;      this.hashCode = hashCode;</b>
&nbsp;    }
&nbsp;
&nbsp;    Entry(final int index, final int tag, final long data, final int hashCode) {
<b class="fc">&nbsp;      super(index, tag, /* owner = */ null, /* name = */ null, /* value = */ null, data);</b>
<b class="fc">&nbsp;      this.hashCode = hashCode;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * The ClassWriter to which this SymbolTable belongs. This is only used to get access to {@link
&nbsp;   * ClassWriter#getCommonSuperClass} and to serialize custom attributes with {@link
&nbsp;   * Attribute#write}.
&nbsp;   */
&nbsp;  final ClassWriter classWriter;
&nbsp;
&nbsp;  /**
&nbsp;   * The ClassReader from which this SymbolTable was constructed, or &lt;tt&gt;null&lt;/tt&gt; if it was
&nbsp;   * constructed from scratch.
&nbsp;   */
&nbsp;  private final ClassReader sourceClassReader;
&nbsp;
&nbsp;  /** The major version number of the class to which this symbol table belongs. */
&nbsp;  private int majorVersion;
&nbsp;
&nbsp;  /** The internal name of the class to which this symbol table belongs. */
&nbsp;  private String className;
&nbsp;
&nbsp;  /**
&nbsp;   * The total number of {@link Entry} instances in {@link #entries}. This includes entries that are
&nbsp;   * accessible (recursively) via {@link Entry#next}.
&nbsp;   */
&nbsp;  private int entryCount;
&nbsp;
&nbsp;  /**
&nbsp;   * A hash set of all the entries in this SymbolTable (this includes the constant pool entries, the
&nbsp;   * bootstrap method entries and the type table entries). Each {@link Entry} instance is stored at
&nbsp;   * the array index given by its hash code modulo the array size. If several entries must be stored
&nbsp;   * at the same array index, they are linked together via their {@link Entry#next} field. The
&nbsp;   * factory methods of this class make sure that this table does not contain duplicated entries.
&nbsp;   */
&nbsp;  private Entry[] entries;
&nbsp;
&nbsp;  /**
&nbsp;   * The number of constant pool items in {@link #constantPool}, plus 1. The first constant pool
&nbsp;   * item has index 1, and long and double items count for two items.
&nbsp;   */
&nbsp;  private int constantPoolCount;
&nbsp;
&nbsp;  /**
&nbsp;   * The content of the ClassFile&#39;s constant_pool JVMS structure corresponding to this SymbolTable.
&nbsp;   * The ClassFile&#39;s constant_pool_count field is &lt;i&gt;not&lt;/i&gt; included.
&nbsp;   */
&nbsp;  private ByteVector constantPool;
&nbsp;
&nbsp;  /**
&nbsp;   * The number of bootstrap methods in {@link #bootstrapMethods}. Corresponds to the
&nbsp;   * BootstrapMethods_attribute&#39;s num_bootstrap_methods field value.
&nbsp;   */
&nbsp;  private int bootstrapMethodCount;
&nbsp;
&nbsp;  /**
&nbsp;   * The content of the BootstrapMethods attribute &#39;bootstrap_methods&#39; array corresponding to this
&nbsp;   * SymbolTable. Note that the first 6 bytes of the BootstrapMethods_attribute, and its
&nbsp;   * num_bootstrap_methods field, are &lt;i&gt;not&lt;/i&gt; included.
&nbsp;   */
&nbsp;  private ByteVector bootstrapMethods;
&nbsp;
&nbsp;  /**
&nbsp;   * The actual number of elements in {@link #typeTable}. These elements are stored from index 0 to
&nbsp;   * typeCount (excluded). The other array entries are empty.
&nbsp;   */
&nbsp;  private int typeCount;
&nbsp;
&nbsp;  /**
&nbsp;   * An ASM specific type table used to temporarily store internal names that will not necessarily
&nbsp;   * be stored in the constant pool. This type table is used by the control flow and data flow
&nbsp;   * analysis algorithm used to compute stack map frames from scratch. This array stores {@link
&nbsp;   * Symbol#TYPE_TAG} and {@link Symbol#UNINITIALIZED_TYPE_TAG}) Symbol. The type symbol at index
&nbsp;   * &lt;tt&gt;i&lt;/tt&gt; has its {@link Symbol#index} equal to &lt;tt&gt;i&lt;/tt&gt; (and vice versa).
&nbsp;   */
&nbsp;  private Entry[] typeTable;
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a new, empty SymbolTable for the given ClassWriter.
&nbsp;   *
&nbsp;   * @param classWriter a ClassWriter.
&nbsp;   */
<b class="fc">&nbsp;  SymbolTable(final ClassWriter classWriter) {</b>
<b class="fc">&nbsp;    this.classWriter = classWriter;</b>
<b class="fc">&nbsp;    this.sourceClassReader = null;</b>
<b class="fc">&nbsp;    this.entries = new Entry[256];</b>
<b class="fc">&nbsp;    this.constantPoolCount = 1;</b>
<b class="fc">&nbsp;    this.constantPool = new ByteVector();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a new SymbolTable for the given ClassWriter, initialized with the constant pool and
&nbsp;   * bootstrap methods of the given ClassReader.
&nbsp;   *
&nbsp;   * @param classWriter a ClassWriter.
&nbsp;   * @param classReader the ClassReader whose constant pool and bootstrap methods must be copied to
&nbsp;   *     initialize the SymbolTable.
&nbsp;   */
<b class="nc">&nbsp;  SymbolTable(final ClassWriter classWriter, final ClassReader classReader) {</b>
<b class="nc">&nbsp;    this.classWriter = classWriter;</b>
<b class="nc">&nbsp;    this.sourceClassReader = classReader;</b>
&nbsp;
&nbsp;    // Copy the constant pool binary content.
<b class="nc">&nbsp;    byte[] inputBytes = classReader.b;</b>
<b class="nc">&nbsp;    int constantPoolOffset = classReader.getItem(1) - 1;</b>
<b class="nc">&nbsp;    int constantPoolLength = classReader.header - constantPoolOffset;</b>
<b class="nc">&nbsp;    constantPoolCount = classReader.getItemCount();</b>
<b class="nc">&nbsp;    constantPool = new ByteVector(constantPoolLength);</b>
<b class="nc">&nbsp;    constantPool.putByteArray(inputBytes, constantPoolOffset, constantPoolLength);</b>
&nbsp;
&nbsp;    // Add the constant pool items in the symbol table entries. Reserve enough space in &#39;entries&#39; to
&nbsp;    // avoid too many hash set collisions (entries is not dynamically resized by the addConstant*
&nbsp;    // method calls below), and to account for bootstrap method entries.
<b class="nc">&nbsp;    entries = new Entry[constantPoolCount * 2];</b>
<b class="nc">&nbsp;    char[] charBuffer = new char[classReader.getMaxStringLength()];</b>
<b class="nc">&nbsp;    int itemIndex = 1;</b>
<b class="nc">&nbsp;    while (itemIndex &lt; constantPoolCount) {</b>
<b class="nc">&nbsp;      int itemOffset = classReader.getItem(itemIndex);</b>
<b class="nc">&nbsp;      int itemTag = inputBytes[itemOffset - 1];</b>
&nbsp;      int nameAndTypeItemOffset;
<b class="nc">&nbsp;      switch (itemTag) {</b>
&nbsp;        case Symbol.CONSTANT_FIELDREF_TAG:
&nbsp;        case Symbol.CONSTANT_METHODREF_TAG:
&nbsp;        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:
<b class="nc">&nbsp;          nameAndTypeItemOffset =</b>
<b class="nc">&nbsp;              classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));</b>
<b class="nc">&nbsp;          addConstantMemberReference(</b>
&nbsp;              itemIndex,
&nbsp;              itemTag,
<b class="nc">&nbsp;              classReader.readClass(itemOffset, charBuffer),</b>
<b class="nc">&nbsp;              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),</b>
<b class="nc">&nbsp;              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Symbol.CONSTANT_INTEGER_TAG:
&nbsp;        case Symbol.CONSTANT_FLOAT_TAG:
<b class="nc">&nbsp;          addConstantInteger(itemIndex, itemTag, classReader.readInt(itemOffset));</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
<b class="nc">&nbsp;          addConstantNameAndType(</b>
&nbsp;              itemIndex,
<b class="nc">&nbsp;              classReader.readUTF8(itemOffset, charBuffer),</b>
<b class="nc">&nbsp;              classReader.readUTF8(itemOffset + 2, charBuffer));</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Symbol.CONSTANT_LONG_TAG:
&nbsp;        case Symbol.CONSTANT_DOUBLE_TAG:
<b class="nc">&nbsp;          addConstantLong(itemIndex, itemTag, classReader.readLong(itemOffset));</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Symbol.CONSTANT_UTF8_TAG:
<b class="nc">&nbsp;          addConstantUtf8(itemIndex, classReader.readUTF(itemIndex, charBuffer));</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Symbol.CONSTANT_METHOD_HANDLE_TAG:
<b class="nc">&nbsp;          int memberRefItemOffset =</b>
<b class="nc">&nbsp;              classReader.getItem(classReader.readUnsignedShort(itemOffset + 1));</b>
<b class="nc">&nbsp;          nameAndTypeItemOffset =</b>
<b class="nc">&nbsp;              classReader.getItem(classReader.readUnsignedShort(memberRefItemOffset + 2));</b>
<b class="nc">&nbsp;          addConstantMethodHandle(</b>
&nbsp;              itemIndex,
<b class="nc">&nbsp;              classReader.readByte(itemOffset),</b>
<b class="nc">&nbsp;              classReader.readClass(memberRefItemOffset, charBuffer),</b>
<b class="nc">&nbsp;              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),</b>
<b class="nc">&nbsp;              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Symbol.CONSTANT_DYNAMIC_TAG:
&nbsp;        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
<b class="nc">&nbsp;          nameAndTypeItemOffset =</b>
<b class="nc">&nbsp;              classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));</b>
<b class="nc">&nbsp;          addConstantDynamicOrInvokeDynamicReference(</b>
&nbsp;              itemTag,
&nbsp;              itemIndex,
<b class="nc">&nbsp;              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),</b>
<b class="nc">&nbsp;              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer),</b>
<b class="nc">&nbsp;              classReader.readUnsignedShort(itemOffset));</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Symbol.CONSTANT_STRING_TAG:
&nbsp;        case Symbol.CONSTANT_CLASS_TAG:
&nbsp;        case Symbol.CONSTANT_METHOD_TYPE_TAG:
&nbsp;        case Symbol.CONSTANT_MODULE_TAG:
&nbsp;        case Symbol.CONSTANT_PACKAGE_TAG:
<b class="nc">&nbsp;          addConstantUtf8Reference(</b>
<b class="nc">&nbsp;              itemIndex, itemTag, classReader.readUTF8(itemOffset, charBuffer));</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        default:
<b class="nc">&nbsp;          throw new IllegalArgumentException();</b>
&nbsp;      }
<b class="nc">&nbsp;      itemIndex +=</b>
&nbsp;          (itemTag == Symbol.CONSTANT_LONG_TAG || itemTag == Symbol.CONSTANT_DOUBLE_TAG) ? 2 : 1;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Copy the BootstrapMethods &#39;bootstrap_methods&#39; array binary content, if any.
<b class="nc">&nbsp;    int currentAttributeOffset = classReader.getFirstAttributeOffset();</b>
<b class="nc">&nbsp;    for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i &gt; 0; --i) {</b>
<b class="nc">&nbsp;      String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer);</b>
<b class="nc">&nbsp;      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      }
<b class="nc">&nbsp;      currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (bootstrapMethodCount &gt; 0) {</b>
&nbsp;      // Compute the offset and the length of the BootstrapMethods &#39;bootstrap_methods&#39; array.
<b class="nc">&nbsp;      int bootstrapMethodsOffset = currentAttributeOffset + 8;</b>
<b class="nc">&nbsp;      int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2;</b>
<b class="nc">&nbsp;      bootstrapMethods = new ByteVector(bootstrapMethodsLength);</b>
<b class="nc">&nbsp;      bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength);</b>
&nbsp;
&nbsp;      // Add each bootstrap method in the symbol table entries.
<b class="nc">&nbsp;      int currentOffset = bootstrapMethodsOffset;</b>
<b class="nc">&nbsp;      for (int i = 0; i &lt; bootstrapMethodCount; i++) {</b>
<b class="nc">&nbsp;        int offset = currentOffset - bootstrapMethodsOffset;</b>
<b class="nc">&nbsp;        int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        int numBootstrapArguments = classReader.readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode();</b>
<b class="nc">&nbsp;        while (numBootstrapArguments-- &gt; 0) {</b>
<b class="nc">&nbsp;          int bootstrapArgument = classReader.readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;          currentOffset += 2;</b>
<b class="nc">&nbsp;          hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode &amp; 0x7FFFFFFF));</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @return the ClassReader from which this SymbolTable was constructed, or &lt;tt&gt;null&lt;/tt&gt; if it was
&nbsp;   *     constructed from scratch.
&nbsp;   */
&nbsp;  ClassReader getSource() {
<b class="nc">&nbsp;    return sourceClassReader;</b>
&nbsp;  }
&nbsp;
&nbsp;  /** @return the major version of the class to which this symbol table belongs. */
&nbsp;  int getMajorVersion() {
<b class="fc">&nbsp;    return majorVersion;</b>
&nbsp;  }
&nbsp;
&nbsp;  /** @return the internal name of the class to which this symbol table belongs. */
&nbsp;  String getClassName() {
<b class="nc">&nbsp;    return className;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Sets the major version and the name of the class to which this symbol table belongs. Also adds
&nbsp;   * the class name to the constant pool.
&nbsp;   *
&nbsp;   * @param majorVersion a major ClassFile version number.
&nbsp;   * @param className an internal class name.
&nbsp;   * @return the constant pool index of a new or already existing Symbol with the given class name.
&nbsp;   */
&nbsp;  int setMajorVersionAndClassName(final int majorVersion, final String className) {
<b class="fc">&nbsp;    this.majorVersion = majorVersion;</b>
<b class="fc">&nbsp;    this.className = className;</b>
<b class="fc">&nbsp;    return addConstantClass(className).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  /** @return the number of items in this symbol table&#39;s constant_pool array (plus 1). */
&nbsp;  int getConstantPoolCount() {
<b class="fc">&nbsp;    return constantPoolCount;</b>
&nbsp;  }
&nbsp;
&nbsp;  /** @return the length in bytes of this symbol table&#39;s constant_pool array. */
&nbsp;  int getConstantPoolLength() {
<b class="fc">&nbsp;    return constantPool.length;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Puts this symbol table&#39;s constant_pool array in the given ByteVector, preceded by the
&nbsp;   * constant_pool_count value.
&nbsp;   *
&nbsp;   * @param output where the JVMS ClassFile&#39;s constant_pool array must be put.
&nbsp;   */
&nbsp;  void putConstantPool(final ByteVector output) {
<b class="fc">&nbsp;    output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the size in bytes of this symbol table&#39;s BootstrapMethods attribute. Also adds the
&nbsp;   * attribute name in the constant pool.
&nbsp;   *
&nbsp;   * @return the size in bytes of this symbol table&#39;s BootstrapMethods attribute.
&nbsp;   */
&nbsp;  int computeBootstrapMethodsSize() {
<b class="pc">&nbsp;    if (bootstrapMethods != null) {</b>
<b class="nc">&nbsp;      addConstantUtf8(Constants.BOOTSTRAP_METHODS);</b>
<b class="nc">&nbsp;      return 8 + bootstrapMethods.length;</b>
&nbsp;    } else {
<b class="fc">&nbsp;      return 0;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Puts this symbol table&#39;s BootstrapMethods attribute in the given ByteVector. This includes the
&nbsp;   * 6 attribute header bytes and the num_bootstrap_methods value.
&nbsp;   *
&nbsp;   * @param output where the JVMS BootstrapMethods attribute must be put.
&nbsp;   */
&nbsp;  void putBootstrapMethods(final ByteVector output) {
<b class="pc">&nbsp;    if (bootstrapMethods != null) {</b>
<b class="nc">&nbsp;      output</b>
<b class="nc">&nbsp;          .putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS))</b>
<b class="nc">&nbsp;          .putInt(bootstrapMethods.length + 2)</b>
<b class="nc">&nbsp;          .putShort(bootstrapMethodCount)</b>
<b class="nc">&nbsp;          .putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Generic symbol table entries management.
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * @param hashCode a {@link Entry#hashCode} value.
&nbsp;   * @return the list of entries which can potentially have the given hash code. The list is stored
&nbsp;   *     via the {@link Entry#next} field.
&nbsp;   */
&nbsp;  private Entry get(final int hashCode) {
<b class="fc">&nbsp;    return entries[hashCode % entries.length];</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Puts the given entry in the {@link #entries} hash set. This method does &lt;i&gt;not&lt;/i&gt; check
&nbsp;   * whether {@link #entries} already contains a similar entry or not. {@link #entries} is resized
&nbsp;   * if necessary to avoid hash collisions (multiple entries needing to be stored at the same {@link
&nbsp;   * #entries} array index) as much as possible, with reasonable memory usage.
&nbsp;   *
&nbsp;   * @param entry an Entry (which must not already be contained in {@link #entries}).
&nbsp;   * @return the given entry
&nbsp;   */
&nbsp;  private Entry put(final Entry entry) {
<b class="fc">&nbsp;    if (entryCount &gt; (entries.length * 3) / 4) {</b>
<b class="fc">&nbsp;      int currentCapacity = entries.length;</b>
<b class="fc">&nbsp;      int newCapacity = currentCapacity * 2 + 1;</b>
<b class="fc">&nbsp;      Entry[] newEntries = new Entry[newCapacity];</b>
<b class="fc">&nbsp;      for (int i = currentCapacity - 1; i &gt;= 0; --i) {</b>
<b class="fc">&nbsp;        Entry currentEntry = entries[i];</b>
<b class="fc">&nbsp;        while (currentEntry != null) {</b>
<b class="fc">&nbsp;          int newCurrentEntryIndex = currentEntry.hashCode % newCapacity;</b>
<b class="fc">&nbsp;          Entry nextEntry = currentEntry.next;</b>
<b class="fc">&nbsp;          currentEntry.next = newEntries[newCurrentEntryIndex];</b>
<b class="fc">&nbsp;          newEntries[newCurrentEntryIndex] = currentEntry;</b>
<b class="fc">&nbsp;          currentEntry = nextEntry;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;      }
<b class="fc">&nbsp;      entries = newEntries;</b>
&nbsp;    }
<b class="fc">&nbsp;    entryCount++;</b>
<b class="fc">&nbsp;    int index = entry.hashCode % entries.length;</b>
<b class="fc">&nbsp;    entry.next = entries[index];</b>
<b class="fc">&nbsp;    return entries[index] = entry;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds the given entry in the {@link #entries} hash set. This method does &lt;i&gt;not&lt;/i&gt; check
&nbsp;   * whether {@link #entries} already contains a similar entry or not, and does &lt;i&gt;not&lt;/i&gt; resize
&nbsp;   * {@link #entries} if necessary.
&nbsp;   *
&nbsp;   * @param entry an Entry (which must not already be contained in {@link #entries}).
&nbsp;   */
&nbsp;  private void add(final Entry entry) {
<b class="nc">&nbsp;    entryCount++;</b>
<b class="nc">&nbsp;    int index = entry.hashCode % entries.length;</b>
<b class="nc">&nbsp;    entry.next = entries[index];</b>
<b class="nc">&nbsp;    entries[index] = entry;</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Constant pool entries management.
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a number or string constant to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param value the value of the constant to be added to the constant pool. This parameter must be
&nbsp;   *     an {@link Integer}, {@link Byte}, {@link Character}, {@link Short}, {@link Boolean}, {@link
&nbsp;   *     Float}, {@link Long}, {@link Double}, {@link String}, {@link Type} or {@link Handle}.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstant(final Object value) {
<b class="pc">&nbsp;    if (value instanceof Integer) {</b>
<b class="nc">&nbsp;      return addConstantInteger(((Integer) value).intValue());</b>
<b class="pc">&nbsp;    } else if (value instanceof Byte) {</b>
<b class="nc">&nbsp;      return addConstantInteger(((Byte) value).intValue());</b>
<b class="pc">&nbsp;    } else if (value instanceof Character) {</b>
<b class="nc">&nbsp;      return addConstantInteger(((Character) value).charValue());</b>
<b class="pc">&nbsp;    } else if (value instanceof Short) {</b>
<b class="nc">&nbsp;      return addConstantInteger(((Short) value).intValue());</b>
<b class="pc">&nbsp;    } else if (value instanceof Boolean) {</b>
<b class="nc">&nbsp;      return addConstantInteger(((Boolean) value).booleanValue() ? 1 : 0);</b>
<b class="pc">&nbsp;    } else if (value instanceof Float) {</b>
<b class="nc">&nbsp;      return addConstantFloat(((Float) value).floatValue());</b>
<b class="fc">&nbsp;    } else if (value instanceof Long) {</b>
<b class="fc">&nbsp;      return addConstantLong(((Long) value).longValue());</b>
<b class="pc">&nbsp;    } else if (value instanceof Double) {</b>
<b class="nc">&nbsp;      return addConstantDouble(((Double) value).doubleValue());</b>
<b class="fc">&nbsp;    } else if (value instanceof String) {</b>
<b class="fc">&nbsp;      return addConstantString((String) value);</b>
<b class="pc">&nbsp;    } else if (value instanceof Type) {</b>
<b class="fc">&nbsp;      Type type = (Type) value;</b>
<b class="fc">&nbsp;      int typeSort = type.getSort();</b>
<b class="fc">&nbsp;      if (typeSort == Type.OBJECT) {</b>
<b class="fc">&nbsp;        return addConstantClass(type.getInternalName());</b>
<b class="pc">&nbsp;      } else if (typeSort == Type.METHOD) {</b>
<b class="nc">&nbsp;        return addConstantMethodType(type.getDescriptor());</b>
&nbsp;      } else { // type is a primitive or array type.
<b class="fc">&nbsp;        return addConstantClass(type.getDescriptor());</b>
&nbsp;      }
<b class="nc">&nbsp;    } else if (value instanceof Handle) {</b>
<b class="nc">&nbsp;      Handle handle = (Handle) value;</b>
<b class="nc">&nbsp;      return addConstantMethodHandle(</b>
<b class="nc">&nbsp;          handle.getTag(),</b>
<b class="nc">&nbsp;          handle.getOwner(),</b>
<b class="nc">&nbsp;          handle.getName(),</b>
<b class="nc">&nbsp;          handle.getDesc(),</b>
<b class="nc">&nbsp;          handle.isInterface());</b>
<b class="nc">&nbsp;    } else if (value instanceof ConstantDynamic) {</b>
<b class="nc">&nbsp;      ConstantDynamic constantDynamic = (ConstantDynamic) value;</b>
<b class="nc">&nbsp;      return addConstantDynamic(</b>
<b class="nc">&nbsp;          constantDynamic.getName(),</b>
<b class="nc">&nbsp;          constantDynamic.getDescriptor(),</b>
<b class="nc">&nbsp;          constantDynamic.getBootstrapMethod(),</b>
<b class="nc">&nbsp;          constantDynamic.getBootstrapMethodArguments());</b>
&nbsp;    } else {
<b class="nc">&nbsp;      throw new IllegalArgumentException(&quot;value &quot; + value);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Class_info to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param value the internal name of a class.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantClass(final String value) {
<b class="fc">&nbsp;    return addConstantUtf8Reference(Symbol.CONSTANT_CLASS_TAG, value);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param owner the internal name of a class.
&nbsp;   * @param name a field name.
&nbsp;   * @param descriptor a field descriptor.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantFieldref(final String owner, final String name, final String descriptor) {
<b class="fc">&nbsp;    return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this
&nbsp;   * symbol table. Does nothing if the constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param owner the internal name of a class.
&nbsp;   * @param name a method name.
&nbsp;   * @param descriptor a method descriptor.
&nbsp;   * @param isInterface whether owner is an interface or not.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantMethodref(
&nbsp;      final String owner, final String name, final String descriptor, final boolean isInterface) {
<b class="pc">&nbsp;    int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG;</b>
<b class="fc">&nbsp;    return addConstantMemberReference(tag, owner, name, descriptor);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to
&nbsp;   * the constant pool of this symbol table. Does nothing if the constant pool already contains a
&nbsp;   * similar item.
&nbsp;   *
&nbsp;   * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}
&nbsp;   *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.
&nbsp;   * @param owner the internal name of a class.
&nbsp;   * @param name a field or method name.
&nbsp;   * @param descriptor a field or method descriptor.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  private Entry addConstantMemberReference(
&nbsp;      final int tag, final String owner, final String name, final String descriptor) {
<b class="fc">&nbsp;    int hashCode = hash(tag, owner, name, descriptor);</b>
<b class="fc">&nbsp;    Entry entry = get(hashCode);</b>
<b class="fc">&nbsp;    while (entry != null) {</b>
<b class="fc">&nbsp;      if (entry.tag == tag</b>
&nbsp;          &amp;&amp; entry.hashCode == hashCode
<b class="pc">&nbsp;          &amp;&amp; entry.owner.equals(owner)</b>
<b class="pc">&nbsp;          &amp;&amp; entry.name.equals(name)</b>
<b class="pc">&nbsp;          &amp;&amp; entry.value.equals(descriptor)) {</b>
<b class="fc">&nbsp;        return entry;</b>
&nbsp;      }
<b class="fc">&nbsp;      entry = entry.next;</b>
&nbsp;    }
<b class="fc">&nbsp;    constantPool.put122(</b>
<b class="fc">&nbsp;        tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor));</b>
<b class="fc">&nbsp;    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info
&nbsp;   * to the constant pool of this symbol table.
&nbsp;   *
&nbsp;   * @param index the constant pool index of the new Symbol.
&nbsp;   * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}
&nbsp;   *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.
&nbsp;   * @param owner the internal name of a class.
&nbsp;   * @param name a field or method name.
&nbsp;   * @param descriptor a field or method descriptor.
&nbsp;   */
&nbsp;  private void addConstantMemberReference(
&nbsp;      final int index,
&nbsp;      final int tag,
&nbsp;      final String owner,
&nbsp;      final String name,
&nbsp;      final String descriptor) {
<b class="nc">&nbsp;    add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor)));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_String_info to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param value a string.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantString(final String value) {
<b class="fc">&nbsp;    return addConstantUtf8Reference(Symbol.CONSTANT_STRING_TAG, value);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Integer_info to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param value an int.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantInteger(final int value) {
<b class="fc">&nbsp;    return addConstantInteger(Symbol.CONSTANT_INTEGER_TAG, value);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Float_info to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param value a float.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantFloat(final float value) {
<b class="nc">&nbsp;    return addConstantInteger(Symbol.CONSTANT_FLOAT_TAG, Float.floatToRawIntBits(value));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.
&nbsp;   * Does nothing if the constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.
&nbsp;   * @param value an int or float.
&nbsp;   * @return a constant pool constant with the given tag and primitive values.
&nbsp;   */
&nbsp;  private Symbol addConstantInteger(final int tag, final int value) {
<b class="fc">&nbsp;    int hashCode = hash(tag, value);</b>
<b class="fc">&nbsp;    Entry entry = get(hashCode);</b>
<b class="fc">&nbsp;    while (entry != null) {</b>
<b class="pc">&nbsp;      if (entry.tag == tag &amp;&amp; entry.hashCode == hashCode &amp;&amp; entry.data == value) {</b>
<b class="fc">&nbsp;        return entry;</b>
&nbsp;      }
<b class="fc">&nbsp;      entry = entry.next;</b>
&nbsp;    }
<b class="fc">&nbsp;    constantPool.putByte(tag).putInt(value);</b>
<b class="fc">&nbsp;    return put(new Entry(constantPoolCount++, tag, value, hashCode));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol
&nbsp;   * table.
&nbsp;   *
&nbsp;   * @param index the constant pool index of the new Symbol.
&nbsp;   * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.
&nbsp;   * @param value an int or float.
&nbsp;   */
&nbsp;  private void addConstantInteger(final int index, final int tag, final int value) {
<b class="nc">&nbsp;    add(new Entry(index, tag, value, hash(tag, value)));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Long_info to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param value a long.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantLong(final long value) {
<b class="fc">&nbsp;    return addConstantLong(Symbol.CONSTANT_LONG_TAG, value);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Double_info to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param value a double.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantDouble(final double value) {
<b class="nc">&nbsp;    return addConstantLong(Symbol.CONSTANT_DOUBLE_TAG, Double.doubleToRawLongBits(value));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.
&nbsp;   * Does nothing if the constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.
&nbsp;   * @param value a long or double.
&nbsp;   * @return a constant pool constant with the given tag and primitive values.
&nbsp;   */
&nbsp;  private Symbol addConstantLong(final int tag, final long value) {
<b class="fc">&nbsp;    int hashCode = hash(tag, value);</b>
<b class="fc">&nbsp;    Entry entry = get(hashCode);</b>
<b class="pc">&nbsp;    while (entry != null) {</b>
<b class="nc">&nbsp;      if (entry.tag == tag &amp;&amp; entry.hashCode == hashCode &amp;&amp; entry.data == value) {</b>
<b class="nc">&nbsp;        return entry;</b>
&nbsp;      }
<b class="nc">&nbsp;      entry = entry.next;</b>
&nbsp;    }
<b class="fc">&nbsp;    int index = constantPoolCount;</b>
<b class="fc">&nbsp;    constantPool.putByte(tag).putLong(value);</b>
<b class="fc">&nbsp;    constantPoolCount += 2;</b>
<b class="fc">&nbsp;    return put(new Entry(index, tag, value, hashCode));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a new CONSTANT_Double_info to the constant pool of this symbol table.
&nbsp;   *
&nbsp;   * @param index the constant pool index of the new Symbol.
&nbsp;   * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.
&nbsp;   * @param value a long or double.
&nbsp;   */
&nbsp;  private void addConstantLong(final int index, final int tag, final long value) {
<b class="nc">&nbsp;    add(new Entry(index, tag, value, hash(tag, value)));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param name a field or method name.
&nbsp;   * @param descriptor a field or method descriptor.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  int addConstantNameAndType(final String name, final String descriptor) {
<b class="fc">&nbsp;    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;</b>
<b class="fc">&nbsp;    int hashCode = hash(tag, name, descriptor);</b>
<b class="fc">&nbsp;    Entry entry = get(hashCode);</b>
<b class="fc">&nbsp;    while (entry != null) {</b>
<b class="fc">&nbsp;      if (entry.tag == tag</b>
&nbsp;          &amp;&amp; entry.hashCode == hashCode
<b class="pc">&nbsp;          &amp;&amp; entry.name.equals(name)</b>
<b class="pc">&nbsp;          &amp;&amp; entry.value.equals(descriptor)) {</b>
<b class="fc">&nbsp;        return entry.index;</b>
&nbsp;      }
<b class="fc">&nbsp;      entry = entry.next;</b>
&nbsp;    }
<b class="fc">&nbsp;    constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor));</b>
<b class="fc">&nbsp;    return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.
&nbsp;   *
&nbsp;   * @param index the constant pool index of the new Symbol.
&nbsp;   * @param name a field or method name.
&nbsp;   * @param descriptor a field or method descriptor.
&nbsp;   */
&nbsp;  private void addConstantNameAndType(final int index, final String name, final String descriptor) {
<b class="nc">&nbsp;    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;</b>
<b class="nc">&nbsp;    add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor)));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param value a string.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  int addConstantUtf8(final String value) {
<b class="fc">&nbsp;    int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);</b>
<b class="fc">&nbsp;    Entry entry = get(hashCode);</b>
<b class="fc">&nbsp;    while (entry != null) {</b>
<b class="fc">&nbsp;      if (entry.tag == Symbol.CONSTANT_UTF8_TAG</b>
&nbsp;          &amp;&amp; entry.hashCode == hashCode
<b class="pc">&nbsp;          &amp;&amp; entry.value.equals(value)) {</b>
<b class="fc">&nbsp;        return entry.index;</b>
&nbsp;      }
<b class="fc">&nbsp;      entry = entry.next;</b>
&nbsp;    }
<b class="fc">&nbsp;    constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);</b>
<b class="fc">&nbsp;    return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a new CONSTANT_String_info to the constant pool of this symbol table.
&nbsp;   *
&nbsp;   * @param index the constant pool index of the new Symbol.
&nbsp;   * @param value a string.
&nbsp;   */
&nbsp;  private void addConstantUtf8(final int index, final String value) {
<b class="nc">&nbsp;    add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value)));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if
&nbsp;   * the constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link
&nbsp;   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link
&nbsp;   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link
&nbsp;   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
&nbsp;   * @param owner the internal name of a class of interface.
&nbsp;   * @param name a field or method name.
&nbsp;   * @param descriptor a field or method descriptor.
&nbsp;   * @param isInterface whether owner is an interface or not.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantMethodHandle(
&nbsp;      final int referenceKind,
&nbsp;      final String owner,
&nbsp;      final String name,
&nbsp;      final String descriptor,
&nbsp;      final boolean isInterface) {
<b class="nc">&nbsp;    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;</b>
&nbsp;    // Note that we don&#39;t need to include isInterface in the hash computation, because it is
&nbsp;    // redundant with owner (we can&#39;t have the same owner with different isInterface values).
<b class="nc">&nbsp;    int hashCode = hash(tag, owner, name, descriptor, referenceKind);</b>
<b class="nc">&nbsp;    Entry entry = get(hashCode);</b>
<b class="nc">&nbsp;    while (entry != null) {</b>
<b class="nc">&nbsp;      if (entry.tag == tag</b>
&nbsp;          &amp;&amp; entry.hashCode == hashCode
&nbsp;          &amp;&amp; entry.data == referenceKind
<b class="nc">&nbsp;          &amp;&amp; entry.owner.equals(owner)</b>
<b class="nc">&nbsp;          &amp;&amp; entry.name.equals(name)</b>
<b class="nc">&nbsp;          &amp;&amp; entry.value.equals(descriptor)) {</b>
<b class="nc">&nbsp;        return entry;</b>
&nbsp;      }
<b class="nc">&nbsp;      entry = entry.next;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (referenceKind &lt;= Opcodes.H_PUTSTATIC) {</b>
<b class="nc">&nbsp;      constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      constantPool.put112(</b>
<b class="nc">&nbsp;          tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index);</b>
&nbsp;    }
<b class="nc">&nbsp;    return put(</b>
&nbsp;        new Entry(constantPoolCount++, tag, owner, name, descriptor, referenceKind, hashCode));
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.
&nbsp;   *
&nbsp;   * @param index the constant pool index of the new Symbol.
&nbsp;   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link
&nbsp;   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link
&nbsp;   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link
&nbsp;   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
&nbsp;   * @param owner the internal name of a class of interface.
&nbsp;   * @param name a field or method name.
&nbsp;   * @param descriptor a field or method descriptor.
&nbsp;   */
&nbsp;  private void addConstantMethodHandle(
&nbsp;      final int index,
&nbsp;      final int referenceKind,
&nbsp;      final String owner,
&nbsp;      final String name,
&nbsp;      final String descriptor) {
<b class="nc">&nbsp;    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;</b>
<b class="nc">&nbsp;    int hashCode = hash(tag, owner, name, descriptor, referenceKind);</b>
<b class="nc">&nbsp;    add(new Entry(index, tag, owner, name, descriptor, referenceKind, hashCode));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_MethodType_info to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param methodDescriptor a method descriptor.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantMethodType(final String methodDescriptor) {
<b class="nc">&nbsp;    return addConstantUtf8Reference(Symbol.CONSTANT_METHOD_TYPE_TAG, methodDescriptor);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related
&nbsp;   * bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant
&nbsp;   * pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param name a method name.
&nbsp;   * @param descriptor a field descriptor.
&nbsp;   * @param bootstrapMethodHandle a bootstrap method handle.
&nbsp;   * @param bootstrapMethodArguments the bootstrap method arguments.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantDynamic(
&nbsp;      final String name,
&nbsp;      final String descriptor,
&nbsp;      final Handle bootstrapMethodHandle,
&nbsp;      final Object... bootstrapMethodArguments) {
<b class="nc">&nbsp;    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);</b>
<b class="nc">&nbsp;    return addConstantDynamicOrInvokeDynamicReference(</b>
&nbsp;        Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the
&nbsp;   * related bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param name a method name.
&nbsp;   * @param descriptor a method descriptor.
&nbsp;   * @param bootstrapMethodHandle a bootstrap method handle.
&nbsp;   * @param bootstrapMethodArguments the bootstrap method arguments.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantInvokeDynamic(
&nbsp;      final String name,
&nbsp;      final String descriptor,
&nbsp;      final Handle bootstrapMethodHandle,
&nbsp;      final Object... bootstrapMethodArguments) {
<b class="nc">&nbsp;    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);</b>
<b class="nc">&nbsp;    return addConstantDynamicOrInvokeDynamicReference(</b>
&nbsp;        Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol
&nbsp;   * table. Does nothing if the constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link
&nbsp;   *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.
&nbsp;   * @param name a method name.
&nbsp;   * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for
&nbsp;   *     CONSTANT_INVOKE_DYNAMIC_TAG.
&nbsp;   * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  private Symbol addConstantDynamicOrInvokeDynamicReference(
&nbsp;      final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {
<b class="nc">&nbsp;    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);</b>
<b class="nc">&nbsp;    Entry entry = get(hashCode);</b>
<b class="nc">&nbsp;    while (entry != null) {</b>
<b class="nc">&nbsp;      if (entry.tag == tag</b>
&nbsp;          &amp;&amp; entry.hashCode == hashCode
&nbsp;          &amp;&amp; entry.data == bootstrapMethodIndex
<b class="nc">&nbsp;          &amp;&amp; entry.name.equals(name)</b>
<b class="nc">&nbsp;          &amp;&amp; entry.value.equals(descriptor)) {</b>
<b class="nc">&nbsp;        return entry;</b>
&nbsp;      }
<b class="nc">&nbsp;      entry = entry.next;</b>
&nbsp;    }
<b class="nc">&nbsp;    constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor));</b>
<b class="nc">&nbsp;    return put(</b>
&nbsp;        new Entry(
&nbsp;            constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this
&nbsp;   * symbol table.
&nbsp;   *
&nbsp;   * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link
&nbsp;   *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.
&nbsp;   * @param index the constant pool index of the new Symbol.
&nbsp;   * @param name a method name.
&nbsp;   * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for
&nbsp;   *     CONSTANT_INVOKE_DYNAMIC_TAG.
&nbsp;   * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.
&nbsp;   */
&nbsp;  private void addConstantDynamicOrInvokeDynamicReference(
&nbsp;      final int tag,
&nbsp;      final int index,
&nbsp;      final String name,
&nbsp;      final String descriptor,
&nbsp;      final int bootstrapMethodIndex) {
<b class="nc">&nbsp;    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);</b>
<b class="nc">&nbsp;    add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Module_info to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param moduleName a fully qualified name (using dots) of a module.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantModule(final String moduleName) {
<b class="nc">&nbsp;    return addConstantUtf8Reference(Symbol.CONSTANT_MODULE_TAG, moduleName);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Package_info to the constant pool of this symbol table. Does nothing if the
&nbsp;   * constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param packageName the internal name of a package.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addConstantPackage(final String packageName) {
<b class="nc">&nbsp;    return addConstantUtf8Reference(Symbol.CONSTANT_PACKAGE_TAG, packageName);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,
&nbsp;   * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does
&nbsp;   * nothing if the constant pool already contains a similar item.
&nbsp;   *
&nbsp;   * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link
&nbsp;   *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link
&nbsp;   *     Symbol#CONSTANT_PACKAGE_TAG}.
&nbsp;   * @param value an internal class name, an arbitrary string, a method descriptor, a module or a
&nbsp;   *     package name, depending on tag.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  private Symbol addConstantUtf8Reference(final int tag, final String value) {
<b class="fc">&nbsp;    int hashCode = hash(tag, value);</b>
<b class="fc">&nbsp;    Entry entry = get(hashCode);</b>
<b class="fc">&nbsp;    while (entry != null) {</b>
<b class="pc">&nbsp;      if (entry.tag == tag &amp;&amp; entry.hashCode == hashCode &amp;&amp; entry.value.equals(value)) {</b>
<b class="fc">&nbsp;        return entry;</b>
&nbsp;      }
<b class="fc">&nbsp;      entry = entry.next;</b>
&nbsp;    }
<b class="fc">&nbsp;    constantPool.put12(tag, addConstantUtf8(value));</b>
<b class="fc">&nbsp;    return put(new Entry(constantPoolCount++, tag, value, hashCode));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,
&nbsp;   * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.
&nbsp;   *
&nbsp;   * @param index the constant pool index of the new Symbol.
&nbsp;   * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link
&nbsp;   *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link
&nbsp;   *     Symbol#CONSTANT_PACKAGE_TAG}.
&nbsp;   * @param value an internal class name, an arbitrary string, a method descriptor, a module or a
&nbsp;   *     package name, depending on tag.
&nbsp;   */
&nbsp;  private void addConstantUtf8Reference(final int index, final int tag, final String value) {
<b class="nc">&nbsp;    add(new Entry(index, tag, value, hash(tag, value)));</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Bootstrap method entries management.
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if
&nbsp;   * the BootstrapMethods already contains a similar bootstrap method.
&nbsp;   *
&nbsp;   * @param bootstrapMethodHandle a bootstrap method handle.
&nbsp;   * @param bootstrapMethodArguments the bootstrap method arguments.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  Symbol addBootstrapMethod(
&nbsp;      final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {
<b class="nc">&nbsp;    ByteVector bootstrapMethodsAttribute = bootstrapMethods;</b>
<b class="nc">&nbsp;    if (bootstrapMethodsAttribute == null) {</b>
<b class="nc">&nbsp;      bootstrapMethodsAttribute = bootstrapMethods = new ByteVector();</b>
&nbsp;    }
&nbsp;
&nbsp;    // The bootstrap method arguments can be Constant_Dynamic values, which reference other
&nbsp;    // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool
&nbsp;    // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified
&nbsp;    // while adding the given bootstrap method to it, in the rest of this method.
<b class="nc">&nbsp;    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {</b>
<b class="nc">&nbsp;      addConstant(bootstrapMethodArgument);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to
&nbsp;    // compare it with existing ones, and will be reverted below if there is already a similar
&nbsp;    // bootstrap method.
<b class="nc">&nbsp;    int bootstrapMethodOffset = bootstrapMethodsAttribute.length;</b>
<b class="nc">&nbsp;    bootstrapMethodsAttribute.putShort(</b>
<b class="nc">&nbsp;        addConstantMethodHandle(</b>
<b class="nc">&nbsp;                bootstrapMethodHandle.getTag(),</b>
<b class="nc">&nbsp;                bootstrapMethodHandle.getOwner(),</b>
<b class="nc">&nbsp;                bootstrapMethodHandle.getName(),</b>
<b class="nc">&nbsp;                bootstrapMethodHandle.getDesc(),</b>
<b class="nc">&nbsp;                bootstrapMethodHandle.isInterface())</b>
&nbsp;            .index);
<b class="nc">&nbsp;    int numBootstrapArguments = bootstrapMethodArguments.length;</b>
<b class="nc">&nbsp;    bootstrapMethodsAttribute.putShort(numBootstrapArguments);</b>
<b class="nc">&nbsp;    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {</b>
<b class="nc">&nbsp;      bootstrapMethodsAttribute.putShort(addConstant(bootstrapMethodArgument).index);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Compute the length and the hash code of the bootstrap method.
<b class="nc">&nbsp;    int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset;</b>
<b class="nc">&nbsp;    int hashCode = bootstrapMethodHandle.hashCode();</b>
<b class="nc">&nbsp;    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {</b>
<b class="nc">&nbsp;      hashCode ^= bootstrapMethodArgument.hashCode();</b>
&nbsp;    }
<b class="nc">&nbsp;    hashCode &amp;= 0x7FFFFFFF;</b>
&nbsp;
&nbsp;    // Add the bootstrap method to the symbol table or revert the above changes.
<b class="nc">&nbsp;    return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if
&nbsp;   * the BootstrapMethods already contains a similar bootstrap method (more precisely, reverts the
&nbsp;   * content of {@link #bootstrapMethods} to remove the last, duplicate bootstrap method).
&nbsp;   *
&nbsp;   * @param offset the offset of the last bootstrap method in {@link #bootstrapMethods}, in bytes.
&nbsp;   * @param length the length of this bootstrap method in {@link #bootstrapMethods}, in bytes.
&nbsp;   * @param hashCode the hash code of this bootstrap method.
&nbsp;   * @return a new or already existing Symbol with the given value.
&nbsp;   */
&nbsp;  private Symbol addBootstrapMethod(final int offset, final int length, final int hashCode) {
<b class="nc">&nbsp;    final byte[] bootstrapMethodsData = bootstrapMethods.data;</b>
<b class="nc">&nbsp;    Entry entry = get(hashCode);</b>
<b class="nc">&nbsp;    while (entry != null) {</b>
<b class="nc">&nbsp;      if (entry.tag == Symbol.BOOTSTRAP_METHOD_TAG &amp;&amp; entry.hashCode == hashCode) {</b>
<b class="nc">&nbsp;        int otherOffset = (int) entry.data;</b>
<b class="nc">&nbsp;        boolean isSameBootstrapMethod = true;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; length; ++i) {</b>
<b class="nc">&nbsp;          if (bootstrapMethodsData[offset + i] != bootstrapMethodsData[otherOffset + i]) {</b>
<b class="nc">&nbsp;            isSameBootstrapMethod = false;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;        if (isSameBootstrapMethod) {</b>
<b class="nc">&nbsp;          bootstrapMethods.length = offset; // Revert to old position.</b>
<b class="nc">&nbsp;          return entry;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      entry = entry.next;</b>
&nbsp;    }
<b class="nc">&nbsp;    return put(new Entry(bootstrapMethodCount++, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode));</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Type table entries management.
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * @param typeIndex a type table index.
&nbsp;   * @return the type table element whose index is given.
&nbsp;   */
&nbsp;  Symbol getType(final int typeIndex) {
<b class="nc">&nbsp;    return typeTable[typeIndex];</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a type in the type table of this symbol table. Does nothing if the type table already
&nbsp;   * contains a similar type.
&nbsp;   *
&nbsp;   * @param value an internal class name.
&nbsp;   * @return the index of a new or already existing type Symbol with the given value.
&nbsp;   */
&nbsp;  int addType(final String value) {
<b class="nc">&nbsp;    int hashCode = hash(Symbol.TYPE_TAG, value);</b>
<b class="nc">&nbsp;    Entry entry = get(hashCode);</b>
<b class="nc">&nbsp;    while (entry != null) {</b>
<b class="nc">&nbsp;      if (entry.tag == Symbol.TYPE_TAG &amp;&amp; entry.hashCode == hashCode &amp;&amp; entry.value.equals(value)) {</b>
<b class="nc">&nbsp;        return entry.index;</b>
&nbsp;      }
<b class="nc">&nbsp;      entry = entry.next;</b>
&nbsp;    }
<b class="nc">&nbsp;    return addType(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds an {@link Frame#ITEM_UNINITIALIZED} type in the type table of this symbol table. Does
&nbsp;   * nothing if the type table already contains a similar type.
&nbsp;   *
&nbsp;   * @param value an internal class name.
&nbsp;   * @param bytecodeOffset the bytecode offset of the NEW instruction that created this {@link
&nbsp;   *     Frame#ITEM_UNINITIALIZED} type value.
&nbsp;   * @return the index of a new or already existing type Symbol with the given value.
&nbsp;   */
&nbsp;  int addUninitializedType(final String value, final int bytecodeOffset) {
<b class="nc">&nbsp;    int hashCode = hash(Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset);</b>
<b class="nc">&nbsp;    Entry entry = get(hashCode);</b>
<b class="nc">&nbsp;    while (entry != null) {</b>
<b class="nc">&nbsp;      if (entry.tag == Symbol.UNINITIALIZED_TYPE_TAG</b>
&nbsp;          &amp;&amp; entry.hashCode == hashCode
&nbsp;          &amp;&amp; entry.data == bytecodeOffset
<b class="nc">&nbsp;          &amp;&amp; entry.value.equals(value)) {</b>
<b class="nc">&nbsp;        return entry.index;</b>
&nbsp;      }
<b class="nc">&nbsp;      entry = entry.next;</b>
&nbsp;    }
<b class="nc">&nbsp;    return addType(</b>
&nbsp;        new Entry(typeCount, Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset, hashCode));
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a merged type in the type table of this symbol table. Does nothing if the type table
&nbsp;   * already contains a similar type.
&nbsp;   *
&nbsp;   * @param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type
&nbsp;   *     table.
&nbsp;   * @param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type
&nbsp;   *     table.
&nbsp;   * @return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,
&nbsp;   *     corresponding to the common super class of the given types.
&nbsp;   */
&nbsp;  int addMergedType(final int typeTableIndex1, final int typeTableIndex2) {
&nbsp;    // TODO sort the arguments? The merge result should be independent of their order.
<b class="nc">&nbsp;    long data = typeTableIndex1 | (((long) typeTableIndex2) &lt;&lt; 32);</b>
<b class="nc">&nbsp;    int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2);</b>
<b class="nc">&nbsp;    Entry entry = get(hashCode);</b>
<b class="nc">&nbsp;    while (entry != null) {</b>
<b class="nc">&nbsp;      if (entry.tag == Symbol.MERGED_TYPE_TAG &amp;&amp; entry.hashCode == hashCode &amp;&amp; entry.data == data) {</b>
<b class="nc">&nbsp;        return entry.info;</b>
&nbsp;      }
<b class="nc">&nbsp;      entry = entry.next;</b>
&nbsp;    }
<b class="nc">&nbsp;    String type1 = typeTable[typeTableIndex1].value;</b>
<b class="nc">&nbsp;    String type2 = typeTable[typeTableIndex2].value;</b>
<b class="nc">&nbsp;    int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2));</b>
<b class="nc">&nbsp;    put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex;</b>
<b class="nc">&nbsp;    return commonSuperTypeIndex;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds the given type Symbol to {@link #typeTable}.
&nbsp;   *
&nbsp;   * @param entry a {@link Symbol#TYPE_TAG} or {@link Symbol#UNINITIALIZED_TYPE_TAG} type symbol.
&nbsp;   *     The index of this Symbol must be equal to the current value of {@link #typeCount}.
&nbsp;   * @return the index in {@link #typeTable} where the given type was added, which is also equal to
&nbsp;   *     entry&#39;s index by hypothesis.
&nbsp;   */
&nbsp;  private int addType(final Entry entry) {
<b class="nc">&nbsp;    if (typeTable == null) {</b>
<b class="nc">&nbsp;      typeTable = new Entry[16];</b>
&nbsp;    }
<b class="nc">&nbsp;    if (typeCount == typeTable.length) {</b>
<b class="nc">&nbsp;      Entry[] newTypeTable = new Entry[2 * typeTable.length];</b>
<b class="nc">&nbsp;      System.arraycopy(typeTable, 0, newTypeTable, 0, typeTable.length);</b>
<b class="nc">&nbsp;      typeTable = newTypeTable;</b>
&nbsp;    }
<b class="nc">&nbsp;    typeTable[typeCount++] = entry;</b>
<b class="nc">&nbsp;    return put(entry).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Static helper methods to compute hash codes.
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  private static int hash(final int tag, final int value) {
<b class="fc">&nbsp;    return 0x7FFFFFFF &amp; (tag + value);</b>
&nbsp;  }
&nbsp;
&nbsp;  private static int hash(final int tag, final long value) {
<b class="fc">&nbsp;    return 0x7FFFFFFF &amp; (tag + (int) value + (int) (value &gt;&gt;&gt; 32));</b>
&nbsp;  }
&nbsp;
&nbsp;  private static int hash(final int tag, final String value) {
<b class="fc">&nbsp;    return 0x7FFFFFFF &amp; (tag + value.hashCode());</b>
&nbsp;  }
&nbsp;
&nbsp;  private static int hash(final int tag, final String value1, final int value2) {
<b class="nc">&nbsp;    return 0x7FFFFFFF &amp; (tag + value1.hashCode() + value2);</b>
&nbsp;  }
&nbsp;
&nbsp;  private static int hash(final int tag, final String value1, final String value2) {
<b class="fc">&nbsp;    return 0x7FFFFFFF &amp; (tag + value1.hashCode() * value2.hashCode());</b>
&nbsp;  }
&nbsp;
&nbsp;  private static int hash(
&nbsp;      final int tag, final String value1, final String value2, final int value3) {
<b class="nc">&nbsp;    return 0x7FFFFFFF &amp; (tag + value1.hashCode() * value2.hashCode() * (value3 + 1));</b>
&nbsp;  }
&nbsp;
&nbsp;  private static int hash(
&nbsp;      final int tag, final String value1, final String value2, final String value3) {
<b class="fc">&nbsp;    return 0x7FFFFFFF &amp; (tag + value1.hashCode() * value2.hashCode() * value3.hashCode());</b>
&nbsp;  }
&nbsp;
&nbsp;  private static int hash(
&nbsp;      final int tag,
&nbsp;      final String value1,
&nbsp;      final String value2,
&nbsp;      final String value3,
&nbsp;      final int value4) {
<b class="nc">&nbsp;    return 0x7FFFFFFF &amp; (tag + value1.hashCode() * value2.hashCode() * value3.hashCode() * value4);</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
