


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Type</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.jar.asm</a>
</div>

<h1>Coverage Summary for Class: Type (net.bytebuddy.jar.asm)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Type</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (12/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16,2%
  </span>
  <span class="absValue">
    (34/210)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27,9%
  </span>
  <span class="absValue">
    (73/262)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;// ASM: a very small and fast Java bytecode manipulation framework
&nbsp;// Copyright (c) 2000-2011 INRIA, France Telecom
&nbsp;// All rights reserved.
&nbsp;//
&nbsp;// Redistribution and use in source and binary forms, with or without
&nbsp;// modification, are permitted provided that the following conditions
&nbsp;// are met:
&nbsp;// 1. Redistributions of source code must retain the above copyright
&nbsp;//    notice, this list of conditions and the following disclaimer.
&nbsp;// 2. Redistributions in binary form must reproduce the above copyright
&nbsp;//    notice, this list of conditions and the following disclaimer in the
&nbsp;//    documentation and/or other materials provided with the distribution.
&nbsp;// 3. Neither the name of the copyright holders nor the names of its
&nbsp;//    contributors may be used to endorse or promote products derived from
&nbsp;//    this software without specific prior written permission.
&nbsp;//
&nbsp;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
&nbsp;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
&nbsp;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
&nbsp;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
&nbsp;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
&nbsp;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
&nbsp;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
&nbsp;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
&nbsp;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
&nbsp;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
&nbsp;// THE POSSIBILITY OF SUCH DAMAGE.
&nbsp;package net.bytebuddy.jar.asm;
&nbsp;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Method;
&nbsp;
&nbsp;/**
&nbsp; * A Java field or method type. This class can be used to make it easier to manipulate type and
&nbsp; * method descriptors.
&nbsp; *
&nbsp; * @author Eric Bruneton
&nbsp; * @author Chris Nokleberg
&nbsp; */
&nbsp;public class Type {
&nbsp;
&nbsp;  /** The sort of the &lt;tt&gt;void&lt;/tt&gt; type. See {@link #getSort}. */
&nbsp;  public static final int VOID = 0;
&nbsp;
&nbsp;  /** The sort of the &lt;tt&gt;boolean&lt;/tt&gt; type. See {@link #getSort}. */
&nbsp;  public static final int BOOLEAN = 1;
&nbsp;
&nbsp;  /** The sort of the &lt;tt&gt;char&lt;/tt&gt; type. See {@link #getSort}. */
&nbsp;  public static final int CHAR = 2;
&nbsp;
&nbsp;  /** The sort of the &lt;tt&gt;byte&lt;/tt&gt; type. See {@link #getSort}. */
&nbsp;  public static final int BYTE = 3;
&nbsp;
&nbsp;  /** The sort of the &lt;tt&gt;short&lt;/tt&gt; type. See {@link #getSort}. */
&nbsp;  public static final int SHORT = 4;
&nbsp;
&nbsp;  /** The sort of the &lt;tt&gt;int&lt;/tt&gt; type. See {@link #getSort}. */
&nbsp;  public static final int INT = 5;
&nbsp;
&nbsp;  /** The sort of the &lt;tt&gt;float&lt;/tt&gt; type. See {@link #getSort}. */
&nbsp;  public static final int FLOAT = 6;
&nbsp;
&nbsp;  /** The sort of the &lt;tt&gt;long&lt;/tt&gt; type. See {@link #getSort}. */
&nbsp;  public static final int LONG = 7;
&nbsp;
&nbsp;  /** The sort of the &lt;tt&gt;double&lt;/tt&gt; type. See {@link #getSort}. */
&nbsp;  public static final int DOUBLE = 8;
&nbsp;
&nbsp;  /** The sort of array reference types. See {@link #getSort}. */
&nbsp;  public static final int ARRAY = 9;
&nbsp;
&nbsp;  /** The sort of object reference types. See {@link #getSort}. */
&nbsp;  public static final int OBJECT = 10;
&nbsp;
&nbsp;  /** The sort of method types. See {@link #getSort}. */
&nbsp;  public static final int METHOD = 11;
&nbsp;
&nbsp;  /** The (private) sort of object reference types represented with an internal name. */
&nbsp;  private static final int INTERNAL = 12;
&nbsp;
&nbsp;  /** The descriptors of the primitive types. */
&nbsp;  private static final String PRIMITIVE_DESCRIPTORS = &quot;VZCBSIFJD&quot;;
&nbsp;
&nbsp;  /** The &lt;tt&gt;void&lt;/tt&gt; type. */
<b class="fc">&nbsp;  public static final Type VOID_TYPE = new Type(VOID, PRIMITIVE_DESCRIPTORS, VOID, VOID + 1);</b>
&nbsp;
&nbsp;  /** The &lt;tt&gt;boolean&lt;/tt&gt; type. */
<b class="fc">&nbsp;  public static final Type BOOLEAN_TYPE =</b>
&nbsp;      new Type(BOOLEAN, PRIMITIVE_DESCRIPTORS, BOOLEAN, BOOLEAN + 1);
&nbsp;
&nbsp;  /** The &lt;tt&gt;char&lt;/tt&gt; type. */
<b class="fc">&nbsp;  public static final Type CHAR_TYPE = new Type(CHAR, PRIMITIVE_DESCRIPTORS, CHAR, CHAR + 1);</b>
&nbsp;
&nbsp;  /** The &lt;tt&gt;byte&lt;/tt&gt; type. */
<b class="fc">&nbsp;  public static final Type BYTE_TYPE = new Type(BYTE, PRIMITIVE_DESCRIPTORS, BYTE, BYTE + 1);</b>
&nbsp;
&nbsp;  /** The &lt;tt&gt;short&lt;/tt&gt; type. */
<b class="fc">&nbsp;  public static final Type SHORT_TYPE = new Type(SHORT, PRIMITIVE_DESCRIPTORS, SHORT, SHORT + 1);</b>
&nbsp;
&nbsp;  /** The &lt;tt&gt;int&lt;/tt&gt; type. */
<b class="fc">&nbsp;  public static final Type INT_TYPE = new Type(INT, PRIMITIVE_DESCRIPTORS, INT, INT + 1);</b>
&nbsp;
&nbsp;  /** The &lt;tt&gt;float&lt;/tt&gt; type. */
<b class="fc">&nbsp;  public static final Type FLOAT_TYPE = new Type(FLOAT, PRIMITIVE_DESCRIPTORS, FLOAT, FLOAT + 1);</b>
&nbsp;
&nbsp;  /** The &lt;tt&gt;long&lt;/tt&gt; type. */
<b class="fc">&nbsp;  public static final Type LONG_TYPE = new Type(LONG, PRIMITIVE_DESCRIPTORS, LONG, LONG + 1);</b>
&nbsp;
&nbsp;  /** The &lt;tt&gt;double&lt;/tt&gt; type. */
<b class="fc">&nbsp;  public static final Type DOUBLE_TYPE =</b>
&nbsp;      new Type(DOUBLE, PRIMITIVE_DESCRIPTORS, DOUBLE, DOUBLE + 1);
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Fields
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * The sort of this type. Either {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE},
&nbsp;   * {@link #SHORT}, {@link #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY},
&nbsp;   * {@link #OBJECT}, {@link #METHOD} or {@link #INTERNAL}.
&nbsp;   */
&nbsp;  private final int sort;
&nbsp;
&nbsp;  /**
&nbsp;   * A buffer containing the value of this field or method type. This value is an internal name for
&nbsp;   * {@link #OBJECT} and {@link #INTERNAL} types, and a field or method descriptor in the other
&nbsp;   * cases.
&nbsp;   *
&nbsp;   * &lt;p&gt;For {@link #OBJECT} types, this field also contains the descriptor: the characters in
&nbsp;   * [{@link #valueBegin},{@link #valueEnd}) contain the internal name, and those in [{@link
&nbsp;   * #valueBegin} - 1, {@link #valueEnd} + 1) contain the descriptor.
&nbsp;   */
&nbsp;  private final String valueBuffer;
&nbsp;
&nbsp;  /**
&nbsp;   * The beginning index, inclusive, of the value of this Java field or method type in {@link
&nbsp;   * #valueBuffer}. This value is an internal name for {@link #OBJECT} and {@link #INTERNAL} types,
&nbsp;   * and a field or method descriptor in the other cases.
&nbsp;   */
&nbsp;  private final int valueBegin;
&nbsp;
&nbsp;  /**
&nbsp;   * The end index, exclusive, of the value of this Java field or method type in {@link
&nbsp;   * #valueBuffer}. This value is an internal name for {@link #OBJECT} and {@link #INTERNAL} types,
&nbsp;   * and a field or method descriptor in the other cases.
&nbsp;   */
&nbsp;  private final int valueEnd;
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Constructors
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a reference type.
&nbsp;   *
&nbsp;   * @param sort the sort of this type, see {@link #sort}.
&nbsp;   * @param valueBuffer a buffer containing the value of this field or method type.
&nbsp;   * @param valueBegin the beginning index, inclusive, of the value of this field or method type in
&nbsp;   *     valueBuffer.
&nbsp;   * @param valueEnd tne end index, exclusive, of the value of this field or method type in
&nbsp;   *     valueBuffer.
&nbsp;   */
<b class="fc">&nbsp;  private Type(final int sort, final String valueBuffer, final int valueBegin, final int valueEnd) {</b>
<b class="fc">&nbsp;    this.sort = sort;</b>
<b class="fc">&nbsp;    this.valueBuffer = valueBuffer;</b>
<b class="fc">&nbsp;    this.valueBegin = valueBegin;</b>
<b class="fc">&nbsp;    this.valueEnd = valueEnd;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the {@link Type} corresponding to the given type descriptor.
&nbsp;   *
&nbsp;   * @param typeDescriptor a field or method type descriptor.
&nbsp;   * @return the {@link Type} corresponding to the given type descriptor.
&nbsp;   */
&nbsp;  public static Type getType(final String typeDescriptor) {
<b class="fc">&nbsp;    return getType(typeDescriptor, 0, typeDescriptor.length());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the {@link Type} corresponding to the given internal name.
&nbsp;   *
&nbsp;   * @param internalName an internal name.
&nbsp;   * @return the {@link Type} corresponding to the given internal name.
&nbsp;   */
&nbsp;  public static Type getObjectType(final String internalName) {
<b class="nc">&nbsp;    return new Type(</b>
<b class="nc">&nbsp;        internalName.charAt(0) == &#39;[&#39; ? ARRAY : INTERNAL, internalName, 0, internalName.length());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the {@link Type} corresponding to the given method descriptor. Equivalent to &lt;code&gt;
&nbsp;   * Type.getType(methodDescriptor)&lt;/code&gt;.
&nbsp;   *
&nbsp;   * @param methodDescriptor a method descriptor.
&nbsp;   * @return the {@link Type} corresponding to the given method descriptor.
&nbsp;   */
&nbsp;  public static Type getMethodType(final String methodDescriptor) {
<b class="nc">&nbsp;    return new Type(METHOD, methodDescriptor, 0, methodDescriptor.length());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the method {@link Type} corresponding to the given argument and return types.
&nbsp;   *
&nbsp;   * @param returnType the return type of the method.
&nbsp;   * @param argumentTypes the argument types of the method.
&nbsp;   * @return the method {@link Type} corresponding to the given argument and return types.
&nbsp;   */
&nbsp;  public static Type getMethodType(final Type returnType, final Type... argumentTypes) {
<b class="nc">&nbsp;    return getType(getMethodDescriptor(returnType, argumentTypes));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the {@link Type} corresponding to the given class.
&nbsp;   *
&nbsp;   * @param clazz a class.
&nbsp;   * @return the {@link Type} corresponding to the given class.
&nbsp;   */
&nbsp;  public static Type getType(final Class&lt;?&gt; clazz) {
<b class="nc">&nbsp;    if (clazz.isPrimitive()) {</b>
<b class="nc">&nbsp;      if (clazz == Integer.TYPE) {</b>
<b class="nc">&nbsp;        return INT_TYPE;</b>
<b class="nc">&nbsp;      } else if (clazz == Void.TYPE) {</b>
<b class="nc">&nbsp;        return VOID_TYPE;</b>
<b class="nc">&nbsp;      } else if (clazz == Boolean.TYPE) {</b>
<b class="nc">&nbsp;        return BOOLEAN_TYPE;</b>
<b class="nc">&nbsp;      } else if (clazz == Byte.TYPE) {</b>
<b class="nc">&nbsp;        return BYTE_TYPE;</b>
<b class="nc">&nbsp;      } else if (clazz == Character.TYPE) {</b>
<b class="nc">&nbsp;        return CHAR_TYPE;</b>
<b class="nc">&nbsp;      } else if (clazz == Short.TYPE) {</b>
<b class="nc">&nbsp;        return SHORT_TYPE;</b>
<b class="nc">&nbsp;      } else if (clazz == Double.TYPE) {</b>
<b class="nc">&nbsp;        return DOUBLE_TYPE;</b>
<b class="nc">&nbsp;      } else if (clazz == Float.TYPE) {</b>
<b class="nc">&nbsp;        return FLOAT_TYPE;</b>
<b class="nc">&nbsp;      } else if (clazz == Long.TYPE) {</b>
<b class="nc">&nbsp;        return LONG_TYPE;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        throw new AssertionError();</b>
&nbsp;      }
&nbsp;    } else {
<b class="nc">&nbsp;      return getType(getDescriptor(clazz));</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the method {@link Type} corresponding to the given constructor.
&nbsp;   *
&nbsp;   * @param constructor a {@link Constructor} object.
&nbsp;   * @return the method {@link Type} corresponding to the given constructor.
&nbsp;   */
&nbsp;  public static Type getType(final Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;    return getType(getConstructorDescriptor(constructor));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the method {@link Type} corresponding to the given method.
&nbsp;   *
&nbsp;   * @param method a {@link Method} object.
&nbsp;   * @return the method {@link Type} corresponding to the given method.
&nbsp;   */
&nbsp;  public static Type getType(final Method method) {
<b class="nc">&nbsp;    return getType(getMethodDescriptor(method));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the {@link Type} values corresponding to the argument types of the given method
&nbsp;   * descriptor.
&nbsp;   *
&nbsp;   * @param methodDescriptor a method descriptor.
&nbsp;   * @return the {@link Type} values corresponding to the argument types of the given method
&nbsp;   *     descriptor.
&nbsp;   */
&nbsp;  public static Type[] getArgumentTypes(final String methodDescriptor) {
&nbsp;    // First step: compute the number of argument types in methodDescriptor.
<b class="nc">&nbsp;    int numArgumentTypes = 0;</b>
&nbsp;    // Skip the first character, which is always a &#39;(&#39;.
<b class="nc">&nbsp;    int currentOffset = 1;</b>
&nbsp;    // Parse the argument types, one at a each loop iteration.
<b class="nc">&nbsp;    while (methodDescriptor.charAt(currentOffset) != &#39;)&#39;) {</b>
<b class="nc">&nbsp;      while (methodDescriptor.charAt(currentOffset) == &#39;[&#39;) {</b>
<b class="nc">&nbsp;        currentOffset++;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (methodDescriptor.charAt(currentOffset++) == &#39;L&#39;) {</b>
<b class="nc">&nbsp;        while (methodDescriptor.charAt(currentOffset++) != &#39;;&#39;) {</b>
&nbsp;          // Skip the argument descriptor content.
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      ++numArgumentTypes;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Second step: create a Type instance for each argument type.
<b class="nc">&nbsp;    Type[] argumentTypes = new Type[numArgumentTypes];</b>
&nbsp;    // Skip the first character, which is always a &#39;(&#39;.
<b class="nc">&nbsp;    currentOffset = 1;</b>
&nbsp;    // Parse and create the argument types, one at each loop iteration.
<b class="nc">&nbsp;    int currentArgumentTypeIndex = 0;</b>
<b class="nc">&nbsp;    while (methodDescriptor.charAt(currentOffset) != &#39;)&#39;) {</b>
<b class="nc">&nbsp;      final int currentArgumentTypeOffset = currentOffset;</b>
<b class="nc">&nbsp;      while (methodDescriptor.charAt(currentOffset) == &#39;[&#39;) {</b>
<b class="nc">&nbsp;        currentOffset++;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (methodDescriptor.charAt(currentOffset++) == &#39;L&#39;) {</b>
<b class="nc">&nbsp;        while (methodDescriptor.charAt(currentOffset++) != &#39;;&#39;) {</b>
&nbsp;          // Skip the argument descriptor content.
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      argumentTypes[currentArgumentTypeIndex++] =</b>
<b class="nc">&nbsp;          getType(methodDescriptor, currentArgumentTypeOffset, currentOffset);</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return argumentTypes;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the {@link Type} values corresponding to the argument types of the given method.
&nbsp;   *
&nbsp;   * @param method a method.
&nbsp;   * @return the {@link Type} values corresponding to the argument types of the given method.
&nbsp;   */
&nbsp;  public static Type[] getArgumentTypes(final Method method) {
<b class="nc">&nbsp;    Class&lt;?&gt;[] classes = method.getParameterTypes();</b>
<b class="nc">&nbsp;    Type[] types = new Type[classes.length];</b>
<b class="nc">&nbsp;    for (int i = classes.length - 1; i &gt;= 0; --i) {</b>
<b class="nc">&nbsp;      types[i] = getType(classes[i]);</b>
&nbsp;    }
<b class="nc">&nbsp;    return types;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the {@link Type} corresponding to the return type of the given method descriptor.
&nbsp;   *
&nbsp;   * @param methodDescriptor a method descriptor.
&nbsp;   * @return the {@link Type} corresponding to the return type of the given method descriptor.
&nbsp;   */
&nbsp;  public static Type getReturnType(final String methodDescriptor) {
&nbsp;    // Skip the first character, which is always a &#39;(&#39;.
<b class="nc">&nbsp;    int currentOffset = 1;</b>
&nbsp;    // Skip the argument types, one at a each loop iteration.
<b class="nc">&nbsp;    while (methodDescriptor.charAt(currentOffset) != &#39;)&#39;) {</b>
<b class="nc">&nbsp;      while (methodDescriptor.charAt(currentOffset) == &#39;[&#39;) {</b>
<b class="nc">&nbsp;        currentOffset++;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (methodDescriptor.charAt(currentOffset++) == &#39;L&#39;) {</b>
<b class="nc">&nbsp;        while (methodDescriptor.charAt(currentOffset++) != &#39;;&#39;) {</b>
&nbsp;          // Skip the argument descriptor content.
&nbsp;        }
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return getType(methodDescriptor, currentOffset + 1, methodDescriptor.length());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the {@link Type} corresponding to the return type of the given method.
&nbsp;   *
&nbsp;   * @param method a method.
&nbsp;   * @return the {@link Type} corresponding to the return type of the given method.
&nbsp;   */
&nbsp;  public static Type getReturnType(final Method method) {
<b class="nc">&nbsp;    return getType(method.getReturnType());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Computes the size of the arguments and of the return value of a method.
&nbsp;   *
&nbsp;   * @param methodDescriptor a method descriptor.
&nbsp;   * @return the size of the arguments of the method (plus one for the implicit this argument),
&nbsp;   *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =
&nbsp;   *     &lt;tt&gt;(argumentsSize &amp;lt;&amp;lt; 2) | returnSize&lt;/tt&gt; (argumentsSize is therefore equal to &lt;tt&gt;i
&nbsp;   *     &amp;gt;&amp;gt; 2&lt;/tt&gt;, and returnSize to &lt;tt&gt;i &amp;amp; 0x03&lt;/tt&gt;).
&nbsp;   */
&nbsp;  public static int getArgumentsAndReturnSizes(final String methodDescriptor) {
<b class="nc">&nbsp;    int argumentsSize = 1;</b>
&nbsp;    // Skip the first character, which is always a &#39;(&#39;.
<b class="nc">&nbsp;    int currentOffset = 1;</b>
<b class="nc">&nbsp;    int currentChar = methodDescriptor.charAt(currentOffset);</b>
&nbsp;    // Parse the argument types and compute their size, one at a each loop iteration.
<b class="nc">&nbsp;    while (currentChar != &#39;)&#39;) {</b>
<b class="nc">&nbsp;      if (currentChar == &#39;J&#39; || currentChar == &#39;D&#39;) {</b>
<b class="nc">&nbsp;        currentOffset++;</b>
<b class="nc">&nbsp;        argumentsSize += 2;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        while (methodDescriptor.charAt(currentOffset) == &#39;[&#39;) {</b>
<b class="nc">&nbsp;          currentOffset++;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (methodDescriptor.charAt(currentOffset++) == &#39;L&#39;) {</b>
<b class="nc">&nbsp;          while (methodDescriptor.charAt(currentOffset++) != &#39;;&#39;) {</b>
&nbsp;            // Skip the argument descriptor content.
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;        argumentsSize += 1;</b>
&nbsp;      }
<b class="nc">&nbsp;      currentChar = methodDescriptor.charAt(currentOffset);</b>
&nbsp;    }
<b class="nc">&nbsp;    currentChar = methodDescriptor.charAt(currentOffset + 1);</b>
<b class="nc">&nbsp;    if (currentChar == &#39;V&#39;) {</b>
<b class="nc">&nbsp;      return argumentsSize &lt;&lt; 2;</b>
&nbsp;    } else {
<b class="nc">&nbsp;      int returnSize = (currentChar == &#39;J&#39; || currentChar == &#39;D&#39;) ? 2 : 1;</b>
<b class="nc">&nbsp;      return argumentsSize &lt;&lt; 2 | returnSize;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the {@link Type} corresponding to the given field or method descriptor.
&nbsp;   *
&nbsp;   * @param descriptorBuffer a buffer containing the field or method descriptor.
&nbsp;   * @param descriptorBegin the beginning index, inclusive, of the field or method descriptor in
&nbsp;   *     descriptorBuffer.
&nbsp;   * @param descriptorEnd the end index, exclusive, of the field or method descriptor in
&nbsp;   *     descriptorBuffer.
&nbsp;   * @return the {@link Type} corresponding to the given type descriptor.
&nbsp;   */
&nbsp;  private static Type getType(
&nbsp;      final String descriptorBuffer, final int descriptorBegin, final int descriptorEnd) {
<b class="pc">&nbsp;    switch (descriptorBuffer.charAt(descriptorBegin)) {</b>
&nbsp;      case &#39;V&#39;:
<b class="nc">&nbsp;        return VOID_TYPE;</b>
&nbsp;      case &#39;Z&#39;:
<b class="nc">&nbsp;        return BOOLEAN_TYPE;</b>
&nbsp;      case &#39;C&#39;:
<b class="nc">&nbsp;        return CHAR_TYPE;</b>
&nbsp;      case &#39;B&#39;:
<b class="nc">&nbsp;        return BYTE_TYPE;</b>
&nbsp;      case &#39;S&#39;:
<b class="nc">&nbsp;        return SHORT_TYPE;</b>
&nbsp;      case &#39;I&#39;:
<b class="nc">&nbsp;        return INT_TYPE;</b>
&nbsp;      case &#39;F&#39;:
<b class="nc">&nbsp;        return FLOAT_TYPE;</b>
&nbsp;      case &#39;J&#39;:
<b class="nc">&nbsp;        return LONG_TYPE;</b>
&nbsp;      case &#39;D&#39;:
<b class="nc">&nbsp;        return DOUBLE_TYPE;</b>
&nbsp;      case &#39;[&#39;:
<b class="fc">&nbsp;        return new Type(ARRAY, descriptorBuffer, descriptorBegin, descriptorEnd);</b>
&nbsp;      case &#39;L&#39;:
<b class="fc">&nbsp;        return new Type(OBJECT, descriptorBuffer, descriptorBegin + 1, descriptorEnd - 1);</b>
&nbsp;      case &#39;(&#39;:
<b class="nc">&nbsp;        return new Type(METHOD, descriptorBuffer, descriptorBegin, descriptorEnd);</b>
&nbsp;      default:
<b class="nc">&nbsp;        throw new IllegalArgumentException();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Accessors
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the sort of this type.
&nbsp;   *
&nbsp;   * @return {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE}, {@link #SHORT}, {@link
&nbsp;   *     #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY}, {@link #OBJECT} or
&nbsp;   *     {@link #METHOD}.
&nbsp;   */
&nbsp;  public int getSort() {
<b class="pc">&nbsp;    return sort == INTERNAL ? OBJECT : sort;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the number of dimensions of this array type. This method should only be used for an
&nbsp;   * array type.
&nbsp;   *
&nbsp;   * @return the number of dimensions of this array type.
&nbsp;   */
&nbsp;  public int getDimensions() {
<b class="nc">&nbsp;    int numDimensions = 1;</b>
<b class="nc">&nbsp;    while (valueBuffer.charAt(valueBegin + numDimensions) == &#39;[&#39;) {</b>
<b class="nc">&nbsp;      numDimensions++;</b>
&nbsp;    }
<b class="nc">&nbsp;    return numDimensions;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the type of the elements of this array type. This method should only be used for an
&nbsp;   * array type.
&nbsp;   *
&nbsp;   * @return Returns the type of the elements of this array type.
&nbsp;   */
&nbsp;  public Type getElementType() {
<b class="nc">&nbsp;    final int numDimensions = getDimensions();</b>
<b class="nc">&nbsp;    return getType(valueBuffer, valueBegin + numDimensions, valueEnd);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the binary name of the class corresponding to this type. This method must not be used
&nbsp;   * on method types.
&nbsp;   *
&nbsp;   * @return the binary name of the class corresponding to this type.
&nbsp;   */
&nbsp;  public String getClassName() {
<b class="nc">&nbsp;    switch (sort) {</b>
&nbsp;      case VOID:
<b class="nc">&nbsp;        return &quot;void&quot;;</b>
&nbsp;      case BOOLEAN:
<b class="nc">&nbsp;        return &quot;boolean&quot;;</b>
&nbsp;      case CHAR:
<b class="nc">&nbsp;        return &quot;char&quot;;</b>
&nbsp;      case BYTE:
<b class="nc">&nbsp;        return &quot;byte&quot;;</b>
&nbsp;      case SHORT:
<b class="nc">&nbsp;        return &quot;short&quot;;</b>
&nbsp;      case INT:
<b class="nc">&nbsp;        return &quot;int&quot;;</b>
&nbsp;      case FLOAT:
<b class="nc">&nbsp;        return &quot;float&quot;;</b>
&nbsp;      case LONG:
<b class="nc">&nbsp;        return &quot;long&quot;;</b>
&nbsp;      case DOUBLE:
<b class="nc">&nbsp;        return &quot;double&quot;;</b>
&nbsp;      case ARRAY:
<b class="nc">&nbsp;        StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName());</b>
<b class="nc">&nbsp;        for (int i = getDimensions(); i &gt; 0; --i) {</b>
<b class="nc">&nbsp;          stringBuilder.append(&quot;[]&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return stringBuilder.toString();</b>
&nbsp;      case OBJECT:
&nbsp;      case INTERNAL:
<b class="nc">&nbsp;        return valueBuffer.substring(valueBegin, valueEnd).replace(&#39;/&#39;, &#39;.&#39;);</b>
&nbsp;      default:
<b class="nc">&nbsp;        throw new AssertionError();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the internal name of the class corresponding to this object or array type. The internal
&nbsp;   * name of a class is its fully qualified name (as returned by Class.getName(), where &#39;.&#39; are
&nbsp;   * replaced by &#39;/&#39;). This method should only be used for an object or array type.
&nbsp;   *
&nbsp;   * @return the internal name of the class corresponding to this object type.
&nbsp;   */
&nbsp;  public String getInternalName() {
<b class="fc">&nbsp;    return valueBuffer.substring(valueBegin, valueEnd);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the argument types of methods of this type. This method should only be used for method
&nbsp;   * types.
&nbsp;   *
&nbsp;   * @return the argument types of methods of this type.
&nbsp;   */
&nbsp;  public Type[] getArgumentTypes() {
<b class="nc">&nbsp;    return getArgumentTypes(getDescriptor());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the return type of methods of this type. This method should only be used for method
&nbsp;   * types.
&nbsp;   *
&nbsp;   * @return the return type of methods of this type.
&nbsp;   */
&nbsp;  public Type getReturnType() {
<b class="nc">&nbsp;    return getReturnType(getDescriptor());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the size of the arguments and of the return value of methods of this type. This method
&nbsp;   * should only be used for method types.
&nbsp;   *
&nbsp;   * @return the size of the arguments of the method (plus one for the implicit this argument),
&nbsp;   *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =
&nbsp;   *     &lt;tt&gt;(argumentsSize &amp;lt;&amp;lt; 2) | returnSize&lt;/tt&gt; (argumentsSize is therefore equal to &lt;tt&gt;i
&nbsp;   *     &amp;gt;&amp;gt; 2&lt;/tt&gt;, and returnSize to &lt;tt&gt;i &amp;amp; 0x03&lt;/tt&gt;).
&nbsp;   */
&nbsp;  public int getArgumentsAndReturnSizes() {
<b class="nc">&nbsp;    return getArgumentsAndReturnSizes(getDescriptor());</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Conversion to type descriptors
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the descriptor corresponding to this type.
&nbsp;   *
&nbsp;   * @return the descriptor corresponding to this type.
&nbsp;   */
&nbsp;  public String getDescriptor() {
<b class="pc">&nbsp;    if (sort == OBJECT) {</b>
<b class="nc">&nbsp;      return valueBuffer.substring(valueBegin - 1, valueEnd + 1);</b>
<b class="pc">&nbsp;    } else if (sort == INTERNAL) {</b>
<b class="nc">&nbsp;      StringBuilder stringBuilder = new StringBuilder();</b>
<b class="nc">&nbsp;      stringBuilder.append(&#39;L&#39;);</b>
<b class="nc">&nbsp;      stringBuilder.append(valueBuffer, valueBegin, valueEnd);</b>
<b class="nc">&nbsp;      stringBuilder.append(&#39;;&#39;);</b>
<b class="nc">&nbsp;      return stringBuilder.toString();</b>
&nbsp;    } else {
<b class="fc">&nbsp;      return valueBuffer.substring(valueBegin, valueEnd);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the descriptor corresponding to the given argument and return types.
&nbsp;   *
&nbsp;   * @param returnType the return type of the method.
&nbsp;   * @param argumentTypes the argument types of the method.
&nbsp;   * @return the descriptor corresponding to the given argument and return types.
&nbsp;   */
&nbsp;  public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) {
<b class="nc">&nbsp;    StringBuilder stringBuilder = new StringBuilder();</b>
<b class="nc">&nbsp;    stringBuilder.append(&#39;(&#39;);</b>
<b class="nc">&nbsp;    for (int i = 0; i &lt; argumentTypes.length; ++i) {</b>
<b class="nc">&nbsp;      argumentTypes[i].appendDescriptor(stringBuilder);</b>
&nbsp;    }
<b class="nc">&nbsp;    stringBuilder.append(&#39;)&#39;);</b>
<b class="nc">&nbsp;    returnType.appendDescriptor(stringBuilder);</b>
<b class="nc">&nbsp;    return stringBuilder.toString();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Appends the descriptor corresponding to this type to the given string buffer.
&nbsp;   *
&nbsp;   * @param stringBuilder the string builder to which the descriptor must be appended.
&nbsp;   */
&nbsp;  private void appendDescriptor(final StringBuilder stringBuilder) {
<b class="nc">&nbsp;    if (sort == OBJECT) {</b>
<b class="nc">&nbsp;      stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1);</b>
<b class="nc">&nbsp;    } else if (sort == INTERNAL) {</b>
<b class="nc">&nbsp;      stringBuilder.append(&#39;L&#39;);</b>
<b class="nc">&nbsp;      stringBuilder.append(valueBuffer, valueBegin, valueEnd);</b>
<b class="nc">&nbsp;      stringBuilder.append(&#39;;&#39;);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      stringBuilder.append(valueBuffer, valueBegin, valueEnd);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Direct conversion from classes to type descriptors,
&nbsp;  // without intermediate Type objects
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the internal name of the given class. The internal name of a class is its fully
&nbsp;   * qualified name, as returned by Class.getName(), where &#39;.&#39; are replaced by &#39;/&#39;.
&nbsp;   *
&nbsp;   * @param clazz an object or array class.
&nbsp;   * @return the internal name of the given class.
&nbsp;   */
&nbsp;  public static String getInternalName(final Class&lt;?&gt; clazz) {
<b class="fc">&nbsp;    return clazz.getName().replace(&#39;.&#39;, &#39;/&#39;);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the descriptor corresponding to the given class.
&nbsp;   *
&nbsp;   * @param clazz an object class, a primitive class or an array class.
&nbsp;   * @return the descriptor corresponding to the given class.
&nbsp;   */
&nbsp;  public static String getDescriptor(final Class&lt;?&gt; clazz) {
<b class="fc">&nbsp;    StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;    appendDescriptor(stringBuilder, clazz);</b>
<b class="fc">&nbsp;    return stringBuilder.toString();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the descriptor corresponding to the given constructor.
&nbsp;   *
&nbsp;   * @param constructor a {@link Constructor} object.
&nbsp;   * @return the descriptor of the given constructor.
&nbsp;   */
&nbsp;  public static String getConstructorDescriptor(final Constructor&lt;?&gt; constructor) {
<b class="fc">&nbsp;    StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;    stringBuilder.append(&#39;(&#39;);</b>
<b class="fc">&nbsp;    Class&lt;?&gt;[] parameters = constructor.getParameterTypes();</b>
<b class="fc">&nbsp;    for (int i = 0; i &lt; parameters.length; ++i) {</b>
<b class="fc">&nbsp;      appendDescriptor(stringBuilder, parameters[i]);</b>
&nbsp;    }
<b class="fc">&nbsp;    return stringBuilder.append(&quot;)V&quot;).toString();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the descriptor corresponding to the given method.
&nbsp;   *
&nbsp;   * @param method a {@link Method} object.
&nbsp;   * @return the descriptor of the given method.
&nbsp;   */
&nbsp;  public static String getMethodDescriptor(final Method method) {
<b class="fc">&nbsp;    StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;    stringBuilder.append(&#39;(&#39;);</b>
<b class="fc">&nbsp;    Class&lt;?&gt;[] parameters = method.getParameterTypes();</b>
<b class="fc">&nbsp;    for (int i = 0; i &lt; parameters.length; ++i) {</b>
<b class="fc">&nbsp;      appendDescriptor(stringBuilder, parameters[i]);</b>
&nbsp;    }
<b class="fc">&nbsp;    stringBuilder.append(&#39;)&#39;);</b>
<b class="fc">&nbsp;    appendDescriptor(stringBuilder, method.getReturnType());</b>
<b class="fc">&nbsp;    return stringBuilder.toString();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Appends the descriptor of the given class to the given string builder.
&nbsp;   *
&nbsp;   * @param stringBuilder the string builder to which the descriptor must be appended.
&nbsp;   * @param clazz the class whose descriptor must be computed.
&nbsp;   */
&nbsp;  private static void appendDescriptor(final StringBuilder stringBuilder, final Class&lt;?&gt; clazz) {
<b class="fc">&nbsp;    Class&lt;?&gt; currentClass = clazz;</b>
<b class="fc">&nbsp;    while (currentClass.isArray()) {</b>
<b class="fc">&nbsp;      stringBuilder.append(&#39;[&#39;);</b>
<b class="fc">&nbsp;      currentClass = currentClass.getComponentType();</b>
&nbsp;    }
<b class="fc">&nbsp;    if (currentClass.isPrimitive()) {</b>
&nbsp;      char descriptor;
<b class="fc">&nbsp;      if (currentClass == Integer.TYPE) {</b>
<b class="fc">&nbsp;        descriptor = &#39;I&#39;;</b>
<b class="fc">&nbsp;      } else if (currentClass == Void.TYPE) {</b>
<b class="fc">&nbsp;        descriptor = &#39;V&#39;;</b>
<b class="fc">&nbsp;      } else if (currentClass == Boolean.TYPE) {</b>
<b class="fc">&nbsp;        descriptor = &#39;Z&#39;;</b>
<b class="fc">&nbsp;      } else if (currentClass == Byte.TYPE) {</b>
<b class="fc">&nbsp;        descriptor = &#39;B&#39;;</b>
<b class="fc">&nbsp;      } else if (currentClass == Character.TYPE) {</b>
<b class="fc">&nbsp;        descriptor = &#39;C&#39;;</b>
<b class="fc">&nbsp;      } else if (currentClass == Short.TYPE) {</b>
<b class="fc">&nbsp;        descriptor = &#39;S&#39;;</b>
<b class="fc">&nbsp;      } else if (currentClass == Double.TYPE) {</b>
<b class="fc">&nbsp;        descriptor = &#39;D&#39;;</b>
<b class="fc">&nbsp;      } else if (currentClass == Float.TYPE) {</b>
<b class="fc">&nbsp;        descriptor = &#39;F&#39;;</b>
<b class="pc">&nbsp;      } else if (currentClass == Long.TYPE) {</b>
<b class="fc">&nbsp;        descriptor = &#39;J&#39;;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        throw new AssertionError();</b>
&nbsp;      }
<b class="fc">&nbsp;      stringBuilder.append(descriptor);</b>
<b class="fc">&nbsp;    } else {</b>
<b class="fc">&nbsp;      stringBuilder.append(&#39;L&#39;);</b>
<b class="fc">&nbsp;      String name = currentClass.getName();</b>
<b class="fc">&nbsp;      int nameLength = name.length();</b>
<b class="fc">&nbsp;      for (int i = 0; i &lt; nameLength; ++i) {</b>
<b class="fc">&nbsp;        char car = name.charAt(i);</b>
<b class="fc">&nbsp;        stringBuilder.append(car == &#39;.&#39; ? &#39;/&#39; : car);</b>
&nbsp;      }
<b class="fc">&nbsp;      stringBuilder.append(&#39;;&#39;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Corresponding size and opcodes
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the size of values of this type. This method must not be used for method types.
&nbsp;   *
&nbsp;   * @return the size of values of this type, i.e., 2 for &lt;tt&gt;long&lt;/tt&gt; and &lt;tt&gt;double&lt;/tt&gt;, 0 for
&nbsp;   *     &lt;tt&gt;void&lt;/tt&gt; and 1 otherwise.
&nbsp;   */
&nbsp;  public int getSize() {
<b class="nc">&nbsp;    switch (sort) {</b>
&nbsp;      case VOID:
<b class="nc">&nbsp;        return 0;</b>
&nbsp;      case BOOLEAN:
&nbsp;      case CHAR:
&nbsp;      case BYTE:
&nbsp;      case SHORT:
&nbsp;      case INT:
&nbsp;      case FLOAT:
&nbsp;      case ARRAY:
&nbsp;      case OBJECT:
&nbsp;      case INTERNAL:
<b class="nc">&nbsp;        return 1;</b>
&nbsp;      case LONG:
&nbsp;      case DOUBLE:
<b class="nc">&nbsp;        return 2;</b>
&nbsp;      default:
<b class="nc">&nbsp;        throw new AssertionError();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns a JVM instruction opcode adapted to this {@link Type}. This method must not be used for
&nbsp;   * method types.
&nbsp;   *
&nbsp;   * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD, ISTORE, IALOAD,
&nbsp;   *     IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL, ISHR, IUSHR, IAND, IOR, IXOR and
&nbsp;   *     IRETURN.
&nbsp;   * @return an opcode that is similar to the given opcode, but adapted to this {@link Type}. For
&nbsp;   *     example, if this type is &lt;tt&gt;float&lt;/tt&gt; and &lt;tt&gt;opcode&lt;/tt&gt; is IRETURN, this method returns
&nbsp;   *     FRETURN.
&nbsp;   */
&nbsp;  public int getOpcode(final int opcode) {
<b class="nc">&nbsp;    if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {</b>
<b class="nc">&nbsp;      switch (sort) {</b>
&nbsp;        case BOOLEAN:
&nbsp;        case BYTE:
<b class="nc">&nbsp;          return opcode + (Opcodes.BALOAD - Opcodes.IALOAD);</b>
&nbsp;        case CHAR:
<b class="nc">&nbsp;          return opcode + (Opcodes.CALOAD - Opcodes.IALOAD);</b>
&nbsp;        case SHORT:
<b class="nc">&nbsp;          return opcode + (Opcodes.SALOAD - Opcodes.IALOAD);</b>
&nbsp;        case INT:
<b class="nc">&nbsp;          return opcode;</b>
&nbsp;        case FLOAT:
<b class="nc">&nbsp;          return opcode + (Opcodes.FALOAD - Opcodes.IALOAD);</b>
&nbsp;        case LONG:
<b class="nc">&nbsp;          return opcode + (Opcodes.LALOAD - Opcodes.IALOAD);</b>
&nbsp;        case DOUBLE:
<b class="nc">&nbsp;          return opcode + (Opcodes.DALOAD - Opcodes.IALOAD);</b>
&nbsp;        case ARRAY:
&nbsp;        case OBJECT:
&nbsp;        case INTERNAL:
<b class="nc">&nbsp;          return opcode + (Opcodes.AALOAD - Opcodes.IALOAD);</b>
&nbsp;        case METHOD:
&nbsp;        case VOID:
<b class="nc">&nbsp;          throw new UnsupportedOperationException();</b>
&nbsp;        default:
<b class="nc">&nbsp;          throw new AssertionError();</b>
&nbsp;      }
&nbsp;    } else {
<b class="nc">&nbsp;      switch (sort) {</b>
&nbsp;        case VOID:
<b class="nc">&nbsp;          if (opcode != Opcodes.IRETURN) {</b>
<b class="nc">&nbsp;            throw new UnsupportedOperationException();</b>
&nbsp;          }
<b class="nc">&nbsp;          return Opcodes.RETURN;</b>
&nbsp;        case BOOLEAN:
&nbsp;        case BYTE:
&nbsp;        case CHAR:
&nbsp;        case SHORT:
&nbsp;        case INT:
<b class="nc">&nbsp;          return opcode;</b>
&nbsp;        case FLOAT:
<b class="nc">&nbsp;          return opcode + (Opcodes.FRETURN - Opcodes.IRETURN);</b>
&nbsp;        case LONG:
<b class="nc">&nbsp;          return opcode + (Opcodes.LRETURN - Opcodes.IRETURN);</b>
&nbsp;        case DOUBLE:
<b class="nc">&nbsp;          return opcode + (Opcodes.DRETURN - Opcodes.IRETURN);</b>
&nbsp;        case ARRAY:
&nbsp;        case OBJECT:
&nbsp;        case INTERNAL:
<b class="nc">&nbsp;          if (opcode != Opcodes.ILOAD &amp;&amp; opcode != Opcodes.ISTORE &amp;&amp; opcode != Opcodes.IRETURN) {</b>
<b class="nc">&nbsp;            throw new UnsupportedOperationException();</b>
&nbsp;          }
<b class="nc">&nbsp;          return opcode + (Opcodes.ARETURN - Opcodes.IRETURN);</b>
&nbsp;        case METHOD:
<b class="nc">&nbsp;          throw new UnsupportedOperationException();</b>
&nbsp;        default:
<b class="nc">&nbsp;          throw new AssertionError();</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Equals, hashCode and toString
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Tests if the given object is equal to this type.
&nbsp;   *
&nbsp;   * @param object the object to be compared to this type.
&nbsp;   * @return &lt;tt&gt;true&lt;/tt&gt; if the given object is equal to this type.
&nbsp;   */
&nbsp;  @Override
&nbsp;  public boolean equals(final Object object) {
<b class="nc">&nbsp;    if (this == object) {</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (!(object instanceof Type)) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="nc">&nbsp;    Type other = (Type) object;</b>
<b class="nc">&nbsp;    if ((sort == INTERNAL ? OBJECT : sort) != (other.sort == INTERNAL ? OBJECT : other.sort)) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="nc">&nbsp;    int begin = valueBegin;</b>
<b class="nc">&nbsp;    int end = valueEnd;</b>
<b class="nc">&nbsp;    int otherBegin = other.valueBegin;</b>
<b class="nc">&nbsp;    int otherEnd = other.valueEnd;</b>
&nbsp;    // Compare the values.
<b class="nc">&nbsp;    if (end - begin != otherEnd - otherBegin) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="nc">&nbsp;    for (int i = begin, j = otherBegin; i &lt; end; i++, j++) {</b>
<b class="nc">&nbsp;      if (valueBuffer.charAt(i) != other.valueBuffer.charAt(j)) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return true;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns a hash code value for this type.
&nbsp;   *
&nbsp;   * @return a hash code value for this type.
&nbsp;   */
&nbsp;  @Override
&nbsp;  public int hashCode() {
<b class="nc">&nbsp;    int hashCode = 13 * (sort == INTERNAL ? OBJECT : sort);</b>
<b class="nc">&nbsp;    if (sort &gt;= ARRAY) {</b>
<b class="nc">&nbsp;      for (int i = valueBegin, end = valueEnd; i &lt; end; i++) {</b>
<b class="nc">&nbsp;        hashCode = 17 * (hashCode + valueBuffer.charAt(i));</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return hashCode;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns a string representation of this type.
&nbsp;   *
&nbsp;   * @return the descriptor of this type.
&nbsp;   */
&nbsp;  @Override
&nbsp;  public String toString() {
<b class="nc">&nbsp;    return getDescriptor();</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
