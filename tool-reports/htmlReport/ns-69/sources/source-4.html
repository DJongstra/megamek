


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > ClassReader</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.jar.asm</a>
</div>

<h1>Coverage Summary for Class: ClassReader (net.bytebuddy.jar.asm)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ClassReader</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/47)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1292)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1371)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;// ASM: a very small and fast Java bytecode manipulation framework
&nbsp;// Copyright (c) 2000-2011 INRIA, France Telecom
&nbsp;// All rights reserved.
&nbsp;//
&nbsp;// Redistribution and use in source and binary forms, with or without
&nbsp;// modification, are permitted provided that the following conditions
&nbsp;// are met:
&nbsp;// 1. Redistributions of source code must retain the above copyright
&nbsp;//    notice, this list of conditions and the following disclaimer.
&nbsp;// 2. Redistributions in binary form must reproduce the above copyright
&nbsp;//    notice, this list of conditions and the following disclaimer in the
&nbsp;//    documentation and/or other materials provided with the distribution.
&nbsp;// 3. Neither the name of the copyright holders nor the names of its
&nbsp;//    contributors may be used to endorse or promote products derived from
&nbsp;//    this software without specific prior written permission.
&nbsp;//
&nbsp;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
&nbsp;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
&nbsp;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
&nbsp;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
&nbsp;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
&nbsp;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
&nbsp;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
&nbsp;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
&nbsp;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
&nbsp;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
&nbsp;// THE POSSIBILITY OF SUCH DAMAGE.
&nbsp;package net.bytebuddy.jar.asm;
&nbsp;
&nbsp;import java.io.ByteArrayOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;
&nbsp;/**
&nbsp; * A parser to make a {@link ClassVisitor} visit a ClassFile structure, as defined in the Java
&nbsp; * Virtual Machine Specification (JVMS). This class parses the ClassFile content and calls the
&nbsp; * appropriate visit methods of a given {@link ClassVisitor} for each field, method and bytecode
&nbsp; * instruction encountered.
&nbsp; *
&nbsp; * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html&quot;&gt;JVMS 4&lt;/a&gt;
&nbsp; * @author Eric Bruneton
&nbsp; * @author Eugene Kuleshov
&nbsp; */
&nbsp;public class ClassReader {
&nbsp;
&nbsp;  /**
&nbsp;   * A flag to skip the Code attributes. If this flag is set the Code attributes are neither parsed
&nbsp;   * nor visited.
&nbsp;   */
&nbsp;  public static final int SKIP_CODE = 1;
&nbsp;
&nbsp;  /**
&nbsp;   * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable
&nbsp;   * and LineNumberTable attributes. If this flag is set these attributes are neither parsed nor
&nbsp;   * visited (i.e. {@link ClassVisitor#visitSource}, {@link MethodVisitor#visitLocalVariable} and
&nbsp;   * {@link MethodVisitor#visitLineNumber} are not called).
&nbsp;   */
&nbsp;  public static final int SKIP_DEBUG = 2;
&nbsp;
&nbsp;  /**
&nbsp;   * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes
&nbsp;   * are neither parsed nor visited (i.e. {@link MethodVisitor#visitFrame} is not called). This flag
&nbsp;   * is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is used: it avoids visiting frames
&nbsp;   * that will be ignored and recomputed from scratch.
&nbsp;   */
&nbsp;  public static final int SKIP_FRAMES = 4;
&nbsp;
&nbsp;  /**
&nbsp;   * A flag to expand the stack map frames. By default stack map frames are visited in their
&nbsp;   * original format (i.e. &quot;expanded&quot; for classes whose version is less than V1_6, and &quot;compressed&quot;
&nbsp;   * for the other classes). If this flag is set, stack map frames are always visited in expanded
&nbsp;   * format (this option adds a decompression/compression step in ClassReader and ClassWriter which
&nbsp;   * degrades performance quite a lot).
&nbsp;   */
&nbsp;  public static final int EXPAND_FRAMES = 8;
&nbsp;
&nbsp;  /**
&nbsp;   * A flag to expand the ASM specific instructions into an equivalent sequence of standard bytecode
&nbsp;   * instructions. When resolving a forward jump it may happen that the signed 2 bytes offset
&nbsp;   * reserved for it is not sufficient to store the bytecode offset. In this case the jump
&nbsp;   * instruction is replaced with a temporary ASM specific instruction using an unsigned 2 bytes
&nbsp;   * offset (see {@link Label#resolve}). This internal flag is used to re-read classes containing
&nbsp;   * such instructions, in order to replace them with standard instructions. In addition, when this
&nbsp;   * flag is used, goto_w and jsr_w are &lt;i&gt;not&lt;/i&gt; converted into goto and jsr, to make sure that
&nbsp;   * infinite loops where a goto_w is replaced with a goto in ClassReader and converted back to a
&nbsp;   * goto_w in ClassWriter cannot occur.
&nbsp;   */
&nbsp;  static final int EXPAND_ASM_INSNS = 256;
&nbsp;
&nbsp;  /** The size of the temporary byte array used to read class input streams chunk by chunk. */
&nbsp;  private static final int INPUT_STREAM_DATA_CHUNK_SIZE = 4096;
&nbsp;
&nbsp;  /**
&nbsp;   * A byte array containing the JVMS ClassFile structure to be parsed. &lt;i&gt;The content of this array
&nbsp;   * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally
&nbsp;   * not needed by class visitors.&lt;/i&gt;
&nbsp;   *
&nbsp;   * &lt;p&gt;NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not
&nbsp;   * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct
&nbsp;   * ClassFile element offsets within this byte array.
&nbsp;   */
&nbsp;  public final byte[] b;
&nbsp;
&nbsp;  /**
&nbsp;   * The offset in bytes, in {@link #b}, of each cp_info entry of the ClassFile&#39;s constant_pool
&nbsp;   * array, &lt;i&gt;plus one&lt;/i&gt;. In other words, the offset of constant pool entry i is given by
&nbsp;   * cpInfoOffsets[i] - 1, i.e. its cp_info&#39;s tag field is given by b[cpInfoOffsets[i] - 1].
&nbsp;   */
&nbsp;  private final int[] cpInfoOffsets;
&nbsp;
&nbsp;  /**
&nbsp;   * The value of each cp_info entry of the ClassFile&#39;s constant_pool array, &lt;i&gt;for Constant_Utf8
&nbsp;   * and Constant_Dynamic constants only&lt;/i&gt;. The value of constant pool entry i is given by
&nbsp;   * cpInfoValues[i]. This cache avoids multiple parsing of those constant pool items.
&nbsp;   */
&nbsp;  private final Object[] cpInfoValues;
&nbsp;
&nbsp;  /**
&nbsp;   * The start offsets in {@link #b} of each element of the bootstrap_methods array (in the
&nbsp;   * BootstrapMethods attribute).
&nbsp;   *
&nbsp;   * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23&quot;&gt;JVMS
&nbsp;   *     4.7.23&lt;/a&gt;
&nbsp;   */
&nbsp;  private final int[] bootstrapMethodOffsets;
&nbsp;
&nbsp;  /**
&nbsp;   * A conservative estimate of the maximum length of the strings contained in the constant pool of
&nbsp;   * the class.
&nbsp;   */
&nbsp;  private final int maxStringLength;
&nbsp;
&nbsp;  /** The offset in bytes, in {@link #b}, of the ClassFile&#39;s access_flags field. */
&nbsp;  public final int header;
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Constructors
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a new {@link ClassReader} object.
&nbsp;   *
&nbsp;   * @param classFile the JVMS ClassFile structure to be read.
&nbsp;   */
&nbsp;  public ClassReader(final byte[] classFile) {
<b class="nc">&nbsp;    this(classFile, 0, classFile.length);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a new {@link ClassReader} object.
&nbsp;   *
&nbsp;   * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.
&nbsp;   * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
&nbsp;   * @param classFileLength the length in bytes of the ClassFile to be read.
&nbsp;   */
&nbsp;  public ClassReader(
&nbsp;      final byte[] classFileBuffer, final int classFileOffset, final int classFileLength) {
<b class="nc">&nbsp;    this(classFileBuffer, classFileOffset, /* checkClassVersion = */ true);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a new {@link ClassReader} object. &lt;i&gt;This internal constructor must not be exposed
&nbsp;   * as a public API&lt;/i&gt;.
&nbsp;   *
&nbsp;   * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.
&nbsp;   * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
&nbsp;   * @param checkClassVersion whether to check the class version or not.
&nbsp;   */
&nbsp;  ClassReader(
<b class="nc">&nbsp;      final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {</b>
<b class="nc">&nbsp;    this.b = classFileBuffer;</b>
&nbsp;    // Check the class&#39; major_version. This field is after the magic and minor_version fields, which
&nbsp;    // use 4 and 2 bytes respectively.
<b class="nc">&nbsp;    if (checkClassVersion &amp;&amp; readShort(classFileOffset + 6) &gt; Opcodes.V11) {</b>
<b class="nc">&nbsp;      throw new IllegalArgumentException(</b>
<b class="nc">&nbsp;          &quot;Unsupported class file major version &quot; + readShort(classFileOffset + 6));</b>
&nbsp;    }
&nbsp;    // Create the constant pool arrays. The constant_pool_count field is after the magic,
&nbsp;    // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.
<b class="nc">&nbsp;    int constantPoolCount = readUnsignedShort(classFileOffset + 8);</b>
<b class="nc">&nbsp;    cpInfoOffsets = new int[constantPoolCount];</b>
<b class="nc">&nbsp;    cpInfoValues = new Object[constantPoolCount];</b>
&nbsp;    // Compute the offset of each constant pool entry, as well as a conservative estimate of the
&nbsp;    // maximum length of the constant pool strings. The first constant pool entry is after the
&nbsp;    // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2
&nbsp;    // bytes respectively.
<b class="nc">&nbsp;    int currentCpInfoIndex = 1;</b>
<b class="nc">&nbsp;    int currentCpInfoOffset = classFileOffset + 10;</b>
<b class="nc">&nbsp;    int currentMaxStringLength = 0;</b>
&nbsp;    // The offset of the other entries depend on the total size of all the previous entries.
<b class="nc">&nbsp;    while (currentCpInfoIndex &lt; constantPoolCount) {</b>
<b class="nc">&nbsp;      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;</b>
&nbsp;      int cpInfoSize;
<b class="nc">&nbsp;      switch (classFileBuffer[currentCpInfoOffset]) {</b>
&nbsp;        case Symbol.CONSTANT_FIELDREF_TAG:
&nbsp;        case Symbol.CONSTANT_METHODREF_TAG:
&nbsp;        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:
&nbsp;        case Symbol.CONSTANT_INTEGER_TAG:
&nbsp;        case Symbol.CONSTANT_FLOAT_TAG:
&nbsp;        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
&nbsp;        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
&nbsp;        case Symbol.CONSTANT_DYNAMIC_TAG:
<b class="nc">&nbsp;          cpInfoSize = 5;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Symbol.CONSTANT_LONG_TAG:
&nbsp;        case Symbol.CONSTANT_DOUBLE_TAG:
<b class="nc">&nbsp;          cpInfoSize = 9;</b>
<b class="nc">&nbsp;          currentCpInfoIndex++;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Symbol.CONSTANT_UTF8_TAG:
<b class="nc">&nbsp;          cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);</b>
<b class="nc">&nbsp;          if (cpInfoSize &gt; currentMaxStringLength) {</b>
&nbsp;            // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate
&nbsp;            // of the length in characters of the corresponding string, and is much cheaper to
&nbsp;            // compute than this exact length.
<b class="nc">&nbsp;            currentMaxStringLength = cpInfoSize;</b>
&nbsp;          }
&nbsp;          break;
&nbsp;        case Symbol.CONSTANT_METHOD_HANDLE_TAG:
<b class="nc">&nbsp;          cpInfoSize = 4;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Symbol.CONSTANT_CLASS_TAG:
&nbsp;        case Symbol.CONSTANT_STRING_TAG:
&nbsp;        case Symbol.CONSTANT_METHOD_TYPE_TAG:
&nbsp;        case Symbol.CONSTANT_PACKAGE_TAG:
&nbsp;        case Symbol.CONSTANT_MODULE_TAG:
<b class="nc">&nbsp;          cpInfoSize = 3;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        default:
<b class="nc">&nbsp;          throw new IllegalArgumentException();</b>
&nbsp;      }
<b class="nc">&nbsp;      currentCpInfoOffset += cpInfoSize;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    this.maxStringLength = currentMaxStringLength;</b>
&nbsp;    // The Classfile&#39;s access_flags field is just after the last constant pool entry.
<b class="nc">&nbsp;    this.header = currentCpInfoOffset;</b>
&nbsp;
&nbsp;    // Read the BootstrapMethods attribute, if any (only get the offset of each method).
<b class="nc">&nbsp;    int currentAttributeOffset = getFirstAttributeOffset();</b>
<b class="nc">&nbsp;    int[] currentBootstrapMethodOffsets = null;</b>
<b class="nc">&nbsp;    for (int i = readUnsignedShort(currentAttributeOffset - 2); i &gt; 0; --i) {</b>
&nbsp;      // Read the attribute_info&#39;s attribute_name and attribute_length fields.
<b class="nc">&nbsp;      String attributeName = readUTF8(currentAttributeOffset, new char[maxStringLength]);</b>
<b class="nc">&nbsp;      int attributeLength = readInt(currentAttributeOffset + 2);</b>
<b class="nc">&nbsp;      currentAttributeOffset += 6;</b>
<b class="nc">&nbsp;      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {</b>
&nbsp;        // Read the num_bootstrap_methods field and create an array of this size.
<b class="nc">&nbsp;        currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];</b>
&nbsp;        // Compute and store the offset of each &#39;bootstrap_methods&#39; array field entry.
<b class="nc">&nbsp;        int currentBootstrapMethodOffset = currentAttributeOffset + 2;</b>
<b class="nc">&nbsp;        for (int j = 0; j &lt; currentBootstrapMethodOffsets.length; ++j) {</b>
<b class="nc">&nbsp;          currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;</b>
&nbsp;          // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),
&nbsp;          // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).
<b class="nc">&nbsp;          currentBootstrapMethodOffset +=</b>
<b class="nc">&nbsp;              4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      currentAttributeOffset += attributeLength;</b>
&nbsp;    }
<b class="nc">&nbsp;    this.bootstrapMethodOffsets = currentBootstrapMethodOffsets;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a new {@link ClassReader} object.
&nbsp;   *
&nbsp;   * @param inputStream an input stream of the JVMS ClassFile structure to be read. This input
&nbsp;   *     stream must contain nothing more than the ClassFile structure itself. It is read from its
&nbsp;   *     current position to its end.
&nbsp;   * @throws IOException if a problem occurs during reading.
&nbsp;   */
&nbsp;  public ClassReader(final InputStream inputStream) throws IOException {
<b class="nc">&nbsp;    this(readStream(inputStream, false));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a new {@link ClassReader} object.
&nbsp;   *
&nbsp;   * @param className the fully qualified name of the class to be read. The ClassFile structure is
&nbsp;   *     retrieved with the current class loader&#39;s {@link ClassLoader#getSystemResourceAsStream}.
&nbsp;   * @throws IOException if an exception occurs during reading.
&nbsp;   */
&nbsp;  public ClassReader(final String className) throws IOException {
<b class="nc">&nbsp;    this(</b>
<b class="nc">&nbsp;        readStream(</b>
<b class="nc">&nbsp;            ClassLoader.getSystemResourceAsStream(className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;), true));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads the given input stream and returns its content as a byte array.
&nbsp;   *
&nbsp;   * @param inputStream an input stream.
&nbsp;   * @param close true to close the input stream after reading.
&nbsp;   * @return the content of the given input stream.
&nbsp;   * @throws IOException if a problem occurs during reading.
&nbsp;   */
&nbsp;  private static byte[] readStream(final InputStream inputStream, final boolean close)
&nbsp;      throws IOException {
<b class="nc">&nbsp;    if (inputStream == null) {</b>
<b class="nc">&nbsp;      throw new IOException(&quot;Class not found&quot;);</b>
&nbsp;    }
&nbsp;    try {
<b class="nc">&nbsp;      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</b>
<b class="nc">&nbsp;      byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];</b>
&nbsp;      int bytesRead;
<b class="nc">&nbsp;      while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {</b>
<b class="nc">&nbsp;        outputStream.write(data, 0, bytesRead);</b>
&nbsp;      }
<b class="nc">&nbsp;      outputStream.flush();</b>
<b class="nc">&nbsp;      return outputStream.toByteArray();</b>
&nbsp;    } finally {
<b class="nc">&nbsp;      if (close) {</b>
<b class="nc">&nbsp;        inputStream.close();</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Accessors
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the class&#39;s access flags (see {@link Opcodes}). This value may not reflect Deprecated
&nbsp;   * and Synthetic flags when bytecode is before 1.5 and those flags are represented by attributes.
&nbsp;   *
&nbsp;   * @return the class access flags.
&nbsp;   * @see ClassVisitor#visit(int, int, String, String, String, String[])
&nbsp;   */
&nbsp;  public int getAccess() {
<b class="nc">&nbsp;    return readUnsignedShort(header);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the internal name of the class (see {@link Type#getInternalName()}).
&nbsp;   *
&nbsp;   * @return the internal class name.
&nbsp;   * @see ClassVisitor#visit(int, int, String, String, String, String[])
&nbsp;   */
&nbsp;  public String getClassName() {
&nbsp;    // this_class is just after the access_flags field (using 2 bytes).
<b class="nc">&nbsp;    return readClass(header + 2, new char[maxStringLength]);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the internal of name of the super class (see {@link Type#getInternalName()}). For
&nbsp;   * interfaces, the super class is {@link Object}.
&nbsp;   *
&nbsp;   * @return the internal name of the super class, or &lt;tt&gt;null&lt;/tt&gt; for {@link Object} class.
&nbsp;   * @see ClassVisitor#visit(int, int, String, String, String, String[])
&nbsp;   */
&nbsp;  public String getSuperName() {
&nbsp;    // super_class is after the access_flags and this_class fields (2 bytes each).
<b class="nc">&nbsp;    return readClass(header + 4, new char[maxStringLength]);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the internal names of the implemented interfaces (see {@link Type#getInternalName()}).
&nbsp;   *
&nbsp;   * @return the internal names of the directly implemented interfaces. Inherited implemented
&nbsp;   *     interfaces are not returned.
&nbsp;   * @see ClassVisitor#visit(int, int, String, String, String, String[])
&nbsp;   */
&nbsp;  public String[] getInterfaces() {
&nbsp;    // interfaces_count is after the access_flags, this_class and super_class fields (2 bytes each).
<b class="nc">&nbsp;    int currentOffset = header + 6;</b>
<b class="nc">&nbsp;    int interfacesCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    String[] interfaces = new String[interfacesCount];</b>
<b class="nc">&nbsp;    if (interfacesCount &gt; 0) {</b>
<b class="nc">&nbsp;      char[] charBuffer = new char[maxStringLength];</b>
<b class="nc">&nbsp;      for (int i = 0; i &lt; interfacesCount; ++i) {</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        interfaces[i] = readClass(currentOffset, charBuffer);</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return interfaces;</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Public methods
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this
&nbsp;   * {@link ClassReader}.
&nbsp;   *
&nbsp;   * @param classVisitor the visitor that must visit this class.
&nbsp;   * @param parsingOptions the options to use to parse this class. One or more of {@link
&nbsp;   *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
&nbsp;   */
&nbsp;  public void accept(final ClassVisitor classVisitor, final int parsingOptions) {
<b class="nc">&nbsp;    accept(classVisitor, new Attribute[0], parsingOptions);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this
&nbsp;   * {@link ClassReader}.
&nbsp;   *
&nbsp;   * @param classVisitor the visitor that must visit this class.
&nbsp;   * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
&nbsp;   *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
&nbsp;   *     be parsed: its byte array value will be passed unchanged to the ClassWriter. &lt;i&gt;This may
&nbsp;   *     corrupt it if this value contains references to the constant pool, or has syntactic or
&nbsp;   *     semantic links with a class element that has been transformed by a class adapter between
&nbsp;   *     the reader and the writer&lt;/i&gt;.
&nbsp;   * @param parsingOptions the options to use to parse this class. One or more of {@link
&nbsp;   *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
&nbsp;   */
&nbsp;  public void accept(
&nbsp;      final ClassVisitor classVisitor,
&nbsp;      final Attribute[] attributePrototypes,
&nbsp;      final int parsingOptions) {
<b class="nc">&nbsp;    Context context = new Context();</b>
<b class="nc">&nbsp;    context.attributePrototypes = attributePrototypes;</b>
<b class="nc">&nbsp;    context.parsingOptions = parsingOptions;</b>
<b class="nc">&nbsp;    context.charBuffer = new char[maxStringLength];</b>
&nbsp;
&nbsp;    // Read the access_flags, this_class, super_class, interface_count and interfaces fields.
<b class="nc">&nbsp;    char[] charBuffer = context.charBuffer;</b>
<b class="nc">&nbsp;    int currentOffset = header;</b>
<b class="nc">&nbsp;    int accessFlags = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    String thisClass = readClass(currentOffset + 2, charBuffer);</b>
<b class="nc">&nbsp;    String superClass = readClass(currentOffset + 4, charBuffer);</b>
<b class="nc">&nbsp;    String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];</b>
<b class="nc">&nbsp;    currentOffset += 8;</b>
<b class="nc">&nbsp;    for (int i = 0; i &lt; interfaces.length; ++i) {</b>
<b class="nc">&nbsp;      interfaces[i] = readClass(currentOffset, charBuffer);</b>
<b class="nc">&nbsp;      currentOffset += 2;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).
&nbsp;    // Attribute offsets exclude the attribute_name_index and attribute_length fields.
&nbsp;    // - The offset of the InnerClasses attribute, or 0.
<b class="nc">&nbsp;    int innerClassesOffset = 0;</b>
&nbsp;    // - The offset of the EnclosingMethod attribute, or 0.
<b class="nc">&nbsp;    int enclosingMethodOffset = 0;</b>
&nbsp;    // - The string corresponding to the Signature attribute, or null.
<b class="nc">&nbsp;    String signature = null;</b>
&nbsp;    // - The string corresponding to the SourceFile attribute, or null.
<b class="nc">&nbsp;    String sourceFile = null;</b>
&nbsp;    // - The string corresponding to the SourceDebugExtension attribute, or null.
<b class="nc">&nbsp;    String sourceDebugExtension = null;</b>
&nbsp;    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeVisibleAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeInvisibleAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeVisibleTypeAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeInvisibleTypeAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the Module attribute, or 0.
<b class="nc">&nbsp;    int moduleOffset = 0;</b>
&nbsp;    // - The offset of the ModulePackages attribute, or 0.
<b class="nc">&nbsp;    int modulePackagesOffset = 0;</b>
&nbsp;    // - The string corresponding to the ModuleMainClass attribute, or null.
<b class="nc">&nbsp;    String moduleMainClass = null;</b>
&nbsp;    // - The string corresponding to the NestHost attribute, or null.
<b class="nc">&nbsp;    String nestHostClass = null;</b>
&nbsp;    // - The offset of the NestMembers attribute, or 0.
<b class="nc">&nbsp;    int nestMembersOffset = 0;</b>
&nbsp;    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
&nbsp;    //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
<b class="nc">&nbsp;    Attribute attributes = null;</b>
&nbsp;
<b class="nc">&nbsp;    int currentAttributeOffset = getFirstAttributeOffset();</b>
<b class="nc">&nbsp;    for (int i = readUnsignedShort(currentAttributeOffset - 2); i &gt; 0; --i) {</b>
&nbsp;      // Read the attribute_info&#39;s attribute_name and attribute_length fields.
<b class="nc">&nbsp;      String attributeName = readUTF8(currentAttributeOffset, charBuffer);</b>
<b class="nc">&nbsp;      int attributeLength = readInt(currentAttributeOffset + 2);</b>
<b class="nc">&nbsp;      currentAttributeOffset += 6;</b>
&nbsp;      // The tests are sorted in decreasing frequency order (based on frequencies observed on
&nbsp;      // typical classes).
<b class="nc">&nbsp;      if (Constants.SOURCE_FILE.equals(attributeName)) {</b>
<b class="nc">&nbsp;        sourceFile = readUTF8(currentAttributeOffset, charBuffer);</b>
<b class="nc">&nbsp;      } else if (Constants.INNER_CLASSES.equals(attributeName)) {</b>
<b class="nc">&nbsp;        innerClassesOffset = currentAttributeOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {</b>
<b class="nc">&nbsp;        enclosingMethodOffset = currentAttributeOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.NEST_HOST.equals(attributeName)) {</b>
<b class="nc">&nbsp;        nestHostClass = readClass(currentAttributeOffset, charBuffer);</b>
<b class="nc">&nbsp;      } else if (Constants.NEST_MEMBERS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        nestMembersOffset = currentAttributeOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.SIGNATURE.equals(attributeName)) {</b>
<b class="nc">&nbsp;        signature = readUTF8(currentAttributeOffset, charBuffer);</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeVisibleAnnotationsOffset = currentAttributeOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.DEPRECATED.equals(attributeName)) {</b>
<b class="nc">&nbsp;        accessFlags |= Opcodes.ACC_DEPRECATED;</b>
<b class="nc">&nbsp;      } else if (Constants.SYNTHETIC.equals(attributeName)) {</b>
<b class="nc">&nbsp;        accessFlags |= Opcodes.ACC_SYNTHETIC;</b>
<b class="nc">&nbsp;      } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {</b>
<b class="nc">&nbsp;        sourceDebugExtension =</b>
<b class="nc">&nbsp;            readUTF(currentAttributeOffset, attributeLength, new char[attributeLength]);</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeInvisibleAnnotationsOffset = currentAttributeOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.MODULE.equals(attributeName)) {</b>
<b class="nc">&nbsp;        moduleOffset = currentAttributeOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        moduleMainClass = readClass(currentAttributeOffset, charBuffer);</b>
<b class="nc">&nbsp;      } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {</b>
<b class="nc">&nbsp;        modulePackagesOffset = currentAttributeOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {</b>
&nbsp;        // This attribute is read in the constructor.
&nbsp;      } else {
<b class="nc">&nbsp;        Attribute attribute =</b>
<b class="nc">&nbsp;            readAttribute(</b>
&nbsp;                attributePrototypes,
&nbsp;                attributeName,
&nbsp;                currentAttributeOffset,
&nbsp;                attributeLength,
&nbsp;                charBuffer,
&nbsp;                -1,
&nbsp;                null);
<b class="nc">&nbsp;        attribute.nextAttribute = attributes;</b>
<b class="nc">&nbsp;        attributes = attribute;</b>
&nbsp;      }
<b class="nc">&nbsp;      currentAttributeOffset += attributeLength;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the class declaration. The minor_version and major_version fields start 6 bytes before
&nbsp;    // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).
<b class="nc">&nbsp;    classVisitor.visit(</b>
<b class="nc">&nbsp;        readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);</b>
&nbsp;
&nbsp;    // Visit the SourceFile and SourceDebugExtenstion attributes.
<b class="nc">&nbsp;    if ((parsingOptions &amp; SKIP_DEBUG) == 0</b>
&nbsp;        &amp;&amp; (sourceFile != null || sourceDebugExtension != null)) {
<b class="nc">&nbsp;      classVisitor.visitSource(sourceFile, sourceDebugExtension);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the Module, ModulePackages and ModuleMainClass attributes.
<b class="nc">&nbsp;    if (moduleOffset != 0) {</b>
<b class="nc">&nbsp;      readModule(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the NestHost attribute.
<b class="nc">&nbsp;    if (nestHostClass != null) {</b>
<b class="nc">&nbsp;      classVisitor.visitNestHostExperimental(nestHostClass);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the EnclosingMethod attribute.
<b class="nc">&nbsp;    if (enclosingMethodOffset != 0) {</b>
<b class="nc">&nbsp;      String className = readClass(enclosingMethodOffset, charBuffer);</b>
<b class="nc">&nbsp;      int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);</b>
<b class="nc">&nbsp;      String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);</b>
<b class="nc">&nbsp;      String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);</b>
<b class="nc">&nbsp;      classVisitor.visitOuterClass(className, name, type);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeVisibleAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeVisibleAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);</b>
<b class="nc">&nbsp;      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentAnnotationOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentAnnotationOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),</b>
&nbsp;                currentAnnotationOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeInvisibleAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeInvisibleAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);</b>
<b class="nc">&nbsp;      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentAnnotationOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentAnnotationOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),</b>
&nbsp;                currentAnnotationOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeVisibleTypeAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeVisibleTypeAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);</b>
<b class="nc">&nbsp;      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the target_type, target_info and target_path fields.
<b class="nc">&nbsp;        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentAnnotationOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentAnnotationOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                classVisitor.visitTypeAnnotation(</b>
&nbsp;                    context.currentTypeAnnotationTarget,
&nbsp;                    context.currentTypeAnnotationTargetPath,
&nbsp;                    annotationDescriptor,
&nbsp;                    /* visible = */ true),
&nbsp;                currentAnnotationOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeInvisibleTypeAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeInvisibleTypeAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);</b>
<b class="nc">&nbsp;      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the target_type, target_info and target_path fields.
<b class="nc">&nbsp;        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentAnnotationOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentAnnotationOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                classVisitor.visitTypeAnnotation(</b>
&nbsp;                    context.currentTypeAnnotationTarget,
&nbsp;                    context.currentTypeAnnotationTargetPath,
&nbsp;                    annotationDescriptor,
&nbsp;                    /* visible = */ false),
&nbsp;                currentAnnotationOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the non standard attributes.
<b class="nc">&nbsp;    while (attributes != null) {</b>
&nbsp;      // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.
<b class="nc">&nbsp;      Attribute nextAttribute = attributes.nextAttribute;</b>
<b class="nc">&nbsp;      attributes.nextAttribute = null;</b>
<b class="nc">&nbsp;      classVisitor.visitAttribute(attributes);</b>
<b class="nc">&nbsp;      attributes = nextAttribute;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Visit the NestedMembers attribute.
<b class="nc">&nbsp;    if (nestMembersOffset != 0) {</b>
<b class="nc">&nbsp;      int numberOfNestMembers = readUnsignedShort(nestMembersOffset);</b>
<b class="nc">&nbsp;      int currentNestMemberOffset = nestMembersOffset + 2;</b>
<b class="nc">&nbsp;      while (numberOfNestMembers-- &gt; 0) {</b>
<b class="nc">&nbsp;        classVisitor.visitNestMemberExperimental(readClass(currentNestMemberOffset, charBuffer));</b>
<b class="nc">&nbsp;        currentNestMemberOffset += 2;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // Visit the InnerClasses attribute.
<b class="nc">&nbsp;    if (innerClassesOffset != 0) {</b>
<b class="nc">&nbsp;      int numberOfClasses = readUnsignedShort(innerClassesOffset);</b>
<b class="nc">&nbsp;      int currentClassesOffset = innerClassesOffset + 2;</b>
<b class="nc">&nbsp;      while (numberOfClasses-- &gt; 0) {</b>
<b class="nc">&nbsp;        classVisitor.visitInnerClass(</b>
<b class="nc">&nbsp;            readClass(currentClassesOffset, charBuffer),</b>
<b class="nc">&nbsp;            readClass(currentClassesOffset + 2, charBuffer),</b>
<b class="nc">&nbsp;            readUTF8(currentClassesOffset + 4, charBuffer),</b>
<b class="nc">&nbsp;            readUnsignedShort(currentClassesOffset + 6));</b>
<b class="nc">&nbsp;        currentClassesOffset += 8;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // Visit the fields and methods.
<b class="nc">&nbsp;    int fieldsCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
<b class="nc">&nbsp;    while (fieldsCount-- &gt; 0) {</b>
<b class="nc">&nbsp;      currentOffset = readField(classVisitor, context, currentOffset);</b>
&nbsp;    }
<b class="nc">&nbsp;    int methodsCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
<b class="nc">&nbsp;    while (methodsCount-- &gt; 0) {</b>
<b class="nc">&nbsp;      currentOffset = readMethod(classVisitor, context, currentOffset);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the end of the class.
<b class="nc">&nbsp;    classVisitor.visitEnd();</b>
&nbsp;  }
&nbsp;
&nbsp;  // ----------------------------------------------------------------------------------------------
&nbsp;  // Methods to parse modules, fields and methods
&nbsp;  // ----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Reads the module attribute and visit it.
&nbsp;   *
&nbsp;   * @param classVisitor the current class visitor
&nbsp;   * @param context information about the class being parsed.
&nbsp;   * @param moduleOffset the offset of the Module attribute (excluding the attribute_info&#39;s
&nbsp;   *     attribute_name_index and attribute_length fields).
&nbsp;   * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the
&nbsp;   *     attribute_info&#39;s attribute_name_index and attribute_length fields), or 0.
&nbsp;   * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or null.
&nbsp;   */
&nbsp;  private void readModule(
&nbsp;      final ClassVisitor classVisitor,
&nbsp;      final Context context,
&nbsp;      final int moduleOffset,
&nbsp;      final int modulePackagesOffset,
&nbsp;      final String moduleMainClass) {
<b class="nc">&nbsp;    char[] buffer = context.charBuffer;</b>
&nbsp;
&nbsp;    // Read the module_name_index, module_flags and module_version_index fields and visit them.
<b class="nc">&nbsp;    int currentOffset = moduleOffset;</b>
<b class="nc">&nbsp;    String moduleName = readModule(currentOffset, buffer);</b>
<b class="nc">&nbsp;    int moduleFlags = readUnsignedShort(currentOffset + 2);</b>
<b class="nc">&nbsp;    String moduleVersion = readUTF8(currentOffset + 4, buffer);</b>
<b class="nc">&nbsp;    currentOffset += 6;</b>
<b class="nc">&nbsp;    ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);</b>
<b class="nc">&nbsp;    if (moduleVisitor == null) {</b>
&nbsp;      return;
&nbsp;    }
&nbsp;
&nbsp;    // Visit the ModuleMainClass attribute.
<b class="nc">&nbsp;    if (moduleMainClass != null) {</b>
<b class="nc">&nbsp;      moduleVisitor.visitMainClass(moduleMainClass);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the ModulePackages attribute.
<b class="nc">&nbsp;    if (modulePackagesOffset != 0) {</b>
<b class="nc">&nbsp;      int packageCount = readUnsignedShort(modulePackagesOffset);</b>
<b class="nc">&nbsp;      int currentPackageOffset = modulePackagesOffset + 2;</b>
<b class="nc">&nbsp;      while (packageCount-- &gt; 0) {</b>
<b class="nc">&nbsp;        moduleVisitor.visitPackage(readPackage(currentPackageOffset, buffer));</b>
<b class="nc">&nbsp;        currentPackageOffset += 2;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // Read the &#39;requires_count&#39; and &#39;requires&#39; fields.
<b class="nc">&nbsp;    int requiresCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
<b class="nc">&nbsp;    while (requiresCount-- &gt; 0) {</b>
&nbsp;      // Read the requires_index, requires_flags and requires_version fields and visit them.
<b class="nc">&nbsp;      String requires = readModule(currentOffset, buffer);</b>
<b class="nc">&nbsp;      int requiresFlags = readUnsignedShort(currentOffset + 2);</b>
<b class="nc">&nbsp;      String requiresVersion = readUTF8(currentOffset + 4, buffer);</b>
<b class="nc">&nbsp;      currentOffset += 6;</b>
<b class="nc">&nbsp;      moduleVisitor.visitRequire(requires, requiresFlags, requiresVersion);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Read the &#39;exports_count&#39; and &#39;exports&#39; fields.
<b class="nc">&nbsp;    int exportsCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
<b class="nc">&nbsp;    while (exportsCount-- &gt; 0) {</b>
&nbsp;      // Read the exports_index, exports_flags, exports_to_count and exports_to_index fields
&nbsp;      // and visit them.
<b class="nc">&nbsp;      String exports = readPackage(currentOffset, buffer);</b>
<b class="nc">&nbsp;      int exportsFlags = readUnsignedShort(currentOffset + 2);</b>
<b class="nc">&nbsp;      int exportsToCount = readUnsignedShort(currentOffset + 4);</b>
<b class="nc">&nbsp;      currentOffset += 6;</b>
<b class="nc">&nbsp;      String[] exportsTo = null;</b>
<b class="nc">&nbsp;      if (exportsToCount != 0) {</b>
<b class="nc">&nbsp;        exportsTo = new String[exportsToCount];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; exportsToCount; ++i) {</b>
<b class="nc">&nbsp;          exportsTo[i] = readModule(currentOffset, buffer);</b>
<b class="nc">&nbsp;          currentOffset += 2;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      moduleVisitor.visitExport(exports, exportsFlags, exportsTo);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Reads the &#39;opens_count&#39; and &#39;opens&#39; fields.
<b class="nc">&nbsp;    int opensCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
<b class="nc">&nbsp;    while (opensCount-- &gt; 0) {</b>
&nbsp;      // Read the opens_index, opens_flags, opens_to_count and opens_to_index fields and visit them.
<b class="nc">&nbsp;      String opens = readPackage(currentOffset, buffer);</b>
<b class="nc">&nbsp;      int opensFlags = readUnsignedShort(currentOffset + 2);</b>
<b class="nc">&nbsp;      int opensToCount = readUnsignedShort(currentOffset + 4);</b>
<b class="nc">&nbsp;      currentOffset += 6;</b>
<b class="nc">&nbsp;      String[] opensTo = null;</b>
<b class="nc">&nbsp;      if (opensToCount != 0) {</b>
<b class="nc">&nbsp;        opensTo = new String[opensToCount];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; opensToCount; ++i) {</b>
<b class="nc">&nbsp;          opensTo[i] = readModule(currentOffset, buffer);</b>
<b class="nc">&nbsp;          currentOffset += 2;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      moduleVisitor.visitOpen(opens, opensFlags, opensTo);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Read the &#39;uses_count&#39; and &#39;uses&#39; fields.
<b class="nc">&nbsp;    int usesCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
<b class="nc">&nbsp;    while (usesCount-- &gt; 0) {</b>
<b class="nc">&nbsp;      moduleVisitor.visitUse(readClass(currentOffset, buffer));</b>
<b class="nc">&nbsp;      currentOffset += 2;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Read the  &#39;provides_count&#39; and &#39;provides&#39; fields.
<b class="nc">&nbsp;    int providesCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
<b class="nc">&nbsp;    while (providesCount-- &gt; 0) {</b>
&nbsp;      // Read the provides_index, provides_with_count and provides_with_index fields and visit them.
<b class="nc">&nbsp;      String provides = readClass(currentOffset, buffer);</b>
<b class="nc">&nbsp;      int providesWithCount = readUnsignedShort(currentOffset + 2);</b>
<b class="nc">&nbsp;      currentOffset += 4;</b>
<b class="nc">&nbsp;      String[] providesWith = new String[providesWithCount];</b>
<b class="nc">&nbsp;      for (int i = 0; i &lt; providesWithCount; ++i) {</b>
<b class="nc">&nbsp;        providesWith[i] = readClass(currentOffset, buffer);</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
&nbsp;      }
<b class="nc">&nbsp;      moduleVisitor.visitProvide(provides, providesWith);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Visit the end of the module attributes.
<b class="nc">&nbsp;    moduleVisitor.visitEnd();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a JVMS field_info structure and makes the given visitor visit it.
&nbsp;   *
&nbsp;   * @param classVisitor the visitor that must visit the field.
&nbsp;   * @param context information about the class being parsed.
&nbsp;   * @param fieldInfoOffset the start offset of the field_info structure.
&nbsp;   * @return the offset of the first byte following the field_info structure.
&nbsp;   */
&nbsp;  private int readField(
&nbsp;      final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {
<b class="nc">&nbsp;    char[] charBuffer = context.charBuffer;</b>
&nbsp;
&nbsp;    // Read the access_flags, name_index and descriptor_index fields.
<b class="nc">&nbsp;    int currentOffset = fieldInfoOffset;</b>
<b class="nc">&nbsp;    int accessFlags = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    String name = readUTF8(currentOffset + 2, charBuffer);</b>
<b class="nc">&nbsp;    String descriptor = readUTF8(currentOffset + 4, charBuffer);</b>
<b class="nc">&nbsp;    currentOffset += 6;</b>
&nbsp;
&nbsp;    // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).
&nbsp;    // Attribute offsets exclude the attribute_name_index and attribute_length fields.
&nbsp;    // - The value corresponding to the ConstantValue attribute, or null.
<b class="nc">&nbsp;    Object constantValue = null;</b>
&nbsp;    // - The string corresponding to the Signature attribute, or null.
<b class="nc">&nbsp;    String signature = null;</b>
&nbsp;    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeVisibleAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeInvisibleAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeVisibleTypeAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeInvisibleTypeAnnotationsOffset = 0;</b>
&nbsp;    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
&nbsp;    //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
<b class="nc">&nbsp;    Attribute attributes = null;</b>
&nbsp;
<b class="nc">&nbsp;    int attributesCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
<b class="nc">&nbsp;    while (attributesCount-- &gt; 0) {</b>
&nbsp;      // Read the attribute_info&#39;s attribute_name and attribute_length fields.
<b class="nc">&nbsp;      String attributeName = readUTF8(currentOffset, charBuffer);</b>
<b class="nc">&nbsp;      int attributeLength = readInt(currentOffset + 2);</b>
<b class="nc">&nbsp;      currentOffset += 6;</b>
&nbsp;      // The tests are sorted in decreasing frequency order (based on frequencies observed on
&nbsp;      // typical classes).
<b class="nc">&nbsp;      if (Constants.CONSTANT_VALUE.equals(attributeName)) {</b>
<b class="nc">&nbsp;        int constantvalueIndex = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;        constantValue = constantvalueIndex == 0 ? null : readConst(constantvalueIndex, charBuffer);</b>
<b class="nc">&nbsp;      } else if (Constants.SIGNATURE.equals(attributeName)) {</b>
<b class="nc">&nbsp;        signature = readUTF8(currentOffset, charBuffer);</b>
<b class="nc">&nbsp;      } else if (Constants.DEPRECATED.equals(attributeName)) {</b>
<b class="nc">&nbsp;        accessFlags |= Opcodes.ACC_DEPRECATED;</b>
<b class="nc">&nbsp;      } else if (Constants.SYNTHETIC.equals(attributeName)) {</b>
<b class="nc">&nbsp;        accessFlags |= Opcodes.ACC_SYNTHETIC;</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeVisibleAnnotationsOffset = currentOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeVisibleTypeAnnotationsOffset = currentOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeInvisibleAnnotationsOffset = currentOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeInvisibleTypeAnnotationsOffset = currentOffset;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        Attribute attribute =</b>
<b class="nc">&nbsp;            readAttribute(</b>
&nbsp;                context.attributePrototypes,
&nbsp;                attributeName,
&nbsp;                currentOffset,
&nbsp;                attributeLength,
&nbsp;                charBuffer,
&nbsp;                -1,
&nbsp;                null);
<b class="nc">&nbsp;        attribute.nextAttribute = attributes;</b>
<b class="nc">&nbsp;        attributes = attribute;</b>
&nbsp;      }
<b class="nc">&nbsp;      currentOffset += attributeLength;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Visit the field declaration.
<b class="nc">&nbsp;    FieldVisitor fieldVisitor =</b>
<b class="nc">&nbsp;        classVisitor.visitField(accessFlags, name, descriptor, signature, constantValue);</b>
<b class="nc">&nbsp;    if (fieldVisitor == null) {</b>
<b class="nc">&nbsp;      return currentOffset;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeVisibleAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeVisibleAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);</b>
<b class="nc">&nbsp;      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentAnnotationOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentAnnotationOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),</b>
&nbsp;                currentAnnotationOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeInvisibleAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeInvisibleAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);</b>
<b class="nc">&nbsp;      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentAnnotationOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentAnnotationOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),</b>
&nbsp;                currentAnnotationOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeVisibleTypeAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeVisibleTypeAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);</b>
<b class="nc">&nbsp;      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the target_type, target_info and target_path fields.
<b class="nc">&nbsp;        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentAnnotationOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentAnnotationOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                fieldVisitor.visitTypeAnnotation(</b>
&nbsp;                    context.currentTypeAnnotationTarget,
&nbsp;                    context.currentTypeAnnotationTargetPath,
&nbsp;                    annotationDescriptor,
&nbsp;                    /* visible = */ true),
&nbsp;                currentAnnotationOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeInvisibleTypeAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeInvisibleTypeAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);</b>
<b class="nc">&nbsp;      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the target_type, target_info and target_path fields.
<b class="nc">&nbsp;        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentAnnotationOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentAnnotationOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                fieldVisitor.visitTypeAnnotation(</b>
&nbsp;                    context.currentTypeAnnotationTarget,
&nbsp;                    context.currentTypeAnnotationTargetPath,
&nbsp;                    annotationDescriptor,
&nbsp;                    /* visible = */ false),
&nbsp;                currentAnnotationOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the non standard attributes.
<b class="nc">&nbsp;    while (attributes != null) {</b>
&nbsp;      // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.
<b class="nc">&nbsp;      Attribute nextAttribute = attributes.nextAttribute;</b>
<b class="nc">&nbsp;      attributes.nextAttribute = null;</b>
<b class="nc">&nbsp;      fieldVisitor.visitAttribute(attributes);</b>
<b class="nc">&nbsp;      attributes = nextAttribute;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Visit the end of the field.
<b class="nc">&nbsp;    fieldVisitor.visitEnd();</b>
<b class="nc">&nbsp;    return currentOffset;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a JVMS method_info structure and makes the given visitor visit it.
&nbsp;   *
&nbsp;   * @param classVisitor the visitor that must visit the method.
&nbsp;   * @param context information about the class being parsed.
&nbsp;   * @param methodInfoOffset the start offset of the method_info structure.
&nbsp;   * @return the offset of the first byte following the method_info structure.
&nbsp;   */
&nbsp;  private int readMethod(
&nbsp;      final ClassVisitor classVisitor, final Context context, final int methodInfoOffset) {
<b class="nc">&nbsp;    char[] charBuffer = context.charBuffer;</b>
&nbsp;
&nbsp;    // Read the access_flags, name_index and descriptor_index fields.
<b class="nc">&nbsp;    int currentOffset = methodInfoOffset;</b>
<b class="nc">&nbsp;    context.currentMethodAccessFlags = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    context.currentMethodName = readUTF8(currentOffset + 2, charBuffer);</b>
<b class="nc">&nbsp;    context.currentMethodDescriptor = readUTF8(currentOffset + 4, charBuffer);</b>
<b class="nc">&nbsp;    currentOffset += 6;</b>
&nbsp;
&nbsp;    // Read the method attributes (the variables are ordered as in Section 4.7 of the JVMS).
&nbsp;    // Attribute offsets exclude the attribute_name_index and attribute_length fields.
&nbsp;    // - The offset of the Code attribute, or 0.
<b class="nc">&nbsp;    int codeOffset = 0;</b>
&nbsp;    // - The offset of the Exceptions attribute, or 0.
<b class="nc">&nbsp;    int exceptionsOffset = 0;</b>
&nbsp;    // - The strings corresponding to the Exceptions attribute, or null.
<b class="nc">&nbsp;    String[] exceptions = null;</b>
&nbsp;    // - Whether the method has a Synthetic attribute.
<b class="nc">&nbsp;    boolean synthetic = false;</b>
&nbsp;    // - The constant pool index contained in the Signature attribute, or 0.
<b class="nc">&nbsp;    int signatureIndex = 0;</b>
&nbsp;    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeVisibleAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeInvisibleAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the RuntimeVisibleParameterAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeVisibleParameterAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the RuntimeInvisibleParameterAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeInvisibleParameterAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeVisibleTypeAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
<b class="nc">&nbsp;    int runtimeInvisibleTypeAnnotationsOffset = 0;</b>
&nbsp;    // - The offset of the AnnotationDefault attribute, or 0.
<b class="nc">&nbsp;    int annotationDefaultOffset = 0;</b>
&nbsp;    // - The offset of the MethodParameters attribute, or 0.
<b class="nc">&nbsp;    int methodParametersOffset = 0;</b>
&nbsp;    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
&nbsp;    //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
<b class="nc">&nbsp;    Attribute attributes = null;</b>
&nbsp;
<b class="nc">&nbsp;    int attributesCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
<b class="nc">&nbsp;    while (attributesCount-- &gt; 0) {</b>
&nbsp;      // Read the attribute_info&#39;s attribute_name and attribute_length fields.
<b class="nc">&nbsp;      String attributeName = readUTF8(currentOffset, charBuffer);</b>
<b class="nc">&nbsp;      int attributeLength = readInt(currentOffset + 2);</b>
<b class="nc">&nbsp;      currentOffset += 6;</b>
&nbsp;      // The tests are sorted in decreasing frequency order (based on frequencies observed on
&nbsp;      // typical classes).
<b class="nc">&nbsp;      if (Constants.CODE.equals(attributeName)) {</b>
<b class="nc">&nbsp;        if ((context.parsingOptions &amp; SKIP_CODE) == 0) {</b>
<b class="nc">&nbsp;          codeOffset = currentOffset;</b>
&nbsp;        }
<b class="nc">&nbsp;      } else if (Constants.EXCEPTIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        exceptionsOffset = currentOffset;</b>
<b class="nc">&nbsp;        exceptions = new String[readUnsignedShort(exceptionsOffset)];</b>
<b class="nc">&nbsp;        int currentExceptionOffset = exceptionsOffset + 2;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; exceptions.length; ++i) {</b>
<b class="nc">&nbsp;          exceptions[i] = readClass(currentExceptionOffset, charBuffer);</b>
<b class="nc">&nbsp;          currentExceptionOffset += 2;</b>
&nbsp;        }
<b class="nc">&nbsp;      } else if (Constants.SIGNATURE.equals(attributeName)) {</b>
<b class="nc">&nbsp;        signatureIndex = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;      } else if (Constants.DEPRECATED.equals(attributeName)) {</b>
<b class="nc">&nbsp;        context.currentMethodAccessFlags |= Opcodes.ACC_DEPRECATED;</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeVisibleAnnotationsOffset = currentOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeVisibleTypeAnnotationsOffset = currentOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.ANNOTATION_DEFAULT.equals(attributeName)) {</b>
<b class="nc">&nbsp;        annotationDefaultOffset = currentOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.SYNTHETIC.equals(attributeName)) {</b>
<b class="nc">&nbsp;        synthetic = true;</b>
<b class="nc">&nbsp;        context.currentMethodAccessFlags |= Opcodes.ACC_SYNTHETIC;</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeInvisibleAnnotationsOffset = currentOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeInvisibleTypeAnnotationsOffset = currentOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeVisibleParameterAnnotationsOffset = currentOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        runtimeInvisibleParameterAnnotationsOffset = currentOffset;</b>
<b class="nc">&nbsp;      } else if (Constants.METHOD_PARAMETERS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        methodParametersOffset = currentOffset;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        Attribute attribute =</b>
<b class="nc">&nbsp;            readAttribute(</b>
&nbsp;                context.attributePrototypes,
&nbsp;                attributeName,
&nbsp;                currentOffset,
&nbsp;                attributeLength,
&nbsp;                charBuffer,
&nbsp;                -1,
&nbsp;                null);
<b class="nc">&nbsp;        attribute.nextAttribute = attributes;</b>
<b class="nc">&nbsp;        attributes = attribute;</b>
&nbsp;      }
<b class="nc">&nbsp;      currentOffset += attributeLength;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Visit the method declaration.
<b class="nc">&nbsp;    MethodVisitor methodVisitor =</b>
<b class="nc">&nbsp;        classVisitor.visitMethod(</b>
&nbsp;            context.currentMethodAccessFlags,
&nbsp;            context.currentMethodName,
&nbsp;            context.currentMethodDescriptor,
<b class="nc">&nbsp;            signatureIndex == 0 ? null : readUTF(signatureIndex, charBuffer),</b>
&nbsp;            exceptions);
<b class="nc">&nbsp;    if (methodVisitor == null) {</b>
<b class="nc">&nbsp;      return currentOffset;</b>
&nbsp;    }
&nbsp;
&nbsp;    // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method
&nbsp;    // adapter between the reader and the writer. In this case, it might be possible to copy
&nbsp;    // the method attributes directly into the writer. If so, return early without visiting
&nbsp;    // the content of these attributes.
<b class="nc">&nbsp;    if (methodVisitor instanceof MethodWriter) {</b>
<b class="nc">&nbsp;      MethodWriter methodWriter = (MethodWriter) methodVisitor;</b>
<b class="nc">&nbsp;      if (methodWriter.canCopyMethodAttributes(</b>
&nbsp;          this,
&nbsp;          methodInfoOffset,
&nbsp;          currentOffset - methodInfoOffset,
&nbsp;          synthetic,
&nbsp;          (context.currentMethodAccessFlags &amp; Opcodes.ACC_DEPRECATED) != 0,
&nbsp;          signatureIndex,
&nbsp;          exceptionsOffset)) {
<b class="nc">&nbsp;        return currentOffset;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // Visit the MethodParameters attribute.
<b class="nc">&nbsp;    if (methodParametersOffset != 0) {</b>
<b class="nc">&nbsp;      int parametersCount = readByte(methodParametersOffset);</b>
<b class="nc">&nbsp;      int currentParameterOffset = methodParametersOffset + 1;</b>
<b class="nc">&nbsp;      while (parametersCount-- &gt; 0) {</b>
&nbsp;        // Read the name_index and access_flags fields and visit them.
<b class="nc">&nbsp;        methodVisitor.visitParameter(</b>
<b class="nc">&nbsp;            readUTF8(currentParameterOffset, charBuffer),</b>
<b class="nc">&nbsp;            readUnsignedShort(currentParameterOffset + 2));</b>
<b class="nc">&nbsp;        currentParameterOffset += 4;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // Visit the AnnotationDefault attribute.
<b class="nc">&nbsp;    if (annotationDefaultOffset != 0) {</b>
<b class="nc">&nbsp;      AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();</b>
<b class="nc">&nbsp;      readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);</b>
<b class="nc">&nbsp;      if (annotationVisitor != null) {</b>
<b class="nc">&nbsp;        annotationVisitor.visitEnd();</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeVisibleAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeVisibleAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);</b>
<b class="nc">&nbsp;      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentAnnotationOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentAnnotationOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),</b>
&nbsp;                currentAnnotationOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeInvisibleAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeInvisibleAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);</b>
<b class="nc">&nbsp;      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentAnnotationOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentAnnotationOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),</b>
&nbsp;                currentAnnotationOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeVisibleTypeAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeVisibleTypeAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);</b>
<b class="nc">&nbsp;      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the target_type, target_info and target_path fields.
<b class="nc">&nbsp;        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentAnnotationOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentAnnotationOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                methodVisitor.visitTypeAnnotation(</b>
&nbsp;                    context.currentTypeAnnotationTarget,
&nbsp;                    context.currentTypeAnnotationTargetPath,
&nbsp;                    annotationDescriptor,
&nbsp;                    /* visible = */ true),
&nbsp;                currentAnnotationOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeInvisibleTypeAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeInvisibleTypeAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);</b>
<b class="nc">&nbsp;      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the target_type, target_info and target_path fields.
<b class="nc">&nbsp;        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentAnnotationOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentAnnotationOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                methodVisitor.visitTypeAnnotation(</b>
&nbsp;                    context.currentTypeAnnotationTarget,
&nbsp;                    context.currentTypeAnnotationTargetPath,
&nbsp;                    annotationDescriptor,
&nbsp;                    /* visible = */ false),
&nbsp;                currentAnnotationOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeVisibleParameterAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeVisibleParameterAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      readParameterAnnotations(</b>
&nbsp;          methodVisitor, context, runtimeVisibleParameterAnnotationsOffset, /* visible = */ true);
&nbsp;    }
&nbsp;
&nbsp;    // Visit the RuntimeInvisibleParameterAnnotations attribute.
<b class="nc">&nbsp;    if (runtimeInvisibleParameterAnnotationsOffset != 0) {</b>
<b class="nc">&nbsp;      readParameterAnnotations(</b>
&nbsp;          methodVisitor,
&nbsp;          context,
&nbsp;          runtimeInvisibleParameterAnnotationsOffset,
&nbsp;          /* visible = */ false);
&nbsp;    }
&nbsp;
&nbsp;    // Visit the non standard attributes.
<b class="nc">&nbsp;    while (attributes != null) {</b>
&nbsp;      // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.
<b class="nc">&nbsp;      Attribute nextAttribute = attributes.nextAttribute;</b>
<b class="nc">&nbsp;      attributes.nextAttribute = null;</b>
<b class="nc">&nbsp;      methodVisitor.visitAttribute(attributes);</b>
<b class="nc">&nbsp;      attributes = nextAttribute;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Visit the Code attribute.
<b class="nc">&nbsp;    if (codeOffset != 0) {</b>
<b class="nc">&nbsp;      methodVisitor.visitCode();</b>
<b class="nc">&nbsp;      readCode(methodVisitor, context, codeOffset);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the end of the method.
<b class="nc">&nbsp;    methodVisitor.visitEnd();</b>
<b class="nc">&nbsp;    return currentOffset;</b>
&nbsp;  }
&nbsp;
&nbsp;  // ----------------------------------------------------------------------------------------------
&nbsp;  // Methods to parse a Code attribute
&nbsp;  // ----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a JVMS &#39;Code&#39; attribute and makes the given visitor visit it.
&nbsp;   *
&nbsp;   * @param methodVisitor the visitor that must visit the Code attribute.
&nbsp;   * @param context information about the class being parsed.
&nbsp;   * @param codeOffset the start offset in {@link #b} of the Code attribute, excluding its
&nbsp;   *     attribute_name_index and attribute_length fields.
&nbsp;   */
&nbsp;  private void readCode(
&nbsp;      final MethodVisitor methodVisitor, final Context context, final int codeOffset) {
<b class="nc">&nbsp;    int currentOffset = codeOffset;</b>
&nbsp;
&nbsp;    // Read the max_stack, max_locals and code_length fields.
<b class="nc">&nbsp;    final byte[] classFileBuffer = b;</b>
<b class="nc">&nbsp;    final char[] charBuffer = context.charBuffer;</b>
<b class="nc">&nbsp;    final int maxStack = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    final int maxLocals = readUnsignedShort(currentOffset + 2);</b>
<b class="nc">&nbsp;    final int codeLength = readInt(currentOffset + 4);</b>
<b class="nc">&nbsp;    currentOffset += 8;</b>
&nbsp;
&nbsp;    // Read the bytecode &#39;code&#39; array to create a label for each referenced instruction.
<b class="nc">&nbsp;    final int bytecodeStartOffset = currentOffset;</b>
<b class="nc">&nbsp;    final int bytecodeEndOffset = currentOffset + codeLength;</b>
<b class="nc">&nbsp;    final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];</b>
<b class="nc">&nbsp;    while (currentOffset &lt; bytecodeEndOffset) {</b>
<b class="nc">&nbsp;      final int bytecodeOffset = currentOffset - bytecodeStartOffset;</b>
<b class="nc">&nbsp;      final int opcode = classFileBuffer[currentOffset] &amp; 0xFF;</b>
<b class="nc">&nbsp;      switch (opcode) {</b>
&nbsp;        case Constants.NOP:
&nbsp;        case Constants.ACONST_NULL:
&nbsp;        case Constants.ICONST_M1:
&nbsp;        case Constants.ICONST_0:
&nbsp;        case Constants.ICONST_1:
&nbsp;        case Constants.ICONST_2:
&nbsp;        case Constants.ICONST_3:
&nbsp;        case Constants.ICONST_4:
&nbsp;        case Constants.ICONST_5:
&nbsp;        case Constants.LCONST_0:
&nbsp;        case Constants.LCONST_1:
&nbsp;        case Constants.FCONST_0:
&nbsp;        case Constants.FCONST_1:
&nbsp;        case Constants.FCONST_2:
&nbsp;        case Constants.DCONST_0:
&nbsp;        case Constants.DCONST_1:
&nbsp;        case Constants.IALOAD:
&nbsp;        case Constants.LALOAD:
&nbsp;        case Constants.FALOAD:
&nbsp;        case Constants.DALOAD:
&nbsp;        case Constants.AALOAD:
&nbsp;        case Constants.BALOAD:
&nbsp;        case Constants.CALOAD:
&nbsp;        case Constants.SALOAD:
&nbsp;        case Constants.IASTORE:
&nbsp;        case Constants.LASTORE:
&nbsp;        case Constants.FASTORE:
&nbsp;        case Constants.DASTORE:
&nbsp;        case Constants.AASTORE:
&nbsp;        case Constants.BASTORE:
&nbsp;        case Constants.CASTORE:
&nbsp;        case Constants.SASTORE:
&nbsp;        case Constants.POP:
&nbsp;        case Constants.POP2:
&nbsp;        case Constants.DUP:
&nbsp;        case Constants.DUP_X1:
&nbsp;        case Constants.DUP_X2:
&nbsp;        case Constants.DUP2:
&nbsp;        case Constants.DUP2_X1:
&nbsp;        case Constants.DUP2_X2:
&nbsp;        case Constants.SWAP:
&nbsp;        case Constants.IADD:
&nbsp;        case Constants.LADD:
&nbsp;        case Constants.FADD:
&nbsp;        case Constants.DADD:
&nbsp;        case Constants.ISUB:
&nbsp;        case Constants.LSUB:
&nbsp;        case Constants.FSUB:
&nbsp;        case Constants.DSUB:
&nbsp;        case Constants.IMUL:
&nbsp;        case Constants.LMUL:
&nbsp;        case Constants.FMUL:
&nbsp;        case Constants.DMUL:
&nbsp;        case Constants.IDIV:
&nbsp;        case Constants.LDIV:
&nbsp;        case Constants.FDIV:
&nbsp;        case Constants.DDIV:
&nbsp;        case Constants.IREM:
&nbsp;        case Constants.LREM:
&nbsp;        case Constants.FREM:
&nbsp;        case Constants.DREM:
&nbsp;        case Constants.INEG:
&nbsp;        case Constants.LNEG:
&nbsp;        case Constants.FNEG:
&nbsp;        case Constants.DNEG:
&nbsp;        case Constants.ISHL:
&nbsp;        case Constants.LSHL:
&nbsp;        case Constants.ISHR:
&nbsp;        case Constants.LSHR:
&nbsp;        case Constants.IUSHR:
&nbsp;        case Constants.LUSHR:
&nbsp;        case Constants.IAND:
&nbsp;        case Constants.LAND:
&nbsp;        case Constants.IOR:
&nbsp;        case Constants.LOR:
&nbsp;        case Constants.IXOR:
&nbsp;        case Constants.LXOR:
&nbsp;        case Constants.I2L:
&nbsp;        case Constants.I2F:
&nbsp;        case Constants.I2D:
&nbsp;        case Constants.L2I:
&nbsp;        case Constants.L2F:
&nbsp;        case Constants.L2D:
&nbsp;        case Constants.F2I:
&nbsp;        case Constants.F2L:
&nbsp;        case Constants.F2D:
&nbsp;        case Constants.D2I:
&nbsp;        case Constants.D2L:
&nbsp;        case Constants.D2F:
&nbsp;        case Constants.I2B:
&nbsp;        case Constants.I2C:
&nbsp;        case Constants.I2S:
&nbsp;        case Constants.LCMP:
&nbsp;        case Constants.FCMPL:
&nbsp;        case Constants.FCMPG:
&nbsp;        case Constants.DCMPL:
&nbsp;        case Constants.DCMPG:
&nbsp;        case Constants.IRETURN:
&nbsp;        case Constants.LRETURN:
&nbsp;        case Constants.FRETURN:
&nbsp;        case Constants.DRETURN:
&nbsp;        case Constants.ARETURN:
&nbsp;        case Constants.RETURN:
&nbsp;        case Constants.ARRAYLENGTH:
&nbsp;        case Constants.ATHROW:
&nbsp;        case Constants.MONITORENTER:
&nbsp;        case Constants.MONITOREXIT:
&nbsp;        case Constants.ILOAD_0:
&nbsp;        case Constants.ILOAD_1:
&nbsp;        case Constants.ILOAD_2:
&nbsp;        case Constants.ILOAD_3:
&nbsp;        case Constants.LLOAD_0:
&nbsp;        case Constants.LLOAD_1:
&nbsp;        case Constants.LLOAD_2:
&nbsp;        case Constants.LLOAD_3:
&nbsp;        case Constants.FLOAD_0:
&nbsp;        case Constants.FLOAD_1:
&nbsp;        case Constants.FLOAD_2:
&nbsp;        case Constants.FLOAD_3:
&nbsp;        case Constants.DLOAD_0:
&nbsp;        case Constants.DLOAD_1:
&nbsp;        case Constants.DLOAD_2:
&nbsp;        case Constants.DLOAD_3:
&nbsp;        case Constants.ALOAD_0:
&nbsp;        case Constants.ALOAD_1:
&nbsp;        case Constants.ALOAD_2:
&nbsp;        case Constants.ALOAD_3:
&nbsp;        case Constants.ISTORE_0:
&nbsp;        case Constants.ISTORE_1:
&nbsp;        case Constants.ISTORE_2:
&nbsp;        case Constants.ISTORE_3:
&nbsp;        case Constants.LSTORE_0:
&nbsp;        case Constants.LSTORE_1:
&nbsp;        case Constants.LSTORE_2:
&nbsp;        case Constants.LSTORE_3:
&nbsp;        case Constants.FSTORE_0:
&nbsp;        case Constants.FSTORE_1:
&nbsp;        case Constants.FSTORE_2:
&nbsp;        case Constants.FSTORE_3:
&nbsp;        case Constants.DSTORE_0:
&nbsp;        case Constants.DSTORE_1:
&nbsp;        case Constants.DSTORE_2:
&nbsp;        case Constants.DSTORE_3:
&nbsp;        case Constants.ASTORE_0:
&nbsp;        case Constants.ASTORE_1:
&nbsp;        case Constants.ASTORE_2:
&nbsp;        case Constants.ASTORE_3:
<b class="nc">&nbsp;          currentOffset += 1;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.IFEQ:
&nbsp;        case Constants.IFNE:
&nbsp;        case Constants.IFLT:
&nbsp;        case Constants.IFGE:
&nbsp;        case Constants.IFGT:
&nbsp;        case Constants.IFLE:
&nbsp;        case Constants.IF_ICMPEQ:
&nbsp;        case Constants.IF_ICMPNE:
&nbsp;        case Constants.IF_ICMPLT:
&nbsp;        case Constants.IF_ICMPGE:
&nbsp;        case Constants.IF_ICMPGT:
&nbsp;        case Constants.IF_ICMPLE:
&nbsp;        case Constants.IF_ACMPEQ:
&nbsp;        case Constants.IF_ACMPNE:
&nbsp;        case Constants.GOTO:
&nbsp;        case Constants.JSR:
&nbsp;        case Constants.IFNULL:
&nbsp;        case Constants.IFNONNULL:
<b class="nc">&nbsp;          createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);</b>
<b class="nc">&nbsp;          currentOffset += 3;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.ASM_IFEQ:
&nbsp;        case Constants.ASM_IFNE:
&nbsp;        case Constants.ASM_IFLT:
&nbsp;        case Constants.ASM_IFGE:
&nbsp;        case Constants.ASM_IFGT:
&nbsp;        case Constants.ASM_IFLE:
&nbsp;        case Constants.ASM_IF_ICMPEQ:
&nbsp;        case Constants.ASM_IF_ICMPNE:
&nbsp;        case Constants.ASM_IF_ICMPLT:
&nbsp;        case Constants.ASM_IF_ICMPGE:
&nbsp;        case Constants.ASM_IF_ICMPGT:
&nbsp;        case Constants.ASM_IF_ICMPLE:
&nbsp;        case Constants.ASM_IF_ACMPEQ:
&nbsp;        case Constants.ASM_IF_ACMPNE:
&nbsp;        case Constants.ASM_GOTO:
&nbsp;        case Constants.ASM_JSR:
&nbsp;        case Constants.ASM_IFNULL:
&nbsp;        case Constants.ASM_IFNONNULL:
<b class="nc">&nbsp;          createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);</b>
<b class="nc">&nbsp;          currentOffset += 3;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.GOTO_W:
&nbsp;        case Constants.JSR_W:
&nbsp;        case Constants.ASM_GOTO_W:
<b class="nc">&nbsp;          createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);</b>
<b class="nc">&nbsp;          currentOffset += 5;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.WIDE:
<b class="nc">&nbsp;          switch (classFileBuffer[currentOffset + 1] &amp; 0xFF) {</b>
&nbsp;            case Constants.ILOAD:
&nbsp;            case Constants.FLOAD:
&nbsp;            case Constants.ALOAD:
&nbsp;            case Constants.LLOAD:
&nbsp;            case Constants.DLOAD:
&nbsp;            case Constants.ISTORE:
&nbsp;            case Constants.FSTORE:
&nbsp;            case Constants.ASTORE:
&nbsp;            case Constants.LSTORE:
&nbsp;            case Constants.DSTORE:
&nbsp;            case Constants.RET:
<b class="nc">&nbsp;              currentOffset += 4;</b>
<b class="nc">&nbsp;              break;</b>
&nbsp;            case Constants.IINC:
<b class="nc">&nbsp;              currentOffset += 6;</b>
<b class="nc">&nbsp;              break;</b>
&nbsp;            default:
<b class="nc">&nbsp;              throw new IllegalArgumentException();</b>
&nbsp;          }
&nbsp;          break;
&nbsp;        case Constants.TABLESWITCH:
&nbsp;          // Skip 0 to 3 padding bytes.
<b class="nc">&nbsp;          currentOffset += 4 - (bytecodeOffset &amp; 3);</b>
&nbsp;          // Read the default label and the number of table entries.
<b class="nc">&nbsp;          createLabel(bytecodeOffset + readInt(currentOffset), labels);</b>
<b class="nc">&nbsp;          int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;</b>
<b class="nc">&nbsp;          currentOffset += 12;</b>
&nbsp;          // Read the table labels.
<b class="nc">&nbsp;          while (numTableEntries-- &gt; 0) {</b>
<b class="nc">&nbsp;            createLabel(bytecodeOffset + readInt(currentOffset), labels);</b>
<b class="nc">&nbsp;            currentOffset += 4;</b>
&nbsp;          }
&nbsp;          break;
&nbsp;        case Constants.LOOKUPSWITCH:
&nbsp;          // Skip 0 to 3 padding bytes.
<b class="nc">&nbsp;          currentOffset += 4 - (bytecodeOffset &amp; 3);</b>
&nbsp;          // Read the default label and the number of switch cases.
<b class="nc">&nbsp;          createLabel(bytecodeOffset + readInt(currentOffset), labels);</b>
<b class="nc">&nbsp;          int numSwitchCases = readInt(currentOffset + 4);</b>
<b class="nc">&nbsp;          currentOffset += 8;</b>
&nbsp;          // Read the switch labels.
<b class="nc">&nbsp;          while (numSwitchCases-- &gt; 0) {</b>
<b class="nc">&nbsp;            createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);</b>
<b class="nc">&nbsp;            currentOffset += 8;</b>
&nbsp;          }
&nbsp;          break;
&nbsp;        case Constants.ILOAD:
&nbsp;        case Constants.LLOAD:
&nbsp;        case Constants.FLOAD:
&nbsp;        case Constants.DLOAD:
&nbsp;        case Constants.ALOAD:
&nbsp;        case Constants.ISTORE:
&nbsp;        case Constants.LSTORE:
&nbsp;        case Constants.FSTORE:
&nbsp;        case Constants.DSTORE:
&nbsp;        case Constants.ASTORE:
&nbsp;        case Constants.RET:
&nbsp;        case Constants.BIPUSH:
&nbsp;        case Constants.NEWARRAY:
&nbsp;        case Constants.LDC:
<b class="nc">&nbsp;          currentOffset += 2;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.SIPUSH:
&nbsp;        case Constants.LDC_W:
&nbsp;        case Constants.LDC2_W:
&nbsp;        case Constants.GETSTATIC:
&nbsp;        case Constants.PUTSTATIC:
&nbsp;        case Constants.GETFIELD:
&nbsp;        case Constants.PUTFIELD:
&nbsp;        case Constants.INVOKEVIRTUAL:
&nbsp;        case Constants.INVOKESPECIAL:
&nbsp;        case Constants.INVOKESTATIC:
&nbsp;        case Constants.NEW:
&nbsp;        case Constants.ANEWARRAY:
&nbsp;        case Constants.CHECKCAST:
&nbsp;        case Constants.INSTANCEOF:
&nbsp;        case Constants.IINC:
<b class="nc">&nbsp;          currentOffset += 3;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.INVOKEINTERFACE:
&nbsp;        case Constants.INVOKEDYNAMIC:
<b class="nc">&nbsp;          currentOffset += 5;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.MULTIANEWARRAY:
<b class="nc">&nbsp;          currentOffset += 4;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        default:
<b class="nc">&nbsp;          throw new IllegalArgumentException();</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Read the &#39;exception_table_length&#39; and &#39;exception_table&#39; field to create a label for each
&nbsp;    // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.
&nbsp;    {
<b class="nc">&nbsp;      int exceptionTableLength = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;      currentOffset += 2;</b>
<b class="nc">&nbsp;      while (exceptionTableLength-- &gt; 0) {</b>
<b class="nc">&nbsp;        Label start = createLabel(readUnsignedShort(currentOffset), labels);</b>
<b class="nc">&nbsp;        Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);</b>
<b class="nc">&nbsp;        Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);</b>
<b class="nc">&nbsp;        String catchType =</b>
<b class="nc">&nbsp;            readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);</b>
<b class="nc">&nbsp;        currentOffset += 8;</b>
<b class="nc">&nbsp;        methodVisitor.visitTryCatchBlock(start, end, handler, catchType);</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Read the Code attributes to create a label for each referenced instruction (the variables
&nbsp;    // are ordered as in Section 4.7 of the JVMS). Attribute offsets exclude the
&nbsp;    // attribute_name_index and attribute_length fields.
&nbsp;    // - The offset of the current &#39;stack_map_frame&#39; in the StackMap[Table] attribute, or 0.
&nbsp;    // Initially, this is the offset of the first &#39;stack_map_frame&#39; entry. Then this offset is
&nbsp;    // updated after each stack_map_frame is read.
<b class="nc">&nbsp;    int stackMapFrameOffset = 0;</b>
&nbsp;    // - The end offset of the StackMap[Table] attribute, or 0.
<b class="nc">&nbsp;    int stackMapTableEndOffset = 0;</b>
&nbsp;    // - Whether the stack map frames are compressed (i.e. in a StackMapTable) or not.
<b class="nc">&nbsp;    boolean compressedFrames = true;</b>
&nbsp;    // - The offset of the LocalVariableTable attribute, or 0.
<b class="nc">&nbsp;    int localVariableTableOffset = 0;</b>
&nbsp;    // - The offset of the LocalVariableTypeTable attribute, or 0.
<b class="nc">&nbsp;    int localVariableTypeTableOffset = 0;</b>
&nbsp;    // - The offset of each &#39;type_annotation&#39; entry in the RuntimeVisibleTypeAnnotations
&nbsp;    // attribute, or null.
<b class="nc">&nbsp;    int[] visibleTypeAnnotationOffsets = null;</b>
&nbsp;    // - The offset of each &#39;type_annotation&#39; entry in the RuntimeInvisibleTypeAnnotations
&nbsp;    // attribute, or null.
<b class="nc">&nbsp;    int[] invisibleTypeAnnotationOffsets = null;</b>
&nbsp;    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
&nbsp;    //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
<b class="nc">&nbsp;    Attribute attributes = null;</b>
&nbsp;
<b class="nc">&nbsp;    int attributesCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
<b class="nc">&nbsp;    while (attributesCount-- &gt; 0) {</b>
&nbsp;      // Read the attribute_info&#39;s attribute_name and attribute_length fields.
<b class="nc">&nbsp;      String attributeName = readUTF8(currentOffset, charBuffer);</b>
<b class="nc">&nbsp;      int attributeLength = readInt(currentOffset + 2);</b>
<b class="nc">&nbsp;      currentOffset += 6;</b>
<b class="nc">&nbsp;      if (Constants.LOCAL_VARIABLE_TABLE.equals(attributeName)) {</b>
<b class="nc">&nbsp;        if ((context.parsingOptions &amp; SKIP_DEBUG) == 0) {</b>
<b class="nc">&nbsp;          localVariableTableOffset = currentOffset;</b>
&nbsp;          // Parse the attribute to find the corresponding (debug only) labels.
<b class="nc">&nbsp;          int currentLocalVariableTableOffset = currentOffset;</b>
<b class="nc">&nbsp;          int localVariableTableLength = readUnsignedShort(currentLocalVariableTableOffset);</b>
<b class="nc">&nbsp;          currentLocalVariableTableOffset += 2;</b>
<b class="nc">&nbsp;          while (localVariableTableLength-- &gt; 0) {</b>
<b class="nc">&nbsp;            int startPc = readUnsignedShort(currentLocalVariableTableOffset);</b>
<b class="nc">&nbsp;            createDebugLabel(startPc, labels);</b>
<b class="nc">&nbsp;            int length = readUnsignedShort(currentLocalVariableTableOffset + 2);</b>
<b class="nc">&nbsp;            createDebugLabel(startPc + length, labels);</b>
&nbsp;            // Skip the name_index, descriptor_index and index fields (2 bytes each).
<b class="nc">&nbsp;            currentLocalVariableTableOffset += 10;</b>
<b class="nc">&nbsp;          }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;      } else if (Constants.LOCAL_VARIABLE_TYPE_TABLE.equals(attributeName)) {</b>
<b class="nc">&nbsp;        localVariableTypeTableOffset = currentOffset;</b>
&nbsp;        // Here we do not extract the labels corresponding to the attribute content. We assume they
&nbsp;        // are the same or a subset of those of the LocalVariableTable attribute.
<b class="nc">&nbsp;      } else if (Constants.LINE_NUMBER_TABLE.equals(attributeName)) {</b>
<b class="nc">&nbsp;        if ((context.parsingOptions &amp; SKIP_DEBUG) == 0) {</b>
&nbsp;          // Parse the attribute to find the corresponding (debug only) labels.
<b class="nc">&nbsp;          int currentLineNumberTableOffset = currentOffset;</b>
<b class="nc">&nbsp;          int lineNumberTableLength = readUnsignedShort(currentLineNumberTableOffset);</b>
<b class="nc">&nbsp;          currentLineNumberTableOffset += 2;</b>
<b class="nc">&nbsp;          while (lineNumberTableLength-- &gt; 0) {</b>
<b class="nc">&nbsp;            int startPc = readUnsignedShort(currentLineNumberTableOffset);</b>
<b class="nc">&nbsp;            int lineNumber = readUnsignedShort(currentLineNumberTableOffset + 2);</b>
<b class="nc">&nbsp;            currentLineNumberTableOffset += 4;</b>
<b class="nc">&nbsp;            createDebugLabel(startPc, labels);</b>
<b class="nc">&nbsp;            labels[startPc].addLineNumber(lineNumber);</b>
<b class="nc">&nbsp;          }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        visibleTypeAnnotationOffsets =</b>
<b class="nc">&nbsp;            readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ true);</b>
&nbsp;        // Here we do not extract the labels corresponding to the attribute content. This would
&nbsp;        // require a full parsing of the attribute, which would need to be repeated when parsing
&nbsp;        // the bytecode instructions (see below). Instead, the content of the attribute is read one
&nbsp;        // type annotation at a time (i.e. after a type annotation has been visited, the next type
&nbsp;        // annotation is read), and the labels it contains are also extracted one annotation at a
&nbsp;        // time. This assumes that type annotations are ordered by increasing bytecode offset.
<b class="nc">&nbsp;      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</b>
<b class="nc">&nbsp;        invisibleTypeAnnotationOffsets =</b>
<b class="nc">&nbsp;            readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ false);</b>
&nbsp;        // Same comment as above for the RuntimeVisibleTypeAnnotations attribute.
<b class="nc">&nbsp;      } else if (Constants.STACK_MAP_TABLE.equals(attributeName)) {</b>
<b class="nc">&nbsp;        if ((context.parsingOptions &amp; SKIP_FRAMES) == 0) {</b>
<b class="nc">&nbsp;          stackMapFrameOffset = currentOffset + 2;</b>
<b class="nc">&nbsp;          stackMapTableEndOffset = currentOffset + attributeLength;</b>
&nbsp;        }
&nbsp;        // Here we do not extract the labels corresponding to the attribute content. This would
&nbsp;        // require a full parsing of the attribute, which would need to be repeated when parsing
&nbsp;        // the bytecode instructions (see below). Instead, the content of the attribute is read one
&nbsp;        // frame at a time (i.e. after a frame has been visited, the next frame is read), and the
&nbsp;        // labels it contains are also extracted one frame at a time. Thanks to the ordering of
&nbsp;        // frames, having only a &quot;one frame lookahead&quot; is not a problem, i.e. it is not possible to
&nbsp;        // see an offset smaller than the offset of the current instruction and for which no Label
&nbsp;        // exist. Except for UNINITIALIZED type offsets. We solve this by parsing the stack map
&nbsp;        // table without a full decoding (see below).
<b class="nc">&nbsp;      } else if (&quot;StackMap&quot;.equals(attributeName)) {</b>
<b class="nc">&nbsp;        if ((context.parsingOptions &amp; SKIP_FRAMES) == 0) {</b>
<b class="nc">&nbsp;          stackMapFrameOffset = currentOffset + 2;</b>
<b class="nc">&nbsp;          stackMapTableEndOffset = currentOffset + attributeLength;</b>
<b class="nc">&nbsp;          compressedFrames = false;</b>
&nbsp;        }
&nbsp;        // IMPORTANT! Here we assume that the frames are ordered, as in the StackMapTable attribute,
&nbsp;        // although this is not guaranteed by the attribute format. This allows an incremental
&nbsp;        // extraction of the labels corresponding to this attribute (see the comment above for the
&nbsp;        // StackMapTable attribute).
&nbsp;      } else {
<b class="nc">&nbsp;        Attribute attribute =</b>
<b class="nc">&nbsp;            readAttribute(</b>
&nbsp;                context.attributePrototypes,
&nbsp;                attributeName,
&nbsp;                currentOffset,
&nbsp;                attributeLength,
&nbsp;                charBuffer,
&nbsp;                codeOffset,
&nbsp;                labels);
<b class="nc">&nbsp;        attribute.nextAttribute = attributes;</b>
<b class="nc">&nbsp;        attributes = attribute;</b>
&nbsp;      }
<b class="nc">&nbsp;      currentOffset += attributeLength;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Initialize the context fields related to stack map frames, and generate the first
&nbsp;    // (implicit) stack map frame, if needed.
<b class="nc">&nbsp;    final boolean expandFrames = (context.parsingOptions &amp; EXPAND_FRAMES) != 0;</b>
<b class="nc">&nbsp;    if (stackMapFrameOffset != 0) {</b>
&nbsp;      // The bytecode offset of the first explicit frame is not offset_delta + 1 but only
&nbsp;      // offset_delta. Setting the implicit frame offset to -1 allows us to use of the
&nbsp;      // &quot;offset_delta + 1&quot; rule in all cases.
<b class="nc">&nbsp;      context.currentFrameOffset = -1;</b>
<b class="nc">&nbsp;      context.currentFrameType = 0;</b>
<b class="nc">&nbsp;      context.currentFrameLocalCount = 0;</b>
<b class="nc">&nbsp;      context.currentFrameLocalCountDelta = 0;</b>
<b class="nc">&nbsp;      context.currentFrameLocalTypes = new Object[maxLocals];</b>
<b class="nc">&nbsp;      context.currentFrameStackCount = 0;</b>
<b class="nc">&nbsp;      context.currentFrameStackTypes = new Object[maxStack];</b>
<b class="nc">&nbsp;      if (expandFrames) {</b>
<b class="nc">&nbsp;        computeImplicitFrame(context);</b>
&nbsp;      }
&nbsp;      // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the
&nbsp;      // stack map table, we look for 3 consecutive bytes that &quot;look like&quot; an UNINITIALIZED type
&nbsp;      // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).
&nbsp;      // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,
&nbsp;      // and the only consequence will be the creation of an unneeded label. This is better than
&nbsp;      // creating a label for each NEW instruction, and faster than fully decoding the whole stack
&nbsp;      // map table.
<b class="nc">&nbsp;      for (int offset = stackMapFrameOffset; offset &lt; stackMapTableEndOffset - 2; ++offset) {</b>
<b class="nc">&nbsp;        if (classFileBuffer[offset] == Frame.ITEM_UNINITIALIZED) {</b>
<b class="nc">&nbsp;          int potentialBytecodeOffset = readUnsignedShort(offset + 1);</b>
<b class="nc">&nbsp;          if (potentialBytecodeOffset &gt;= 0</b>
&nbsp;              &amp;&amp; potentialBytecodeOffset &lt; codeLength
&nbsp;              &amp;&amp; (classFileBuffer[bytecodeStartOffset + potentialBytecodeOffset] &amp; 0xFF)
&nbsp;                  == Opcodes.NEW) {
<b class="nc">&nbsp;            createLabel(potentialBytecodeOffset, labels);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    if (expandFrames &amp;&amp; (context.parsingOptions &amp; EXPAND_ASM_INSNS) != 0) {</b>
&nbsp;      // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method
&nbsp;      // does not currently have any frame. These inserted frames must be computed by simulating the
&nbsp;      // effect of the bytecode instructions, one by one, starting from the implicit first frame.
&nbsp;      // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To
&nbsp;      // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is
&nbsp;      // computed in MethodWriter).
<b class="nc">&nbsp;      methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the bytecode instructions. First, introduce state variables for the incremental parsing
&nbsp;    // of the type annotations.
&nbsp;
&nbsp;    // Index of the next runtime visible type annotation to read (in the
&nbsp;    // visibleTypeAnnotationOffsets array).
<b class="nc">&nbsp;    int currentVisibleTypeAnnotationIndex = 0;</b>
&nbsp;    // The bytecode offset of the next runtime visible type annotation to read, or -1.
<b class="nc">&nbsp;    int currentVisibleTypeAnnotationBytecodeOffset =</b>
<b class="nc">&nbsp;        getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, 0);</b>
&nbsp;    // Index of the next runtime invisible type annotation to read (in the
&nbsp;    // invisibleTypeAnnotationOffsets array).
<b class="nc">&nbsp;    int currentInvisibleTypeAnnotationIndex = 0;</b>
&nbsp;    // The bytecode offset of the next runtime invisible type annotation to read, or -1.
<b class="nc">&nbsp;    int currentInvisibleTypeAnnotationBytecodeOffset =</b>
<b class="nc">&nbsp;        getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, 0);</b>
&nbsp;
&nbsp;    // Whether a F_INSERT stack map frame must be inserted before the current instruction.
<b class="nc">&nbsp;    boolean insertFrame = false;</b>
&nbsp;
&nbsp;    // The delta to subtract from a goto_w or jsr_w opcode to get the corresponding goto or jsr
&nbsp;    // opcode, or 0 if goto_w and jsr_w must be left unchanged (i.e. when expanding ASM specific
&nbsp;    // instructions).
<b class="nc">&nbsp;    final int wideJumpOpcodeDelta =</b>
&nbsp;        (context.parsingOptions &amp; EXPAND_ASM_INSNS) == 0 ? Constants.WIDE_JUMP_OPCODE_DELTA : 0;
&nbsp;
<b class="nc">&nbsp;    currentOffset = bytecodeStartOffset;</b>
<b class="nc">&nbsp;    while (currentOffset &lt; bytecodeEndOffset) {</b>
<b class="nc">&nbsp;      final int currentBytecodeOffset = currentOffset - bytecodeStartOffset;</b>
&nbsp;
&nbsp;      // Visit the label and the line number(s) for this bytecode offset, if any.
<b class="nc">&nbsp;      Label currentLabel = labels[currentBytecodeOffset];</b>
<b class="nc">&nbsp;      if (currentLabel != null) {</b>
<b class="nc">&nbsp;        currentLabel.accept(methodVisitor, (context.parsingOptions &amp; SKIP_DEBUG) == 0);</b>
&nbsp;      }
&nbsp;
&nbsp;      // Visit the stack map frame for this bytecode offset, if any.
<b class="nc">&nbsp;      while (stackMapFrameOffset != 0</b>
&nbsp;          &amp;&amp; (context.currentFrameOffset == currentBytecodeOffset
&nbsp;              || context.currentFrameOffset == -1)) {
&nbsp;        // If there is a stack map frame for this offset, make methodVisitor visit it, and read the
&nbsp;        // next stack map frame if there is one.
<b class="nc">&nbsp;        if (context.currentFrameOffset != -1) {</b>
<b class="nc">&nbsp;          if (!compressedFrames || expandFrames) {</b>
<b class="nc">&nbsp;            methodVisitor.visitFrame(</b>
&nbsp;                Opcodes.F_NEW,
&nbsp;                context.currentFrameLocalCount,
&nbsp;                context.currentFrameLocalTypes,
&nbsp;                context.currentFrameStackCount,
&nbsp;                context.currentFrameStackTypes);
&nbsp;          } else {
<b class="nc">&nbsp;            methodVisitor.visitFrame(</b>
&nbsp;                context.currentFrameType,
&nbsp;                context.currentFrameLocalCountDelta,
&nbsp;                context.currentFrameLocalTypes,
&nbsp;                context.currentFrameStackCount,
&nbsp;                context.currentFrameStackTypes);
&nbsp;          }
&nbsp;          // Since there is already a stack map frame for this bytecode offset, there is no need to
&nbsp;          // insert a new one.
<b class="nc">&nbsp;          insertFrame = false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (stackMapFrameOffset &lt; stackMapTableEndOffset) {</b>
<b class="nc">&nbsp;          stackMapFrameOffset =</b>
<b class="nc">&nbsp;              readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);</b>
&nbsp;        } else {
<b class="nc">&nbsp;          stackMapFrameOffset = 0;</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to
&nbsp;      // true during the previous iteration. The actual frame content is computed in MethodWriter.
<b class="nc">&nbsp;      if (insertFrame) {</b>
<b class="nc">&nbsp;        if ((context.parsingOptions &amp; EXPAND_FRAMES) != 0) {</b>
<b class="nc">&nbsp;          methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);</b>
&nbsp;        }
<b class="nc">&nbsp;        insertFrame = false;</b>
&nbsp;      }
&nbsp;
&nbsp;      // Visit the instruction at this bytecode offset.
<b class="nc">&nbsp;      int opcode = classFileBuffer[currentOffset] &amp; 0xFF;</b>
<b class="nc">&nbsp;      switch (opcode) {</b>
&nbsp;        case Constants.NOP:
&nbsp;        case Constants.ACONST_NULL:
&nbsp;        case Constants.ICONST_M1:
&nbsp;        case Constants.ICONST_0:
&nbsp;        case Constants.ICONST_1:
&nbsp;        case Constants.ICONST_2:
&nbsp;        case Constants.ICONST_3:
&nbsp;        case Constants.ICONST_4:
&nbsp;        case Constants.ICONST_5:
&nbsp;        case Constants.LCONST_0:
&nbsp;        case Constants.LCONST_1:
&nbsp;        case Constants.FCONST_0:
&nbsp;        case Constants.FCONST_1:
&nbsp;        case Constants.FCONST_2:
&nbsp;        case Constants.DCONST_0:
&nbsp;        case Constants.DCONST_1:
&nbsp;        case Constants.IALOAD:
&nbsp;        case Constants.LALOAD:
&nbsp;        case Constants.FALOAD:
&nbsp;        case Constants.DALOAD:
&nbsp;        case Constants.AALOAD:
&nbsp;        case Constants.BALOAD:
&nbsp;        case Constants.CALOAD:
&nbsp;        case Constants.SALOAD:
&nbsp;        case Constants.IASTORE:
&nbsp;        case Constants.LASTORE:
&nbsp;        case Constants.FASTORE:
&nbsp;        case Constants.DASTORE:
&nbsp;        case Constants.AASTORE:
&nbsp;        case Constants.BASTORE:
&nbsp;        case Constants.CASTORE:
&nbsp;        case Constants.SASTORE:
&nbsp;        case Constants.POP:
&nbsp;        case Constants.POP2:
&nbsp;        case Constants.DUP:
&nbsp;        case Constants.DUP_X1:
&nbsp;        case Constants.DUP_X2:
&nbsp;        case Constants.DUP2:
&nbsp;        case Constants.DUP2_X1:
&nbsp;        case Constants.DUP2_X2:
&nbsp;        case Constants.SWAP:
&nbsp;        case Constants.IADD:
&nbsp;        case Constants.LADD:
&nbsp;        case Constants.FADD:
&nbsp;        case Constants.DADD:
&nbsp;        case Constants.ISUB:
&nbsp;        case Constants.LSUB:
&nbsp;        case Constants.FSUB:
&nbsp;        case Constants.DSUB:
&nbsp;        case Constants.IMUL:
&nbsp;        case Constants.LMUL:
&nbsp;        case Constants.FMUL:
&nbsp;        case Constants.DMUL:
&nbsp;        case Constants.IDIV:
&nbsp;        case Constants.LDIV:
&nbsp;        case Constants.FDIV:
&nbsp;        case Constants.DDIV:
&nbsp;        case Constants.IREM:
&nbsp;        case Constants.LREM:
&nbsp;        case Constants.FREM:
&nbsp;        case Constants.DREM:
&nbsp;        case Constants.INEG:
&nbsp;        case Constants.LNEG:
&nbsp;        case Constants.FNEG:
&nbsp;        case Constants.DNEG:
&nbsp;        case Constants.ISHL:
&nbsp;        case Constants.LSHL:
&nbsp;        case Constants.ISHR:
&nbsp;        case Constants.LSHR:
&nbsp;        case Constants.IUSHR:
&nbsp;        case Constants.LUSHR:
&nbsp;        case Constants.IAND:
&nbsp;        case Constants.LAND:
&nbsp;        case Constants.IOR:
&nbsp;        case Constants.LOR:
&nbsp;        case Constants.IXOR:
&nbsp;        case Constants.LXOR:
&nbsp;        case Constants.I2L:
&nbsp;        case Constants.I2F:
&nbsp;        case Constants.I2D:
&nbsp;        case Constants.L2I:
&nbsp;        case Constants.L2F:
&nbsp;        case Constants.L2D:
&nbsp;        case Constants.F2I:
&nbsp;        case Constants.F2L:
&nbsp;        case Constants.F2D:
&nbsp;        case Constants.D2I:
&nbsp;        case Constants.D2L:
&nbsp;        case Constants.D2F:
&nbsp;        case Constants.I2B:
&nbsp;        case Constants.I2C:
&nbsp;        case Constants.I2S:
&nbsp;        case Constants.LCMP:
&nbsp;        case Constants.FCMPL:
&nbsp;        case Constants.FCMPG:
&nbsp;        case Constants.DCMPL:
&nbsp;        case Constants.DCMPG:
&nbsp;        case Constants.IRETURN:
&nbsp;        case Constants.LRETURN:
&nbsp;        case Constants.FRETURN:
&nbsp;        case Constants.DRETURN:
&nbsp;        case Constants.ARETURN:
&nbsp;        case Constants.RETURN:
&nbsp;        case Constants.ARRAYLENGTH:
&nbsp;        case Constants.ATHROW:
&nbsp;        case Constants.MONITORENTER:
&nbsp;        case Constants.MONITOREXIT:
<b class="nc">&nbsp;          methodVisitor.visitInsn(opcode);</b>
<b class="nc">&nbsp;          currentOffset += 1;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.ILOAD_0:
&nbsp;        case Constants.ILOAD_1:
&nbsp;        case Constants.ILOAD_2:
&nbsp;        case Constants.ILOAD_3:
&nbsp;        case Constants.LLOAD_0:
&nbsp;        case Constants.LLOAD_1:
&nbsp;        case Constants.LLOAD_2:
&nbsp;        case Constants.LLOAD_3:
&nbsp;        case Constants.FLOAD_0:
&nbsp;        case Constants.FLOAD_1:
&nbsp;        case Constants.FLOAD_2:
&nbsp;        case Constants.FLOAD_3:
&nbsp;        case Constants.DLOAD_0:
&nbsp;        case Constants.DLOAD_1:
&nbsp;        case Constants.DLOAD_2:
&nbsp;        case Constants.DLOAD_3:
&nbsp;        case Constants.ALOAD_0:
&nbsp;        case Constants.ALOAD_1:
&nbsp;        case Constants.ALOAD_2:
&nbsp;        case Constants.ALOAD_3:
<b class="nc">&nbsp;          opcode -= Constants.ILOAD_0;</b>
<b class="nc">&nbsp;          methodVisitor.visitVarInsn(Opcodes.ILOAD + (opcode &gt;&gt; 2), opcode &amp; 0x3);</b>
<b class="nc">&nbsp;          currentOffset += 1;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.ISTORE_0:
&nbsp;        case Constants.ISTORE_1:
&nbsp;        case Constants.ISTORE_2:
&nbsp;        case Constants.ISTORE_3:
&nbsp;        case Constants.LSTORE_0:
&nbsp;        case Constants.LSTORE_1:
&nbsp;        case Constants.LSTORE_2:
&nbsp;        case Constants.LSTORE_3:
&nbsp;        case Constants.FSTORE_0:
&nbsp;        case Constants.FSTORE_1:
&nbsp;        case Constants.FSTORE_2:
&nbsp;        case Constants.FSTORE_3:
&nbsp;        case Constants.DSTORE_0:
&nbsp;        case Constants.DSTORE_1:
&nbsp;        case Constants.DSTORE_2:
&nbsp;        case Constants.DSTORE_3:
&nbsp;        case Constants.ASTORE_0:
&nbsp;        case Constants.ASTORE_1:
&nbsp;        case Constants.ASTORE_2:
&nbsp;        case Constants.ASTORE_3:
<b class="nc">&nbsp;          opcode -= Constants.ISTORE_0;</b>
<b class="nc">&nbsp;          methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode &gt;&gt; 2), opcode &amp; 0x3);</b>
<b class="nc">&nbsp;          currentOffset += 1;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.IFEQ:
&nbsp;        case Constants.IFNE:
&nbsp;        case Constants.IFLT:
&nbsp;        case Constants.IFGE:
&nbsp;        case Constants.IFGT:
&nbsp;        case Constants.IFLE:
&nbsp;        case Constants.IF_ICMPEQ:
&nbsp;        case Constants.IF_ICMPNE:
&nbsp;        case Constants.IF_ICMPLT:
&nbsp;        case Constants.IF_ICMPGE:
&nbsp;        case Constants.IF_ICMPGT:
&nbsp;        case Constants.IF_ICMPLE:
&nbsp;        case Constants.IF_ACMPEQ:
&nbsp;        case Constants.IF_ACMPNE:
&nbsp;        case Constants.GOTO:
&nbsp;        case Constants.JSR:
&nbsp;        case Constants.IFNULL:
&nbsp;        case Constants.IFNONNULL:
<b class="nc">&nbsp;          methodVisitor.visitJumpInsn(</b>
<b class="nc">&nbsp;              opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);</b>
<b class="nc">&nbsp;          currentOffset += 3;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.GOTO_W:
&nbsp;        case Constants.JSR_W:
<b class="nc">&nbsp;          methodVisitor.visitJumpInsn(</b>
&nbsp;              opcode - wideJumpOpcodeDelta,
<b class="nc">&nbsp;              labels[currentBytecodeOffset + readInt(currentOffset + 1)]);</b>
<b class="nc">&nbsp;          currentOffset += 5;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.ASM_IFEQ:
&nbsp;        case Constants.ASM_IFNE:
&nbsp;        case Constants.ASM_IFLT:
&nbsp;        case Constants.ASM_IFGE:
&nbsp;        case Constants.ASM_IFGT:
&nbsp;        case Constants.ASM_IFLE:
&nbsp;        case Constants.ASM_IF_ICMPEQ:
&nbsp;        case Constants.ASM_IF_ICMPNE:
&nbsp;        case Constants.ASM_IF_ICMPLT:
&nbsp;        case Constants.ASM_IF_ICMPGE:
&nbsp;        case Constants.ASM_IF_ICMPGT:
&nbsp;        case Constants.ASM_IF_ICMPLE:
&nbsp;        case Constants.ASM_IF_ACMPEQ:
&nbsp;        case Constants.ASM_IF_ACMPNE:
&nbsp;        case Constants.ASM_GOTO:
&nbsp;        case Constants.ASM_JSR:
&nbsp;        case Constants.ASM_IFNULL:
&nbsp;        case Constants.ASM_IFNONNULL:
&nbsp;          {
&nbsp;            // A forward jump with an offset &gt; 32767. In this case we automatically replace ASM_GOTO
&nbsp;            // with GOTO_W, ASM_JSR with JSR_W and ASM_IFxxx &lt;l&gt; with IFNOTxxx &lt;L&gt; GOTO_W &lt;l&gt; L:...,
&nbsp;            // where IFNOTxxx is the &quot;opposite&quot; opcode of ASMS_IFxxx (e.g. IFNE for ASM_IFEQ) and
&nbsp;            // where &lt;L&gt; designates the instruction just after the GOTO_W.
&nbsp;            // First, change the ASM specific opcodes ASM_IFEQ ... ASM_JSR, ASM_IFNULL and
&nbsp;            // ASM_IFNONNULL to IFEQ ... JSR, IFNULL and IFNONNULL.
<b class="nc">&nbsp;            opcode =</b>
&nbsp;                opcode &lt; Constants.ASM_IFNULL
&nbsp;                    ? opcode - Constants.ASM_OPCODE_DELTA
&nbsp;                    : opcode - Constants.ASM_IFNULL_OPCODE_DELTA;
<b class="nc">&nbsp;            Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];</b>
<b class="nc">&nbsp;            if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {</b>
&nbsp;              // Replace GOTO with GOTO_W and JSR with JSR_W.
<b class="nc">&nbsp;              methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);</b>
&nbsp;            } else {
&nbsp;              // Compute the &quot;opposite&quot; of opcode. This can be done by flipping the least
&nbsp;              // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ
&nbsp;              // (with a pre and post offset by 1).
<b class="nc">&nbsp;              opcode = opcode &lt; Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;</b>
<b class="nc">&nbsp;              Label endif = createLabel(currentBytecodeOffset + 3, labels);</b>
<b class="nc">&nbsp;              methodVisitor.visitJumpInsn(opcode, endif);</b>
<b class="nc">&nbsp;              methodVisitor.visitJumpInsn(Constants.GOTO_W, target);</b>
&nbsp;              // endif designates the instruction just after GOTO_W, and is visited as part of the
&nbsp;              // next instruction. Since it is a jump target, we need to insert a frame here.
<b class="nc">&nbsp;              insertFrame = true;</b>
&nbsp;            }
<b class="nc">&nbsp;            currentOffset += 3;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          }
&nbsp;        case Constants.ASM_GOTO_W:
&nbsp;          {
&nbsp;            // Replace ASM_GOTO_W with GOTO_W.
<b class="nc">&nbsp;            methodVisitor.visitJumpInsn(</b>
<b class="nc">&nbsp;                Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);</b>
&nbsp;            // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns
&nbsp;            // IFNOTxxx &lt;L&gt; ASM_GOTO_W &lt;l&gt; L:..., see MethodWriter), so we need to insert a frame
&nbsp;            // here.
<b class="nc">&nbsp;            insertFrame = true;</b>
<b class="nc">&nbsp;            currentOffset += 5;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          }
&nbsp;        case Constants.WIDE:
<b class="nc">&nbsp;          opcode = classFileBuffer[currentOffset + 1] &amp; 0xFF;</b>
<b class="nc">&nbsp;          if (opcode == Opcodes.IINC) {</b>
<b class="nc">&nbsp;            methodVisitor.visitIincInsn(</b>
<b class="nc">&nbsp;                readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));</b>
<b class="nc">&nbsp;            currentOffset += 6;</b>
&nbsp;          } else {
<b class="nc">&nbsp;            methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));</b>
<b class="nc">&nbsp;            currentOffset += 4;</b>
&nbsp;          }
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.TABLESWITCH:
&nbsp;          {
&nbsp;            // Skip 0 to 3 padding bytes.
<b class="nc">&nbsp;            currentOffset += 4 - (currentBytecodeOffset &amp; 3);</b>
&nbsp;            // Read the instruction.
<b class="nc">&nbsp;            Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];</b>
<b class="nc">&nbsp;            int low = readInt(currentOffset + 4);</b>
<b class="nc">&nbsp;            int high = readInt(currentOffset + 8);</b>
<b class="nc">&nbsp;            currentOffset += 12;</b>
<b class="nc">&nbsp;            Label[] table = new Label[high - low + 1];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; table.length; ++i) {</b>
<b class="nc">&nbsp;              table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];</b>
<b class="nc">&nbsp;              currentOffset += 4;</b>
&nbsp;            }
<b class="nc">&nbsp;            methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          }
&nbsp;        case Constants.LOOKUPSWITCH:
&nbsp;          {
&nbsp;            // Skip 0 to 3 padding bytes.
<b class="nc">&nbsp;            currentOffset += 4 - (currentBytecodeOffset &amp; 3);</b>
&nbsp;            // Read the instruction.
<b class="nc">&nbsp;            Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];</b>
<b class="nc">&nbsp;            int nPairs = readInt(currentOffset + 4);</b>
<b class="nc">&nbsp;            currentOffset += 8;</b>
<b class="nc">&nbsp;            int[] keys = new int[nPairs];</b>
<b class="nc">&nbsp;            Label[] values = new Label[nPairs];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; nPairs; ++i) {</b>
<b class="nc">&nbsp;              keys[i] = readInt(currentOffset);</b>
<b class="nc">&nbsp;              values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];</b>
<b class="nc">&nbsp;              currentOffset += 8;</b>
&nbsp;            }
<b class="nc">&nbsp;            methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          }
&nbsp;        case Constants.ILOAD:
&nbsp;        case Constants.LLOAD:
&nbsp;        case Constants.FLOAD:
&nbsp;        case Constants.DLOAD:
&nbsp;        case Constants.ALOAD:
&nbsp;        case Constants.ISTORE:
&nbsp;        case Constants.LSTORE:
&nbsp;        case Constants.FSTORE:
&nbsp;        case Constants.DSTORE:
&nbsp;        case Constants.ASTORE:
&nbsp;        case Constants.RET:
<b class="nc">&nbsp;          methodVisitor.visitVarInsn(opcode, classFileBuffer[currentOffset + 1] &amp; 0xFF);</b>
<b class="nc">&nbsp;          currentOffset += 2;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.BIPUSH:
&nbsp;        case Constants.NEWARRAY:
<b class="nc">&nbsp;          methodVisitor.visitIntInsn(opcode, classFileBuffer[currentOffset + 1]);</b>
<b class="nc">&nbsp;          currentOffset += 2;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.SIPUSH:
<b class="nc">&nbsp;          methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));</b>
<b class="nc">&nbsp;          currentOffset += 3;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.LDC:
<b class="nc">&nbsp;          methodVisitor.visitLdcInsn(</b>
<b class="nc">&nbsp;              readConst(classFileBuffer[currentOffset + 1] &amp; 0xFF, charBuffer));</b>
<b class="nc">&nbsp;          currentOffset += 2;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.LDC_W:
&nbsp;        case Constants.LDC2_W:
<b class="nc">&nbsp;          methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));</b>
<b class="nc">&nbsp;          currentOffset += 3;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.GETSTATIC:
&nbsp;        case Constants.PUTSTATIC:
&nbsp;        case Constants.GETFIELD:
&nbsp;        case Constants.PUTFIELD:
&nbsp;        case Constants.INVOKEVIRTUAL:
&nbsp;        case Constants.INVOKESPECIAL:
&nbsp;        case Constants.INVOKESTATIC:
&nbsp;        case Constants.INVOKEINTERFACE:
&nbsp;          {
<b class="nc">&nbsp;            int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];</b>
<b class="nc">&nbsp;            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];</b>
<b class="nc">&nbsp;            String owner = readClass(cpInfoOffset, charBuffer);</b>
<b class="nc">&nbsp;            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);</b>
<b class="nc">&nbsp;            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);</b>
<b class="nc">&nbsp;            if (opcode &lt; Opcodes.INVOKEVIRTUAL) {</b>
<b class="nc">&nbsp;              methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);</b>
&nbsp;            } else {
<b class="nc">&nbsp;              boolean isInterface =</b>
&nbsp;                  classFileBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
<b class="nc">&nbsp;              methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (opcode == Opcodes.INVOKEINTERFACE) {</b>
<b class="nc">&nbsp;              currentOffset += 5;</b>
&nbsp;            } else {
<b class="nc">&nbsp;              currentOffset += 3;</b>
&nbsp;            }
<b class="nc">&nbsp;            break;</b>
&nbsp;          }
&nbsp;        case Constants.INVOKEDYNAMIC:
&nbsp;          {
<b class="nc">&nbsp;            int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];</b>
<b class="nc">&nbsp;            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];</b>
<b class="nc">&nbsp;            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);</b>
<b class="nc">&nbsp;            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);</b>
<b class="nc">&nbsp;            int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];</b>
<b class="nc">&nbsp;            Handle handle =</b>
<b class="nc">&nbsp;                (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);</b>
<b class="nc">&nbsp;            Object[] bootstrapMethodArguments =</b>
<b class="nc">&nbsp;                new Object[readUnsignedShort(bootstrapMethodOffset + 2)];</b>
<b class="nc">&nbsp;            bootstrapMethodOffset += 4;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; bootstrapMethodArguments.length; i++) {</b>
<b class="nc">&nbsp;              bootstrapMethodArguments[i] =</b>
<b class="nc">&nbsp;                  readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);</b>
<b class="nc">&nbsp;              bootstrapMethodOffset += 2;</b>
&nbsp;            }
<b class="nc">&nbsp;            methodVisitor.visitInvokeDynamicInsn(</b>
&nbsp;                name, descriptor, handle, bootstrapMethodArguments);
<b class="nc">&nbsp;            currentOffset += 5;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          }
&nbsp;        case Constants.NEW:
&nbsp;        case Constants.ANEWARRAY:
&nbsp;        case Constants.CHECKCAST:
&nbsp;        case Constants.INSTANCEOF:
<b class="nc">&nbsp;          methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));</b>
<b class="nc">&nbsp;          currentOffset += 3;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.IINC:
<b class="nc">&nbsp;          methodVisitor.visitIincInsn(</b>
&nbsp;              classFileBuffer[currentOffset + 1] &amp; 0xFF, classFileBuffer[currentOffset + 2]);
<b class="nc">&nbsp;          currentOffset += 3;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case Constants.MULTIANEWARRAY:
<b class="nc">&nbsp;          methodVisitor.visitMultiANewArrayInsn(</b>
<b class="nc">&nbsp;              readClass(currentOffset + 1, charBuffer), classFileBuffer[currentOffset + 3] &amp; 0xFF);</b>
<b class="nc">&nbsp;          currentOffset += 4;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        default:
<b class="nc">&nbsp;          throw new AssertionError();</b>
&nbsp;      }
&nbsp;
&nbsp;      // Visit the runtime visible instruction annotations, if any.
<b class="nc">&nbsp;      while (visibleTypeAnnotationOffsets != null</b>
&nbsp;          &amp;&amp; currentVisibleTypeAnnotationIndex &lt; visibleTypeAnnotationOffsets.length
&nbsp;          &amp;&amp; currentVisibleTypeAnnotationBytecodeOffset &lt;= currentBytecodeOffset) {
<b class="nc">&nbsp;        if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {</b>
&nbsp;          // Parse the target_type, target_info and target_path fields.
<b class="nc">&nbsp;          int currentAnnotationOffset =</b>
<b class="nc">&nbsp;              readTypeAnnotationTarget(</b>
&nbsp;                  context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);
&nbsp;          // Parse the type_index field.
<b class="nc">&nbsp;          String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;          currentAnnotationOffset += 2;</b>
&nbsp;          // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;          readElementValues(</b>
<b class="nc">&nbsp;              methodVisitor.visitInsnAnnotation(</b>
&nbsp;                  context.currentTypeAnnotationTarget,
&nbsp;                  context.currentTypeAnnotationTargetPath,
&nbsp;                  annotationDescriptor,
&nbsp;                  /* visible = */ true),
&nbsp;              currentAnnotationOffset,
&nbsp;              /* named = */ true,
&nbsp;              charBuffer);
&nbsp;        }
<b class="nc">&nbsp;        currentVisibleTypeAnnotationBytecodeOffset =</b>
<b class="nc">&nbsp;            getTypeAnnotationBytecodeOffset(</b>
&nbsp;                visibleTypeAnnotationOffsets, ++currentVisibleTypeAnnotationIndex);
&nbsp;      }
&nbsp;
&nbsp;      // Visit the runtime invisible instruction annotations, if any.
<b class="nc">&nbsp;      while (invisibleTypeAnnotationOffsets != null</b>
&nbsp;          &amp;&amp; currentInvisibleTypeAnnotationIndex &lt; invisibleTypeAnnotationOffsets.length
&nbsp;          &amp;&amp; currentInvisibleTypeAnnotationBytecodeOffset &lt;= currentBytecodeOffset) {
<b class="nc">&nbsp;        if (currentInvisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {</b>
&nbsp;          // Parse the target_type, target_info and target_path fields.
<b class="nc">&nbsp;          int currentAnnotationOffset =</b>
<b class="nc">&nbsp;              readTypeAnnotationTarget(</b>
&nbsp;                  context, invisibleTypeAnnotationOffsets[currentInvisibleTypeAnnotationIndex]);
&nbsp;          // Parse the type_index field.
<b class="nc">&nbsp;          String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</b>
<b class="nc">&nbsp;          currentAnnotationOffset += 2;</b>
&nbsp;          // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;          readElementValues(</b>
<b class="nc">&nbsp;              methodVisitor.visitInsnAnnotation(</b>
&nbsp;                  context.currentTypeAnnotationTarget,
&nbsp;                  context.currentTypeAnnotationTargetPath,
&nbsp;                  annotationDescriptor,
&nbsp;                  /* visible = */ false),
&nbsp;              currentAnnotationOffset,
&nbsp;              /* named = */ true,
&nbsp;              charBuffer);
&nbsp;        }
<b class="nc">&nbsp;        currentInvisibleTypeAnnotationBytecodeOffset =</b>
<b class="nc">&nbsp;            getTypeAnnotationBytecodeOffset(</b>
&nbsp;                invisibleTypeAnnotationOffsets, ++currentInvisibleTypeAnnotationIndex);
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    if (labels[codeLength] != null) {</b>
<b class="nc">&nbsp;      methodVisitor.visitLabel(labels[codeLength]);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit LocalVariableTable and LocalVariableTypeTable attributes.
<b class="nc">&nbsp;    if (localVariableTableOffset != 0 &amp;&amp; (context.parsingOptions &amp; SKIP_DEBUG) == 0) {</b>
&nbsp;      // The (start_pc, index, signature_index) fields of each entry of the LocalVariableTypeTable.
<b class="nc">&nbsp;      int[] typeTable = null;</b>
<b class="nc">&nbsp;      if (localVariableTypeTableOffset != 0) {</b>
<b class="nc">&nbsp;        typeTable = new int[readUnsignedShort(localVariableTypeTableOffset) * 3];</b>
<b class="nc">&nbsp;        currentOffset = localVariableTypeTableOffset + 2;</b>
<b class="nc">&nbsp;        int typeTableIndex = typeTable.length;</b>
<b class="nc">&nbsp;        while (typeTableIndex &gt; 0) {</b>
&nbsp;          // Store the offset of &#39;signature_index&#39;, and the value of &#39;index&#39; and &#39;start_pc&#39;.
<b class="nc">&nbsp;          typeTable[--typeTableIndex] = currentOffset + 6;</b>
<b class="nc">&nbsp;          typeTable[--typeTableIndex] = readUnsignedShort(currentOffset + 8);</b>
<b class="nc">&nbsp;          typeTable[--typeTableIndex] = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;          currentOffset += 10;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      int localVariableTableLength = readUnsignedShort(localVariableTableOffset);</b>
<b class="nc">&nbsp;      currentOffset = localVariableTableOffset + 2;</b>
<b class="nc">&nbsp;      while (localVariableTableLength-- &gt; 0) {</b>
<b class="nc">&nbsp;        int startPc = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;        int length = readUnsignedShort(currentOffset + 2);</b>
<b class="nc">&nbsp;        String name = readUTF8(currentOffset + 4, charBuffer);</b>
<b class="nc">&nbsp;        String descriptor = readUTF8(currentOffset + 6, charBuffer);</b>
<b class="nc">&nbsp;        int index = readUnsignedShort(currentOffset + 8);</b>
<b class="nc">&nbsp;        currentOffset += 10;</b>
<b class="nc">&nbsp;        String signature = null;</b>
<b class="nc">&nbsp;        if (typeTable != null) {</b>
<b class="nc">&nbsp;          for (int i = 0; i &lt; typeTable.length; i += 3) {</b>
<b class="nc">&nbsp;            if (typeTable[i] == startPc &amp;&amp; typeTable[i + 1] == index) {</b>
<b class="nc">&nbsp;              signature = readUTF8(typeTable[i + 2], charBuffer);</b>
<b class="nc">&nbsp;              break;</b>
&nbsp;            }
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;        methodVisitor.visitLocalVariable(</b>
&nbsp;            name, descriptor, signature, labels[startPc], labels[startPc + length], index);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Visit the local variable type annotations of the RuntimeVisibleTypeAnnotations attribute.
<b class="nc">&nbsp;    if (visibleTypeAnnotationOffsets != null) {</b>
<b class="nc">&nbsp;      for (int i = 0; i &lt; visibleTypeAnnotationOffsets.length; ++i) {</b>
<b class="nc">&nbsp;        int targetType = readByte(visibleTypeAnnotationOffsets[i]);</b>
<b class="nc">&nbsp;        if (targetType == TypeReference.LOCAL_VARIABLE</b>
&nbsp;            || targetType == TypeReference.RESOURCE_VARIABLE) {
&nbsp;          // Parse the target_type, target_info and target_path fields.
<b class="nc">&nbsp;          currentOffset = readTypeAnnotationTarget(context, visibleTypeAnnotationOffsets[i]);</b>
&nbsp;          // Parse the type_index field.
<b class="nc">&nbsp;          String annotationDescriptor = readUTF8(currentOffset, charBuffer);</b>
<b class="nc">&nbsp;          currentOffset += 2;</b>
&nbsp;          // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;          readElementValues(</b>
<b class="nc">&nbsp;              methodVisitor.visitLocalVariableAnnotation(</b>
&nbsp;                  context.currentTypeAnnotationTarget,
&nbsp;                  context.currentTypeAnnotationTargetPath,
&nbsp;                  context.currentLocalVariableAnnotationRangeStarts,
&nbsp;                  context.currentLocalVariableAnnotationRangeEnds,
&nbsp;                  context.currentLocalVariableAnnotationRangeIndices,
&nbsp;                  annotationDescriptor,
&nbsp;                  /* visible = */ true),
&nbsp;              currentOffset,
&nbsp;              /* named = */ true,
&nbsp;              charBuffer);
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // Visit the local variable type annotations of the RuntimeInvisibleTypeAnnotations attribute.
<b class="nc">&nbsp;    if (invisibleTypeAnnotationOffsets != null) {</b>
<b class="nc">&nbsp;      for (int i = 0; i &lt; invisibleTypeAnnotationOffsets.length; ++i) {</b>
<b class="nc">&nbsp;        int targetType = readByte(invisibleTypeAnnotationOffsets[i]);</b>
<b class="nc">&nbsp;        if (targetType == TypeReference.LOCAL_VARIABLE</b>
&nbsp;            || targetType == TypeReference.RESOURCE_VARIABLE) {
&nbsp;          // Parse the target_type, target_info and target_path fields.
<b class="nc">&nbsp;          currentOffset = readTypeAnnotationTarget(context, invisibleTypeAnnotationOffsets[i]);</b>
&nbsp;          // Parse the type_index field.
<b class="nc">&nbsp;          String annotationDescriptor = readUTF8(currentOffset, charBuffer);</b>
<b class="nc">&nbsp;          currentOffset += 2;</b>
&nbsp;          // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;          readElementValues(</b>
<b class="nc">&nbsp;              methodVisitor.visitLocalVariableAnnotation(</b>
&nbsp;                  context.currentTypeAnnotationTarget,
&nbsp;                  context.currentTypeAnnotationTargetPath,
&nbsp;                  context.currentLocalVariableAnnotationRangeStarts,
&nbsp;                  context.currentLocalVariableAnnotationRangeEnds,
&nbsp;                  context.currentLocalVariableAnnotationRangeIndices,
&nbsp;                  annotationDescriptor,
&nbsp;                  /* visible = */ false),
&nbsp;              currentOffset,
&nbsp;              /* named = */ true,
&nbsp;              charBuffer);
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // Visit the non standard attributes.
<b class="nc">&nbsp;    while (attributes != null) {</b>
&nbsp;      // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.
<b class="nc">&nbsp;      Attribute nextAttribute = attributes.nextAttribute;</b>
<b class="nc">&nbsp;      attributes.nextAttribute = null;</b>
<b class="nc">&nbsp;      methodVisitor.visitAttribute(attributes);</b>
<b class="nc">&nbsp;      attributes = nextAttribute;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Visit the max stack and max locals values.
<b class="nc">&nbsp;    methodVisitor.visitMaxs(maxStack, maxLocals);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the label corresponding to the given bytecode offset. The default implementation of
&nbsp;   * this method creates a label for the given offset if it has not been already created.
&nbsp;   *
&nbsp;   * @param bytecodeOffset a bytecode offset in a method.
&nbsp;   * @param labels the already created labels, indexed by their offset. If a label already exists
&nbsp;   *     for bytecodeOffset this method must not create a new one. Otherwise it must store the new
&nbsp;   *     label in this array.
&nbsp;   * @return a non null Label, which must be equal to labels[bytecodeOffset].
&nbsp;   */
&nbsp;  protected Label readLabel(final int bytecodeOffset, final Label[] labels) {
<b class="nc">&nbsp;    if (labels[bytecodeOffset] == null) {</b>
<b class="nc">&nbsp;      labels[bytecodeOffset] = new Label();</b>
&nbsp;    }
<b class="nc">&nbsp;    return labels[bytecodeOffset];</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a label without the {@link Label#FLAG_DEBUG_ONLY} flag set, for the given bytecode
&nbsp;   * offset. The label is created with a call to {@link #readLabel} and its {@link
&nbsp;   * Label#FLAG_DEBUG_ONLY} flag is cleared.
&nbsp;   *
&nbsp;   * @param bytecodeOffset a bytecode offset in a method.
&nbsp;   * @param labels the already created labels, indexed by their offset.
&nbsp;   * @return a Label without the {@link Label#FLAG_DEBUG_ONLY} flag set.
&nbsp;   */
&nbsp;  private Label createLabel(final int bytecodeOffset, final Label[] labels) {
<b class="nc">&nbsp;    Label label = readLabel(bytecodeOffset, labels);</b>
<b class="nc">&nbsp;    label.flags &amp;= ~Label.FLAG_DEBUG_ONLY;</b>
<b class="nc">&nbsp;    return label;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a label with the {@link Label#FLAG_DEBUG_ONLY} flag set, if there is no already
&nbsp;   * existing label for the given bytecode offset (otherwise does nothing). The label is created
&nbsp;   * with a call to {@link #readLabel}.
&nbsp;   *
&nbsp;   * @param bytecodeOffset a bytecode offset in a method.
&nbsp;   * @param labels the already created labels, indexed by their offset.
&nbsp;   */
&nbsp;  private void createDebugLabel(final int bytecodeOffset, final Label[] labels) {
<b class="nc">&nbsp;    if (labels[bytecodeOffset] == null) {</b>
<b class="nc">&nbsp;      readLabel(bytecodeOffset, labels).flags |= Label.FLAG_DEBUG_ONLY;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // ----------------------------------------------------------------------------------------------
&nbsp;  // Methods to parse annotations, type annotations and parameter annotations
&nbsp;  // ----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Parses a Runtime[In]VisibleTypeAnnotations attribute to find the offset of each type_annotation
&nbsp;   * entry it contains, to find the corresponding labels, and to visit the try catch block
&nbsp;   * annotations.
&nbsp;   *
&nbsp;   * @param methodVisitor the method visitor to be used to visit the try catch block annotations.
&nbsp;   * @param context information about the class being parsed.
&nbsp;   * @param runtimeTypeAnnotationsOffset the start offset of a Runtime[In]VisibleTypeAnnotations
&nbsp;   *     attribute, excluding the attribute_info&#39;s attribute_name_index and attribute_length fields.
&nbsp;   * @param visible true if the attribute to parse is a RuntimeVisibleTypeAnnotations attribute,
&nbsp;   *     false it is a RuntimeInvisibleTypeAnnotations attribute.
&nbsp;   * @return the start offset of each entry of the Runtime[In]VisibleTypeAnnotations_attribute&#39;s
&nbsp;   *     &#39;annotations&#39; array field.
&nbsp;   */
&nbsp;  private int[] readTypeAnnotations(
&nbsp;      final MethodVisitor methodVisitor,
&nbsp;      final Context context,
&nbsp;      final int runtimeTypeAnnotationsOffset,
&nbsp;      final boolean visible) {
<b class="nc">&nbsp;    char[] charBuffer = context.charBuffer;</b>
<b class="nc">&nbsp;    int currentOffset = runtimeTypeAnnotationsOffset;</b>
&nbsp;    // Read the num_annotations field and create an array to store the type_annotation offsets.
<b class="nc">&nbsp;    int[] typeAnnotationsOffsets = new int[readUnsignedShort(currentOffset)];</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
&nbsp;    // Parse the &#39;annotations&#39; array field.
<b class="nc">&nbsp;    for (int i = 0; i &lt; typeAnnotationsOffsets.length; ++i) {</b>
<b class="nc">&nbsp;      typeAnnotationsOffsets[i] = currentOffset;</b>
&nbsp;      // Parse the type_annotation&#39;s target_type and the target_info fields. The size of the
&nbsp;      // target_info field depends on the value of target_type.
<b class="nc">&nbsp;      int targetType = readInt(currentOffset);</b>
<b class="nc">&nbsp;      switch (targetType &gt;&gt;&gt; 24) {</b>
&nbsp;        case TypeReference.LOCAL_VARIABLE:
&nbsp;        case TypeReference.RESOURCE_VARIABLE:
&nbsp;          // A localvar_target has a variable size, which depends on the value of their table_length
&nbsp;          // field. It also references bytecode offsets, for which we need labels.
<b class="nc">&nbsp;          int tableLength = readUnsignedShort(currentOffset + 1);</b>
<b class="nc">&nbsp;          currentOffset += 3;</b>
<b class="nc">&nbsp;          while (tableLength-- &gt; 0) {</b>
<b class="nc">&nbsp;            int startPc = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;            int length = readUnsignedShort(currentOffset + 2);</b>
&nbsp;            // Skip the index field (2 bytes).
<b class="nc">&nbsp;            currentOffset += 6;</b>
<b class="nc">&nbsp;            createLabel(startPc, context.currentMethodLabels);</b>
<b class="nc">&nbsp;            createLabel(startPc + length, context.currentMethodLabels);</b>
<b class="nc">&nbsp;          }</b>
&nbsp;          break;
&nbsp;        case TypeReference.CAST:
&nbsp;        case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
&nbsp;        case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
&nbsp;        case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
&nbsp;        case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
<b class="nc">&nbsp;          currentOffset += 4;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case TypeReference.CLASS_EXTENDS:
&nbsp;        case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
&nbsp;        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
&nbsp;        case TypeReference.THROWS:
&nbsp;        case TypeReference.EXCEPTION_PARAMETER:
&nbsp;        case TypeReference.INSTANCEOF:
&nbsp;        case TypeReference.NEW:
&nbsp;        case TypeReference.CONSTRUCTOR_REFERENCE:
&nbsp;        case TypeReference.METHOD_REFERENCE:
<b class="nc">&nbsp;          currentOffset += 3;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case TypeReference.CLASS_TYPE_PARAMETER:
&nbsp;        case TypeReference.METHOD_TYPE_PARAMETER:
&nbsp;        case TypeReference.METHOD_FORMAL_PARAMETER:
&nbsp;        case TypeReference.FIELD:
&nbsp;        case TypeReference.METHOD_RETURN:
&nbsp;        case TypeReference.METHOD_RECEIVER:
&nbsp;        default:
&nbsp;          // TypeReference type which can&#39;t be used in Code attribute, or which is unknown.
<b class="nc">&nbsp;          throw new IllegalArgumentException();</b>
&nbsp;      }
&nbsp;      // Parse the rest of the type_annotation structure, starting with the target_path structure
&nbsp;      // (whose size depends on its path_length field).
<b class="nc">&nbsp;      int pathLength = readByte(currentOffset);</b>
<b class="nc">&nbsp;      if ((targetType &gt;&gt;&gt; 24) == TypeReference.EXCEPTION_PARAMETER) {</b>
&nbsp;        // Parse the target_path structure and create a corresponding TypePath.
<b class="nc">&nbsp;        TypePath path = pathLength == 0 ? null : new TypePath(b, currentOffset);</b>
<b class="nc">&nbsp;        currentOffset += 1 + 2 * pathLength;</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                methodVisitor.visitTryCatchAnnotation(</b>
&nbsp;                    targetType &amp; 0xFFFFFF00, path, annotationDescriptor, visible),
&nbsp;                currentOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      } else {</b>
&nbsp;        // We don&#39;t want to visit the other target_type annotations, so we just skip them (which
&nbsp;        // requires some parsing because the element_value_pairs array has a variable size). First,
&nbsp;        // skip the target_path structure:
<b class="nc">&nbsp;        currentOffset += 3 + 2 * pathLength;</b>
&nbsp;        // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them
&nbsp;        // with a null AnnotationVisitor).
<b class="nc">&nbsp;        currentOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
&nbsp;                /* annotationVisitor = */ null, currentOffset, /* named = */ true, charBuffer);
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return typeAnnotationsOffsets;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the bytecode offset corresponding to the specified JVMS &#39;type_annotation&#39; structure, or
&nbsp;   * -1 if there is no such type_annotation of if it does not have a bytecode offset.
&nbsp;   *
&nbsp;   * @param typeAnnotationOffsets the offset of each &#39;type_annotation&#39; entry in a
&nbsp;   *     Runtime[In]VisibleTypeAnnotations attribute, or null.
&nbsp;   * @param typeAnnotationIndex the index a &#39;type_annotation&#39; entry in typeAnnotationOffsets.
&nbsp;   * @return bytecode offset corresponding to the specified JVMS &#39;type_annotation&#39; structure, or -1
&nbsp;   *     if there is no such type_annotation of if it does not have a bytecode offset.
&nbsp;   */
&nbsp;  private int getTypeAnnotationBytecodeOffset(
&nbsp;      final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {
<b class="nc">&nbsp;    if (typeAnnotationOffsets == null</b>
&nbsp;        || typeAnnotationIndex &gt;= typeAnnotationOffsets.length
<b class="nc">&nbsp;        || readByte(typeAnnotationOffsets[typeAnnotationIndex]) &lt; TypeReference.INSTANCEOF) {</b>
<b class="nc">&nbsp;      return -1;</b>
&nbsp;    }
<b class="nc">&nbsp;    return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info
&nbsp;   * and target_path (the result is stored in the given context), and returns the start offset of
&nbsp;   * the rest of the type_annotation structure.
&nbsp;   *
&nbsp;   * @param context information about the class being parsed. This is where the extracted
&nbsp;   *     target_type and target_path must be stored.
&nbsp;   * @param typeAnnotationOffset the start offset of a type_annotation structure.
&nbsp;   * @return the start offset of the rest of the type_annotation structure.
&nbsp;   */
&nbsp;  private int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) {
<b class="nc">&nbsp;    int currentOffset = typeAnnotationOffset;</b>
&nbsp;    // Parse and store the target_type structure.
<b class="nc">&nbsp;    int targetType = readInt(typeAnnotationOffset);</b>
<b class="nc">&nbsp;    switch (targetType &gt;&gt;&gt; 24) {</b>
&nbsp;      case TypeReference.CLASS_TYPE_PARAMETER:
&nbsp;      case TypeReference.METHOD_TYPE_PARAMETER:
&nbsp;      case TypeReference.METHOD_FORMAL_PARAMETER:
<b class="nc">&nbsp;        targetType &amp;= 0xFFFF0000;</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case TypeReference.FIELD:
&nbsp;      case TypeReference.METHOD_RETURN:
&nbsp;      case TypeReference.METHOD_RECEIVER:
<b class="nc">&nbsp;        targetType &amp;= 0xFF000000;</b>
<b class="nc">&nbsp;        currentOffset += 1;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case TypeReference.LOCAL_VARIABLE:
&nbsp;      case TypeReference.RESOURCE_VARIABLE:
<b class="nc">&nbsp;        targetType &amp;= 0xFF000000;</b>
<b class="nc">&nbsp;        int tableLength = readUnsignedShort(currentOffset + 1);</b>
<b class="nc">&nbsp;        currentOffset += 3;</b>
<b class="nc">&nbsp;        context.currentLocalVariableAnnotationRangeStarts = new Label[tableLength];</b>
<b class="nc">&nbsp;        context.currentLocalVariableAnnotationRangeEnds = new Label[tableLength];</b>
<b class="nc">&nbsp;        context.currentLocalVariableAnnotationRangeIndices = new int[tableLength];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; tableLength; ++i) {</b>
<b class="nc">&nbsp;          int startPc = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;          int length = readUnsignedShort(currentOffset + 2);</b>
<b class="nc">&nbsp;          int index = readUnsignedShort(currentOffset + 4);</b>
<b class="nc">&nbsp;          currentOffset += 6;</b>
<b class="nc">&nbsp;          context.currentLocalVariableAnnotationRangeStarts[i] =</b>
<b class="nc">&nbsp;              createLabel(startPc, context.currentMethodLabels);</b>
<b class="nc">&nbsp;          context.currentLocalVariableAnnotationRangeEnds[i] =</b>
<b class="nc">&nbsp;              createLabel(startPc + length, context.currentMethodLabels);</b>
<b class="nc">&nbsp;          context.currentLocalVariableAnnotationRangeIndices[i] = index;</b>
&nbsp;        }
<b class="nc">&nbsp;        break;</b>
&nbsp;      case TypeReference.CAST:
&nbsp;      case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
&nbsp;      case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
&nbsp;      case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
&nbsp;      case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
<b class="nc">&nbsp;        targetType &amp;= 0xFF0000FF;</b>
<b class="nc">&nbsp;        currentOffset += 4;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case TypeReference.CLASS_EXTENDS:
&nbsp;      case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
&nbsp;      case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
&nbsp;      case TypeReference.THROWS:
&nbsp;      case TypeReference.EXCEPTION_PARAMETER:
<b class="nc">&nbsp;        targetType &amp;= 0xFFFFFF00;</b>
<b class="nc">&nbsp;        currentOffset += 3;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case TypeReference.INSTANCEOF:
&nbsp;      case TypeReference.NEW:
&nbsp;      case TypeReference.CONSTRUCTOR_REFERENCE:
&nbsp;      case TypeReference.METHOD_REFERENCE:
<b class="nc">&nbsp;        targetType &amp;= 0xFF000000;</b>
<b class="nc">&nbsp;        currentOffset += 3;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      default:
<b class="nc">&nbsp;        throw new IllegalArgumentException();</b>
&nbsp;    }
<b class="nc">&nbsp;    context.currentTypeAnnotationTarget = targetType;</b>
&nbsp;    // Parse and store the target_path structure.
<b class="nc">&nbsp;    int pathLength = readByte(currentOffset);</b>
<b class="nc">&nbsp;    context.currentTypeAnnotationTargetPath =</b>
&nbsp;        pathLength == 0 ? null : new TypePath(b, currentOffset);
&nbsp;    // Return the start offset of the rest of the type_annotation structure.
<b class="nc">&nbsp;    return currentOffset + 1 + 2 * pathLength;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.
&nbsp;   *
&nbsp;   * @param methodVisitor the visitor that must visit the parameter annotations.
&nbsp;   * @param context information about the class being parsed.
&nbsp;   * @param runtimeParameterAnnotationsOffset the start offset of a
&nbsp;   *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info&#39;s
&nbsp;   *     attribute_name_index and attribute_length fields.
&nbsp;   * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations
&nbsp;   *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.
&nbsp;   */
&nbsp;  private void readParameterAnnotations(
&nbsp;      final MethodVisitor methodVisitor,
&nbsp;      final Context context,
&nbsp;      final int runtimeParameterAnnotationsOffset,
&nbsp;      final boolean visible) {
<b class="nc">&nbsp;    int currentOffset = runtimeParameterAnnotationsOffset;</b>
<b class="nc">&nbsp;    int numParameters = b[currentOffset++] &amp; 0xFF;</b>
<b class="nc">&nbsp;    methodVisitor.visitAnnotableParameterCount(numParameters, visible);</b>
<b class="nc">&nbsp;    char[] charBuffer = context.charBuffer;</b>
<b class="nc">&nbsp;    for (int i = 0; i &lt; numParameters; ++i) {</b>
<b class="nc">&nbsp;      int numAnnotations = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;      currentOffset += 2;</b>
<b class="nc">&nbsp;      while (numAnnotations-- &gt; 0) {</b>
&nbsp;        // Parse the type_index field.
<b class="nc">&nbsp;        String annotationDescriptor = readUTF8(currentOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
&nbsp;        // Parse num_element_value_pairs and element_value_pairs and visit these values.
<b class="nc">&nbsp;        currentOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible),</b>
&nbsp;                currentOffset,
&nbsp;                /* named = */ true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads the element values of a JVMS &#39;annotation&#39; structure and makes the given visitor visit
&nbsp;   * them. This method can also be used to read the values of the JVMS &#39;array_value&#39; field of an
&nbsp;   * annotation&#39;s &#39;element_value&#39;.
&nbsp;   *
&nbsp;   * @param annotationVisitor the visitor that must visit the values.
&nbsp;   * @param annotationOffset the start offset of an &#39;annotation&#39; structure (excluding its type_index
&nbsp;   *     field) or of an &#39;array_value&#39; structure.
&nbsp;   * @param named if the annotation values are named or not. This should be true to parse the values
&nbsp;   *     of a JVMS &#39;annotation&#39; structure, and false to parse the JVMS &#39;array_value&#39; of an
&nbsp;   *     annotation&#39;s element_value.
&nbsp;   * @param charBuffer the buffer used to read strings in the constant pool.
&nbsp;   * @return the end offset of the JVMS &#39;annotation&#39; or &#39;array_value&#39; structure.
&nbsp;   */
&nbsp;  private int readElementValues(
&nbsp;      final AnnotationVisitor annotationVisitor,
&nbsp;      final int annotationOffset,
&nbsp;      final boolean named,
&nbsp;      final char[] charBuffer) {
<b class="nc">&nbsp;    int currentOffset = annotationOffset;</b>
&nbsp;    // Read the num_element_value_pairs field (or num_values field for an array_value).
<b class="nc">&nbsp;    int numElementValuePairs = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
<b class="nc">&nbsp;    if (named) {</b>
&nbsp;      // Parse the element_value_pairs array.
<b class="nc">&nbsp;      while (numElementValuePairs-- &gt; 0) {</b>
<b class="nc">&nbsp;        String elementName = readUTF8(currentOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentOffset =</b>
<b class="nc">&nbsp;            readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    } else {
&nbsp;      // Parse the array_value array.
<b class="nc">&nbsp;      while (numElementValuePairs-- &gt; 0) {</b>
<b class="nc">&nbsp;        currentOffset =</b>
<b class="nc">&nbsp;            readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer);</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    if (annotationVisitor != null) {</b>
<b class="nc">&nbsp;      annotationVisitor.visitEnd();</b>
&nbsp;    }
<b class="nc">&nbsp;    return currentOffset;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a JVMS &#39;element_value&#39; structure and makes the given visitor visit it.
&nbsp;   *
&nbsp;   * @param annotationVisitor the visitor that must visit the element_value structure.
&nbsp;   * @param elementValueOffset the start offset in {@link #b} of the element_value structure to be
&nbsp;   *     read.
&nbsp;   * @param elementName the name of the element_value structure to be read, or &lt;tt&gt;null&lt;/tt&gt;.
&nbsp;   * @param charBuffer the buffer used to read strings in the constant pool.
&nbsp;   * @return the end offset of the JVMS &#39;element_value&#39; structure.
&nbsp;   */
&nbsp;  private int readElementValue(
&nbsp;      final AnnotationVisitor annotationVisitor,
&nbsp;      final int elementValueOffset,
&nbsp;      final String elementName,
&nbsp;      final char[] charBuffer) {
<b class="nc">&nbsp;    int currentOffset = elementValueOffset;</b>
<b class="nc">&nbsp;    if (annotationVisitor == null) {</b>
<b class="nc">&nbsp;      switch (b[currentOffset] &amp; 0xFF) {</b>
&nbsp;        case &#39;e&#39;: // enum_const_value
<b class="nc">&nbsp;          return currentOffset + 5;</b>
&nbsp;        case &#39;@&#39;: // annotation_value
<b class="nc">&nbsp;          return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);</b>
&nbsp;        case &#39;[&#39;: // array_value
<b class="nc">&nbsp;          return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);</b>
&nbsp;        default:
<b class="nc">&nbsp;          return currentOffset + 3;</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    switch (b[currentOffset++] &amp; 0xFF) {</b>
&nbsp;      case &#39;B&#39;: // const_value_index, CONSTANT_Integer
<b class="nc">&nbsp;        annotationVisitor.visit(</b>
<b class="nc">&nbsp;            elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case &#39;C&#39;: // const_value_index, CONSTANT_Integer
<b class="nc">&nbsp;        annotationVisitor.visit(</b>
<b class="nc">&nbsp;            elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case &#39;D&#39;: // const_value_index, CONSTANT_Double
&nbsp;      case &#39;F&#39;: // const_value_index, CONSTANT_Float
&nbsp;      case &#39;I&#39;: // const_value_index, CONSTANT_Integer
&nbsp;      case &#39;J&#39;: // const_value_index, CONSTANT_Long
<b class="nc">&nbsp;        annotationVisitor.visit(</b>
<b class="nc">&nbsp;            elementName, readConst(readUnsignedShort(currentOffset), charBuffer));</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case &#39;S&#39;: // const_value_index, CONSTANT_Integer
<b class="nc">&nbsp;        annotationVisitor.visit(</b>
<b class="nc">&nbsp;            elementName, (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;
&nbsp;      case &#39;Z&#39;: // const_value_index, CONSTANT_Integer
<b class="nc">&nbsp;        annotationVisitor.visit(</b>
&nbsp;            elementName,
<b class="nc">&nbsp;            readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]) == 0</b>
&nbsp;                ? Boolean.FALSE
&nbsp;                : Boolean.TRUE);
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case &#39;s&#39;: // const_value_index, CONSTANT_Utf8
<b class="nc">&nbsp;        annotationVisitor.visit(elementName, readUTF8(currentOffset, charBuffer));</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case &#39;e&#39;: // enum_const_value
<b class="nc">&nbsp;        annotationVisitor.visitEnum(</b>
&nbsp;            elementName,
<b class="nc">&nbsp;            readUTF8(currentOffset, charBuffer),</b>
<b class="nc">&nbsp;            readUTF8(currentOffset + 2, charBuffer));</b>
<b class="nc">&nbsp;        currentOffset += 4;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case &#39;c&#39;: // class_info
<b class="nc">&nbsp;        annotationVisitor.visit(elementName, Type.getType(readUTF8(currentOffset, charBuffer)));</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case &#39;@&#39;: // annotation_value
<b class="nc">&nbsp;        currentOffset =</b>
<b class="nc">&nbsp;            readElementValues(</b>
<b class="nc">&nbsp;                annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)),</b>
&nbsp;                currentOffset + 2,
&nbsp;                true,
&nbsp;                charBuffer);
<b class="nc">&nbsp;        break;</b>
&nbsp;      case &#39;[&#39;: // array_value
<b class="nc">&nbsp;        int numValues = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        if (numValues == 0) {</b>
<b class="nc">&nbsp;          return readElementValues(</b>
<b class="nc">&nbsp;              annotationVisitor.visitArray(elementName),</b>
&nbsp;              currentOffset - 2,
&nbsp;              /* named = */ false,
&nbsp;              charBuffer);
&nbsp;        }
<b class="nc">&nbsp;        switch (b[currentOffset] &amp; 0xFF) {</b>
&nbsp;          case &#39;B&#39;:
<b class="nc">&nbsp;            byte[] byteValues = new byte[numValues];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; numValues; i++) {</b>
<b class="nc">&nbsp;              byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);</b>
<b class="nc">&nbsp;              currentOffset += 3;</b>
&nbsp;            }
<b class="nc">&nbsp;            annotationVisitor.visit(elementName, byteValues);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;Z&#39;:
<b class="nc">&nbsp;            boolean[] booleanValues = new boolean[numValues];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; numValues; i++) {</b>
<b class="nc">&nbsp;              booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;</b>
<b class="nc">&nbsp;              currentOffset += 3;</b>
&nbsp;            }
<b class="nc">&nbsp;            annotationVisitor.visit(elementName, booleanValues);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;S&#39;:
<b class="nc">&nbsp;            short[] shortValues = new short[numValues];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; numValues; i++) {</b>
<b class="nc">&nbsp;              shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);</b>
<b class="nc">&nbsp;              currentOffset += 3;</b>
&nbsp;            }
<b class="nc">&nbsp;            annotationVisitor.visit(elementName, shortValues);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;C&#39;:
<b class="nc">&nbsp;            char[] charValues = new char[numValues];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; numValues; i++) {</b>
<b class="nc">&nbsp;              charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);</b>
<b class="nc">&nbsp;              currentOffset += 3;</b>
&nbsp;            }
<b class="nc">&nbsp;            annotationVisitor.visit(elementName, charValues);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;I&#39;:
<b class="nc">&nbsp;            int[] intValues = new int[numValues];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; numValues; i++) {</b>
<b class="nc">&nbsp;              intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);</b>
<b class="nc">&nbsp;              currentOffset += 3;</b>
&nbsp;            }
<b class="nc">&nbsp;            annotationVisitor.visit(elementName, intValues);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;J&#39;:
<b class="nc">&nbsp;            long[] longValues = new long[numValues];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; numValues; i++) {</b>
<b class="nc">&nbsp;              longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);</b>
<b class="nc">&nbsp;              currentOffset += 3;</b>
&nbsp;            }
<b class="nc">&nbsp;            annotationVisitor.visit(elementName, longValues);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;F&#39;:
<b class="nc">&nbsp;            float[] floatValues = new float[numValues];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; numValues; i++) {</b>
<b class="nc">&nbsp;              floatValues[i] =</b>
<b class="nc">&nbsp;                  Float.intBitsToFloat(</b>
<b class="nc">&nbsp;                      readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));</b>
<b class="nc">&nbsp;              currentOffset += 3;</b>
&nbsp;            }
<b class="nc">&nbsp;            annotationVisitor.visit(elementName, floatValues);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;D&#39;:
<b class="nc">&nbsp;            double[] doubleValues = new double[numValues];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; numValues; i++) {</b>
<b class="nc">&nbsp;              doubleValues[i] =</b>
<b class="nc">&nbsp;                  Double.longBitsToDouble(</b>
<b class="nc">&nbsp;                      readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));</b>
<b class="nc">&nbsp;              currentOffset += 3;</b>
&nbsp;            }
<b class="nc">&nbsp;            annotationVisitor.visit(elementName, doubleValues);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          default:
<b class="nc">&nbsp;            currentOffset =</b>
<b class="nc">&nbsp;                readElementValues(</b>
<b class="nc">&nbsp;                    annotationVisitor.visitArray(elementName),</b>
&nbsp;                    currentOffset - 2,
&nbsp;                    /* named = */ false,
&nbsp;                    charBuffer);
<b class="nc">&nbsp;            break;</b>
&nbsp;        }
&nbsp;        break;
&nbsp;      default:
<b class="nc">&nbsp;        throw new IllegalArgumentException();</b>
&nbsp;    }
<b class="nc">&nbsp;    return currentOffset;</b>
&nbsp;  }
&nbsp;
&nbsp;  // ----------------------------------------------------------------------------------------------
&nbsp;  // Methods to parse stack map frames
&nbsp;  // ----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Computes the implicit frame of the method currently being parsed (as defined in the given
&nbsp;   * {@link Context}) and stores it in the given context.
&nbsp;   *
&nbsp;   * @param context information about the class being parsed.
&nbsp;   */
&nbsp;  private void computeImplicitFrame(final Context context) {
<b class="nc">&nbsp;    String methodDescriptor = context.currentMethodDescriptor;</b>
<b class="nc">&nbsp;    Object[] locals = context.currentFrameLocalTypes;</b>
<b class="nc">&nbsp;    int nLocal = 0;</b>
<b class="nc">&nbsp;    if ((context.currentMethodAccessFlags &amp; Opcodes.ACC_STATIC) == 0) {</b>
<b class="nc">&nbsp;      if (&quot;&lt;init&gt;&quot;.equals(context.currentMethodName)) {</b>
<b class="nc">&nbsp;        locals[nLocal++] = Opcodes.UNINITIALIZED_THIS;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        locals[nLocal++] = readClass(header + 2, context.charBuffer);</b>
&nbsp;      }
&nbsp;    }
&nbsp;    // Parse the method descriptor, one argument type descriptor at each iteration. Start by
&nbsp;    // skipping the first method descriptor character, which is always &#39;(&#39;.
<b class="nc">&nbsp;    int currentMethodDescritorOffset = 1;</b>
&nbsp;    while (true) {
<b class="nc">&nbsp;      int currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;</b>
<b class="nc">&nbsp;      switch (methodDescriptor.charAt(currentMethodDescritorOffset++)) {</b>
&nbsp;        case &#39;Z&#39;:
&nbsp;        case &#39;C&#39;:
&nbsp;        case &#39;B&#39;:
&nbsp;        case &#39;S&#39;:
&nbsp;        case &#39;I&#39;:
<b class="nc">&nbsp;          locals[nLocal++] = Opcodes.INTEGER;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case &#39;F&#39;:
<b class="nc">&nbsp;          locals[nLocal++] = Opcodes.FLOAT;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case &#39;J&#39;:
<b class="nc">&nbsp;          locals[nLocal++] = Opcodes.LONG;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case &#39;D&#39;:
<b class="nc">&nbsp;          locals[nLocal++] = Opcodes.DOUBLE;</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case &#39;[&#39;:
<b class="nc">&nbsp;          while (methodDescriptor.charAt(currentMethodDescritorOffset) == &#39;[&#39;) {</b>
<b class="nc">&nbsp;            ++currentMethodDescritorOffset;</b>
&nbsp;          }
<b class="nc">&nbsp;          if (methodDescriptor.charAt(currentMethodDescritorOffset) == &#39;L&#39;) {</b>
<b class="nc">&nbsp;            ++currentMethodDescritorOffset;</b>
<b class="nc">&nbsp;            while (methodDescriptor.charAt(currentMethodDescritorOffset) != &#39;;&#39;) {</b>
<b class="nc">&nbsp;              ++currentMethodDescritorOffset;</b>
&nbsp;            }
&nbsp;          }
<b class="nc">&nbsp;          locals[nLocal++] =</b>
<b class="nc">&nbsp;              methodDescriptor.substring(</b>
&nbsp;                  currentArgumentDescriptorStartOffset, ++currentMethodDescritorOffset);
<b class="nc">&nbsp;          break;</b>
&nbsp;        case &#39;L&#39;:
<b class="nc">&nbsp;          while (methodDescriptor.charAt(currentMethodDescritorOffset) != &#39;;&#39;) {</b>
<b class="nc">&nbsp;            ++currentMethodDescritorOffset;</b>
&nbsp;          }
<b class="nc">&nbsp;          locals[nLocal++] =</b>
<b class="nc">&nbsp;              methodDescriptor.substring(</b>
&nbsp;                  currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);
<b class="nc">&nbsp;          break;</b>
&nbsp;        default:
<b class="nc">&nbsp;          context.currentFrameLocalCount = nLocal;</b>
&nbsp;          return;
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a JVMS &#39;stack_map_frame&#39; structure and stores the result in the given {@link Context}
&nbsp;   * object. This method can also be used to read a full_frame structure, excluding its frame_type
&nbsp;   * field (this is used to parse the legacy StackMap attributes).
&nbsp;   *
&nbsp;   * @param stackMapFrameOffset the start offset in {@link #b} of the stack_map_frame_value
&nbsp;   *     structure to be read, or the start offset of a full_frame structure (excluding its
&nbsp;   *     frame_type field).
&nbsp;   * @param compressed true to read a &#39;stack_map_frame&#39; structure, false to read a &#39;full_frame&#39;
&nbsp;   *     structure without its frame_type field.
&nbsp;   * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.
&nbsp;   * @param context where the parsed stack map frame must be stored.
&nbsp;   * @return the end offset of the JVMS &#39;stack_map_frame&#39; or &#39;full_frame&#39; structure.
&nbsp;   */
&nbsp;  private int readStackMapFrame(
&nbsp;      final int stackMapFrameOffset,
&nbsp;      final boolean compressed,
&nbsp;      final boolean expand,
&nbsp;      final Context context) {
<b class="nc">&nbsp;    int currentOffset = stackMapFrameOffset;</b>
<b class="nc">&nbsp;    final char[] charBuffer = context.charBuffer;</b>
<b class="nc">&nbsp;    final Label[] labels = context.currentMethodLabels;</b>
&nbsp;    int frameType;
<b class="nc">&nbsp;    if (compressed) {</b>
&nbsp;      // Read the frame_type field.
<b class="nc">&nbsp;      frameType = b[currentOffset++] &amp; 0xFF;</b>
&nbsp;    } else {
<b class="nc">&nbsp;      frameType = Frame.FULL_FRAME;</b>
<b class="nc">&nbsp;      context.currentFrameOffset = -1;</b>
&nbsp;    }
&nbsp;    int offsetDelta;
<b class="nc">&nbsp;    context.currentFrameLocalCountDelta = 0;</b>
<b class="nc">&nbsp;    if (frameType &lt; Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {</b>
<b class="nc">&nbsp;      offsetDelta = frameType;</b>
<b class="nc">&nbsp;      context.currentFrameType = Opcodes.F_SAME;</b>
<b class="nc">&nbsp;      context.currentFrameStackCount = 0;</b>
<b class="nc">&nbsp;    } else if (frameType &lt; Frame.RESERVED) {</b>
<b class="nc">&nbsp;      offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;</b>
<b class="nc">&nbsp;      currentOffset =</b>
<b class="nc">&nbsp;          readVerificationTypeInfo(</b>
&nbsp;              currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);
<b class="nc">&nbsp;      context.currentFrameType = Opcodes.F_SAME1;</b>
<b class="nc">&nbsp;      context.currentFrameStackCount = 1;</b>
<b class="nc">&nbsp;    } else if (frameType &gt;= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {</b>
<b class="nc">&nbsp;      offsetDelta = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;      currentOffset += 2;</b>
<b class="nc">&nbsp;      if (frameType == Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {</b>
<b class="nc">&nbsp;        currentOffset =</b>
<b class="nc">&nbsp;            readVerificationTypeInfo(</b>
&nbsp;                currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);
<b class="nc">&nbsp;        context.currentFrameType = Opcodes.F_SAME1;</b>
<b class="nc">&nbsp;        context.currentFrameStackCount = 1;</b>
<b class="nc">&nbsp;      } else if (frameType &gt;= Frame.CHOP_FRAME &amp;&amp; frameType &lt; Frame.SAME_FRAME_EXTENDED) {</b>
<b class="nc">&nbsp;        context.currentFrameType = Opcodes.F_CHOP;</b>
<b class="nc">&nbsp;        context.currentFrameLocalCountDelta = Frame.SAME_FRAME_EXTENDED - frameType;</b>
<b class="nc">&nbsp;        context.currentFrameLocalCount -= context.currentFrameLocalCountDelta;</b>
<b class="nc">&nbsp;        context.currentFrameStackCount = 0;</b>
<b class="nc">&nbsp;      } else if (frameType == Frame.SAME_FRAME_EXTENDED) {</b>
<b class="nc">&nbsp;        context.currentFrameType = Opcodes.F_SAME;</b>
<b class="nc">&nbsp;        context.currentFrameStackCount = 0;</b>
<b class="nc">&nbsp;      } else if (frameType &lt; Frame.FULL_FRAME) {</b>
<b class="nc">&nbsp;        int local = expand ? context.currentFrameLocalCount : 0;</b>
<b class="nc">&nbsp;        for (int k = frameType - Frame.SAME_FRAME_EXTENDED; k &gt; 0; k--) {</b>
<b class="nc">&nbsp;          currentOffset =</b>
<b class="nc">&nbsp;              readVerificationTypeInfo(</b>
&nbsp;                  currentOffset, context.currentFrameLocalTypes, local++, charBuffer, labels);
&nbsp;        }
<b class="nc">&nbsp;        context.currentFrameType = Opcodes.F_APPEND;</b>
<b class="nc">&nbsp;        context.currentFrameLocalCountDelta = frameType - Frame.SAME_FRAME_EXTENDED;</b>
<b class="nc">&nbsp;        context.currentFrameLocalCount += context.currentFrameLocalCountDelta;</b>
<b class="nc">&nbsp;        context.currentFrameStackCount = 0;</b>
<b class="nc">&nbsp;      } else {</b>
<b class="nc">&nbsp;        final int numberOfLocals = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        context.currentFrameType = Opcodes.F_FULL;</b>
<b class="nc">&nbsp;        context.currentFrameLocalCountDelta = numberOfLocals;</b>
<b class="nc">&nbsp;        context.currentFrameLocalCount = numberOfLocals;</b>
<b class="nc">&nbsp;        for (int local = 0; local &lt; numberOfLocals; ++local) {</b>
<b class="nc">&nbsp;          currentOffset =</b>
<b class="nc">&nbsp;              readVerificationTypeInfo(</b>
&nbsp;                  currentOffset, context.currentFrameLocalTypes, local, charBuffer, labels);
&nbsp;        }
<b class="nc">&nbsp;        final int numberOfStackItems = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        context.currentFrameStackCount = numberOfStackItems;</b>
<b class="nc">&nbsp;        for (int stack = 0; stack &lt; numberOfStackItems; ++stack) {</b>
<b class="nc">&nbsp;          currentOffset =</b>
<b class="nc">&nbsp;              readVerificationTypeInfo(</b>
&nbsp;                  currentOffset, context.currentFrameStackTypes, stack, charBuffer, labels);
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;    } else {
<b class="nc">&nbsp;      throw new IllegalArgumentException();</b>
&nbsp;    }
<b class="nc">&nbsp;    context.currentFrameOffset += offsetDelta + 1;</b>
<b class="nc">&nbsp;    createLabel(context.currentFrameOffset, labels);</b>
<b class="nc">&nbsp;    return currentOffset;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a JVMS &#39;verification_type_info&#39; structure and stores it at the given index in the given
&nbsp;   * array.
&nbsp;   *
&nbsp;   * @param verificationTypeInfoOffset the start offset of the &#39;verification_type_info&#39; structure to
&nbsp;   *     read.
&nbsp;   * @param frame the array where the parsed type must be stored.
&nbsp;   * @param index the index in &#39;frame&#39; where the parsed type must be stored.
&nbsp;   * @param charBuffer the buffer used to read strings in the constant pool.
&nbsp;   * @param labels the labels of the method currently being parsed, indexed by their offset. If the
&nbsp;   *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is
&nbsp;   *     stored in this array if it does not already exist.
&nbsp;   * @return the end offset of the JVMS &#39;verification_type_info&#39; structure.
&nbsp;   */
&nbsp;  private int readVerificationTypeInfo(
&nbsp;      final int verificationTypeInfoOffset,
&nbsp;      final Object[] frame,
&nbsp;      final int index,
&nbsp;      final char[] charBuffer,
&nbsp;      final Label[] labels) {
<b class="nc">&nbsp;    int currentOffset = verificationTypeInfoOffset;</b>
<b class="nc">&nbsp;    int tag = b[currentOffset++] &amp; 0xFF;</b>
<b class="nc">&nbsp;    switch (tag) {</b>
&nbsp;      case Frame.ITEM_TOP:
<b class="nc">&nbsp;        frame[index] = Opcodes.TOP;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Frame.ITEM_INTEGER:
<b class="nc">&nbsp;        frame[index] = Opcodes.INTEGER;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Frame.ITEM_FLOAT:
<b class="nc">&nbsp;        frame[index] = Opcodes.FLOAT;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Frame.ITEM_DOUBLE:
<b class="nc">&nbsp;        frame[index] = Opcodes.DOUBLE;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Frame.ITEM_LONG:
<b class="nc">&nbsp;        frame[index] = Opcodes.LONG;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Frame.ITEM_NULL:
<b class="nc">&nbsp;        frame[index] = Opcodes.NULL;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Frame.ITEM_UNINITIALIZED_THIS:
<b class="nc">&nbsp;        frame[index] = Opcodes.UNINITIALIZED_THIS;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Frame.ITEM_OBJECT:
<b class="nc">&nbsp;        frame[index] = readClass(currentOffset, charBuffer);</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Frame.ITEM_UNINITIALIZED:
<b class="nc">&nbsp;        frame[index] = createLabel(readUnsignedShort(currentOffset), labels);</b>
<b class="nc">&nbsp;        currentOffset += 2;</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      default:
<b class="nc">&nbsp;        throw new IllegalArgumentException();</b>
&nbsp;    }
<b class="nc">&nbsp;    return currentOffset;</b>
&nbsp;  }
&nbsp;
&nbsp;  // ----------------------------------------------------------------------------------------------
&nbsp;  // Methods to parse attributes
&nbsp;  // ----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /** @return the offset in {@link #b} of the first ClassFile&#39;s &#39;attributes&#39; array field entry. */
&nbsp;  final int getFirstAttributeOffset() {
&nbsp;    // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes
&nbsp;    // each), as well as the interfaces array field (2 bytes per interface).
<b class="nc">&nbsp;    int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;</b>
&nbsp;
&nbsp;    // Read the fields_count field.
<b class="nc">&nbsp;    int fieldsCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
&nbsp;    // Skip the &#39;fields&#39; array field.
<b class="nc">&nbsp;    while (fieldsCount-- &gt; 0) {</b>
&nbsp;      // Invariant: currentOffset is the offset of a field_info structure.
&nbsp;      // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the
&nbsp;      // attributes_count field.
<b class="nc">&nbsp;      int attributesCount = readUnsignedShort(currentOffset + 6);</b>
<b class="nc">&nbsp;      currentOffset += 8;</b>
&nbsp;      // Skip the &#39;attributes&#39; array field.
<b class="nc">&nbsp;      while (attributesCount-- &gt; 0) {</b>
&nbsp;        // Invariant: currentOffset is the offset of an attribute_info structure.
&nbsp;        // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip
&nbsp;        // this many bytes, plus 6 for the attribute_name_index and attribute_length fields
&nbsp;        // (yielding the total size of the attribute_info structure).
<b class="nc">&nbsp;        currentOffset += 6 + readInt(currentOffset + 2);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Skip the methods_count and &#39;methods&#39; fields, using the same method as above.
<b class="nc">&nbsp;    int methodsCount = readUnsignedShort(currentOffset);</b>
<b class="nc">&nbsp;    currentOffset += 2;</b>
<b class="nc">&nbsp;    while (methodsCount-- &gt; 0) {</b>
<b class="nc">&nbsp;      int attributesCount = readUnsignedShort(currentOffset + 6);</b>
<b class="nc">&nbsp;      currentOffset += 8;</b>
<b class="nc">&nbsp;      while (attributesCount-- &gt; 0) {</b>
<b class="nc">&nbsp;        currentOffset += 6 + readInt(currentOffset + 2);</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Skip the ClassFile&#39;s attributes_count field.
<b class="nc">&nbsp;    return currentOffset + 2;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a non standard JVMS &#39;attribute&#39; structure in {@link #b}.
&nbsp;   *
&nbsp;   * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
&nbsp;   *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
&nbsp;   *     be parsed: its byte array value will be passed unchanged to the ClassWriter.
&nbsp;   * @param type the type of the attribute.
&nbsp;   * @param offset the start offset of the JVMS &#39;attribute&#39; structure in {@link #b}. The 6 attribute
&nbsp;   *     header bytes (attribute_name_index and attribute_length) are not taken into account here.
&nbsp;   * @param length the length of the attribute&#39;s content (excluding the 6 attribute header bytes).
&nbsp;   * @param charBuffer the buffer to be used to read strings in the constant pool.
&nbsp;   * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link #b}, or
&nbsp;   *     -1 if the attribute to be read is not a code attribute. The 6 attribute header bytes
&nbsp;   *     (attribute_name_index and attribute_length) are not taken into account here.
&nbsp;   * @param labels the labels of the method&#39;s code, or &lt;tt&gt;null&lt;/tt&gt; if the attribute to be read is
&nbsp;   *     not a code attribute.
&nbsp;   * @return the attribute that has been read.
&nbsp;   */
&nbsp;  private Attribute readAttribute(
&nbsp;      final Attribute[] attributePrototypes,
&nbsp;      final String type,
&nbsp;      final int offset,
&nbsp;      final int length,
&nbsp;      final char[] charBuffer,
&nbsp;      final int codeAttributeOffset,
&nbsp;      final Label[] labels) {
<b class="nc">&nbsp;    for (int i = 0; i &lt; attributePrototypes.length; ++i) {</b>
<b class="nc">&nbsp;      if (attributePrototypes[i].type.equals(type)) {</b>
<b class="nc">&nbsp;        return attributePrototypes[i].read(</b>
&nbsp;            this, offset, length, charBuffer, codeAttributeOffset, labels);
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return new Attribute(type).read(this, offset, length, null, -1, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Utility methods: low level parsing
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the number of entries in the class&#39;s constant pool table.
&nbsp;   *
&nbsp;   * @return the number of entries in the class&#39;s constant pool table.
&nbsp;   */
&nbsp;  public int getItemCount() {
<b class="nc">&nbsp;    return cpInfoOffsets.length;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the start offset in {@link #b} of a JVMS &#39;cp_info&#39; structure (i.e. a constant pool
&nbsp;   * entry), plus one. &lt;i&gt;This method is intended for {@link Attribute} sub classes, and is normally
&nbsp;   * not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param constantPoolEntryIndex the index a constant pool entry in the class&#39;s constant pool
&nbsp;   *     table.
&nbsp;   * @return the start offset in {@link #b} of the corresponding JVMS &#39;cp_info&#39; structure, plus one.
&nbsp;   */
&nbsp;  public int getItem(final int constantPoolEntryIndex) {
<b class="nc">&nbsp;    return cpInfoOffsets[constantPoolEntryIndex];</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns a conservative estimate of the maximum length of the strings contained in the class&#39;s
&nbsp;   * constant pool table.
&nbsp;   *
&nbsp;   * @return a conservative estimate of the maximum length of the strings contained in the class&#39;s
&nbsp;   *     constant pool table.
&nbsp;   */
&nbsp;  public int getMaxStringLength() {
<b class="nc">&nbsp;    return maxStringLength;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a byte value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute} sub classes,
&nbsp;   * and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param offset the start offset of the value to be read in {@link #b}.
&nbsp;   * @return the read value.
&nbsp;   */
&nbsp;  public int readByte(final int offset) {
<b class="nc">&nbsp;    return b[offset] &amp; 0xFF;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads an unsigned short value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute}
&nbsp;   * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param offset the start index of the value to be read in {@link #b}.
&nbsp;   * @return the read value.
&nbsp;   */
&nbsp;  public int readUnsignedShort(final int offset) {
<b class="nc">&nbsp;    byte[] classFileBuffer = b;</b>
<b class="nc">&nbsp;    return ((classFileBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classFileBuffer[offset + 1] &amp; 0xFF);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a signed short value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute} sub
&nbsp;   * classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param offset the start offset of the value to be read in {@link #b}.
&nbsp;   * @return the read value.
&nbsp;   */
&nbsp;  public short readShort(final int offset) {
<b class="nc">&nbsp;    byte[] classFileBuffer = b;</b>
<b class="nc">&nbsp;    return (short) (((classFileBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classFileBuffer[offset + 1] &amp; 0xFF));</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a signed int value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute} sub
&nbsp;   * classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param offset the start offset of the value to be read in {@link #b}.
&nbsp;   * @return the read value.
&nbsp;   */
&nbsp;  public int readInt(final int offset) {
<b class="nc">&nbsp;    byte[] classFileBuffer = b;</b>
<b class="nc">&nbsp;    return ((classFileBuffer[offset] &amp; 0xFF) &lt;&lt; 24)</b>
&nbsp;        | ((classFileBuffer[offset + 1] &amp; 0xFF) &lt;&lt; 16)
&nbsp;        | ((classFileBuffer[offset + 2] &amp; 0xFF) &lt;&lt; 8)
&nbsp;        | (classFileBuffer[offset + 3] &amp; 0xFF);
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a signed long value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute} sub
&nbsp;   * classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param offset the start offset of the value to be read in {@link #b}.
&nbsp;   * @return the read value.
&nbsp;   */
&nbsp;  public long readLong(final int offset) {
<b class="nc">&nbsp;    long l1 = readInt(offset);</b>
<b class="nc">&nbsp;    long l0 = readInt(offset + 4) &amp; 0xFFFFFFFFL;</b>
<b class="nc">&nbsp;    return (l1 &lt;&lt; 32) | l0;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a CONSTANT_Utf8 constant pool entry in {@link #b}. &lt;i&gt;This method is intended for {@link
&nbsp;   * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
&nbsp;   *     index of a CONSTANT_Utf8 entry in the class&#39;s constant pool table.
&nbsp;   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
&nbsp;   *     large. It is not automatically resized.
&nbsp;   * @return the String corresponding to the specified CONSTANT_Utf8 entry.
&nbsp;   */
&nbsp;  public String readUTF8(final int offset, final char[] charBuffer) {
<b class="nc">&nbsp;    int constantPoolEntryIndex = readUnsignedShort(offset);</b>
<b class="nc">&nbsp;    if (offset == 0 || constantPoolEntryIndex == 0) {</b>
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
<b class="nc">&nbsp;    return readUTF(constantPoolEntryIndex, charBuffer);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a CONSTANT_Utf8 constant pool entry in {@link #b}.
&nbsp;   *
&nbsp;   * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class&#39;s constant pool
&nbsp;   *     table.
&nbsp;   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
&nbsp;   *     large. It is not automatically resized.
&nbsp;   * @return the String corresponding to the specified CONSTANT_Utf8 entry.
&nbsp;   */
&nbsp;  final String readUTF(final int constantPoolEntryIndex, final char[] charBuffer) {
<b class="nc">&nbsp;    String value = (String) cpInfoValues[constantPoolEntryIndex];</b>
<b class="nc">&nbsp;    if (value != null) {</b>
<b class="nc">&nbsp;      return value;</b>
&nbsp;    }
<b class="nc">&nbsp;    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];</b>
<b class="nc">&nbsp;    value = readUTF(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);</b>
<b class="nc">&nbsp;    cpInfoValues[constantPoolEntryIndex] = value;</b>
<b class="nc">&nbsp;    return value;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads an UTF8 string in {@link #b}.
&nbsp;   *
&nbsp;   * @param utfOffset the start offset of the UTF8 string to be read.
&nbsp;   * @param utfLength the length of the UTF8 string to be read.
&nbsp;   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
&nbsp;   *     large. It is not automatically resized.
&nbsp;   * @return the String corresponding to the specified UTF8 string.
&nbsp;   */
&nbsp;  private String readUTF(final int utfOffset, final int utfLength, final char[] charBuffer) {
<b class="nc">&nbsp;    int currentOffset = utfOffset;</b>
<b class="nc">&nbsp;    int endOffset = currentOffset + utfLength;</b>
<b class="nc">&nbsp;    int strLength = 0;</b>
<b class="nc">&nbsp;    byte[] classFileBuffer = b;</b>
<b class="nc">&nbsp;    while (currentOffset &lt; endOffset) {</b>
<b class="nc">&nbsp;      int currentByte = classFileBuffer[currentOffset++];</b>
<b class="nc">&nbsp;      if ((currentByte &amp; 0x80) == 0) {</b>
<b class="nc">&nbsp;        charBuffer[strLength++] = (char) (currentByte &amp; 0x7F);</b>
<b class="nc">&nbsp;      } else if ((currentByte &amp; 0xE0) == 0xC0) {</b>
<b class="nc">&nbsp;        charBuffer[strLength++] =</b>
&nbsp;            (char) (((currentByte &amp; 0x1F) &lt;&lt; 6) + (classFileBuffer[currentOffset++] &amp; 0x3F));
&nbsp;      } else {
<b class="nc">&nbsp;        charBuffer[strLength++] =</b>
&nbsp;            (char)
&nbsp;                (((currentByte &amp; 0xF) &lt;&lt; 12)
&nbsp;                    + ((classFileBuffer[currentOffset++] &amp; 0x3F) &lt;&lt; 6)
&nbsp;                    + (classFileBuffer[currentOffset++] &amp; 0x3F));
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    return new String(charBuffer, 0, strLength);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
&nbsp;   * CONSTANT_Package constant pool entry in {@link #b}. &lt;i&gt;This method is intended for {@link
&nbsp;   * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
&nbsp;   *     index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
&nbsp;   *     CONSTANT_Package entry in class&#39;s constant pool table.
&nbsp;   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
&nbsp;   *     large. It is not automatically resized.
&nbsp;   * @return the String corresponding to the specified constant pool entry.
&nbsp;   */
&nbsp;  private String readStringish(final int offset, final char[] charBuffer) {
&nbsp;    // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry
&nbsp;    // designated by the first two bytes of this cp_info.
<b class="nc">&nbsp;    return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a CONSTANT_Class constant pool entry in {@link #b}. &lt;i&gt;This method is intended for {@link
&nbsp;   * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
&nbsp;   *     index of a CONSTANT_Class entry in class&#39;s constant pool table.
&nbsp;   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
&nbsp;   *     large. It is not automatically resized.
&nbsp;   * @return the String corresponding to the specified CONSTANT_Class entry.
&nbsp;   */
&nbsp;  public String readClass(final int offset, final char[] charBuffer) {
<b class="nc">&nbsp;    return readStringish(offset, charBuffer);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a CONSTANT_Module constant pool entry in {@link #b}. &lt;i&gt;This method is intended for
&nbsp;   * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
&nbsp;   *     index of a CONSTANT_Module entry in class&#39;s constant pool table.
&nbsp;   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
&nbsp;   *     large. It is not automatically resized.
&nbsp;   * @return the String corresponding to the specified CONSTANT_Module entry.
&nbsp;   */
&nbsp;  public String readModule(final int offset, final char[] charBuffer) {
<b class="nc">&nbsp;    return readStringish(offset, charBuffer);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a CONSTANT_Package constant pool entry in {@link #b}. &lt;i&gt;This method is intended for
&nbsp;   * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
&nbsp;   *     index of a CONSTANT_Package entry in class&#39;s constant pool table.
&nbsp;   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
&nbsp;   *     large. It is not automatically resized.
&nbsp;   * @return the String corresponding to the specified CONSTANT_Package entry.
&nbsp;   */
&nbsp;  public String readPackage(final int offset, final char[] charBuffer) {
<b class="nc">&nbsp;    return readStringish(offset, charBuffer);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a CONSTANT_Dynamic constant pool entry in {@link #b}.
&nbsp;   *
&nbsp;   * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class&#39;s constant
&nbsp;   *     pool table.
&nbsp;   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
&nbsp;   *     large. It is not automatically resized.
&nbsp;   * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.
&nbsp;   */
&nbsp;  private ConstantDynamic readConstantDynamic(
&nbsp;      final int constantPoolEntryIndex, final char[] charBuffer) {
<b class="nc">&nbsp;    ConstantDynamic constantDynamic = (ConstantDynamic) cpInfoValues[constantPoolEntryIndex];</b>
<b class="nc">&nbsp;    if (constantDynamic != null) {</b>
<b class="nc">&nbsp;      return constantDynamic;</b>
&nbsp;    }
<b class="nc">&nbsp;    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];</b>
<b class="nc">&nbsp;    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];</b>
<b class="nc">&nbsp;    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);</b>
<b class="nc">&nbsp;    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);</b>
<b class="nc">&nbsp;    int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];</b>
<b class="nc">&nbsp;    Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);</b>
<b class="nc">&nbsp;    Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];</b>
<b class="nc">&nbsp;    bootstrapMethodOffset += 4;</b>
<b class="nc">&nbsp;    for (int i = 0; i &lt; bootstrapMethodArguments.length; i++) {</b>
<b class="nc">&nbsp;      bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);</b>
<b class="nc">&nbsp;      bootstrapMethodOffset += 2;</b>
&nbsp;    }
<b class="nc">&nbsp;    constantDynamic = new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);</b>
<b class="nc">&nbsp;    cpInfoValues[constantPoolEntryIndex] = constantDynamic;</b>
<b class="nc">&nbsp;    return constantDynamic;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Reads a numeric or string constant pool entry in {@link #b}. &lt;i&gt;This method is intended for
&nbsp;   * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,
&nbsp;   *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
&nbsp;   *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class&#39;s constant pool.
&nbsp;   * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently
&nbsp;   *     large. It is not automatically resized.
&nbsp;   * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},
&nbsp;   *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified
&nbsp;   *     constant pool entry.
&nbsp;   */
&nbsp;  public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {
<b class="nc">&nbsp;    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];</b>
<b class="nc">&nbsp;    switch (b[cpInfoOffset - 1]) {</b>
&nbsp;      case Symbol.CONSTANT_INTEGER_TAG:
<b class="nc">&nbsp;        return readInt(cpInfoOffset);</b>
&nbsp;      case Symbol.CONSTANT_FLOAT_TAG:
<b class="nc">&nbsp;        return Float.intBitsToFloat(readInt(cpInfoOffset));</b>
&nbsp;      case Symbol.CONSTANT_LONG_TAG:
<b class="nc">&nbsp;        return readLong(cpInfoOffset);</b>
&nbsp;      case Symbol.CONSTANT_DOUBLE_TAG:
<b class="nc">&nbsp;        return Double.longBitsToDouble(readLong(cpInfoOffset));</b>
&nbsp;      case Symbol.CONSTANT_CLASS_TAG:
<b class="nc">&nbsp;        return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));</b>
&nbsp;      case Symbol.CONSTANT_STRING_TAG:
<b class="nc">&nbsp;        return readUTF8(cpInfoOffset, charBuffer);</b>
&nbsp;      case Symbol.CONSTANT_METHOD_TYPE_TAG:
<b class="nc">&nbsp;        return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));</b>
&nbsp;      case Symbol.CONSTANT_METHOD_HANDLE_TAG:
<b class="nc">&nbsp;        int referenceKind = readByte(cpInfoOffset);</b>
<b class="nc">&nbsp;        int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];</b>
<b class="nc">&nbsp;        int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];</b>
<b class="nc">&nbsp;        String owner = readClass(referenceCpInfoOffset, charBuffer);</b>
<b class="nc">&nbsp;        String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);</b>
<b class="nc">&nbsp;        String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);</b>
<b class="nc">&nbsp;        boolean isInterface =</b>
&nbsp;            b[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
<b class="nc">&nbsp;        return new Handle(referenceKind, owner, name, descriptor, isInterface);</b>
&nbsp;      case Symbol.CONSTANT_DYNAMIC_TAG:
<b class="nc">&nbsp;        return readConstantDynamic(constantPoolEntryIndex, charBuffer);</b>
&nbsp;      default:
<b class="nc">&nbsp;        throw new IllegalArgumentException();</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
