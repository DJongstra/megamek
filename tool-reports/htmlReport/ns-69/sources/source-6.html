


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > ClassWriter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.jar.asm</a>
</div>

<h1>Coverage Summary for Class: ClassWriter (net.bytebuddy.jar.asm)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ClassWriter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21,9%
  </span>
  <span class="absValue">
    (7/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42%
  </span>
  <span class="absValue">
    (63/150)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    34,2%
  </span>
  <span class="absValue">
    (101/295)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;// ASM: a very small and fast Java bytecode manipulation framework
&nbsp;// Copyright (c) 2000-2011 INRIA, France Telecom
&nbsp;// All rights reserved.
&nbsp;//
&nbsp;// Redistribution and use in source and binary forms, with or without
&nbsp;// modification, are permitted provided that the following conditions
&nbsp;// are met:
&nbsp;// 1. Redistributions of source code must retain the above copyright
&nbsp;//    notice, this list of conditions and the following disclaimer.
&nbsp;// 2. Redistributions in binary form must reproduce the above copyright
&nbsp;//    notice, this list of conditions and the following disclaimer in the
&nbsp;//    documentation and/or other materials provided with the distribution.
&nbsp;// 3. Neither the name of the copyright holders nor the names of its
&nbsp;//    contributors may be used to endorse or promote products derived from
&nbsp;//    this software without specific prior written permission.
&nbsp;//
&nbsp;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
&nbsp;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
&nbsp;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
&nbsp;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
&nbsp;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
&nbsp;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
&nbsp;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
&nbsp;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
&nbsp;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
&nbsp;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
&nbsp;// THE POSSIBILITY OF SUCH DAMAGE.
&nbsp;package net.bytebuddy.jar.asm;
&nbsp;
&nbsp;/**
&nbsp; * A {@link ClassVisitor} that generates a corresponding ClassFile structure, as defined in the Java
&nbsp; * Virtual Machine Specification (JVMS). It can be used alone, to generate a Java class &quot;from
&nbsp; * scratch&quot;, or with one or more {@link ClassReader} and adapter {@link ClassVisitor} to generate a
&nbsp; * modified class from one or more existing Java classes.
&nbsp; *
&nbsp; * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html&quot;&gt;JVMS 4&lt;/a&gt;
&nbsp; * @author Eric Bruneton
&nbsp; */
&nbsp;public class ClassWriter extends ClassVisitor {
&nbsp;
&nbsp;  /**
&nbsp;   * A flag to automatically compute the maximum stack size and the maximum number of local
&nbsp;   * variables of methods. If this flag is set, then the arguments of the {@link
&nbsp;   * MethodVisitor#visitMaxs} method of the {@link MethodVisitor} returned by the {@link
&nbsp;   * #visitMethod} method will be ignored, and computed automatically from the signature and the
&nbsp;   * bytecode of each method.
&nbsp;   *
&nbsp;   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; for classes whose version is {@link Opcodes#V1_7} of more, this option requires
&nbsp;   * valid stack map frames. The maximum stack size is then computed from these frames, and from the
&nbsp;   * bytecode instructions in between. If stack map frames are not present or must be recomputed,
&nbsp;   * used {@link #COMPUTE_FRAMES} instead.
&nbsp;   *
&nbsp;   * @see #ClassWriter(int)
&nbsp;   */
&nbsp;  public static final int COMPUTE_MAXS = 1;
&nbsp;
&nbsp;  /**
&nbsp;   * A flag to automatically compute the stack map frames of methods from scratch. If this flag is
&nbsp;   * set, then the calls to the {@link MethodVisitor#visitFrame} method are ignored, and the stack
&nbsp;   * map frames are recomputed from the methods bytecode. The arguments of the {@link
&nbsp;   * MethodVisitor#visitMaxs} method are also ignored and recomputed from the bytecode. In other
&nbsp;   * words, {@link #COMPUTE_FRAMES} implies {@link #COMPUTE_MAXS}.
&nbsp;   *
&nbsp;   * @see #ClassWriter(int)
&nbsp;   */
&nbsp;  public static final int COMPUTE_FRAMES = 2;
&nbsp;
&nbsp;  // Note: fields are ordered as in the ClassFile structure, and those related to attributes are
&nbsp;  // ordered as in Section 4.7 of the JVMS.
&nbsp;
&nbsp;  /**
&nbsp;   * The minor_version and major_version fields of the JVMS ClassFile structure. minor_version is
&nbsp;   * stored in the 16 most significant bits, and major_version in the 16 least significant bits.
&nbsp;   */
&nbsp;  private int version;
&nbsp;
&nbsp;  /** The symbol table for this class (contains the constant_pool and the BootstrapMethods). */
&nbsp;  private final SymbolTable symbolTable;
&nbsp;
&nbsp;  /**
&nbsp;   * The access_flags field of the JVMS ClassFile structure. This field can contain ASM specific
&nbsp;   * access flags, such as {@link Opcodes#ACC_DEPRECATED}, which are removed when generating the
&nbsp;   * ClassFile structure.
&nbsp;   */
&nbsp;  private int accessFlags;
&nbsp;
&nbsp;  /** The this_class field of the JVMS ClassFile structure. */
&nbsp;  private int thisClass;
&nbsp;
&nbsp;  /** The super_class field of the JVMS ClassFile structure. */
&nbsp;  private int superClass;
&nbsp;
&nbsp;  /** The interface_count field of the JVMS ClassFile structure. */
&nbsp;  private int interfaceCount;
&nbsp;
&nbsp;  /** The &#39;interfaces&#39; array of the JVMS ClassFile structure. */
&nbsp;  private int[] interfaces;
&nbsp;
&nbsp;  /**
&nbsp;   * The fields of this class, stored in a linked list of {@link FieldWriter} linked via their
&nbsp;   * {@link FieldWriter#fv} field. This field stores the first element of this list.
&nbsp;   */
&nbsp;  private FieldWriter firstField;
&nbsp;
&nbsp;  /**
&nbsp;   * The fields of this class, stored in a linked list of {@link FieldWriter} linked via their
&nbsp;   * {@link FieldWriter#fv} field. This field stores the last element of this list.
&nbsp;   */
&nbsp;  private FieldWriter lastField;
&nbsp;
&nbsp;  /**
&nbsp;   * The methods of this class, stored in a linked list of {@link MethodWriter} linked via their
&nbsp;   * {@link MethodWriter#mv} field. This field stores the first element of this list.
&nbsp;   */
&nbsp;  private MethodWriter firstMethod;
&nbsp;
&nbsp;  /**
&nbsp;   * The methods of this class, stored in a linked list of {@link MethodWriter} linked via their
&nbsp;   * {@link MethodWriter#mv} field. This field stores the last element of this list.
&nbsp;   */
&nbsp;  private MethodWriter lastMethod;
&nbsp;
&nbsp;  /** The number_of_classes field of the InnerClasses attribute, or 0. */
&nbsp;  private int numberOfInnerClasses;
&nbsp;
&nbsp;  /** The &#39;classes&#39; array of the InnerClasses attribute, or &lt;tt&gt;null&lt;/tt&gt;. */
&nbsp;  private ByteVector innerClasses;
&nbsp;
&nbsp;  /** The class_index field of the EnclosingMethod attribute, or 0. */
&nbsp;  private int enclosingClassIndex;
&nbsp;
&nbsp;  /** The method_index field of the EnclosingMethod attribute. */
&nbsp;  private int enclosingMethodIndex;
&nbsp;
&nbsp;  /** The signature_index field of the Signature attribute, or 0. */
&nbsp;  private int signatureIndex;
&nbsp;
&nbsp;  /** The source_file_index field of the SourceFile attribute, or 0. */
&nbsp;  private int sourceFileIndex;
&nbsp;
&nbsp;  /** The debug_extension field of the SourceDebugExtension attribute, or &lt;tt&gt;null&lt;/tt&gt;. */
&nbsp;  private ByteVector debugExtension;
&nbsp;
&nbsp;  /**
&nbsp;   * The last runtime visible annotation of this class. The previous ones can be accessed with the
&nbsp;   * {@link AnnotationWriter#previousAnnotation} field. May be &lt;tt&gt;null&lt;/tt&gt;.
&nbsp;   */
&nbsp;  private AnnotationWriter lastRuntimeVisibleAnnotation;
&nbsp;
&nbsp;  /**
&nbsp;   * The last runtime invisible annotation of this class. The previous ones can be accessed with the
&nbsp;   * {@link AnnotationWriter#previousAnnotation} field. May be &lt;tt&gt;null&lt;/tt&gt;.
&nbsp;   */
&nbsp;  private AnnotationWriter lastRuntimeInvisibleAnnotation;
&nbsp;
&nbsp;  /**
&nbsp;   * The last runtime visible type annotation of this class. The previous ones can be accessed with
&nbsp;   * the {@link AnnotationWriter#previousAnnotation} field. May be &lt;tt&gt;null&lt;/tt&gt;.
&nbsp;   */
&nbsp;  private AnnotationWriter lastRuntimeVisibleTypeAnnotation;
&nbsp;
&nbsp;  /**
&nbsp;   * The last runtime invisible type annotation of this class. The previous ones can be accessed
&nbsp;   * with the {@link AnnotationWriter#previousAnnotation} field. May be &lt;tt&gt;null&lt;/tt&gt;.
&nbsp;   */
&nbsp;  private AnnotationWriter lastRuntimeInvisibleTypeAnnotation;
&nbsp;
&nbsp;  /** The Module attribute of this class, or &lt;tt&gt;null&lt;/tt&gt;. */
&nbsp;  private ModuleWriter moduleWriter;
&nbsp;
&nbsp;  /** The host_class_index field of the NestHost attribute, or 0. */
&nbsp;  private int nestHostClassIndex;
&nbsp;
&nbsp;  /** The number_of_classes field of the NestMembers attribute, or 0. */
&nbsp;  private int numberOfNestMemberClasses;
&nbsp;
&nbsp;  /** The &#39;classes&#39; array of the NestMembers attribute, or &lt;tt&gt;null&lt;/tt&gt;. */
&nbsp;  private ByteVector nestMemberClasses;
&nbsp;
&nbsp;  /**
&nbsp;   * The first non standard attribute of this class. The next ones can be accessed with the {@link
&nbsp;   * Attribute#nextAttribute} field. May be &lt;tt&gt;null&lt;/tt&gt;.
&nbsp;   *
&nbsp;   * &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: this list stores the attributes in the &lt;i&gt;reverse&lt;/i&gt; order of their visit.
&nbsp;   * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link
&nbsp;   * #toByteArray} method writes the attributes in the order defined by this list, i.e. in the
&nbsp;   * reverse order specified by the user.
&nbsp;   */
&nbsp;  private Attribute firstAttribute;
&nbsp;
&nbsp;  /**
&nbsp;   * Indicates what must be automatically computed in {@link MethodWriter}. Must be one of {@link
&nbsp;   * MethodWriter#COMPUTE_NOTHING}, {@link MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL}, {@link
&nbsp;   * MethodWriter#COMPUTE_INSERTED_FRAMES}, or {@link MethodWriter#COMPUTE_ALL_FRAMES}.
&nbsp;   */
&nbsp;  private int compute;
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Constructor
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a new {@link ClassWriter} object.
&nbsp;   *
&nbsp;   * @param flags option flags that can be used to modify the default behavior of this class. Must
&nbsp;   *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}.
&nbsp;   */
&nbsp;  public ClassWriter(final int flags) {
<b class="fc">&nbsp;    this(null, flags);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a new {@link ClassWriter} object and enables optimizations for &quot;mostly add&quot; bytecode
&nbsp;   * transformations. These optimizations are the following:
&nbsp;   *
&nbsp;   * &lt;ul&gt;
&nbsp;   *   &lt;li&gt;The constant pool and bootstrap methods from the original class are copied as is in the
&nbsp;   *       new class, which saves time. New constant pool entries and new bootstrap methods will be
&nbsp;   *       added at the end if necessary, but unused constant pool entries or bootstrap methods
&nbsp;   *       &lt;i&gt;won&#39;t be removed&lt;/i&gt;.
&nbsp;   *   &lt;li&gt;Methods that are not transformed are copied as is in the new class, directly from the
&nbsp;   *       original class bytecode (i.e. without emitting visit events for all the method
&nbsp;   *       instructions), which saves a &lt;i&gt;lot&lt;/i&gt; of time. Untransformed methods are detected by
&nbsp;   *       the fact that the {@link ClassReader} receives {@link MethodVisitor} objects that come
&nbsp;   *       from a {@link ClassWriter} (and not from any other {@link ClassVisitor} instance).
&nbsp;   * &lt;/ul&gt;
&nbsp;   *
&nbsp;   * @param classReader the {@link ClassReader} used to read the original class. It will be used to
&nbsp;   *     copy the entire constant pool and bootstrap methods from the original class and also to
&nbsp;   *     copy other fragments of original bytecode where applicable.
&nbsp;   * @param flags option flags that can be used to modify the default behavior of this class.Must be
&nbsp;   *     zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}. &lt;i&gt;These option flags do
&nbsp;   *     not affect methods that are copied as is in the new class. This means that neither the
&nbsp;   *     maximum stack size nor the stack frames will be computed for these methods&lt;/i&gt;.
&nbsp;   */
&nbsp;  public ClassWriter(final ClassReader classReader, final int flags) {
<b class="fc">&nbsp;    super(Opcodes.ASM6);</b>
<b class="pc">&nbsp;    symbolTable = classReader == null ? new SymbolTable(this) : new SymbolTable(this, classReader);</b>
<b class="pc">&nbsp;    if ((flags &amp; COMPUTE_FRAMES) != 0) {</b>
<b class="nc">&nbsp;      this.compute = MethodWriter.COMPUTE_ALL_FRAMES;</b>
<b class="pc">&nbsp;    } else if ((flags &amp; COMPUTE_MAXS) != 0) {</b>
<b class="nc">&nbsp;      this.compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL;</b>
&nbsp;    } else {
<b class="fc">&nbsp;      this.compute = MethodWriter.COMPUTE_NOTHING;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Implementation of the ClassVisitor abstract class
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  @Override
&nbsp;  public final void visit(
&nbsp;      final int version,
&nbsp;      final int access,
&nbsp;      final String name,
&nbsp;      final String signature,
&nbsp;      final String superName,
&nbsp;      final String[] interfaces) {
<b class="fc">&nbsp;    this.version = version;</b>
<b class="fc">&nbsp;    this.accessFlags = access;</b>
<b class="fc">&nbsp;    this.thisClass = symbolTable.setMajorVersionAndClassName(version &amp; 0xFFFF, name);</b>
<b class="pc">&nbsp;    if (signature != null) {</b>
<b class="nc">&nbsp;      this.signatureIndex = symbolTable.addConstantUtf8(signature);</b>
&nbsp;    }
<b class="pc">&nbsp;    this.superClass = superName == null ? 0 : symbolTable.addConstantClass(superName).index;</b>
<b class="pc">&nbsp;    if (interfaces != null &amp;&amp; interfaces.length &gt; 0) {</b>
<b class="fc">&nbsp;      interfaceCount = interfaces.length;</b>
<b class="fc">&nbsp;      this.interfaces = new int[interfaceCount];</b>
<b class="fc">&nbsp;      for (int i = 0; i &lt; interfaceCount; ++i) {</b>
<b class="fc">&nbsp;        this.interfaces[i] = symbolTable.addConstantClass(interfaces[i]).index;</b>
&nbsp;      }
&nbsp;    }
<b class="pc">&nbsp;    if (compute == MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL &amp;&amp; (version &amp; 0xFFFF) &gt;= Opcodes.V1_7) {</b>
<b class="nc">&nbsp;      compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public final void visitSource(final String file, final String debug) {
<b class="nc">&nbsp;    if (file != null) {</b>
<b class="nc">&nbsp;      sourceFileIndex = symbolTable.addConstantUtf8(file);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (debug != null) {</b>
<b class="nc">&nbsp;      debugExtension = new ByteVector().encodeUTF8(debug, 0, Integer.MAX_VALUE);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public final ModuleVisitor visitModule(
&nbsp;      final String name, final int access, final String version) {
<b class="nc">&nbsp;    return moduleWriter =</b>
&nbsp;        new ModuleWriter(
&nbsp;            symbolTable,
<b class="nc">&nbsp;            symbolTable.addConstantModule(name).index,</b>
&nbsp;            access,
<b class="nc">&nbsp;            version == null ? 0 : symbolTable.addConstantUtf8(version));</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public void visitNestHostExperimental(final String nestHost) {
<b class="nc">&nbsp;    nestHostClassIndex = symbolTable.addConstantClass(nestHost).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public final void visitOuterClass(
&nbsp;      final String owner, final String name, final String descriptor) {
<b class="nc">&nbsp;    enclosingClassIndex = symbolTable.addConstantClass(owner).index;</b>
<b class="nc">&nbsp;    if (name != null &amp;&amp; descriptor != null) {</b>
<b class="nc">&nbsp;      enclosingMethodIndex = symbolTable.addConstantNameAndType(name, descriptor);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public final AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
&nbsp;    // Create a ByteVector to hold an &#39;annotation&#39; JVMS structure.
&nbsp;    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.
<b class="nc">&nbsp;    ByteVector annotation = new ByteVector();</b>
&nbsp;    // Write type_index and reserve space for num_element_value_pairs.
<b class="nc">&nbsp;    annotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);</b>
<b class="nc">&nbsp;    if (visible) {</b>
<b class="nc">&nbsp;      return lastRuntimeVisibleAnnotation =</b>
&nbsp;          new AnnotationWriter(symbolTable, annotation, lastRuntimeVisibleAnnotation);
&nbsp;    } else {
<b class="nc">&nbsp;      return lastRuntimeInvisibleAnnotation =</b>
&nbsp;          new AnnotationWriter(symbolTable, annotation, lastRuntimeInvisibleAnnotation);
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public final AnnotationVisitor visitTypeAnnotation(
&nbsp;      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
&nbsp;    // Create a ByteVector to hold a &#39;type_annotation&#39; JVMS structure.
&nbsp;    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.
<b class="nc">&nbsp;    ByteVector typeAnnotation = new ByteVector();</b>
&nbsp;    // Write target_type, target_info, and target_path.
<b class="nc">&nbsp;    TypeReference.putTarget(typeRef, typeAnnotation);</b>
<b class="nc">&nbsp;    TypePath.put(typePath, typeAnnotation);</b>
&nbsp;    // Write type_index and reserve space for num_element_value_pairs.
<b class="nc">&nbsp;    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);</b>
<b class="nc">&nbsp;    if (visible) {</b>
<b class="nc">&nbsp;      return lastRuntimeVisibleTypeAnnotation =</b>
&nbsp;          new AnnotationWriter(symbolTable, typeAnnotation, lastRuntimeVisibleTypeAnnotation);
&nbsp;    } else {
<b class="nc">&nbsp;      return lastRuntimeInvisibleTypeAnnotation =</b>
&nbsp;          new AnnotationWriter(symbolTable, typeAnnotation, lastRuntimeInvisibleTypeAnnotation);
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public final void visitAttribute(final Attribute attribute) {
&nbsp;    // Store the attributes in the &lt;i&gt;reverse&lt;/i&gt; order of their visit by this method.
<b class="nc">&nbsp;    attribute.nextAttribute = firstAttribute;</b>
<b class="nc">&nbsp;    firstAttribute = attribute;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public void visitNestMemberExperimental(final String nestMember) {
<b class="nc">&nbsp;    if (nestMemberClasses == null) {</b>
<b class="nc">&nbsp;      nestMemberClasses = new ByteVector();</b>
&nbsp;    }
<b class="nc">&nbsp;    ++numberOfNestMemberClasses;</b>
<b class="nc">&nbsp;    nestMemberClasses.putShort(symbolTable.addConstantClass(nestMember).index);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public final void visitInnerClass(
&nbsp;      final String name, final String outerName, final String innerName, final int access) {
<b class="nc">&nbsp;    if (innerClasses == null) {</b>
<b class="nc">&nbsp;      innerClasses = new ByteVector();</b>
&nbsp;    }
&nbsp;    // Section 4.7.6 of the JVMS states &quot;Every CONSTANT_Class_info entry in the constant_pool table
&nbsp;    // which represents a class or interface C that is not a package member must have exactly one
&nbsp;    // corresponding entry in the classes array&quot;. To avoid duplicates we keep track in the info
&nbsp;    // field of the Symbol of each CONSTANT_Class_info entry C whether an inner class entry has
&nbsp;    // already been added for C. If so, we store the index of this inner class entry (plus one) in
&nbsp;    // the info field. This trick allows duplicate detection in O(1) time.
<b class="nc">&nbsp;    Symbol nameSymbol = symbolTable.addConstantClass(name);</b>
<b class="nc">&nbsp;    if (nameSymbol.info == 0) {</b>
<b class="nc">&nbsp;      ++numberOfInnerClasses;</b>
<b class="nc">&nbsp;      innerClasses.putShort(nameSymbol.index);</b>
<b class="nc">&nbsp;      innerClasses.putShort(outerName == null ? 0 : symbolTable.addConstantClass(outerName).index);</b>
<b class="nc">&nbsp;      innerClasses.putShort(innerName == null ? 0 : symbolTable.addConstantUtf8(innerName));</b>
<b class="nc">&nbsp;      innerClasses.putShort(access);</b>
<b class="nc">&nbsp;      nameSymbol.info = numberOfInnerClasses;</b>
&nbsp;    } else {
&nbsp;      // Compare the inner classes entry nameSymbol.info - 1 with the arguments of this method and
&nbsp;      // throw an exception if there is a difference?
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public final FieldVisitor visitField(
&nbsp;      final int access,
&nbsp;      final String name,
&nbsp;      final String descriptor,
&nbsp;      final String signature,
&nbsp;      final Object value) {
<b class="fc">&nbsp;    FieldWriter fieldWriter =</b>
&nbsp;        new FieldWriter(symbolTable, access, name, descriptor, signature, value);
<b class="fc">&nbsp;    if (firstField == null) {</b>
<b class="fc">&nbsp;      firstField = fieldWriter;</b>
&nbsp;    } else {
<b class="fc">&nbsp;      lastField.fv = fieldWriter;</b>
&nbsp;    }
<b class="fc">&nbsp;    return lastField = fieldWriter;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public final MethodVisitor visitMethod(
&nbsp;      final int access,
&nbsp;      final String name,
&nbsp;      final String descriptor,
&nbsp;      final String signature,
&nbsp;      final String[] exceptions) {
<b class="fc">&nbsp;    MethodWriter methodWriter =</b>
&nbsp;        new MethodWriter(symbolTable, access, name, descriptor, signature, exceptions, compute);
<b class="fc">&nbsp;    if (firstMethod == null) {</b>
<b class="fc">&nbsp;      firstMethod = methodWriter;</b>
&nbsp;    } else {
<b class="fc">&nbsp;      lastMethod.mv = methodWriter;</b>
&nbsp;    }
<b class="fc">&nbsp;    return lastMethod = methodWriter;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public final void visitEnd() {
&nbsp;    // Nothing to do.
<b class="fc">&nbsp;  }</b>
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Other public methods
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the content of the class file that was built by this ClassWriter.
&nbsp;   *
&nbsp;   * @return the binary content of the JVMS ClassFile structure that was built by this ClassWriter.
&nbsp;   */
&nbsp;  public byte[] toByteArray() {
&nbsp;    // First step: compute the size in bytes of the ClassFile structure.
&nbsp;    // The magic field uses 4 bytes, 10 mandatory fields (minor_version, major_version,
&nbsp;    // constant_pool_count, access_flags, this_class, super_class, interfaces_count, fields_count,
&nbsp;    // methods_count and attributes_count) use 2 bytes each, and each interface uses 2 bytes too.
<b class="fc">&nbsp;    int size = 24 + 2 * interfaceCount;</b>
<b class="fc">&nbsp;    int fieldsCount = 0;</b>
<b class="fc">&nbsp;    FieldWriter fieldWriter = firstField;</b>
<b class="fc">&nbsp;    while (fieldWriter != null) {</b>
<b class="fc">&nbsp;      ++fieldsCount;</b>
<b class="fc">&nbsp;      size += fieldWriter.computeFieldInfoSize();</b>
<b class="fc">&nbsp;      fieldWriter = (FieldWriter) fieldWriter.fv;</b>
&nbsp;    }
<b class="fc">&nbsp;    int methodsCount = 0;</b>
<b class="fc">&nbsp;    MethodWriter methodWriter = firstMethod;</b>
<b class="fc">&nbsp;    while (methodWriter != null) {</b>
<b class="fc">&nbsp;      ++methodsCount;</b>
<b class="fc">&nbsp;      size += methodWriter.computeMethodInfoSize();</b>
<b class="fc">&nbsp;      methodWriter = (MethodWriter) methodWriter.mv;</b>
&nbsp;    }
&nbsp;    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
<b class="fc">&nbsp;    int attributesCount = 0;</b>
<b class="pc">&nbsp;    if (innerClasses != null) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size += 8 + innerClasses.length;</b>
<b class="nc">&nbsp;      symbolTable.addConstantUtf8(Constants.INNER_CLASSES);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (enclosingClassIndex != 0) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size += 10;</b>
<b class="nc">&nbsp;      symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD);</b>
&nbsp;    }
<b class="pc">&nbsp;    if ((accessFlags &amp; Opcodes.ACC_SYNTHETIC) != 0 &amp;&amp; (version &amp; 0xFFFF) &lt; Opcodes.V1_5) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size += 6;</b>
<b class="nc">&nbsp;      symbolTable.addConstantUtf8(Constants.SYNTHETIC);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (signatureIndex != 0) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size += 8;</b>
<b class="nc">&nbsp;      symbolTable.addConstantUtf8(Constants.SIGNATURE);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (sourceFileIndex != 0) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size += 8;</b>
<b class="nc">&nbsp;      symbolTable.addConstantUtf8(Constants.SOURCE_FILE);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (debugExtension != null) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size += 6 + debugExtension.length;</b>
<b class="nc">&nbsp;      symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION);</b>
&nbsp;    }
<b class="pc">&nbsp;    if ((accessFlags &amp; Opcodes.ACC_DEPRECATED) != 0) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size += 6;</b>
<b class="nc">&nbsp;      symbolTable.addConstantUtf8(Constants.DEPRECATED);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (lastRuntimeVisibleAnnotation != null) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size +=</b>
<b class="nc">&nbsp;          lastRuntimeVisibleAnnotation.computeAnnotationsSize(</b>
&nbsp;              Constants.RUNTIME_VISIBLE_ANNOTATIONS);
&nbsp;    }
<b class="pc">&nbsp;    if (lastRuntimeInvisibleAnnotation != null) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size +=</b>
<b class="nc">&nbsp;          lastRuntimeInvisibleAnnotation.computeAnnotationsSize(</b>
&nbsp;              Constants.RUNTIME_INVISIBLE_ANNOTATIONS);
&nbsp;    }
<b class="pc">&nbsp;    if (lastRuntimeVisibleTypeAnnotation != null) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size +=</b>
<b class="nc">&nbsp;          lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(</b>
&nbsp;              Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);
&nbsp;    }
<b class="pc">&nbsp;    if (lastRuntimeInvisibleTypeAnnotation != null) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size +=</b>
<b class="nc">&nbsp;          lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(</b>
&nbsp;              Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);
&nbsp;    }
<b class="pc">&nbsp;    if (symbolTable.computeBootstrapMethodsSize() &gt; 0) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size += symbolTable.computeBootstrapMethodsSize();</b>
&nbsp;    }
<b class="pc">&nbsp;    if (moduleWriter != null) {</b>
<b class="nc">&nbsp;      attributesCount += moduleWriter.getAttributeCount();</b>
<b class="nc">&nbsp;      size += moduleWriter.computeAttributesSize();</b>
&nbsp;    }
<b class="pc">&nbsp;    if (nestHostClassIndex != 0) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size += 8;</b>
<b class="nc">&nbsp;      symbolTable.addConstantUtf8(Constants.NEST_HOST);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (nestMemberClasses != null) {</b>
<b class="nc">&nbsp;      ++attributesCount;</b>
<b class="nc">&nbsp;      size += 8 + nestMemberClasses.length;</b>
<b class="nc">&nbsp;      symbolTable.addConstantUtf8(Constants.NEST_MEMBERS);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (firstAttribute != null) {</b>
<b class="nc">&nbsp;      attributesCount += firstAttribute.getAttributeCount();</b>
<b class="nc">&nbsp;      size += firstAttribute.computeAttributesSize(symbolTable);</b>
&nbsp;    }
&nbsp;    // IMPORTANT: this must be the last part of the ClassFile size computation, because the previous
&nbsp;    // statements can add attribute names to the constant pool, thereby changing its size!
<b class="fc">&nbsp;    size += symbolTable.getConstantPoolLength();</b>
<b class="pc">&nbsp;    if (symbolTable.getConstantPoolCount() &gt; 0xFFFF) {</b>
<b class="nc">&nbsp;      throw new IndexOutOfBoundsException(&quot;Class file too large!&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Second step: allocate a ByteVector of the correct size (in order to avoid any array copy in
&nbsp;    // dynamic resizes) and fill it with the ClassFile content.
<b class="fc">&nbsp;    ByteVector result = new ByteVector(size);</b>
<b class="fc">&nbsp;    result.putInt(0xCAFEBABE).putInt(version);</b>
<b class="fc">&nbsp;    symbolTable.putConstantPool(result);</b>
<b class="pc">&nbsp;    int mask = (version &amp; 0xFFFF) &lt; Opcodes.V1_5 ? Opcodes.ACC_SYNTHETIC : 0;</b>
<b class="fc">&nbsp;    result.putShort(accessFlags &amp; ~mask).putShort(thisClass).putShort(superClass);</b>
<b class="fc">&nbsp;    result.putShort(interfaceCount);</b>
<b class="fc">&nbsp;    for (int i = 0; i &lt; interfaceCount; ++i) {</b>
<b class="fc">&nbsp;      result.putShort(interfaces[i]);</b>
&nbsp;    }
<b class="fc">&nbsp;    result.putShort(fieldsCount);</b>
<b class="fc">&nbsp;    fieldWriter = firstField;</b>
<b class="fc">&nbsp;    while (fieldWriter != null) {</b>
<b class="fc">&nbsp;      fieldWriter.putFieldInfo(result);</b>
<b class="fc">&nbsp;      fieldWriter = (FieldWriter) fieldWriter.fv;</b>
&nbsp;    }
<b class="fc">&nbsp;    result.putShort(methodsCount);</b>
<b class="fc">&nbsp;    boolean hasFrames = false;</b>
<b class="fc">&nbsp;    boolean hasAsmInstructions = false;</b>
<b class="fc">&nbsp;    methodWriter = firstMethod;</b>
<b class="fc">&nbsp;    while (methodWriter != null) {</b>
<b class="fc">&nbsp;      hasFrames |= methodWriter.hasFrames();</b>
<b class="fc">&nbsp;      hasAsmInstructions |= methodWriter.hasAsmInstructions();</b>
<b class="fc">&nbsp;      methodWriter.putMethodInfo(result);</b>
<b class="fc">&nbsp;      methodWriter = (MethodWriter) methodWriter.mv;</b>
&nbsp;    }
&nbsp;    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
<b class="fc">&nbsp;    result.putShort(attributesCount);</b>
<b class="pc">&nbsp;    if (innerClasses != null) {</b>
<b class="nc">&nbsp;      result</b>
<b class="nc">&nbsp;          .putShort(symbolTable.addConstantUtf8(Constants.INNER_CLASSES))</b>
<b class="nc">&nbsp;          .putInt(innerClasses.length + 2)</b>
<b class="nc">&nbsp;          .putShort(numberOfInnerClasses)</b>
<b class="nc">&nbsp;          .putByteArray(innerClasses.data, 0, innerClasses.length);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (enclosingClassIndex != 0) {</b>
<b class="nc">&nbsp;      result</b>
<b class="nc">&nbsp;          .putShort(symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD))</b>
<b class="nc">&nbsp;          .putInt(4)</b>
<b class="nc">&nbsp;          .putShort(enclosingClassIndex)</b>
<b class="nc">&nbsp;          .putShort(enclosingMethodIndex);</b>
&nbsp;    }
<b class="pc">&nbsp;    if ((accessFlags &amp; Opcodes.ACC_SYNTHETIC) != 0 &amp;&amp; (version &amp; 0xFFFF) &lt; Opcodes.V1_5) {</b>
<b class="nc">&nbsp;      result.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (signatureIndex != 0) {</b>
<b class="nc">&nbsp;      result</b>
<b class="nc">&nbsp;          .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE))</b>
<b class="nc">&nbsp;          .putInt(2)</b>
<b class="nc">&nbsp;          .putShort(signatureIndex);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (sourceFileIndex != 0) {</b>
<b class="nc">&nbsp;      result</b>
<b class="nc">&nbsp;          .putShort(symbolTable.addConstantUtf8(Constants.SOURCE_FILE))</b>
<b class="nc">&nbsp;          .putInt(2)</b>
<b class="nc">&nbsp;          .putShort(sourceFileIndex);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (debugExtension != null) {</b>
<b class="nc">&nbsp;      int length = debugExtension.length;</b>
<b class="nc">&nbsp;      result</b>
<b class="nc">&nbsp;          .putShort(symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION))</b>
<b class="nc">&nbsp;          .putInt(length)</b>
<b class="nc">&nbsp;          .putByteArray(debugExtension.data, 0, length);</b>
&nbsp;    }
<b class="pc">&nbsp;    if ((accessFlags &amp; Opcodes.ACC_DEPRECATED) != 0) {</b>
<b class="nc">&nbsp;      result.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (lastRuntimeVisibleAnnotation != null) {</b>
<b class="nc">&nbsp;      lastRuntimeVisibleAnnotation.putAnnotations(</b>
<b class="nc">&nbsp;          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_ANNOTATIONS), result);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (lastRuntimeInvisibleAnnotation != null) {</b>
<b class="nc">&nbsp;      lastRuntimeInvisibleAnnotation.putAnnotations(</b>
<b class="nc">&nbsp;          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), result);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (lastRuntimeVisibleTypeAnnotation != null) {</b>
<b class="nc">&nbsp;      lastRuntimeVisibleTypeAnnotation.putAnnotations(</b>
<b class="nc">&nbsp;          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), result);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (lastRuntimeInvisibleTypeAnnotation != null) {</b>
<b class="nc">&nbsp;      lastRuntimeInvisibleTypeAnnotation.putAnnotations(</b>
<b class="nc">&nbsp;          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), result);</b>
&nbsp;    }
<b class="fc">&nbsp;    symbolTable.putBootstrapMethods(result);</b>
<b class="pc">&nbsp;    if (moduleWriter != null) {</b>
<b class="nc">&nbsp;      moduleWriter.putAttributes(result);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (nestHostClassIndex != 0) {</b>
<b class="nc">&nbsp;      result</b>
<b class="nc">&nbsp;          .putShort(symbolTable.addConstantUtf8(Constants.NEST_HOST))</b>
<b class="nc">&nbsp;          .putInt(2)</b>
<b class="nc">&nbsp;          .putShort(nestHostClassIndex);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (nestMemberClasses != null) {</b>
<b class="nc">&nbsp;      result</b>
<b class="nc">&nbsp;          .putShort(symbolTable.addConstantUtf8(Constants.NEST_MEMBERS))</b>
<b class="nc">&nbsp;          .putInt(nestMemberClasses.length + 2)</b>
<b class="nc">&nbsp;          .putShort(numberOfNestMemberClasses)</b>
<b class="nc">&nbsp;          .putByteArray(nestMemberClasses.data, 0, nestMemberClasses.length);</b>
&nbsp;    }
<b class="pc">&nbsp;    if (firstAttribute != null) {</b>
<b class="nc">&nbsp;      firstAttribute.putAttributes(symbolTable, result);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Third step: replace the ASM specific instructions, if any.
<b class="pc">&nbsp;    if (hasAsmInstructions) {</b>
<b class="nc">&nbsp;      return replaceAsmInstructions(result.data, hasFrames);</b>
&nbsp;    } else {
<b class="fc">&nbsp;      return result.data;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the equivalent of the given class file, with the ASM specific instructions replaced
&nbsp;   * with standard ones. This is done with a ClassReader -&amp;gt; ClassWriter round trip.
&nbsp;   *
&nbsp;   * @param classFile a class file containing ASM specific instructions, generated by this
&nbsp;   *     ClassWriter.
&nbsp;   * @param hasFrames whether there is at least one stack map frames in &#39;classFile&#39;.
&nbsp;   * @return an equivalent of &#39;classFile&#39;, with the ASM specific instructions replaced with standard
&nbsp;   *     ones.
&nbsp;   */
&nbsp;  private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) {
<b class="nc">&nbsp;    Attribute[] attributes = getAttributePrototypes();</b>
<b class="nc">&nbsp;    firstField = null;</b>
<b class="nc">&nbsp;    lastField = null;</b>
<b class="nc">&nbsp;    firstMethod = null;</b>
<b class="nc">&nbsp;    lastMethod = null;</b>
<b class="nc">&nbsp;    lastRuntimeVisibleAnnotation = null;</b>
<b class="nc">&nbsp;    lastRuntimeInvisibleAnnotation = null;</b>
<b class="nc">&nbsp;    lastRuntimeVisibleTypeAnnotation = null;</b>
<b class="nc">&nbsp;    lastRuntimeInvisibleTypeAnnotation = null;</b>
<b class="nc">&nbsp;    moduleWriter = null;</b>
<b class="nc">&nbsp;    nestHostClassIndex = 0;</b>
<b class="nc">&nbsp;    numberOfNestMemberClasses = 0;</b>
<b class="nc">&nbsp;    nestMemberClasses = null;</b>
<b class="nc">&nbsp;    firstAttribute = null;</b>
<b class="nc">&nbsp;    compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING;</b>
<b class="nc">&nbsp;    new ClassReader(classFile, 0, /* checkClassVersion = */ false)</b>
<b class="nc">&nbsp;        .accept(</b>
&nbsp;            this,
&nbsp;            attributes,
&nbsp;            (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS);
<b class="nc">&nbsp;    return toByteArray();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the prototypes of the attributes used by this class, its fields and its methods.
&nbsp;   *
&nbsp;   * @return the prototypes of the attributes used by this class, its fields and its methods.
&nbsp;   */
&nbsp;  private Attribute[] getAttributePrototypes() {
<b class="nc">&nbsp;    Attribute.Set attributePrototypes = new Attribute.Set();</b>
<b class="nc">&nbsp;    attributePrototypes.addAttributes(firstAttribute);</b>
<b class="nc">&nbsp;    FieldWriter fieldWriter = firstField;</b>
<b class="nc">&nbsp;    while (fieldWriter != null) {</b>
<b class="nc">&nbsp;      fieldWriter.collectAttributePrototypes(attributePrototypes);</b>
<b class="nc">&nbsp;      fieldWriter = (FieldWriter) fieldWriter.fv;</b>
&nbsp;    }
<b class="nc">&nbsp;    MethodWriter methodWriter = firstMethod;</b>
<b class="nc">&nbsp;    while (methodWriter != null) {</b>
<b class="nc">&nbsp;      methodWriter.collectAttributePrototypes(attributePrototypes);</b>
<b class="nc">&nbsp;      methodWriter = (MethodWriter) methodWriter.mv;</b>
&nbsp;    }
<b class="nc">&nbsp;    return attributePrototypes.toArray();</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Utility methods: constant pool management for Attribute sub classes
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a number or string constant to the constant pool of the class being build. Does nothing if
&nbsp;   * the constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link
&nbsp;   * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param value the value of the constant to be added to the constant pool. This parameter must be
&nbsp;   *     an {@link Integer}, a {@link Float}, a {@link Long}, a {@link Double} or a {@link String}.
&nbsp;   * @return the index of a new or already existing constant item with the given value.
&nbsp;   */
&nbsp;  public int newConst(final Object value) {
<b class="nc">&nbsp;    return symbolTable.addConstant(value).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds an UTF8 string to the constant pool of the class being build. Does nothing if the constant
&nbsp;   * pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute} sub
&nbsp;   * classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param value the String value.
&nbsp;   * @return the index of a new or already existing UTF8 item.
&nbsp;   */
&nbsp;  public int newUTF8(final String value) {
<b class="nc">&nbsp;    return symbolTable.addConstantUtf8(value);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a class reference to the constant pool of the class being build. Does nothing if the
&nbsp;   * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
&nbsp;   * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param value the internal name of the class.
&nbsp;   * @return the index of a new or already existing class reference item.
&nbsp;   */
&nbsp;  public int newClass(final String value) {
<b class="nc">&nbsp;    return symbolTable.addConstantClass(value).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a method type reference to the constant pool of the class being build. Does nothing if the
&nbsp;   * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
&nbsp;   * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param methodDescriptor method descriptor of the method type.
&nbsp;   * @return the index of a new or already existing method type reference item.
&nbsp;   */
&nbsp;  public int newMethodType(final String methodDescriptor) {
<b class="nc">&nbsp;    return symbolTable.addConstantMethodType(methodDescriptor).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a module reference to the constant pool of the class being build. Does nothing if the
&nbsp;   * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
&nbsp;   * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param moduleName name of the module.
&nbsp;   * @return the index of a new or already existing module reference item.
&nbsp;   */
&nbsp;  public int newModule(final String moduleName) {
<b class="nc">&nbsp;    return symbolTable.addConstantModule(moduleName).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a package reference to the constant pool of the class being build. Does nothing if the
&nbsp;   * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
&nbsp;   * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param packageName name of the package in its internal form.
&nbsp;   * @return the index of a new or already existing module reference item.
&nbsp;   */
&nbsp;  public int newPackage(final String packageName) {
<b class="nc">&nbsp;    return symbolTable.addConstantPackage(packageName).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool
&nbsp;   * already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute} sub classes,
&nbsp;   * and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link
&nbsp;   *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link
&nbsp;   *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},
&nbsp;   *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
&nbsp;   * @param owner the internal name of the field or method owner class.
&nbsp;   * @param name the name of the field or method.
&nbsp;   * @param descriptor the descriptor of the field or method.
&nbsp;   * @return the index of a new or already existing method type reference item.
&nbsp;   * @deprecated this method is superseded by {@link #newHandle(int, String, String, String,
&nbsp;   *     boolean)}.
&nbsp;   */
&nbsp;  @Deprecated
&nbsp;  public int newHandle(
&nbsp;      final int tag, final String owner, final String name, final String descriptor) {
<b class="nc">&nbsp;    return newHandle(tag, owner, name, descriptor, tag == Opcodes.H_INVOKEINTERFACE);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool
&nbsp;   * already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute} sub classes,
&nbsp;   * and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link
&nbsp;   *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link
&nbsp;   *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},
&nbsp;   *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
&nbsp;   * @param owner the internal name of the field or method owner class.
&nbsp;   * @param name the name of the field or method.
&nbsp;   * @param descriptor the descriptor of the field or method.
&nbsp;   * @param isInterface true if the owner is an interface.
&nbsp;   * @return the index of a new or already existing method type reference item.
&nbsp;   */
&nbsp;  public int newHandle(
&nbsp;      final int tag,
&nbsp;      final String owner,
&nbsp;      final String name,
&nbsp;      final String descriptor,
&nbsp;      final boolean isInterface) {
<b class="nc">&nbsp;    return symbolTable.addConstantMethodHandle(tag, owner, name, descriptor, isInterface).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a dynamic constant reference to the constant pool of the class being build. Does nothing
&nbsp;   * if the constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link
&nbsp;   * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param name name of the invoked method.
&nbsp;   * @param descriptor field descriptor of the constant type.
&nbsp;   * @param bootstrapMethodHandle the bootstrap method.
&nbsp;   * @param bootstrapMethodArguments the bootstrap method constant arguments.
&nbsp;   * @return the index of a new or already existing dynamic constant reference item.
&nbsp;   */
&nbsp;  public int newConstantDynamic(
&nbsp;      final String name,
&nbsp;      final String descriptor,
&nbsp;      final Handle bootstrapMethodHandle,
&nbsp;      final Object... bootstrapMethodArguments) {
<b class="nc">&nbsp;    return symbolTable.addConstantDynamic(</b>
&nbsp;            name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments)
&nbsp;        .index;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds an invokedynamic reference to the constant pool of the class being build. Does nothing if
&nbsp;   * the constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link
&nbsp;   * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param name name of the invoked method.
&nbsp;   * @param descriptor descriptor of the invoke method.
&nbsp;   * @param bootstrapMethodHandle the bootstrap method.
&nbsp;   * @param bootstrapMethodArguments the bootstrap method constant arguments.
&nbsp;   * @return the index of a new or already existing invokedynamic reference item.
&nbsp;   */
&nbsp;  public int newInvokeDynamic(
&nbsp;      final String name,
&nbsp;      final String descriptor,
&nbsp;      final Handle bootstrapMethodHandle,
&nbsp;      final Object... bootstrapMethodArguments) {
<b class="nc">&nbsp;    return symbolTable.addConstantInvokeDynamic(</b>
&nbsp;            name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments)
&nbsp;        .index;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a field reference to the constant pool of the class being build. Does nothing if the
&nbsp;   * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
&nbsp;   * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param owner the internal name of the field&#39;s owner class.
&nbsp;   * @param name the field&#39;s name.
&nbsp;   * @param descriptor the field&#39;s descriptor.
&nbsp;   * @return the index of a new or already existing field reference item.
&nbsp;   */
&nbsp;  public int newField(final String owner, final String name, final String descriptor) {
<b class="nc">&nbsp;    return symbolTable.addConstantFieldref(owner, name, descriptor).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a method reference to the constant pool of the class being build. Does nothing if the
&nbsp;   * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
&nbsp;   * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param owner the internal name of the method&#39;s owner class.
&nbsp;   * @param name the method&#39;s name.
&nbsp;   * @param descriptor the method&#39;s descriptor.
&nbsp;   * @param isInterface &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;owner&lt;/tt&gt; is an interface.
&nbsp;   * @return the index of a new or already existing method reference item.
&nbsp;   */
&nbsp;  public int newMethod(
&nbsp;      final String owner, final String name, final String descriptor, final boolean isInterface) {
<b class="nc">&nbsp;    return symbolTable.addConstantMethodref(owner, name, descriptor, isInterface).index;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Adds a name and type to the constant pool of the class being build. Does nothing if the
&nbsp;   * constant pool already contains a similar item. &lt;i&gt;This method is intended for {@link Attribute}
&nbsp;   * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;
&nbsp;   *
&nbsp;   * @param name a name.
&nbsp;   * @param descriptor a type descriptor.
&nbsp;   * @return the index of a new or already existing name and type item.
&nbsp;   */
&nbsp;  public int newNameType(final String name, final String descriptor) {
<b class="nc">&nbsp;    return symbolTable.addConstantNameAndType(name, descriptor);</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Default method to compute common super classes when computing stack map frames
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the common super type of the two given types. The default implementation of this method
&nbsp;   * &lt;i&gt;loads&lt;/i&gt; the two given classes and uses the java.lang.Class methods to find the common
&nbsp;   * super class. It can be overridden to compute this common super type in other ways, in
&nbsp;   * particular without actually loading any class, or to take into account the class that is
&nbsp;   * currently being generated by this ClassWriter, which can of course not be loaded since it is
&nbsp;   * under construction.
&nbsp;   *
&nbsp;   * @param type1 the internal name of a class.
&nbsp;   * @param type2 the internal name of another class.
&nbsp;   * @return the internal name of the common super class of the two given classes.
&nbsp;   */
&nbsp;  protected String getCommonSuperClass(final String type1, final String type2) {
<b class="nc">&nbsp;    ClassLoader classLoader = getClass().getClassLoader();</b>
&nbsp;    Class&lt;?&gt; class1;
&nbsp;    try {
<b class="nc">&nbsp;      class1 = Class.forName(type1.replace(&#39;/&#39;, &#39;.&#39;), false, classLoader);</b>
<b class="nc">&nbsp;    } catch (Exception e) {</b>
<b class="nc">&nbsp;      throw new TypeNotPresentException(type1, e);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    Class&lt;?&gt; class2;
&nbsp;    try {
<b class="nc">&nbsp;      class2 = Class.forName(type2.replace(&#39;/&#39;, &#39;.&#39;), false, classLoader);</b>
<b class="nc">&nbsp;    } catch (Exception e) {</b>
<b class="nc">&nbsp;      throw new TypeNotPresentException(type2, e);</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    if (class1.isAssignableFrom(class2)) {</b>
<b class="nc">&nbsp;      return type1;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (class2.isAssignableFrom(class1)) {</b>
<b class="nc">&nbsp;      return type2;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (class1.isInterface() || class2.isInterface()) {</b>
<b class="nc">&nbsp;      return &quot;java/lang/Object&quot;;</b>
&nbsp;    } else {
&nbsp;      do {
<b class="nc">&nbsp;        class1 = class1.getSuperclass();</b>
<b class="nc">&nbsp;      } while (!class1.isAssignableFrom(class2));</b>
<b class="nc">&nbsp;      return class1.getName().replace(&#39;.&#39;, &#39;/&#39;);</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
