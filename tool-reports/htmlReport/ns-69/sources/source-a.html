


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Frame</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.jar.asm</a>
</div>

<h1>Coverage Summary for Class: Frame (net.bytebuddy.jar.asm)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Frame</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/541)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/557)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;// ASM: a very small and fast Java bytecode manipulation framework
&nbsp;// Copyright (c) 2000-2011 INRIA, France Telecom
&nbsp;// All rights reserved.
&nbsp;//
&nbsp;// Redistribution and use in source and binary forms, with or without
&nbsp;// modification, are permitted provided that the following conditions
&nbsp;// are met:
&nbsp;// 1. Redistributions of source code must retain the above copyright
&nbsp;//    notice, this list of conditions and the following disclaimer.
&nbsp;// 2. Redistributions in binary form must reproduce the above copyright
&nbsp;//    notice, this list of conditions and the following disclaimer in the
&nbsp;//    documentation and/or other materials provided with the distribution.
&nbsp;// 3. Neither the name of the copyright holders nor the names of its
&nbsp;//    contributors may be used to endorse or promote products derived from
&nbsp;//    this software without specific prior written permission.
&nbsp;//
&nbsp;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
&nbsp;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
&nbsp;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
&nbsp;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
&nbsp;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
&nbsp;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
&nbsp;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
&nbsp;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
&nbsp;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
&nbsp;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
&nbsp;// THE POSSIBILITY OF SUCH DAMAGE.
&nbsp;package net.bytebuddy.jar.asm;
&nbsp;
&nbsp;/**
&nbsp; * The input and output stack map frames of a basic block.
&nbsp; *
&nbsp; * &lt;p&gt;Stack map frames are computed in two steps:
&nbsp; *
&nbsp; * &lt;ul&gt;
&nbsp; *   &lt;li&gt;During the visit of each instruction in MethodWriter, the state of the frame at the end of
&nbsp; *       the current basic block is updated by simulating the action of the instruction on the
&nbsp; *       previous state of this so called &quot;output frame&quot;.
&nbsp; *   &lt;li&gt;After all instructions have been visited, a fix point algorithm is used in MethodWriter to
&nbsp; *       compute the &quot;input frame&quot; of each basic block (i.e. the stack map frame at the beginning of
&nbsp; *       the basic block). See {@link MethodWriter#computeAllFrames}.
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;p&gt;Output stack map frames are computed relatively to the input frame of the basic block, which
&nbsp; * is not yet known when output frames are computed. It is therefore necessary to be able to
&nbsp; * represent abstract types such as &quot;the type at position x in the input frame locals&quot; or &quot;the type
&nbsp; * at position x from the top of the input frame stack&quot; or even &quot;the type at position x in the input
&nbsp; * frame, with y more (or less) array dimensions&quot;. This explains the rather complicated type format
&nbsp; * used in this class, explained below.
&nbsp; *
&nbsp; * &lt;p&gt;The local variables and the operand stack of input and output frames contain values called
&nbsp; * &quot;abstract types&quot; hereafter. An abstract type is represented with 4 fields named DIM, KIND, FLAGS
&nbsp; * and VALUE, packed in a single int value for better performance and memory efficiency:
&nbsp; *
&nbsp; * &lt;pre&gt;
&nbsp; *   =====================================
&nbsp; *   |.DIM|KIND|FLAG|...............VALUE|
&nbsp; *   =====================================
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;ul&gt;
&nbsp; *   &lt;li&gt;the DIM field, stored in the 4 most significant bits, is a signed number of array
&nbsp; *       dimensions (from -8 to 7, included). It can be retrieved with {@link #DIM_MASK} and a right
&nbsp; *       shift of {@link #DIM_SHIFT}.
&nbsp; *   &lt;li&gt;the KIND field, stored in 4 bits, indicates the kind of VALUE used. These 4 bits can be
&nbsp; *       retrieved with {@link #KIND_MASK} and, without any shift, must be equal to {@link
&nbsp; *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link #LOCAL_KIND}
&nbsp; *       or {@link #STACK_KIND}.
&nbsp; *   &lt;li&gt;the FLAGS field, stored in 4 bits, contains up to 4 boolean flags. Currently only one flag
&nbsp; *       is defined, namely {@link #TOP_IF_LONG_OR_DOUBLE_FLAG}.
&nbsp; *   &lt;li&gt;the VALUE field, stored in the remaining 20 bits, contains either
&nbsp; *       &lt;ul&gt;
&nbsp; *         &lt;li&gt;one of the constants {@link #ITEM_TOP}, {@link #ITEM_ASM_BOOLEAN}, {@link
&nbsp; *             #ITEM_ASM_BYTE}, {@link #ITEM_ASM_CHAR} or {@link #ITEM_ASM_SHORT}, {@link
&nbsp; *             #ITEM_INTEGER}, {@link #ITEM_FLOAT}, {@link #ITEM_LONG}, {@link #ITEM_DOUBLE}, {@link
&nbsp; *             #ITEM_NULL} or {@link #ITEM_UNINITIALIZED_THIS}, if KIND is equal to {@link
&nbsp; *             #CONSTANT_KIND}.
&nbsp; *         &lt;li&gt;the index of a {@link Symbol#TYPE_TAG} {@link Symbol} in the type table of a {@link
&nbsp; *             SymbolTable}, if KIND is equal to {@link #REFERENCE_KIND}.
&nbsp; *         &lt;li&gt;the index of an {@link Symbol#UNINITIALIZED_TYPE_TAG} {@link Symbol} in the type
&nbsp; *             table of a SymbolTable, if KIND is equal to {@link #UNINITIALIZED_KIND}.
&nbsp; *         &lt;li&gt;the index of a local variable in the input stack frame, if KIND is equal to {@link
&nbsp; *             #LOCAL_KIND}.
&nbsp; *         &lt;li&gt;a position relatively to the top of the stack of the input stack frame, if KIND is
&nbsp; *             equal to {@link #STACK_KIND},
&nbsp; *       &lt;/ul&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;p&gt;Output frames can contain abstract types of any kind and with a positive or negative array
&nbsp; * dimension (and even unassigned types, represented by 0 - which does not correspond to any valid
&nbsp; * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND or
&nbsp; * UNINITIALIZED_KIND abstract types of positive or null array dimension. In all cases the type
&nbsp; * table contains only internal type names (array type descriptors are forbidden - array dimensions
&nbsp; * must be represented through the DIM field).
&nbsp; *
&nbsp; * &lt;p&gt;The LONG and DOUBLE types are always represented by using two slots (LONG + TOP or DOUBLE +
&nbsp; * TOP), for local variables as well as in the operand stack. This is necessary to be able to
&nbsp; * simulate DUPx_y instructions, whose effect would be dependent on the concrete types represented
&nbsp; * by the abstract types in the stack (which are not always known).
&nbsp; *
&nbsp; * @author Eric Bruneton
&nbsp; */
&nbsp;class Frame {
&nbsp;
&nbsp;  // Constants used in the StackMapTable attribute.
&nbsp;  // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4.
&nbsp;
&nbsp;  static final int SAME_FRAME = 0;
&nbsp;  static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;
&nbsp;  static final int RESERVED = 128;
&nbsp;  static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;
&nbsp;  static final int CHOP_FRAME = 248;
&nbsp;  static final int SAME_FRAME_EXTENDED = 251;
&nbsp;  static final int APPEND_FRAME = 252;
&nbsp;  static final int FULL_FRAME = 255;
&nbsp;
&nbsp;  static final int ITEM_TOP = 0;
&nbsp;  static final int ITEM_INTEGER = 1;
&nbsp;  static final int ITEM_FLOAT = 2;
&nbsp;  static final int ITEM_DOUBLE = 3;
&nbsp;  static final int ITEM_LONG = 4;
&nbsp;  static final int ITEM_NULL = 5;
&nbsp;  static final int ITEM_UNINITIALIZED_THIS = 6;
&nbsp;  static final int ITEM_OBJECT = 7;
&nbsp;  static final int ITEM_UNINITIALIZED = 8;
&nbsp;  // Additional, ASM specific constants used in abstract types below.
&nbsp;  private static final int ITEM_ASM_BOOLEAN = 9;
&nbsp;  private static final int ITEM_ASM_BYTE = 10;
&nbsp;  private static final int ITEM_ASM_CHAR = 11;
&nbsp;  private static final int ITEM_ASM_SHORT = 12;
&nbsp;
&nbsp;  // Bitmasks to get each field of an abstract type.
&nbsp;
&nbsp;  private static final int DIM_MASK = 0xF0000000;
&nbsp;  private static final int KIND_MASK = 0x0F000000;
&nbsp;  private static final int FLAGS_MASK = 0x00F00000;
&nbsp;  private static final int VALUE_MASK = 0x000FFFFF;
&nbsp;
&nbsp;  // Constants to manipulate the DIM field of an abstract type.
&nbsp;
&nbsp;  /** The number of right shift bits to use to get the array dimensions of an abstract type. */
&nbsp;  private static final int DIM_SHIFT = 28;
&nbsp;
&nbsp;  /** The constant to be added to an abstract type to get one with one more array dimension. */
&nbsp;  private static final int ARRAY_OF = +1 &lt;&lt; DIM_SHIFT;
&nbsp;
&nbsp;  /** The constant to be added to an abstract type to get one with one less array dimension. */
&nbsp;  private static final int ELEMENT_OF = -1 &lt;&lt; DIM_SHIFT;
&nbsp;
&nbsp;  // Possible values for the KIND field of an abstract type.
&nbsp;
&nbsp;  private static final int CONSTANT_KIND = 0x01000000;
&nbsp;  private static final int REFERENCE_KIND = 0x02000000;
&nbsp;  private static final int UNINITIALIZED_KIND = 0x03000000;
&nbsp;  private static final int LOCAL_KIND = 0x04000000;
&nbsp;  private static final int STACK_KIND = 0x05000000;
&nbsp;
&nbsp;  // Possible flags for the FLAGS field of an abstract type.
&nbsp;
&nbsp;  /**
&nbsp;   * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,
&nbsp;   * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been
&nbsp;   * partially overridden with an xSTORE instruction).
&nbsp;   */
&nbsp;  private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 0x00100000 &amp; FLAGS_MASK;
&nbsp;
&nbsp;  // Useful predefined abstract types (all the possible CONSTANT_KIND types).
&nbsp;
&nbsp;  private static final int TOP = CONSTANT_KIND | ITEM_TOP;
&nbsp;  private static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;
&nbsp;  private static final int BYTE = CONSTANT_KIND | ITEM_ASM_BYTE;
&nbsp;  private static final int CHAR = CONSTANT_KIND | ITEM_ASM_CHAR;
&nbsp;  private static final int SHORT = CONSTANT_KIND | ITEM_ASM_SHORT;
&nbsp;  private static final int INTEGER = CONSTANT_KIND | ITEM_INTEGER;
&nbsp;  private static final int FLOAT = CONSTANT_KIND | ITEM_FLOAT;
&nbsp;  private static final int LONG = CONSTANT_KIND | ITEM_LONG;
&nbsp;  private static final int DOUBLE = CONSTANT_KIND | ITEM_DOUBLE;
&nbsp;  private static final int NULL = CONSTANT_KIND | ITEM_NULL;
&nbsp;  private static final int UNINITIALIZED_THIS = CONSTANT_KIND | ITEM_UNINITIALIZED_THIS;
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Instance fields
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /** The basic block to which these input and output stack map frames correspond. */
&nbsp;  Label owner;
&nbsp;
&nbsp;  /** The input stack map frame locals. This is an array of abstract types. */
&nbsp;  private int[] inputLocals;
&nbsp;
&nbsp;  /** The input stack map frame stack. This is an array of abstract types. */
&nbsp;  private int[] inputStack;
&nbsp;
&nbsp;  /** The output stack map frame locals. This is an array of abstract types. */
&nbsp;  private int[] outputLocals;
&nbsp;
&nbsp;  /** The output stack map frame stack. This is an array of abstract types. */
&nbsp;  private int[] outputStack;
&nbsp;
&nbsp;  /**
&nbsp;   * The start of the output stack, relatively to the input stack. This offset is always negative or
&nbsp;   * null. A null offset means that the output stack must be appended to the input stack. A -n
&nbsp;   * offset means that the first n output stack elements must replace the top n input stack
&nbsp;   * elements, and that the other elements must be appended to the input stack.
&nbsp;   */
&nbsp;  private short outputStackStart;
&nbsp;
&nbsp;  /** The index of the top stack element in {@link #outputStack}. */
&nbsp;  private short outputStackTop;
&nbsp;
&nbsp;  /** The number of types that are initialized in the basic block. See {@link #initializations}. */
&nbsp;  private int initializationCount;
&nbsp;
&nbsp;  /**
&nbsp;   * The abstract types that are initialized in the basic block. A constructor invocation on an
&nbsp;   * UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace &lt;i&gt;every occurrence&lt;/i&gt; of this
&nbsp;   * type in the local variables and in the operand stack. This cannot be done during the first step
&nbsp;   * of the algorithm since, during this step, the local variables and the operand stack types are
&nbsp;   * still abstract. It is therefore necessary to store the abstract types of the constructors which
&nbsp;   * are invoked in the basic block, in order to do this replacement during the second step of the
&nbsp;   * algorithm, where the frames are fully computed. Note that this array can contain abstract types
&nbsp;   * that are relative to the input locals or to the input stack.
&nbsp;   */
&nbsp;  private int[] initializations;
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Static methods to get abstract types from other type formats
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the abstract type corresponding to the given public API frame element type.
&nbsp;   *
&nbsp;   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
&nbsp;   * @param type a frame element type described using the same format as in {@link
&nbsp;   *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link
&nbsp;   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or
&nbsp;   *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating
&nbsp;   *     a NEW instruction (for uninitialized types).
&nbsp;   * @return the abstract type corresponding to the given frame element type.
&nbsp;   */
&nbsp;  static int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) {
<b class="nc">&nbsp;    if (type instanceof Integer) {</b>
<b class="nc">&nbsp;      return CONSTANT_KIND | ((Integer) type).intValue();</b>
<b class="nc">&nbsp;    } else if (type instanceof String) {</b>
<b class="nc">&nbsp;      String descriptor = Type.getObjectType((String) type).getDescriptor();</b>
<b class="nc">&nbsp;      return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      return UNINITIALIZED_KIND</b>
<b class="nc">&nbsp;          | symbolTable.addUninitializedType(&quot;&quot;, ((Label) type).bytecodeOffset);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the abstract type corresponding to the internal name of a class.
&nbsp;   *
&nbsp;   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
&nbsp;   * @param internalName the internal name of a class. This must &lt;i&gt;not&lt;/i&gt; be an array type
&nbsp;   *     descriptor.
&nbsp;   * @return the abstract type value corresponding to the given internal name.
&nbsp;   */
&nbsp;  static int getAbstractTypeFromInternalName(
&nbsp;      final SymbolTable symbolTable, final String internalName) {
<b class="nc">&nbsp;    return REFERENCE_KIND | symbolTable.addType(internalName);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the abstract type corresponding to the given type descriptor.
&nbsp;   *
&nbsp;   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
&nbsp;   * @param buffer a string ending with a type descriptor.
&nbsp;   * @param offset the start offset of the type descriptor in buffer.
&nbsp;   * @return the abstract type corresponding to the given type descriptor.
&nbsp;   */
&nbsp;  private static int getAbstractTypeFromDescriptor(
&nbsp;      final SymbolTable symbolTable, final String buffer, final int offset) {
&nbsp;    String internalName;
<b class="nc">&nbsp;    switch (buffer.charAt(offset)) {</b>
&nbsp;      case &#39;V&#39;:
<b class="nc">&nbsp;        return 0;</b>
&nbsp;      case &#39;Z&#39;:
&nbsp;      case &#39;C&#39;:
&nbsp;      case &#39;B&#39;:
&nbsp;      case &#39;S&#39;:
&nbsp;      case &#39;I&#39;:
<b class="nc">&nbsp;        return INTEGER;</b>
&nbsp;      case &#39;F&#39;:
<b class="nc">&nbsp;        return FLOAT;</b>
&nbsp;      case &#39;J&#39;:
<b class="nc">&nbsp;        return LONG;</b>
&nbsp;      case &#39;D&#39;:
<b class="nc">&nbsp;        return DOUBLE;</b>
&nbsp;      case &#39;L&#39;:
<b class="nc">&nbsp;        internalName = buffer.substring(offset + 1, buffer.length() - 1);</b>
<b class="nc">&nbsp;        return REFERENCE_KIND | symbolTable.addType(internalName);</b>
&nbsp;      case &#39;[&#39;:
<b class="nc">&nbsp;        int elementDescriptorOffset = offset + 1;</b>
<b class="nc">&nbsp;        while (buffer.charAt(elementDescriptorOffset) == &#39;[&#39;) {</b>
<b class="nc">&nbsp;          ++elementDescriptorOffset;</b>
&nbsp;        }
&nbsp;        int typeValue;
<b class="nc">&nbsp;        switch (buffer.charAt(elementDescriptorOffset)) {</b>
&nbsp;          case &#39;Z&#39;:
<b class="nc">&nbsp;            typeValue = BOOLEAN;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;C&#39;:
<b class="nc">&nbsp;            typeValue = CHAR;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;B&#39;:
<b class="nc">&nbsp;            typeValue = BYTE;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;S&#39;:
<b class="nc">&nbsp;            typeValue = SHORT;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;I&#39;:
<b class="nc">&nbsp;            typeValue = INTEGER;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;F&#39;:
<b class="nc">&nbsp;            typeValue = FLOAT;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;J&#39;:
<b class="nc">&nbsp;            typeValue = LONG;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;D&#39;:
<b class="nc">&nbsp;            typeValue = DOUBLE;</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;L&#39;:
<b class="nc">&nbsp;            internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1);</b>
<b class="nc">&nbsp;            typeValue = REFERENCE_KIND | symbolTable.addType(internalName);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          default:
<b class="nc">&nbsp;            throw new IllegalArgumentException();</b>
&nbsp;        }
<b class="nc">&nbsp;        return ((elementDescriptorOffset - offset) &lt;&lt; DIM_SHIFT) | typeValue;</b>
&nbsp;      default:
<b class="nc">&nbsp;        throw new IllegalArgumentException();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Constructor
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a new Frame.
&nbsp;   *
&nbsp;   * @param owner the basic block to which these input and output stack map frames correspond.
&nbsp;   */
<b class="nc">&nbsp;  Frame(final Label owner) {</b>
<b class="nc">&nbsp;    this.owner = owner;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Sets this frame to the value of the given frame.
&nbsp;   *
&nbsp;   * &lt;p&gt;WARNING: after this method is called the two frames share the same data structures. It is
&nbsp;   * recommended to discard the given frame to avoid unexpected side effects.
&nbsp;   *
&nbsp;   * @param frame The new frame value.
&nbsp;   */
&nbsp;  final void copyFrom(final Frame frame) {
<b class="nc">&nbsp;    inputLocals = frame.inputLocals;</b>
<b class="nc">&nbsp;    inputStack = frame.inputStack;</b>
<b class="nc">&nbsp;    outputStackStart = 0;</b>
<b class="nc">&nbsp;    outputLocals = frame.outputLocals;</b>
<b class="nc">&nbsp;    outputStack = frame.outputStack;</b>
<b class="nc">&nbsp;    outputStackTop = frame.outputStackTop;</b>
<b class="nc">&nbsp;    initializationCount = frame.initializationCount;</b>
<b class="nc">&nbsp;    initializations = frame.initializations;</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Methods related to the input frame
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Sets the input frame from the given method description. This method is used to initialize the
&nbsp;   * first frame of a method, which is implicit (i.e. not stored explicitly in the StackMapTable
&nbsp;   * attribute).
&nbsp;   *
&nbsp;   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
&nbsp;   * @param access the method&#39;s access flags.
&nbsp;   * @param descriptor the method descriptor.
&nbsp;   * @param maxLocals the maximum number of local variables of the method.
&nbsp;   */
&nbsp;  final void setInputFrameFromDescriptor(
&nbsp;      final SymbolTable symbolTable,
&nbsp;      final int access,
&nbsp;      final String descriptor,
&nbsp;      final int maxLocals) {
<b class="nc">&nbsp;    inputLocals = new int[maxLocals];</b>
<b class="nc">&nbsp;    inputStack = new int[0];</b>
<b class="nc">&nbsp;    int inputLocalIndex = 0;</b>
<b class="nc">&nbsp;    if ((access &amp; Opcodes.ACC_STATIC) == 0) {</b>
<b class="nc">&nbsp;      if ((access &amp; Constants.ACC_CONSTRUCTOR) == 0) {</b>
<b class="nc">&nbsp;        inputLocals[inputLocalIndex++] =</b>
<b class="nc">&nbsp;            REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());</b>
&nbsp;      } else {
<b class="nc">&nbsp;        inputLocals[inputLocalIndex++] = UNINITIALIZED_THIS;</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    for (Type argumentType : Type.getArgumentTypes(descriptor)) {</b>
<b class="nc">&nbsp;      int abstractType =</b>
<b class="nc">&nbsp;          getAbstractTypeFromDescriptor(symbolTable, argumentType.getDescriptor(), 0);</b>
<b class="nc">&nbsp;      inputLocals[inputLocalIndex++] = abstractType;</b>
<b class="nc">&nbsp;      if (abstractType == LONG || abstractType == DOUBLE) {</b>
<b class="nc">&nbsp;        inputLocals[inputLocalIndex++] = TOP;</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    while (inputLocalIndex &lt; maxLocals) {</b>
<b class="nc">&nbsp;      inputLocals[inputLocalIndex++] = TOP;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Sets the input frame from the given public API frame description.
&nbsp;   *
&nbsp;   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
&nbsp;   * @param nLocal the number of local variables.
&nbsp;   * @param local the local variable types, described using the same format as in {@link
&nbsp;   *     MethodVisitor#visitFrame}.
&nbsp;   * @param nStack the number of operand stack elements.
&nbsp;   * @param stack the operand stack types, described using the same format as in {@link
&nbsp;   *     MethodVisitor#visitFrame}.
&nbsp;   */
&nbsp;  final void setInputFrameFromApiFormat(
&nbsp;      final SymbolTable symbolTable,
&nbsp;      final int nLocal,
&nbsp;      final Object[] local,
&nbsp;      final int nStack,
&nbsp;      final Object[] stack) {
<b class="nc">&nbsp;    int inputLocalIndex = 0;</b>
<b class="nc">&nbsp;    for (int i = 0; i &lt; nLocal; ++i) {</b>
<b class="nc">&nbsp;      inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]);</b>
<b class="nc">&nbsp;      if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) {</b>
<b class="nc">&nbsp;        inputLocals[inputLocalIndex++] = TOP;</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    while (inputLocalIndex &lt; inputLocals.length) {</b>
<b class="nc">&nbsp;      inputLocals[inputLocalIndex++] = TOP;</b>
&nbsp;    }
<b class="nc">&nbsp;    int nStackTop = 0;</b>
<b class="nc">&nbsp;    for (int i = 0; i &lt; nStack; ++i) {</b>
<b class="nc">&nbsp;      if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {</b>
<b class="nc">&nbsp;        ++nStackTop;</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    inputStack = new int[nStack + nStackTop];</b>
<b class="nc">&nbsp;    int inputStackIndex = 0;</b>
<b class="nc">&nbsp;    for (int i = 0; i &lt; nStack; ++i) {</b>
<b class="nc">&nbsp;      inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]);</b>
<b class="nc">&nbsp;      if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {</b>
<b class="nc">&nbsp;        inputStack[inputStackIndex++] = TOP;</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    outputStackTop = 0;</b>
<b class="nc">&nbsp;    initializationCount = 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  final int getInputStackSize() {
<b class="nc">&nbsp;    return inputStack.length;</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Methods related to the output frame
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the abstract type stored at the given local variable index in the output frame.
&nbsp;   *
&nbsp;   * @param localIndex the index of the local variable whose value must be returned.
&nbsp;   * @return the abstract type stored at the given local variable index in the output frame.
&nbsp;   */
&nbsp;  private int getLocal(final int localIndex) {
<b class="nc">&nbsp;    if (outputLocals == null || localIndex &gt;= outputLocals.length) {</b>
&nbsp;      // If this local has never been assigned in this basic block, it is still equal to its value
&nbsp;      // in the input frame.
<b class="nc">&nbsp;      return LOCAL_KIND | localIndex;</b>
&nbsp;    } else {
<b class="nc">&nbsp;      int abstractType = outputLocals[localIndex];</b>
<b class="nc">&nbsp;      if (abstractType == 0) {</b>
&nbsp;        // If this local has never been assigned in this basic block, so it is still equal to its
&nbsp;        // value in the input frame.
<b class="nc">&nbsp;        abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex;</b>
&nbsp;      }
<b class="nc">&nbsp;      return abstractType;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Replaces the abstract type stored at the given local variable index in the output frame.
&nbsp;   *
&nbsp;   * @param localIndex the index of the output frame local variable that must be set.
&nbsp;   * @param abstractType the value that must be set.
&nbsp;   */
&nbsp;  private void setLocal(final int localIndex, final int abstractType) {
&nbsp;    // Create and/or resize the output local variables array if necessary.
<b class="nc">&nbsp;    if (outputLocals == null) {</b>
<b class="nc">&nbsp;      outputLocals = new int[10];</b>
&nbsp;    }
<b class="nc">&nbsp;    int outputLocalsLength = outputLocals.length;</b>
<b class="nc">&nbsp;    if (localIndex &gt;= outputLocalsLength) {</b>
<b class="nc">&nbsp;      int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)];</b>
<b class="nc">&nbsp;      System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength);</b>
<b class="nc">&nbsp;      outputLocals = newOutputLocals;</b>
&nbsp;    }
&nbsp;    // Set the local variable.
<b class="nc">&nbsp;    outputLocals[localIndex] = abstractType;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Pushes the given abstract type on the output frame stack.
&nbsp;   *
&nbsp;   * @param abstractType an abstract type.
&nbsp;   */
&nbsp;  private void push(final int abstractType) {
&nbsp;    // Create and/or resize the output stack array if necessary.
<b class="nc">&nbsp;    if (outputStack == null) {</b>
<b class="nc">&nbsp;      outputStack = new int[10];</b>
&nbsp;    }
<b class="nc">&nbsp;    int outputStackLength = outputStack.length;</b>
<b class="nc">&nbsp;    if (outputStackTop &gt;= outputStackLength) {</b>
<b class="nc">&nbsp;      int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)];</b>
<b class="nc">&nbsp;      System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);</b>
<b class="nc">&nbsp;      outputStack = newOutputStack;</b>
&nbsp;    }
&nbsp;    // Pushes the abstract type on the output stack.
<b class="nc">&nbsp;    outputStack[outputStackTop++] = abstractType;</b>
&nbsp;    // Updates the maximum size reached by the output stack, if needed (note that this size is
&nbsp;    // relative to the input stack size, which is not known yet).
<b class="nc">&nbsp;    short outputStackSize = (short) (outputStackStart + outputStackTop);</b>
<b class="nc">&nbsp;    if (outputStackSize &gt; owner.outputStackMax) {</b>
<b class="nc">&nbsp;      owner.outputStackMax = outputStackSize;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Pushes the abstract type corresponding to the given descriptor on the output frame stack.
&nbsp;   *
&nbsp;   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
&nbsp;   * @param descriptor a type or method descriptor (in which case its return type is pushed).
&nbsp;   */
&nbsp;  private void push(final SymbolTable symbolTable, final String descriptor) {
<b class="nc">&nbsp;    int typeDescriptorOffset = descriptor.charAt(0) == &#39;(&#39; ? descriptor.indexOf(&#39;)&#39;) + 1 : 0;</b>
<b class="nc">&nbsp;    int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);</b>
<b class="nc">&nbsp;    if (abstractType != 0) {</b>
<b class="nc">&nbsp;      push(abstractType);</b>
<b class="nc">&nbsp;      if (abstractType == LONG || abstractType == DOUBLE) {</b>
<b class="nc">&nbsp;        push(TOP);</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Pops an abstract type from the output frame stack and returns its value.
&nbsp;   *
&nbsp;   * @return the abstract type that has been popped from the output frame stack.
&nbsp;   */
&nbsp;  private int pop() {
<b class="nc">&nbsp;    if (outputStackTop &gt; 0) {</b>
<b class="nc">&nbsp;      return outputStack[--outputStackTop];</b>
&nbsp;    } else {
&nbsp;      // If the output frame stack is empty, pop from the input stack.
<b class="nc">&nbsp;      return STACK_KIND | -(--outputStackStart);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Pops the given number of abstract types from the output frame stack.
&nbsp;   *
&nbsp;   * @param elements the number of abstract types that must be popped.
&nbsp;   */
&nbsp;  private void pop(final int elements) {
<b class="nc">&nbsp;    if (outputStackTop &gt;= elements) {</b>
<b class="nc">&nbsp;      outputStackTop -= elements;</b>
&nbsp;    } else {
&nbsp;      // If the number of elements to be popped is greater than the number of elements in the output
&nbsp;      // stack, clear it, and pop the remaining elements from the input stack.
<b class="nc">&nbsp;      outputStackStart -= elements - outputStackTop;</b>
<b class="nc">&nbsp;      outputStackTop = 0;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Pops as many abstract types from the output frame stack as described by the given descriptor.
&nbsp;   *
&nbsp;   * @param descriptor a type or method descriptor (in which case its argument types are popped).
&nbsp;   */
&nbsp;  private void pop(final String descriptor) {
<b class="nc">&nbsp;    char firstDescriptorChar = descriptor.charAt(0);</b>
<b class="nc">&nbsp;    if (firstDescriptorChar == &#39;(&#39;) {</b>
<b class="nc">&nbsp;      pop((Type.getArgumentsAndReturnSizes(descriptor) &gt;&gt; 2) - 1);</b>
<b class="nc">&nbsp;    } else if (firstDescriptorChar == &#39;J&#39; || firstDescriptorChar == &#39;D&#39;) {</b>
<b class="nc">&nbsp;      pop(2);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      pop(1);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Methods to handle uninitialized types
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Adds an abstract type to the list of types on which a constructor is invoked in the basic
&nbsp;   * block.
&nbsp;   *
&nbsp;   * @param abstractType an abstract type on a which a constructor is invoked.
&nbsp;   */
&nbsp;  private void addInitializedType(final int abstractType) {
&nbsp;    // Create and/or resize the initializations array if necessary.
<b class="nc">&nbsp;    if (initializations == null) {</b>
<b class="nc">&nbsp;      initializations = new int[2];</b>
&nbsp;    }
<b class="nc">&nbsp;    int initializationsLength = initializations.length;</b>
<b class="nc">&nbsp;    if (initializationCount &gt;= initializationsLength) {</b>
<b class="nc">&nbsp;      int[] newInitializations =</b>
<b class="nc">&nbsp;          new int[Math.max(initializationCount + 1, 2 * initializationsLength)];</b>
<b class="nc">&nbsp;      System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);</b>
<b class="nc">&nbsp;      initializations = newInitializations;</b>
&nbsp;    }
&nbsp;    // Store the abstract type.
<b class="nc">&nbsp;    initializations[initializationCount++] = abstractType;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the &quot;initialized&quot; abstract type corresponding to the given abstract type.
&nbsp;   *
&nbsp;   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
&nbsp;   * @param abstractType an abstract type.
&nbsp;   * @return the REFERENCE_KIND abstract type corresponding to abstractType if it is
&nbsp;   *     UNINITIALIZED_THIS or an UNINITIALIZED_KIND abstract type for one of the types on which a
&nbsp;   *     constructor is invoked in the basic block. Otherwise returns abstractType.
&nbsp;   */
&nbsp;  private int getInitializedType(final SymbolTable symbolTable, final int abstractType) {
<b class="nc">&nbsp;    if (abstractType == UNINITIALIZED_THIS</b>
&nbsp;        || (abstractType &amp; (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) {
<b class="nc">&nbsp;      for (int i = 0; i &lt; initializationCount; ++i) {</b>
<b class="nc">&nbsp;        int initializedType = initializations[i];</b>
<b class="nc">&nbsp;        int dim = initializedType &amp; DIM_MASK;</b>
<b class="nc">&nbsp;        int kind = initializedType &amp; KIND_MASK;</b>
<b class="nc">&nbsp;        int value = initializedType &amp; VALUE_MASK;</b>
<b class="nc">&nbsp;        if (kind == LOCAL_KIND) {</b>
<b class="nc">&nbsp;          initializedType = dim + inputLocals[value];</b>
<b class="nc">&nbsp;        } else if (kind == STACK_KIND) {</b>
<b class="nc">&nbsp;          initializedType = dim + inputStack[inputStack.length - value];</b>
&nbsp;        }
<b class="nc">&nbsp;        if (abstractType == initializedType) {</b>
<b class="nc">&nbsp;          if (abstractType == UNINITIALIZED_THIS) {</b>
<b class="nc">&nbsp;            return REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());</b>
&nbsp;          } else {
<b class="nc">&nbsp;            return REFERENCE_KIND</b>
<b class="nc">&nbsp;                | symbolTable.addType(symbolTable.getType(abstractType &amp; VALUE_MASK).value);</b>
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return abstractType;</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Main method, to simulate the execution of each instruction on the output frame
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Simulates the action of the given instruction on the output stack frame.
&nbsp;   *
&nbsp;   * @param opcode the opcode of the instruction.
&nbsp;   * @param arg the numeric operand of the instruction, if any.
&nbsp;   * @param argSymbol the Symbol operand of the instruction, if any.
&nbsp;   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
&nbsp;   */
&nbsp;  void execute(
&nbsp;      final int opcode, final int arg, final Symbol argSymbol, final SymbolTable symbolTable) {
&nbsp;    // Abstract types popped from the stack or read from local variables.
&nbsp;    int abstractType1;
&nbsp;    int abstractType2;
&nbsp;    int abstractType3;
&nbsp;    int abstractType4;
<b class="nc">&nbsp;    switch (opcode) {</b>
&nbsp;      case Opcodes.NOP:
&nbsp;      case Opcodes.INEG:
&nbsp;      case Opcodes.LNEG:
&nbsp;      case Opcodes.FNEG:
&nbsp;      case Opcodes.DNEG:
&nbsp;      case Opcodes.I2B:
&nbsp;      case Opcodes.I2C:
&nbsp;      case Opcodes.I2S:
&nbsp;      case Opcodes.GOTO:
&nbsp;      case Opcodes.RETURN:
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.ACONST_NULL:
<b class="nc">&nbsp;        push(NULL);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.ICONST_M1:
&nbsp;      case Opcodes.ICONST_0:
&nbsp;      case Opcodes.ICONST_1:
&nbsp;      case Opcodes.ICONST_2:
&nbsp;      case Opcodes.ICONST_3:
&nbsp;      case Opcodes.ICONST_4:
&nbsp;      case Opcodes.ICONST_5:
&nbsp;      case Opcodes.BIPUSH:
&nbsp;      case Opcodes.SIPUSH:
&nbsp;      case Opcodes.ILOAD:
<b class="nc">&nbsp;        push(INTEGER);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.LCONST_0:
&nbsp;      case Opcodes.LCONST_1:
&nbsp;      case Opcodes.LLOAD:
<b class="nc">&nbsp;        push(LONG);</b>
<b class="nc">&nbsp;        push(TOP);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.FCONST_0:
&nbsp;      case Opcodes.FCONST_1:
&nbsp;      case Opcodes.FCONST_2:
&nbsp;      case Opcodes.FLOAD:
<b class="nc">&nbsp;        push(FLOAT);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.DCONST_0:
&nbsp;      case Opcodes.DCONST_1:
&nbsp;      case Opcodes.DLOAD:
<b class="nc">&nbsp;        push(DOUBLE);</b>
<b class="nc">&nbsp;        push(TOP);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.LDC:
<b class="nc">&nbsp;        switch (argSymbol.tag) {</b>
&nbsp;          case Symbol.CONSTANT_INTEGER_TAG:
<b class="nc">&nbsp;            push(INTEGER);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Symbol.CONSTANT_LONG_TAG:
<b class="nc">&nbsp;            push(LONG);</b>
<b class="nc">&nbsp;            push(TOP);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Symbol.CONSTANT_FLOAT_TAG:
<b class="nc">&nbsp;            push(FLOAT);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Symbol.CONSTANT_DOUBLE_TAG:
<b class="nc">&nbsp;            push(DOUBLE);</b>
<b class="nc">&nbsp;            push(TOP);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Symbol.CONSTANT_CLASS_TAG:
<b class="nc">&nbsp;            push(REFERENCE_KIND | symbolTable.addType(&quot;java/lang/Class&quot;));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Symbol.CONSTANT_STRING_TAG:
<b class="nc">&nbsp;            push(REFERENCE_KIND | symbolTable.addType(&quot;java/lang/String&quot;));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Symbol.CONSTANT_METHOD_TYPE_TAG:
<b class="nc">&nbsp;            push(REFERENCE_KIND | symbolTable.addType(&quot;java/lang/invoke/MethodType&quot;));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Symbol.CONSTANT_METHOD_HANDLE_TAG:
<b class="nc">&nbsp;            push(REFERENCE_KIND | symbolTable.addType(&quot;java/lang/invoke/MethodHandle&quot;));</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Symbol.CONSTANT_DYNAMIC_TAG:
<b class="nc">&nbsp;            push(symbolTable, argSymbol.value);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          default:
<b class="nc">&nbsp;            throw new AssertionError();</b>
&nbsp;        }
&nbsp;        break;
&nbsp;      case Opcodes.ALOAD:
<b class="nc">&nbsp;        push(getLocal(arg));</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.LALOAD:
&nbsp;      case Opcodes.D2L:
<b class="nc">&nbsp;        pop(2);</b>
<b class="nc">&nbsp;        push(LONG);</b>
<b class="nc">&nbsp;        push(TOP);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.DALOAD:
&nbsp;      case Opcodes.L2D:
<b class="nc">&nbsp;        pop(2);</b>
<b class="nc">&nbsp;        push(DOUBLE);</b>
<b class="nc">&nbsp;        push(TOP);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.AALOAD:
<b class="nc">&nbsp;        pop(1);</b>
<b class="nc">&nbsp;        abstractType1 = pop();</b>
<b class="nc">&nbsp;        push(abstractType1 == NULL ? abstractType1 : ELEMENT_OF + abstractType1);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.ISTORE:
&nbsp;      case Opcodes.FSTORE:
&nbsp;      case Opcodes.ASTORE:
<b class="nc">&nbsp;        abstractType1 = pop();</b>
<b class="nc">&nbsp;        setLocal(arg, abstractType1);</b>
<b class="nc">&nbsp;        if (arg &gt; 0) {</b>
<b class="nc">&nbsp;          int previousLocalType = getLocal(arg - 1);</b>
<b class="nc">&nbsp;          if (previousLocalType == LONG || previousLocalType == DOUBLE) {</b>
<b class="nc">&nbsp;            setLocal(arg - 1, TOP);</b>
<b class="nc">&nbsp;          } else if ((previousLocalType &amp; KIND_MASK) == LOCAL_KIND</b>
&nbsp;              || (previousLocalType &amp; KIND_MASK) == STACK_KIND) {
&nbsp;            // The type of the previous local variable is not known yet, but if it later appears
&nbsp;            // to be LONG or DOUBLE, we should then use TOP instead.
<b class="nc">&nbsp;            setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);</b>
&nbsp;          }
<b class="nc">&nbsp;        }</b>
&nbsp;        break;
&nbsp;      case Opcodes.LSTORE:
&nbsp;      case Opcodes.DSTORE:
<b class="nc">&nbsp;        pop(1);</b>
<b class="nc">&nbsp;        abstractType1 = pop();</b>
<b class="nc">&nbsp;        setLocal(arg, abstractType1);</b>
<b class="nc">&nbsp;        setLocal(arg + 1, TOP);</b>
<b class="nc">&nbsp;        if (arg &gt; 0) {</b>
<b class="nc">&nbsp;          int previousLocalType = getLocal(arg - 1);</b>
<b class="nc">&nbsp;          if (previousLocalType == LONG || previousLocalType == DOUBLE) {</b>
<b class="nc">&nbsp;            setLocal(arg - 1, TOP);</b>
<b class="nc">&nbsp;          } else if ((previousLocalType &amp; KIND_MASK) == LOCAL_KIND</b>
&nbsp;              || (previousLocalType &amp; KIND_MASK) == STACK_KIND) {
&nbsp;            // The type of the previous local variable is not known yet, but if it later appears
&nbsp;            // to be LONG or DOUBLE, we should then use TOP instead.
<b class="nc">&nbsp;            setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);</b>
&nbsp;          }
<b class="nc">&nbsp;        }</b>
&nbsp;        break;
&nbsp;      case Opcodes.IASTORE:
&nbsp;      case Opcodes.BASTORE:
&nbsp;      case Opcodes.CASTORE:
&nbsp;      case Opcodes.SASTORE:
&nbsp;      case Opcodes.FASTORE:
&nbsp;      case Opcodes.AASTORE:
<b class="nc">&nbsp;        pop(3);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.LASTORE:
&nbsp;      case Opcodes.DASTORE:
<b class="nc">&nbsp;        pop(4);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.POP:
&nbsp;      case Opcodes.IFEQ:
&nbsp;      case Opcodes.IFNE:
&nbsp;      case Opcodes.IFLT:
&nbsp;      case Opcodes.IFGE:
&nbsp;      case Opcodes.IFGT:
&nbsp;      case Opcodes.IFLE:
&nbsp;      case Opcodes.IRETURN:
&nbsp;      case Opcodes.FRETURN:
&nbsp;      case Opcodes.ARETURN:
&nbsp;      case Opcodes.TABLESWITCH:
&nbsp;      case Opcodes.LOOKUPSWITCH:
&nbsp;      case Opcodes.ATHROW:
&nbsp;      case Opcodes.MONITORENTER:
&nbsp;      case Opcodes.MONITOREXIT:
&nbsp;      case Opcodes.IFNULL:
&nbsp;      case Opcodes.IFNONNULL:
<b class="nc">&nbsp;        pop(1);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.POP2:
&nbsp;      case Opcodes.IF_ICMPEQ:
&nbsp;      case Opcodes.IF_ICMPNE:
&nbsp;      case Opcodes.IF_ICMPLT:
&nbsp;      case Opcodes.IF_ICMPGE:
&nbsp;      case Opcodes.IF_ICMPGT:
&nbsp;      case Opcodes.IF_ICMPLE:
&nbsp;      case Opcodes.IF_ACMPEQ:
&nbsp;      case Opcodes.IF_ACMPNE:
&nbsp;      case Opcodes.LRETURN:
&nbsp;      case Opcodes.DRETURN:
<b class="nc">&nbsp;        pop(2);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.DUP:
<b class="nc">&nbsp;        abstractType1 = pop();</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.DUP_X1:
<b class="nc">&nbsp;        abstractType1 = pop();</b>
<b class="nc">&nbsp;        abstractType2 = pop();</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        push(abstractType2);</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.DUP_X2:
<b class="nc">&nbsp;        abstractType1 = pop();</b>
<b class="nc">&nbsp;        abstractType2 = pop();</b>
<b class="nc">&nbsp;        abstractType3 = pop();</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        push(abstractType3);</b>
<b class="nc">&nbsp;        push(abstractType2);</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.DUP2:
<b class="nc">&nbsp;        abstractType1 = pop();</b>
<b class="nc">&nbsp;        abstractType2 = pop();</b>
<b class="nc">&nbsp;        push(abstractType2);</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        push(abstractType2);</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.DUP2_X1:
<b class="nc">&nbsp;        abstractType1 = pop();</b>
<b class="nc">&nbsp;        abstractType2 = pop();</b>
<b class="nc">&nbsp;        abstractType3 = pop();</b>
<b class="nc">&nbsp;        push(abstractType2);</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        push(abstractType3);</b>
<b class="nc">&nbsp;        push(abstractType2);</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.DUP2_X2:
<b class="nc">&nbsp;        abstractType1 = pop();</b>
<b class="nc">&nbsp;        abstractType2 = pop();</b>
<b class="nc">&nbsp;        abstractType3 = pop();</b>
<b class="nc">&nbsp;        abstractType4 = pop();</b>
<b class="nc">&nbsp;        push(abstractType2);</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        push(abstractType4);</b>
<b class="nc">&nbsp;        push(abstractType3);</b>
<b class="nc">&nbsp;        push(abstractType2);</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.SWAP:
<b class="nc">&nbsp;        abstractType1 = pop();</b>
<b class="nc">&nbsp;        abstractType2 = pop();</b>
<b class="nc">&nbsp;        push(abstractType1);</b>
<b class="nc">&nbsp;        push(abstractType2);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.IALOAD:
&nbsp;      case Opcodes.BALOAD:
&nbsp;      case Opcodes.CALOAD:
&nbsp;      case Opcodes.SALOAD:
&nbsp;      case Opcodes.IADD:
&nbsp;      case Opcodes.ISUB:
&nbsp;      case Opcodes.IMUL:
&nbsp;      case Opcodes.IDIV:
&nbsp;      case Opcodes.IREM:
&nbsp;      case Opcodes.IAND:
&nbsp;      case Opcodes.IOR:
&nbsp;      case Opcodes.IXOR:
&nbsp;      case Opcodes.ISHL:
&nbsp;      case Opcodes.ISHR:
&nbsp;      case Opcodes.IUSHR:
&nbsp;      case Opcodes.L2I:
&nbsp;      case Opcodes.D2I:
&nbsp;      case Opcodes.FCMPL:
&nbsp;      case Opcodes.FCMPG:
<b class="nc">&nbsp;        pop(2);</b>
<b class="nc">&nbsp;        push(INTEGER);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.LADD:
&nbsp;      case Opcodes.LSUB:
&nbsp;      case Opcodes.LMUL:
&nbsp;      case Opcodes.LDIV:
&nbsp;      case Opcodes.LREM:
&nbsp;      case Opcodes.LAND:
&nbsp;      case Opcodes.LOR:
&nbsp;      case Opcodes.LXOR:
<b class="nc">&nbsp;        pop(4);</b>
<b class="nc">&nbsp;        push(LONG);</b>
<b class="nc">&nbsp;        push(TOP);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.FALOAD:
&nbsp;      case Opcodes.FADD:
&nbsp;      case Opcodes.FSUB:
&nbsp;      case Opcodes.FMUL:
&nbsp;      case Opcodes.FDIV:
&nbsp;      case Opcodes.FREM:
&nbsp;      case Opcodes.L2F:
&nbsp;      case Opcodes.D2F:
<b class="nc">&nbsp;        pop(2);</b>
<b class="nc">&nbsp;        push(FLOAT);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.DADD:
&nbsp;      case Opcodes.DSUB:
&nbsp;      case Opcodes.DMUL:
&nbsp;      case Opcodes.DDIV:
&nbsp;      case Opcodes.DREM:
<b class="nc">&nbsp;        pop(4);</b>
<b class="nc">&nbsp;        push(DOUBLE);</b>
<b class="nc">&nbsp;        push(TOP);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.LSHL:
&nbsp;      case Opcodes.LSHR:
&nbsp;      case Opcodes.LUSHR:
<b class="nc">&nbsp;        pop(3);</b>
<b class="nc">&nbsp;        push(LONG);</b>
<b class="nc">&nbsp;        push(TOP);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.IINC:
<b class="nc">&nbsp;        setLocal(arg, INTEGER);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.I2L:
&nbsp;      case Opcodes.F2L:
<b class="nc">&nbsp;        pop(1);</b>
<b class="nc">&nbsp;        push(LONG);</b>
<b class="nc">&nbsp;        push(TOP);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.I2F:
<b class="nc">&nbsp;        pop(1);</b>
<b class="nc">&nbsp;        push(FLOAT);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.I2D:
&nbsp;      case Opcodes.F2D:
<b class="nc">&nbsp;        pop(1);</b>
<b class="nc">&nbsp;        push(DOUBLE);</b>
<b class="nc">&nbsp;        push(TOP);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.F2I:
&nbsp;      case Opcodes.ARRAYLENGTH:
&nbsp;      case Opcodes.INSTANCEOF:
<b class="nc">&nbsp;        pop(1);</b>
<b class="nc">&nbsp;        push(INTEGER);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.LCMP:
&nbsp;      case Opcodes.DCMPL:
&nbsp;      case Opcodes.DCMPG:
<b class="nc">&nbsp;        pop(4);</b>
<b class="nc">&nbsp;        push(INTEGER);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.JSR:
&nbsp;      case Opcodes.RET:
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;JSR/RET are not supported with computeFrames option&quot;);</b>
&nbsp;      case Opcodes.GETSTATIC:
<b class="nc">&nbsp;        push(symbolTable, argSymbol.value);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.PUTSTATIC:
<b class="nc">&nbsp;        pop(argSymbol.value);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.GETFIELD:
<b class="nc">&nbsp;        pop(1);</b>
<b class="nc">&nbsp;        push(symbolTable, argSymbol.value);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.PUTFIELD:
<b class="nc">&nbsp;        pop(argSymbol.value);</b>
<b class="nc">&nbsp;        pop();</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.INVOKEVIRTUAL:
&nbsp;      case Opcodes.INVOKESPECIAL:
&nbsp;      case Opcodes.INVOKESTATIC:
&nbsp;      case Opcodes.INVOKEINTERFACE:
<b class="nc">&nbsp;        pop(argSymbol.value);</b>
<b class="nc">&nbsp;        if (opcode != Opcodes.INVOKESTATIC) {</b>
<b class="nc">&nbsp;          abstractType1 = pop();</b>
<b class="nc">&nbsp;          if (opcode == Opcodes.INVOKESPECIAL &amp;&amp; argSymbol.name.charAt(0) == &#39;&lt;&#39;) {</b>
<b class="nc">&nbsp;            addInitializedType(abstractType1);</b>
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;        push(symbolTable, argSymbol.value);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.INVOKEDYNAMIC:
<b class="nc">&nbsp;        pop(argSymbol.value);</b>
<b class="nc">&nbsp;        push(symbolTable, argSymbol.value);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.NEW:
<b class="nc">&nbsp;        push(UNINITIALIZED_KIND | symbolTable.addUninitializedType(argSymbol.value, arg));</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.NEWARRAY:
<b class="nc">&nbsp;        pop();</b>
<b class="nc">&nbsp;        switch (arg) {</b>
&nbsp;          case Opcodes.T_BOOLEAN:
<b class="nc">&nbsp;            push(ARRAY_OF | BOOLEAN);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Opcodes.T_CHAR:
<b class="nc">&nbsp;            push(ARRAY_OF | CHAR);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Opcodes.T_BYTE:
<b class="nc">&nbsp;            push(ARRAY_OF | BYTE);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Opcodes.T_SHORT:
<b class="nc">&nbsp;            push(ARRAY_OF | SHORT);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Opcodes.T_INT:
<b class="nc">&nbsp;            push(ARRAY_OF | INTEGER);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Opcodes.T_FLOAT:
<b class="nc">&nbsp;            push(ARRAY_OF | FLOAT);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Opcodes.T_DOUBLE:
<b class="nc">&nbsp;            push(ARRAY_OF | DOUBLE);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Opcodes.T_LONG:
<b class="nc">&nbsp;            push(ARRAY_OF | LONG);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          default:
<b class="nc">&nbsp;            throw new IllegalArgumentException();</b>
&nbsp;        }
&nbsp;        break;
&nbsp;      case Opcodes.ANEWARRAY:
<b class="nc">&nbsp;        String arrayElementType = argSymbol.value;</b>
<b class="nc">&nbsp;        pop();</b>
<b class="nc">&nbsp;        if (arrayElementType.charAt(0) == &#39;[&#39;) {</b>
<b class="nc">&nbsp;          push(symbolTable, &#39;[&#39; + arrayElementType);</b>
&nbsp;        } else {
<b class="nc">&nbsp;          push(ARRAY_OF | REFERENCE_KIND | symbolTable.addType(arrayElementType));</b>
&nbsp;        }
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.CHECKCAST:
<b class="nc">&nbsp;        String castType = argSymbol.value;</b>
<b class="nc">&nbsp;        pop();</b>
<b class="nc">&nbsp;        if (castType.charAt(0) == &#39;[&#39;) {</b>
<b class="nc">&nbsp;          push(symbolTable, castType);</b>
&nbsp;        } else {
<b class="nc">&nbsp;          push(REFERENCE_KIND | symbolTable.addType(castType));</b>
&nbsp;        }
<b class="nc">&nbsp;        break;</b>
&nbsp;      case Opcodes.MULTIANEWARRAY:
<b class="nc">&nbsp;        pop(arg);</b>
<b class="nc">&nbsp;        push(symbolTable, argSymbol.value);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      default:
<b class="nc">&nbsp;        throw new IllegalArgumentException();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Frame merging methods, used in the second step of the stack map frame computation algorithm
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Merges the input frame of the given {@link Frame} with the input and output frames of this
&nbsp;   * {@link Frame}. Returns &lt;tt&gt;true&lt;/tt&gt; if the given frame has been changed by this operation (the
&nbsp;   * input and output frames of this {@link Frame} are never changed).
&nbsp;   *
&nbsp;   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
&nbsp;   * @param dstFrame the {@link Frame} whose input frame must be updated. This should be the frame
&nbsp;   *     of a successor, in the control flow graph, of the basic block corresponding to this frame.
&nbsp;   * @param catchTypeIndex if &#39;frame&#39; corresponds to an exception handler basic block, the type
&nbsp;   *     table index of the caught exception type, otherwise 0.
&nbsp;   * @return &lt;tt&gt;true&lt;/tt&gt; if the input frame of &#39;frame&#39; has been changed by this operation.
&nbsp;   */
&nbsp;  final boolean merge(
&nbsp;      final SymbolTable symbolTable, final Frame dstFrame, final int catchTypeIndex) {
<b class="nc">&nbsp;    boolean frameChanged = false;</b>
&nbsp;
&nbsp;    // Compute the concrete types of the local variables at the end of the basic block corresponding
&nbsp;    // to this frame, by resolving its abstract output types, and merge these concrete types with
&nbsp;    // those of the local variables in the input frame of dstFrame.
<b class="nc">&nbsp;    int nLocal = inputLocals.length;</b>
<b class="nc">&nbsp;    int nStack = inputStack.length;</b>
<b class="nc">&nbsp;    if (dstFrame.inputLocals == null) {</b>
<b class="nc">&nbsp;      dstFrame.inputLocals = new int[nLocal];</b>
<b class="nc">&nbsp;      frameChanged = true;</b>
&nbsp;    }
<b class="nc">&nbsp;    for (int i = 0; i &lt; nLocal; ++i) {</b>
&nbsp;      int concreteOutputType;
<b class="nc">&nbsp;      if (outputLocals != null &amp;&amp; i &lt; outputLocals.length) {</b>
<b class="nc">&nbsp;        int abstractOutputType = outputLocals[i];</b>
<b class="nc">&nbsp;        if (abstractOutputType == 0) {</b>
&nbsp;          // If the local variable has never been assigned in this basic block, it is equal to its
&nbsp;          // value at the beginning of the block.
<b class="nc">&nbsp;          concreteOutputType = inputLocals[i];</b>
&nbsp;        } else {
<b class="nc">&nbsp;          int dim = abstractOutputType &amp; DIM_MASK;</b>
<b class="nc">&nbsp;          int kind = abstractOutputType &amp; KIND_MASK;</b>
<b class="nc">&nbsp;          if (kind == LOCAL_KIND) {</b>
&nbsp;            // By definition, a LOCAL_KIND type designates the concrete type of a local variable at
&nbsp;            // the beginning of the basic block corresponding to this frame (which is known when
&nbsp;            // this method is called, but was not when the abstract type was computed).
<b class="nc">&nbsp;            concreteOutputType = dim + inputLocals[abstractOutputType &amp; VALUE_MASK];</b>
<b class="nc">&nbsp;            if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</b>
&nbsp;                &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
<b class="nc">&nbsp;              concreteOutputType = TOP;</b>
&nbsp;            }
<b class="nc">&nbsp;          } else if (kind == STACK_KIND) {</b>
&nbsp;            // By definition, a STACK_KIND type designates the concrete type of a local variable at
&nbsp;            // the beginning of the basic block corresponding to this frame (which is known when
&nbsp;            // this method is called, but was not when the abstract type was computed).
<b class="nc">&nbsp;            concreteOutputType = dim + inputStack[nStack - (abstractOutputType &amp; VALUE_MASK)];</b>
<b class="nc">&nbsp;            if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</b>
&nbsp;                &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
<b class="nc">&nbsp;              concreteOutputType = TOP;</b>
&nbsp;            }
&nbsp;          } else {
<b class="nc">&nbsp;            concreteOutputType = abstractOutputType;</b>
&nbsp;          }
&nbsp;        }
<b class="nc">&nbsp;      } else {</b>
&nbsp;        // If the local variable has never been assigned in this basic block, it is equal to its
&nbsp;        // value at the beginning of the block.
<b class="nc">&nbsp;        concreteOutputType = inputLocals[i];</b>
&nbsp;      }
&nbsp;      // concreteOutputType might be an uninitialized type from the input locals or from the input
&nbsp;      // stack. However, if a constructor has been called for this class type in the basic block,
&nbsp;      // then this type is no longer uninitialized at the end of basic block.
<b class="nc">&nbsp;      if (initializations != null) {</b>
<b class="nc">&nbsp;        concreteOutputType = getInitializedType(symbolTable, concreteOutputType);</b>
&nbsp;      }
<b class="nc">&nbsp;      frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);</b>
&nbsp;    }
&nbsp;
&nbsp;    // If dstFrame is an exception handler block, it can be reached from any instruction of the
&nbsp;    // basic block corresponding to this frame, in particular from the first one. Therefore, the
&nbsp;    // input locals of dstFrame should be compatible (i.e. merged) with the input locals of this
&nbsp;    // frame (and the input stack of dstFrame should be compatible, i.e. merged, with a one
&nbsp;    // element stack containing the caught exception type).
<b class="nc">&nbsp;    if (catchTypeIndex &gt; 0) {</b>
<b class="nc">&nbsp;      for (int i = 0; i &lt; nLocal; ++i) {</b>
<b class="nc">&nbsp;        frameChanged |= merge(symbolTable, inputLocals[i], dstFrame.inputLocals, i);</b>
&nbsp;      }
<b class="nc">&nbsp;      if (dstFrame.inputStack == null) {</b>
<b class="nc">&nbsp;        dstFrame.inputStack = new int[1];</b>
<b class="nc">&nbsp;        frameChanged = true;</b>
&nbsp;      }
<b class="nc">&nbsp;      frameChanged |= merge(symbolTable, catchTypeIndex, dstFrame.inputStack, 0);</b>
<b class="nc">&nbsp;      return frameChanged;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Compute the concrete types of the stack operands at the end of the basic block corresponding
&nbsp;    // to this frame, by resolving its abstract output types, and merge these concrete types with
&nbsp;    // those of the stack operands in the input frame of dstFrame.
<b class="nc">&nbsp;    int nInputStack = inputStack.length + outputStackStart;</b>
<b class="nc">&nbsp;    if (dstFrame.inputStack == null) {</b>
<b class="nc">&nbsp;      dstFrame.inputStack = new int[nInputStack + outputStackTop];</b>
<b class="nc">&nbsp;      frameChanged = true;</b>
&nbsp;    }
&nbsp;    // First, do this for the stack operands that have not been popped in the basic block
&nbsp;    // corresponding to this frame, and which are therefore equal to their value in the input
&nbsp;    // frame (except for uninitialized types, which may have been initialized).
<b class="nc">&nbsp;    for (int i = 0; i &lt; nInputStack; ++i) {</b>
<b class="nc">&nbsp;      int concreteOutputType = inputStack[i];</b>
<b class="nc">&nbsp;      if (initializations != null) {</b>
<b class="nc">&nbsp;        concreteOutputType = getInitializedType(symbolTable, concreteOutputType);</b>
&nbsp;      }
<b class="nc">&nbsp;      frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);</b>
&nbsp;    }
&nbsp;    // Then, do this for the stack operands that have pushed in the basic block (this code is the
&nbsp;    // same as the one above for local variables).
<b class="nc">&nbsp;    for (int i = 0; i &lt; outputStackTop; ++i) {</b>
&nbsp;      int concreteOutputType;
<b class="nc">&nbsp;      int abstractOutputType = outputStack[i];</b>
<b class="nc">&nbsp;      int dim = abstractOutputType &amp; DIM_MASK;</b>
<b class="nc">&nbsp;      int kind = abstractOutputType &amp; KIND_MASK;</b>
<b class="nc">&nbsp;      if (kind == LOCAL_KIND) {</b>
<b class="nc">&nbsp;        concreteOutputType = dim + inputLocals[abstractOutputType &amp; VALUE_MASK];</b>
<b class="nc">&nbsp;        if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</b>
&nbsp;            &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
<b class="nc">&nbsp;          concreteOutputType = TOP;</b>
&nbsp;        }
<b class="nc">&nbsp;      } else if (kind == STACK_KIND) {</b>
<b class="nc">&nbsp;        concreteOutputType = dim + inputStack[nStack - (abstractOutputType &amp; VALUE_MASK)];</b>
<b class="nc">&nbsp;        if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</b>
&nbsp;            &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
<b class="nc">&nbsp;          concreteOutputType = TOP;</b>
&nbsp;        }
&nbsp;      } else {
<b class="nc">&nbsp;        concreteOutputType = abstractOutputType;</b>
&nbsp;      }
<b class="nc">&nbsp;      if (initializations != null) {</b>
<b class="nc">&nbsp;        concreteOutputType = getInitializedType(symbolTable, concreteOutputType);</b>
&nbsp;      }
<b class="nc">&nbsp;      frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, nInputStack + i);</b>
&nbsp;    }
<b class="nc">&nbsp;    return frameChanged;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Merges the type at the given index in the given abstract type array with the given type.
&nbsp;   * Returns &lt;tt&gt;true&lt;/tt&gt; if the type array has been modified by this operation.
&nbsp;   *
&nbsp;   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
&nbsp;   * @param sourceType the abstract type with which the abstract type array element must be merged.
&nbsp;   *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND} or {@link
&nbsp;   *     #UNINITIALIZED_KIND} kind, with positive or null array dimensions.
&nbsp;   * @param dstTypes an array of abstract types. These types should be of {@link #CONSTANT_KIND},
&nbsp;   *     {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or null array
&nbsp;   *     dimensions.
&nbsp;   * @param dstIndex the index of the type that must be merged in dstTypes.
&nbsp;   * @return &lt;tt&gt;true&lt;/tt&gt; if the type array has been modified by this operation.
&nbsp;   */
&nbsp;  private static boolean merge(
&nbsp;      final SymbolTable symbolTable,
&nbsp;      final int sourceType,
&nbsp;      final int[] dstTypes,
&nbsp;      final int dstIndex) {
<b class="nc">&nbsp;    int dstType = dstTypes[dstIndex];</b>
<b class="nc">&nbsp;    if (dstType == sourceType) {</b>
&nbsp;      // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="nc">&nbsp;    int srcType = sourceType;</b>
<b class="nc">&nbsp;    if ((sourceType &amp; ~DIM_MASK) == NULL) {</b>
<b class="nc">&nbsp;      if (dstType == NULL) {</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;      }
<b class="nc">&nbsp;      srcType = NULL;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (dstType == 0) {</b>
&nbsp;      // If dstTypes[dstIndex] has never been assigned, merge(srcType, dstType) = srcType.
<b class="nc">&nbsp;      dstTypes[dstIndex] = srcType;</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
&nbsp;    int mergedType;
<b class="nc">&nbsp;    if ((dstType &amp; DIM_MASK) != 0 || (dstType &amp; KIND_MASK) == REFERENCE_KIND) {</b>
&nbsp;      // If dstType is a reference type of any array dimension.
<b class="nc">&nbsp;      if (srcType == NULL) {</b>
&nbsp;        // If srcType is the NULL type, merge(srcType, dstType) = dstType, so there is no change.
<b class="nc">&nbsp;        return false;</b>
<b class="nc">&nbsp;      } else if ((srcType &amp; (DIM_MASK | KIND_MASK)) == (dstType &amp; (DIM_MASK | KIND_MASK))) {</b>
&nbsp;        // If srcType has the same array dimension and the same kind as dstType.
<b class="nc">&nbsp;        if ((dstType &amp; KIND_MASK) == REFERENCE_KIND) {</b>
&nbsp;          // If srcType and dstType are reference types with the same array dimension,
&nbsp;          // merge(srcType, dstType) = dim(srcType) | common super class of srcType and dstType.
<b class="nc">&nbsp;          mergedType =</b>
&nbsp;              (srcType &amp; DIM_MASK)
&nbsp;                  | REFERENCE_KIND
<b class="nc">&nbsp;                  | symbolTable.addMergedType(srcType &amp; VALUE_MASK, dstType &amp; VALUE_MASK);</b>
&nbsp;        } else {
&nbsp;          // If srcType and dstType are array types of equal dimension but different element types,
&nbsp;          // merge(srcType, dstType) = dim(srcType) - 1 | java/lang/Object.
<b class="nc">&nbsp;          int mergedDim = ELEMENT_OF + (srcType &amp; DIM_MASK);</b>
<b class="nc">&nbsp;          mergedType = mergedDim | REFERENCE_KIND | symbolTable.addType(&quot;java/lang/Object&quot;);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;      } else if ((srcType &amp; DIM_MASK) != 0 || (srcType &amp; KIND_MASK) == REFERENCE_KIND) {</b>
&nbsp;        // If srcType is any other reference or array type,
&nbsp;        // merge(srcType, dstType) = min(srcDdim, dstDim) | java/lang/Object
&nbsp;        // where srcDim is the array dimension of srcType, minus 1 if srcType is an array type
&nbsp;        // with a non reference element type (and similarly for dstDim).
<b class="nc">&nbsp;        int srcDim = srcType &amp; DIM_MASK;</b>
<b class="nc">&nbsp;        if (srcDim != 0 &amp;&amp; (srcType &amp; KIND_MASK) != REFERENCE_KIND) {</b>
<b class="nc">&nbsp;          srcDim = ELEMENT_OF + srcDim;</b>
&nbsp;        }
<b class="nc">&nbsp;        int dstDim = dstType &amp; DIM_MASK;</b>
<b class="nc">&nbsp;        if (dstDim != 0 &amp;&amp; (dstType &amp; KIND_MASK) != REFERENCE_KIND) {</b>
<b class="nc">&nbsp;          dstDim = ELEMENT_OF + dstDim;</b>
&nbsp;        }
<b class="nc">&nbsp;        mergedType =</b>
<b class="nc">&nbsp;            Math.min(srcDim, dstDim) | REFERENCE_KIND | symbolTable.addType(&quot;java/lang/Object&quot;);</b>
<b class="nc">&nbsp;      } else {</b>
&nbsp;        // If srcType is any other type, merge(srcType, dstType) = TOP.
<b class="nc">&nbsp;        mergedType = TOP;</b>
&nbsp;      }
<b class="nc">&nbsp;    } else if (dstType == NULL) {</b>
&nbsp;      // If dstType is the NULL type, merge(srcType, dstType) = srcType, or TOP if srcType is not a
&nbsp;      // an array type or a reference type.
<b class="nc">&nbsp;      mergedType =</b>
&nbsp;          (srcType &amp; DIM_MASK) != 0 || (srcType &amp; KIND_MASK) == REFERENCE_KIND ? srcType : TOP;
&nbsp;    } else {
&nbsp;      // If dstType is any other type, merge(srcType, dstType) = TOP whatever srcType.
<b class="nc">&nbsp;      mergedType = TOP;</b>
&nbsp;    }
<b class="nc">&nbsp;    if (mergedType != dstType) {</b>
<b class="nc">&nbsp;      dstTypes[dstIndex] = mergedType;</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Frame output methods, to generate StackMapFrame attributes
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Makes the given {@link MethodWriter} visit the input frame of this {@link Frame}. The visit is
&nbsp;   * done with the {@link MethodWriter#visitFrameStart}, {@link MethodWriter#visitAbstractType} and
&nbsp;   * {@link MethodWriter#visitFrameEnd} methods.
&nbsp;   *
&nbsp;   * @param methodWriter the {@link MethodWriter} that should visit the input frame of this {@link
&nbsp;   *     Frame}.
&nbsp;   */
&nbsp;  final void accept(final MethodWriter methodWriter) {
&nbsp;    // Compute the number of locals, ignoring TOP types that are just after a LONG or a DOUBLE, and
&nbsp;    // all trailing TOP types.
<b class="nc">&nbsp;    int[] localTypes = inputLocals;</b>
<b class="nc">&nbsp;    int nLocal = 0;</b>
<b class="nc">&nbsp;    int nTrailingTop = 0;</b>
<b class="nc">&nbsp;    int i = 0;</b>
<b class="nc">&nbsp;    while (i &lt; localTypes.length) {</b>
<b class="nc">&nbsp;      int localType = localTypes[i];</b>
<b class="nc">&nbsp;      i += (localType == LONG || localType == DOUBLE) ? 2 : 1;</b>
<b class="nc">&nbsp;      if (localType == TOP) {</b>
<b class="nc">&nbsp;        nTrailingTop++;</b>
&nbsp;      } else {
<b class="nc">&nbsp;        nLocal += nTrailingTop + 1;</b>
<b class="nc">&nbsp;        nTrailingTop = 0;</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;    // Compute the stack size, ignoring TOP types that are just after a LONG or a DOUBLE.
<b class="nc">&nbsp;    int[] stackTypes = inputStack;</b>
<b class="nc">&nbsp;    int nStack = 0;</b>
<b class="nc">&nbsp;    i = 0;</b>
<b class="nc">&nbsp;    while (i &lt; stackTypes.length) {</b>
<b class="nc">&nbsp;      int stackType = stackTypes[i];</b>
<b class="nc">&nbsp;      i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;</b>
<b class="nc">&nbsp;      nStack++;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    // Visit the frame and its content.
<b class="nc">&nbsp;    int frameIndex = methodWriter.visitFrameStart(owner.bytecodeOffset, nLocal, nStack);</b>
<b class="nc">&nbsp;    i = 0;</b>
<b class="nc">&nbsp;    while (nLocal-- &gt; 0) {</b>
<b class="nc">&nbsp;      int localType = localTypes[i];</b>
<b class="nc">&nbsp;      i += (localType == LONG || localType == DOUBLE) ? 2 : 1;</b>
<b class="nc">&nbsp;      methodWriter.visitAbstractType(frameIndex++, localType);</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    i = 0;</b>
<b class="nc">&nbsp;    while (nStack-- &gt; 0) {</b>
<b class="nc">&nbsp;      int stackType = stackTypes[i];</b>
<b class="nc">&nbsp;      i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;</b>
<b class="nc">&nbsp;      methodWriter.visitAbstractType(frameIndex++, stackType);</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;    methodWriter.visitFrameEnd();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Put the given abstract type in the given ByteVector, using the JVMS verification_type_info
&nbsp;   * format used in StackMapTable attributes.
&nbsp;   *
&nbsp;   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
&nbsp;   * @param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link
&nbsp;   *     Frame#REFERENCE_KIND} or {@link Frame#UNINITIALIZED_KIND} types.
&nbsp;   * @param output where the abstract type must be put.
&nbsp;   * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4&quot;&gt;JVMS
&nbsp;   *     4.7.4&lt;/a&gt;
&nbsp;   */
&nbsp;  static void putAbstractType(
&nbsp;      final SymbolTable symbolTable, final int abstractType, final ByteVector output) {
<b class="nc">&nbsp;    int arrayDimensions = (abstractType &amp; Frame.DIM_MASK) &gt;&gt; DIM_SHIFT;</b>
<b class="nc">&nbsp;    if (arrayDimensions == 0) {</b>
<b class="nc">&nbsp;      int typeValue = abstractType &amp; VALUE_MASK;</b>
<b class="nc">&nbsp;      switch (abstractType &amp; KIND_MASK) {</b>
&nbsp;        case CONSTANT_KIND:
<b class="nc">&nbsp;          output.putByte(typeValue);</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case REFERENCE_KIND:
<b class="nc">&nbsp;          output</b>
<b class="nc">&nbsp;              .putByte(ITEM_OBJECT)</b>
<b class="nc">&nbsp;              .putShort(symbolTable.addConstantClass(symbolTable.getType(typeValue).value).index);</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case UNINITIALIZED_KIND:
<b class="nc">&nbsp;          output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.getType(typeValue).data);</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        default:
<b class="nc">&nbsp;          throw new AssertionError();</b>
&nbsp;      }
<b class="nc">&nbsp;    } else {</b>
&nbsp;      // Case of an array type, we need to build its descriptor first.
<b class="nc">&nbsp;      StringBuilder typeDescriptor = new StringBuilder();</b>
<b class="nc">&nbsp;      while (arrayDimensions-- &gt; 0) {</b>
<b class="nc">&nbsp;        typeDescriptor.append(&#39;[&#39;);</b>
&nbsp;      }
<b class="nc">&nbsp;      if ((abstractType &amp; KIND_MASK) == REFERENCE_KIND) {</b>
<b class="nc">&nbsp;        typeDescriptor</b>
<b class="nc">&nbsp;            .append(&#39;L&#39;)</b>
<b class="nc">&nbsp;            .append(symbolTable.getType(abstractType &amp; VALUE_MASK).value)</b>
<b class="nc">&nbsp;            .append(&#39;;&#39;);</b>
&nbsp;      } else {
<b class="nc">&nbsp;        switch (abstractType &amp; VALUE_MASK) {</b>
&nbsp;          case Frame.ITEM_ASM_BOOLEAN:
<b class="nc">&nbsp;            typeDescriptor.append(&#39;Z&#39;);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Frame.ITEM_ASM_BYTE:
<b class="nc">&nbsp;            typeDescriptor.append(&#39;B&#39;);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Frame.ITEM_ASM_CHAR:
<b class="nc">&nbsp;            typeDescriptor.append(&#39;C&#39;);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Frame.ITEM_ASM_SHORT:
<b class="nc">&nbsp;            typeDescriptor.append(&#39;S&#39;);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Frame.ITEM_INTEGER:
<b class="nc">&nbsp;            typeDescriptor.append(&#39;I&#39;);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Frame.ITEM_FLOAT:
<b class="nc">&nbsp;            typeDescriptor.append(&#39;F&#39;);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Frame.ITEM_LONG:
<b class="nc">&nbsp;            typeDescriptor.append(&#39;J&#39;);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case Frame.ITEM_DOUBLE:
<b class="nc">&nbsp;            typeDescriptor.append(&#39;D&#39;);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          default:
<b class="nc">&nbsp;            throw new AssertionError();</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      output</b>
<b class="nc">&nbsp;          .putByte(ITEM_OBJECT)</b>
<b class="nc">&nbsp;          .putShort(symbolTable.addConstantClass(typeDescriptor.toString()).index);</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
