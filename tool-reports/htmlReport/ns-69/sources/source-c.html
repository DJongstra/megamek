


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MethodVisitor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.jar.asm</a>
</div>

<h1>Coverage Summary for Class: MethodVisitor (net.bytebuddy.jar.asm)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodVisitor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5,9%
  </span>
  <span class="absValue">
    (2/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0,9%
  </span>
  <span class="absValue">
    (1/106)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5%
  </span>
  <span class="absValue">
    (5/101)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;// ASM: a very small and fast Java bytecode manipulation framework
&nbsp;// Copyright (c) 2000-2011 INRIA, France Telecom
&nbsp;// All rights reserved.
&nbsp;//
&nbsp;// Redistribution and use in source and binary forms, with or without
&nbsp;// modification, are permitted provided that the following conditions
&nbsp;// are met:
&nbsp;// 1. Redistributions of source code must retain the above copyright
&nbsp;//    notice, this list of conditions and the following disclaimer.
&nbsp;// 2. Redistributions in binary form must reproduce the above copyright
&nbsp;//    notice, this list of conditions and the following disclaimer in the
&nbsp;//    documentation and/or other materials provided with the distribution.
&nbsp;// 3. Neither the name of the copyright holders nor the names of its
&nbsp;//    contributors may be used to endorse or promote products derived from
&nbsp;//    this software without specific prior written permission.
&nbsp;//
&nbsp;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
&nbsp;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
&nbsp;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
&nbsp;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
&nbsp;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
&nbsp;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
&nbsp;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
&nbsp;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
&nbsp;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
&nbsp;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
&nbsp;// THE POSSIBILITY OF SUCH DAMAGE.
&nbsp;package net.bytebuddy.jar.asm;
&nbsp;
&nbsp;/**
&nbsp; * A visitor to visit a Java method. The methods of this class must be called in the following
&nbsp; * order: ( &lt;tt&gt;visitParameter&lt;/tt&gt; )* [ &lt;tt&gt;visitAnnotationDefault&lt;/tt&gt; ] (
&nbsp; * &lt;tt&gt;visitAnnotation&lt;/tt&gt; | &lt;tt&gt;visitAnnotableParameterCount&lt;/tt&gt; |
&nbsp; * &lt;tt&gt;visitParameterAnnotation&lt;/tt&gt; &lt;tt&gt;visitTypeAnnotation&lt;/tt&gt; | &lt;tt&gt;visitAttribute&lt;/tt&gt; )* [
&nbsp; * &lt;tt&gt;visitCode&lt;/tt&gt; ( &lt;tt&gt;visitFrame&lt;/tt&gt; | &lt;tt&gt;visit&lt;i&gt;X&lt;/i&gt;Insn&lt;/tt&gt; | &lt;tt&gt;visitLabel&lt;/tt&gt; |
&nbsp; * &lt;tt&gt;visitInsnAnnotation&lt;/tt&gt; | &lt;tt&gt;visitTryCatchBlock&lt;/tt&gt; | &lt;tt&gt;visitTryCatchAnnotation&lt;/tt&gt; |
&nbsp; * &lt;tt&gt;visitLocalVariable&lt;/tt&gt; | &lt;tt&gt;visitLocalVariableAnnotation&lt;/tt&gt; | &lt;tt&gt;visitLineNumber&lt;/tt&gt; )*
&nbsp; * &lt;tt&gt;visitMaxs&lt;/tt&gt; ] &lt;tt&gt;visitEnd&lt;/tt&gt;. In addition, the &lt;tt&gt;visit&lt;i&gt;X&lt;/i&gt;Insn&lt;/tt&gt; and
&nbsp; * &lt;tt&gt;visitLabel&lt;/tt&gt; methods must be called in the sequential order of the bytecode instructions
&nbsp; * of the visited code, &lt;tt&gt;visitInsnAnnotation&lt;/tt&gt; must be called &lt;i&gt;after&lt;/i&gt; the annotated
&nbsp; * instruction, &lt;tt&gt;visitTryCatchBlock&lt;/tt&gt; must be called &lt;i&gt;before&lt;/i&gt; the labels passed as
&nbsp; * arguments have been visited, &lt;tt&gt;visitTryCatchBlockAnnotation&lt;/tt&gt; must be called &lt;i&gt;after&lt;/i&gt;
&nbsp; * the corresponding try catch block has been visited, and the &lt;tt&gt;visitLocalVariable&lt;/tt&gt;,
&nbsp; * &lt;tt&gt;visitLocalVariableAnnotation&lt;/tt&gt; and &lt;tt&gt;visitLineNumber&lt;/tt&gt; methods must be called
&nbsp; * &lt;i&gt;after&lt;/i&gt; the labels passed as arguments have been visited.
&nbsp; *
&nbsp; * @author Eric Bruneton
&nbsp; */
&nbsp;public abstract class MethodVisitor {
&nbsp;
&nbsp;  private static final String REQUIRES_ASM5 = &quot;This feature requires ASM5&quot;;
&nbsp;
&nbsp;  /**
&nbsp;   * The ASM API version implemented by this visitor. The value of this field must be one of {@link
&nbsp;   * Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7_EXPERIMENTAL}.
&nbsp;   */
&nbsp;  protected final int api;
&nbsp;
&nbsp;  /** The method visitor to which this visitor must delegate method calls. May be null. */
&nbsp;  protected MethodVisitor mv;
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a new {@link MethodVisitor}.
&nbsp;   *
&nbsp;   * @param api the ASM API version implemented by this visitor. Must be one of {@link
&nbsp;   *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link
&nbsp;   *     Opcodes#ASM7_EXPERIMENTAL}.
&nbsp;   */
&nbsp;  public MethodVisitor(final int api) {
<b class="fc">&nbsp;    this(api, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a new {@link MethodVisitor}.
&nbsp;   *
&nbsp;   * @param api the ASM API version implemented by this visitor. Must be one of {@link
&nbsp;   *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link
&nbsp;   *     Opcodes#ASM7_EXPERIMENTAL}.
&nbsp;   * @param methodVisitor the method visitor to which this visitor must delegate method calls. May
&nbsp;   *     be null.
&nbsp;   */
<b class="fc">&nbsp;  public MethodVisitor(final int api, final MethodVisitor methodVisitor) {</b>
<b class="pc">&nbsp;    if (api != Opcodes.ASM6</b>
&nbsp;        &amp;&amp; api != Opcodes.ASM5
&nbsp;        &amp;&amp; api != Opcodes.ASM4
&nbsp;        &amp;&amp; api != Opcodes.ASM7_EXPERIMENTAL) {
<b class="nc">&nbsp;      throw new IllegalArgumentException();</b>
&nbsp;    }
<b class="fc">&nbsp;    this.api = api;</b>
<b class="fc">&nbsp;    this.mv = methodVisitor;</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Parameters, annotations and non standard attributes
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a parameter of this method.
&nbsp;   *
&nbsp;   * @param name parameter name or null if none is provided.
&nbsp;   * @param access the parameter&#39;s access flags, only &lt;tt&gt;ACC_FINAL&lt;/tt&gt;, &lt;tt&gt;ACC_SYNTHETIC&lt;/tt&gt;
&nbsp;   *     or/and &lt;tt&gt;ACC_MANDATED&lt;/tt&gt; are allowed (see {@link Opcodes}).
&nbsp;   */
&nbsp;  public void visitParameter(final String name, final int access) {
<b class="nc">&nbsp;    if (api &lt; Opcodes.ASM5) {</b>
<b class="nc">&nbsp;      throw new UnsupportedOperationException(REQUIRES_ASM5);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitParameter(name, access);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits the default value of this annotation interface method.
&nbsp;   *
&nbsp;   * @return a visitor to the visit the actual default value of this annotation interface method, or
&nbsp;   *     &lt;tt&gt;null&lt;/tt&gt; if this visitor is not interested in visiting this default value. The &#39;name&#39;
&nbsp;   *     parameters passed to the methods of this annotation visitor are ignored. Moreover, exacly
&nbsp;   *     one visit method must be called on this annotation visitor, followed by visitEnd.
&nbsp;   */
&nbsp;  public AnnotationVisitor visitAnnotationDefault() {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      return mv.visitAnnotationDefault();</b>
&nbsp;    }
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits an annotation of this method.
&nbsp;   *
&nbsp;   * @param descriptor the class descriptor of the annotation class.
&nbsp;   * @param visible &lt;tt&gt;true&lt;/tt&gt; if the annotation is visible at runtime.
&nbsp;   * @return a visitor to visit the annotation values, or &lt;tt&gt;null&lt;/tt&gt; if this visitor is not
&nbsp;   *     interested in visiting this annotation.
&nbsp;   */
&nbsp;  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      return mv.visitAnnotation(descriptor, visible);</b>
&nbsp;    }
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits an annotation on a type in the method signature.
&nbsp;   *
&nbsp;   * @param typeRef a reference to the annotated type. The sort of this type reference must be
&nbsp;   *     {@link TypeReference#METHOD_TYPE_PARAMETER}, {@link
&nbsp;   *     TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link
&nbsp;   *     TypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link
&nbsp;   *     TypeReference#THROWS}. See {@link TypeReference}.
&nbsp;   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
&nbsp;   *     static inner type within &#39;typeRef&#39;. May be &lt;tt&gt;null&lt;/tt&gt; if the annotation targets
&nbsp;   *     &#39;typeRef&#39; as a whole.
&nbsp;   * @param descriptor the class descriptor of the annotation class.
&nbsp;   * @param visible &lt;tt&gt;true&lt;/tt&gt; if the annotation is visible at runtime.
&nbsp;   * @return a visitor to visit the annotation values, or &lt;tt&gt;null&lt;/tt&gt; if this visitor is not
&nbsp;   *     interested in visiting this annotation.
&nbsp;   */
&nbsp;  public AnnotationVisitor visitTypeAnnotation(
&nbsp;      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
<b class="nc">&nbsp;    if (api &lt; Opcodes.ASM5) {</b>
<b class="nc">&nbsp;      throw new UnsupportedOperationException(REQUIRES_ASM5);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);</b>
&nbsp;    }
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits the number of method parameters that can have annotations. By default (i.e. when this
&nbsp;   * method is not called), all the method parameters defined by the method descriptor can have
&nbsp;   * annotations.
&nbsp;   *
&nbsp;   * @param parameterCount the number of method parameters than can have annotations. This number
&nbsp;   *     must be less or equal than the number of parameter types in the method descriptor. It can
&nbsp;   *     be strictly less when a method has synthetic parameters and when these parameters are
&nbsp;   *     ignored when computing parameter indices for the purpose of parameter annotations (see
&nbsp;   *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).
&nbsp;   * @param visible &lt;tt&gt;true&lt;/tt&gt; to define the number of method parameters that can have
&nbsp;   *     annotations visible at runtime, &lt;tt&gt;false&lt;/tt&gt; to define the number of method parameters
&nbsp;   *     that can have annotations invisible at runtime.
&nbsp;   */
&nbsp;  public void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitAnnotableParameterCount(parameterCount, visible);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits an annotation of a parameter this method.
&nbsp;   *
&nbsp;   * @param parameter the parameter index. This index must be strictly smaller than the number of
&nbsp;   *     parameters in the method descriptor, and strictly smaller than the parameter count
&nbsp;   *     specified in {@link #visitAnnotableParameterCount}. Important note: &lt;i&gt;a parameter index i
&nbsp;   *     is not required to correspond to the i&#39;th parameter descriptor in the method
&nbsp;   *     descriptor&lt;/i&gt;, in particular in case of synthetic parameters (see
&nbsp;   *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).
&nbsp;   * @param descriptor the class descriptor of the annotation class.
&nbsp;   * @param visible &lt;tt&gt;true&lt;/tt&gt; if the annotation is visible at runtime.
&nbsp;   * @return a visitor to visit the annotation values, or &lt;tt&gt;null&lt;/tt&gt; if this visitor is not
&nbsp;   *     interested in visiting this annotation.
&nbsp;   */
&nbsp;  public AnnotationVisitor visitParameterAnnotation(
&nbsp;      final int parameter, final String descriptor, final boolean visible) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      return mv.visitParameterAnnotation(parameter, descriptor, visible);</b>
&nbsp;    }
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a non standard attribute of this method.
&nbsp;   *
&nbsp;   * @param attribute an attribute.
&nbsp;   */
&nbsp;  public void visitAttribute(final Attribute attribute) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitAttribute(attribute);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /** Starts the visit of the method&#39;s code, if any (i.e. non abstract method). */
&nbsp;  public void visitCode() {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitCode();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits the current state of the local variables and operand stack elements. This method must(*)
&nbsp;   * be called &lt;i&gt;just before&lt;/i&gt; any instruction &lt;b&gt;i&lt;/b&gt; that follows an unconditional branch
&nbsp;   * instruction such as GOTO or THROW, that is the target of a jump instruction, or that starts an
&nbsp;   * exception handler block. The visited types must describe the values of the local variables and
&nbsp;   * of the operand stack elements &lt;i&gt;just before&lt;/i&gt; &lt;b&gt;i&lt;/b&gt; is executed.&lt;br&gt;
&nbsp;   * &lt;br&gt;
&nbsp;   * (*) this is mandatory only for classes whose version is greater than or equal to {@link
&nbsp;   * Opcodes#V1_6}. &lt;br&gt;
&nbsp;   * &lt;br&gt;
&nbsp;   * The frames of a method must be given either in expanded form, or in compressed form (all frames
&nbsp;   * must use the same format, i.e. you must not mix expanded and compressed frames within a single
&nbsp;   * method):
&nbsp;   *
&nbsp;   * &lt;ul&gt;
&nbsp;   *   &lt;li&gt;In expanded form, all frames must have the F_NEW type.
&nbsp;   *   &lt;li&gt;In compressed form, frames are basically &quot;deltas&quot; from the state of the previous frame:
&nbsp;   *       &lt;ul&gt;
&nbsp;   *         &lt;li&gt;{@link Opcodes#F_SAME} representing frame with exactly the same locals as the
&nbsp;   *             previous frame and with the empty stack.
&nbsp;   *         &lt;li&gt;{@link Opcodes#F_SAME1} representing frame with exactly the same locals as the
&nbsp;   *             previous frame and with single value on the stack ( &lt;code&gt;nStack&lt;/code&gt; is 1 and
&nbsp;   *             &lt;code&gt;stack[0]&lt;/code&gt; contains value for the type of the stack item).
&nbsp;   *         &lt;li&gt;{@link Opcodes#F_APPEND} representing frame with current locals are the same as the
&nbsp;   *             locals in the previous frame, except that additional locals are defined (&lt;code&gt;
&nbsp;   *             nLocal&lt;/code&gt; is 1, 2 or 3 and &lt;code&gt;local&lt;/code&gt; elements contains values
&nbsp;   *             representing added types).
&nbsp;   *         &lt;li&gt;{@link Opcodes#F_CHOP} representing frame with current locals are the same as the
&nbsp;   *             locals in the previous frame, except that the last 1-3 locals are absent and with
&nbsp;   *             the empty stack (&lt;code&gt;nLocals&lt;/code&gt; is 1, 2 or 3).
&nbsp;   *         &lt;li&gt;{@link Opcodes#F_FULL} representing complete frame data.
&nbsp;   *       &lt;/ul&gt;
&nbsp;   * &lt;/ul&gt;
&nbsp;   *
&nbsp;   * &lt;br&gt;
&nbsp;   * In both cases the first frame, corresponding to the method&#39;s parameters and access flags, is
&nbsp;   * implicit and must not be visited. Also, it is illegal to visit two or more frames for the same
&nbsp;   * code location (i.e., at least one instruction must be visited between two calls to visitFrame).
&nbsp;   *
&nbsp;   * @param type the type of this stack map frame. Must be {@link Opcodes#F_NEW} for expanded
&nbsp;   *     frames, or {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND}, {@link Opcodes#F_CHOP}, {@link
&nbsp;   *     Opcodes#F_SAME} or {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed frames.
&nbsp;   * @param nLocal the number of local variables in the visited frame.
&nbsp;   * @param local the local variable types in this frame. This array must not be modified. Primitive
&nbsp;   *     types are represented by {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link
&nbsp;   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL} or
&nbsp;   *     {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented by a single element).
&nbsp;   *     Reference types are represented by String objects (representing internal names), and
&nbsp;   *     uninitialized types by Label objects (this label designates the NEW instruction that
&nbsp;   *     created this uninitialized value).
&nbsp;   * @param nStack the number of operand stack elements in the visited frame.
&nbsp;   * @param stack the operand stack types in this frame. This array must not be modified. Its
&nbsp;   *     content has the same format as the &quot;local&quot; array.
&nbsp;   * @throws IllegalStateException if a frame is visited just after another one, without any
&nbsp;   *     instruction between the two (unless this frame is a Opcodes#F_SAME frame, in which case it
&nbsp;   *     is silently ignored).
&nbsp;   */
&nbsp;  public void visitFrame(
&nbsp;      final int type,
&nbsp;      final int nLocal,
&nbsp;      final Object[] local,
&nbsp;      final int nStack,
&nbsp;      final Object[] stack) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitFrame(type, nLocal, local, nStack, stack);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Normal instructions
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a zero operand instruction.
&nbsp;   *
&nbsp;   * @param opcode the opcode of the instruction to be visited. This opcode is either NOP,
&nbsp;   *     ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5,
&nbsp;   *     LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD,
&nbsp;   *     FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE, DASTORE,
&nbsp;   *     AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2,
&nbsp;   *     SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV,
&nbsp;   *     FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR,
&nbsp;   *     LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I,
&nbsp;   *     D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN,
&nbsp;   *     DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER, or MONITOREXIT.
&nbsp;   */
&nbsp;  public void visitInsn(final int opcode) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitInsn(opcode);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits an instruction with a single int operand.
&nbsp;   *
&nbsp;   * @param opcode the opcode of the instruction to be visited. This opcode is either BIPUSH, SIPUSH
&nbsp;   *     or NEWARRAY.
&nbsp;   * @param operand the operand of the instruction to be visited.&lt;br&gt;
&nbsp;   *     When opcode is BIPUSH, operand value should be between Byte.MIN_VALUE and Byte.MAX_VALUE.
&nbsp;   *     &lt;br&gt;
&nbsp;   *     When opcode is SIPUSH, operand value should be between Short.MIN_VALUE and Short.MAX_VALUE.
&nbsp;   *     &lt;br&gt;
&nbsp;   *     When opcode is NEWARRAY, operand value should be one of {@link Opcodes#T_BOOLEAN}, {@link
&nbsp;   *     Opcodes#T_CHAR}, {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE}, {@link Opcodes#T_BYTE},
&nbsp;   *     {@link Opcodes#T_SHORT}, {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.
&nbsp;   */
&nbsp;  public void visitIntInsn(final int opcode, final int operand) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitIntInsn(opcode, operand);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a local variable instruction. A local variable instruction is an instruction that loads
&nbsp;   * or stores the value of a local variable.
&nbsp;   *
&nbsp;   * @param opcode the opcode of the local variable instruction to be visited. This opcode is either
&nbsp;   *     ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.
&nbsp;   * @param var the operand of the instruction to be visited. This operand is the index of a local
&nbsp;   *     variable.
&nbsp;   */
&nbsp;  public void visitVarInsn(final int opcode, final int var) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitVarInsn(opcode, var);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a type instruction. A type instruction is an instruction that takes the internal name of
&nbsp;   * a class as parameter.
&nbsp;   *
&nbsp;   * @param opcode the opcode of the type instruction to be visited. This opcode is either NEW,
&nbsp;   *     ANEWARRAY, CHECKCAST or INSTANCEOF.
&nbsp;   * @param type the operand of the instruction to be visited. This operand must be the internal
&nbsp;   *     name of an object or array class (see {@link Type#getInternalName()}).
&nbsp;   */
&nbsp;  public void visitTypeInsn(final int opcode, final String type) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitTypeInsn(opcode, type);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a field instruction. A field instruction is an instruction that loads or stores the
&nbsp;   * value of a field of an object.
&nbsp;   *
&nbsp;   * @param opcode the opcode of the type instruction to be visited. This opcode is either
&nbsp;   *     GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.
&nbsp;   * @param owner the internal name of the field&#39;s owner class (see {@link Type#getInternalName()}).
&nbsp;   * @param name the field&#39;s name.
&nbsp;   * @param descriptor the field&#39;s descriptor (see {@link Type}).
&nbsp;   */
&nbsp;  public void visitFieldInsn(
&nbsp;      final int opcode, final String owner, final String name, final String descriptor) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitFieldInsn(opcode, owner, name, descriptor);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a method instruction. A method instruction is an instruction that invokes a method.
&nbsp;   *
&nbsp;   * @param opcode the opcode of the type instruction to be visited. This opcode is either
&nbsp;   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.
&nbsp;   * @param owner the internal name of the method&#39;s owner class (see {@link
&nbsp;   *     Type#getInternalName()}).
&nbsp;   * @param name the method&#39;s name.
&nbsp;   * @param descriptor the method&#39;s descriptor (see {@link Type}).
&nbsp;   * @deprecated
&nbsp;   */
&nbsp;  @Deprecated
&nbsp;  public void visitMethodInsn(
&nbsp;      final int opcode, final String owner, final String name, final String descriptor) {
<b class="nc">&nbsp;    if (api &gt;= Opcodes.ASM5) {</b>
<b class="nc">&nbsp;      boolean isInterface = opcode == Opcodes.INVOKEINTERFACE;</b>
<b class="nc">&nbsp;      visitMethodInsn(opcode, owner, name, descriptor, isInterface);</b>
&nbsp;      return;
&nbsp;    }
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitMethodInsn(opcode, owner, name, descriptor);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a method instruction. A method instruction is an instruction that invokes a method.
&nbsp;   *
&nbsp;   * @param opcode the opcode of the type instruction to be visited. This opcode is either
&nbsp;   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.
&nbsp;   * @param owner the internal name of the method&#39;s owner class (see {@link
&nbsp;   *     Type#getInternalName()}).
&nbsp;   * @param name the method&#39;s name.
&nbsp;   * @param descriptor the method&#39;s descriptor (see {@link Type}).
&nbsp;   * @param isInterface if the method&#39;s owner class is an interface.
&nbsp;   */
&nbsp;  public void visitMethodInsn(
&nbsp;      final int opcode,
&nbsp;      final String owner,
&nbsp;      final String name,
&nbsp;      final String descriptor,
&nbsp;      final boolean isInterface) {
<b class="nc">&nbsp;    if (api &lt; Opcodes.ASM5) {</b>
<b class="nc">&nbsp;      if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) {</b>
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;INVOKESPECIAL/STATIC on interfaces requires ASM5&quot;);</b>
&nbsp;      }
<b class="nc">&nbsp;      visitMethodInsn(opcode, owner, name, descriptor);</b>
&nbsp;      return;
&nbsp;    }
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits an invokedynamic instruction.
&nbsp;   *
&nbsp;   * @param name the method&#39;s name.
&nbsp;   * @param descriptor the method&#39;s descriptor (see {@link Type}).
&nbsp;   * @param bootstrapMethodHandle the bootstrap method.
&nbsp;   * @param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be
&nbsp;   *     an {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link
&nbsp;   *     Type}, {@link Handle} or {@link ConstantDynamic} value. This method is allowed to modify
&nbsp;   *     the content of the array so a caller should expect that this array may change.
&nbsp;   */
&nbsp;  public void visitInvokeDynamicInsn(
&nbsp;      final String name,
&nbsp;      final String descriptor,
&nbsp;      final Handle bootstrapMethodHandle,
&nbsp;      final Object... bootstrapMethodArguments) {
<b class="nc">&nbsp;    if (api &lt; Opcodes.ASM5) {</b>
<b class="nc">&nbsp;      throw new UnsupportedOperationException(REQUIRES_ASM5);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a jump instruction. A jump instruction is an instruction that may jump to another
&nbsp;   * instruction.
&nbsp;   *
&nbsp;   * @param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ,
&nbsp;   *     IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,
&nbsp;   *     IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.
&nbsp;   * @param label the operand of the instruction to be visited. This operand is a label that
&nbsp;   *     designates the instruction to which the jump instruction may jump.
&nbsp;   */
&nbsp;  public void visitJumpInsn(final int opcode, final Label label) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitJumpInsn(opcode, label);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a label. A label designates the instruction that will be visited just after it.
&nbsp;   *
&nbsp;   * @param label a {@link Label} object.
&nbsp;   */
&nbsp;  public void visitLabel(final Label label) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitLabel(label);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Special instructions
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a LDC instruction. Note that new constant types may be added in future versions of the
&nbsp;   * Java Virtual Machine. To easily detect new constant types, implementations of this method
&nbsp;   * should check for unexpected constant types, like this:
&nbsp;   *
&nbsp;   * &lt;pre&gt;
&nbsp;   * if (cst instanceof Integer) {
&nbsp;   *     // ...
&nbsp;   * } else if (cst instanceof Float) {
&nbsp;   *     // ...
&nbsp;   * } else if (cst instanceof Long) {
&nbsp;   *     // ...
&nbsp;   * } else if (cst instanceof Double) {
&nbsp;   *     // ...
&nbsp;   * } else if (cst instanceof String) {
&nbsp;   *     // ...
&nbsp;   * } else if (cst instanceof Type) {
&nbsp;   *     int sort = ((Type) cst).getSort();
&nbsp;   *     if (sort == Type.OBJECT) {
&nbsp;   *         // ...
&nbsp;   *     } else if (sort == Type.ARRAY) {
&nbsp;   *         // ...
&nbsp;   *     } else if (sort == Type.METHOD) {
&nbsp;   *         // ...
&nbsp;   *     } else {
&nbsp;   *         // throw an exception
&nbsp;   *     }
&nbsp;   * } else if (cst instanceof Handle) {
&nbsp;   *     // ...
&nbsp;   * } else if (cst instanceof Condy) {
&nbsp;   *     // ...
&nbsp;   * } else {
&nbsp;   *     // throw an exception
&nbsp;   * }
&nbsp;   * &lt;/pre&gt;
&nbsp;   *
&nbsp;   * @param value the constant to be loaded on the stack. This parameter must be a non null {@link
&nbsp;   *     Integer}, a {@link Float}, a {@link Long}, a {@link Double}, a {@link String}, a {@link
&nbsp;   *     Type} of OBJECT or ARRAY sort for &lt;tt&gt;.class&lt;/tt&gt; constants, for classes whose version is
&nbsp;   *     49, a {@link Type} of METHOD sort for MethodType, a {@link Handle} for MethodHandle
&nbsp;   *     constants, for classes whose version is 51 or a {@link ConstantDynamic} for a constant
&nbsp;   *     dynamic for classes whose version is 55.
&nbsp;   */
&nbsp;  public void visitLdcInsn(final Object value) {
<b class="nc">&nbsp;    if (api &lt; Opcodes.ASM5</b>
&nbsp;        &amp;&amp; (value instanceof Handle
<b class="nc">&nbsp;            || (value instanceof Type &amp;&amp; ((Type) value).getSort() == Type.METHOD))) {</b>
<b class="nc">&nbsp;      throw new UnsupportedOperationException(REQUIRES_ASM5);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (api != Opcodes.ASM7_EXPERIMENTAL &amp;&amp; value instanceof ConstantDynamic) {</b>
<b class="nc">&nbsp;      throw new UnsupportedOperationException(&quot;This feature requires ASM7&quot;);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitLdcInsn(value);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits an IINC instruction.
&nbsp;   *
&nbsp;   * @param var index of the local variable to be incremented.
&nbsp;   * @param increment amount to increment the local variable by.
&nbsp;   */
&nbsp;  public void visitIincInsn(final int var, final int increment) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitIincInsn(var, increment);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a TABLESWITCH instruction.
&nbsp;   *
&nbsp;   * @param min the minimum key value.
&nbsp;   * @param max the maximum key value.
&nbsp;   * @param dflt beginning of the default handler block.
&nbsp;   * @param labels beginnings of the handler blocks. &lt;tt&gt;labels[i]&lt;/tt&gt; is the beginning of the
&nbsp;   *     handler block for the &lt;tt&gt;min + i&lt;/tt&gt; key.
&nbsp;   */
&nbsp;  public void visitTableSwitchInsn(
&nbsp;      final int min, final int max, final Label dflt, final Label... labels) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitTableSwitchInsn(min, max, dflt, labels);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a LOOKUPSWITCH instruction.
&nbsp;   *
&nbsp;   * @param dflt beginning of the default handler block.
&nbsp;   * @param keys the values of the keys.
&nbsp;   * @param labels beginnings of the handler blocks. &lt;tt&gt;labels[i]&lt;/tt&gt; is the beginning of the
&nbsp;   *     handler block for the &lt;tt&gt;keys[i]&lt;/tt&gt; key.
&nbsp;   */
&nbsp;  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitLookupSwitchInsn(dflt, keys, labels);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a MULTIANEWARRAY instruction.
&nbsp;   *
&nbsp;   * @param descriptor an array type descriptor (see {@link Type}).
&nbsp;   * @param numDimensions the number of dimensions of the array to allocate.
&nbsp;   */
&nbsp;  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitMultiANewArrayInsn(descriptor, numDimensions);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits an annotation on an instruction. This method must be called just &lt;i&gt;after&lt;/i&gt; the
&nbsp;   * annotated instruction. It can be called several times for the same instruction.
&nbsp;   *
&nbsp;   * @param typeRef a reference to the annotated type. The sort of this type reference must be
&nbsp;   *     {@link TypeReference#INSTANCEOF}, {@link TypeReference#NEW}, {@link
&nbsp;   *     TypeReference#CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE}, {@link
&nbsp;   *     TypeReference#CAST}, {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link
&nbsp;   *     TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT}, {@link
&nbsp;   *     TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link
&nbsp;   *     TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.
&nbsp;   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
&nbsp;   *     static inner type within &#39;typeRef&#39;. May be &lt;tt&gt;null&lt;/tt&gt; if the annotation targets
&nbsp;   *     &#39;typeRef&#39; as a whole.
&nbsp;   * @param descriptor the class descriptor of the annotation class.
&nbsp;   * @param visible &lt;tt&gt;true&lt;/tt&gt; if the annotation is visible at runtime.
&nbsp;   * @return a visitor to visit the annotation values, or &lt;tt&gt;null&lt;/tt&gt; if this visitor is not
&nbsp;   *     interested in visiting this annotation.
&nbsp;   */
&nbsp;  public AnnotationVisitor visitInsnAnnotation(
&nbsp;      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
<b class="nc">&nbsp;    if (api &lt; Opcodes.ASM5) {</b>
<b class="nc">&nbsp;      throw new UnsupportedOperationException(REQUIRES_ASM5);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      return mv.visitInsnAnnotation(typeRef, typePath, descriptor, visible);</b>
&nbsp;    }
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;  // Exceptions table entries, debug information, max stack and max locals
&nbsp;  // -----------------------------------------------------------------------------------------------
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a try catch block.
&nbsp;   *
&nbsp;   * @param start the beginning of the exception handler&#39;s scope (inclusive).
&nbsp;   * @param end the end of the exception handler&#39;s scope (exclusive).
&nbsp;   * @param handler the beginning of the exception handler&#39;s code.
&nbsp;   * @param type the internal name of the type of exceptions handled by the handler, or
&nbsp;   *     &lt;tt&gt;null&lt;/tt&gt; to catch any exceptions (for &quot;finally&quot; blocks).
&nbsp;   * @throws IllegalArgumentException if one of the labels has already been visited by this visitor
&nbsp;   *     (by the {@link #visitLabel} method).
&nbsp;   */
&nbsp;  public void visitTryCatchBlock(
&nbsp;      final Label start, final Label end, final Label handler, final String type) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitTryCatchBlock(start, end, handler, type);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits an annotation on an exception handler type. This method must be called &lt;i&gt;after&lt;/i&gt; the
&nbsp;   * {@link #visitTryCatchBlock} for the annotated exception handler. It can be called several times
&nbsp;   * for the same exception handler.
&nbsp;   *
&nbsp;   * @param typeRef a reference to the annotated type. The sort of this type reference must be
&nbsp;   *     {@link TypeReference#EXCEPTION_PARAMETER}. See {@link TypeReference}.
&nbsp;   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
&nbsp;   *     static inner type within &#39;typeRef&#39;. May be &lt;tt&gt;null&lt;/tt&gt; if the annotation targets
&nbsp;   *     &#39;typeRef&#39; as a whole.
&nbsp;   * @param descriptor the class descriptor of the annotation class.
&nbsp;   * @param visible &lt;tt&gt;true&lt;/tt&gt; if the annotation is visible at runtime.
&nbsp;   * @return a visitor to visit the annotation values, or &lt;tt&gt;null&lt;/tt&gt; if this visitor is not
&nbsp;   *     interested in visiting this annotation.
&nbsp;   */
&nbsp;  public AnnotationVisitor visitTryCatchAnnotation(
&nbsp;      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
<b class="nc">&nbsp;    if (api &lt; Opcodes.ASM5) {</b>
<b class="nc">&nbsp;      throw new UnsupportedOperationException(REQUIRES_ASM5);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      return mv.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);</b>
&nbsp;    }
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a local variable declaration.
&nbsp;   *
&nbsp;   * @param name the name of a local variable.
&nbsp;   * @param descriptor the type descriptor of this local variable.
&nbsp;   * @param signature the type signature of this local variable. May be &lt;tt&gt;null&lt;/tt&gt; if the local
&nbsp;   *     variable type does not use generic types.
&nbsp;   * @param start the first instruction corresponding to the scope of this local variable
&nbsp;   *     (inclusive).
&nbsp;   * @param end the last instruction corresponding to the scope of this local variable (exclusive).
&nbsp;   * @param index the local variable&#39;s index.
&nbsp;   * @throws IllegalArgumentException if one of the labels has not already been visited by this
&nbsp;   *     visitor (by the {@link #visitLabel} method).
&nbsp;   */
&nbsp;  public void visitLocalVariable(
&nbsp;      final String name,
&nbsp;      final String descriptor,
&nbsp;      final String signature,
&nbsp;      final Label start,
&nbsp;      final Label end,
&nbsp;      final int index) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitLocalVariable(name, descriptor, signature, start, end, index);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits an annotation on a local variable type.
&nbsp;   *
&nbsp;   * @param typeRef a reference to the annotated type. The sort of this type reference must be
&nbsp;   *     {@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link
&nbsp;   *     TypeReference}.
&nbsp;   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
&nbsp;   *     static inner type within &#39;typeRef&#39;. May be &lt;tt&gt;null&lt;/tt&gt; if the annotation targets
&nbsp;   *     &#39;typeRef&#39; as a whole.
&nbsp;   * @param start the fist instructions corresponding to the continuous ranges that make the scope
&nbsp;   *     of this local variable (inclusive).
&nbsp;   * @param end the last instructions corresponding to the continuous ranges that make the scope of
&nbsp;   *     this local variable (exclusive). This array must have the same size as the &#39;start&#39; array.
&nbsp;   * @param index the local variable&#39;s index in each range. This array must have the same size as
&nbsp;   *     the &#39;start&#39; array.
&nbsp;   * @param descriptor the class descriptor of the annotation class.
&nbsp;   * @param visible &lt;tt&gt;true&lt;/tt&gt; if the annotation is visible at runtime.
&nbsp;   * @return a visitor to visit the annotation values, or &lt;tt&gt;null&lt;/tt&gt; if this visitor is not
&nbsp;   *     interested in visiting this annotation.
&nbsp;   */
&nbsp;  public AnnotationVisitor visitLocalVariableAnnotation(
&nbsp;      final int typeRef,
&nbsp;      final TypePath typePath,
&nbsp;      final Label[] start,
&nbsp;      final Label[] end,
&nbsp;      final int[] index,
&nbsp;      final String descriptor,
&nbsp;      final boolean visible) {
<b class="nc">&nbsp;    if (api &lt; Opcodes.ASM5) {</b>
<b class="nc">&nbsp;      throw new UnsupportedOperationException(REQUIRES_ASM5);</b>
&nbsp;    }
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      return mv.visitLocalVariableAnnotation(</b>
&nbsp;          typeRef, typePath, start, end, index, descriptor, visible);
&nbsp;    }
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits a line number declaration.
&nbsp;   *
&nbsp;   * @param line a line number. This number refers to the source file from which the class was
&nbsp;   *     compiled.
&nbsp;   * @param start the first instruction corresponding to this line number.
&nbsp;   * @throws IllegalArgumentException if &lt;tt&gt;start&lt;/tt&gt; has not already been visited by this visitor
&nbsp;   *     (by the {@link #visitLabel} method).
&nbsp;   */
&nbsp;  public void visitLineNumber(final int line, final Label start) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitLineNumber(line, start);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits the maximum stack size and the maximum number of local variables of the method.
&nbsp;   *
&nbsp;   * @param maxStack maximum stack size of the method.
&nbsp;   * @param maxLocals maximum number of local variables for the method.
&nbsp;   */
&nbsp;  public void visitMaxs(final int maxStack, final int maxLocals) {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitMaxs(maxStack, maxLocals);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Visits the end of the method. This method, which is the last one to be called, is used to
&nbsp;   * inform the visitor that all the annotations and attributes of the method have been visited.
&nbsp;   */
&nbsp;  public void visitEnd() {
<b class="nc">&nbsp;    if (mv != null) {</b>
<b class="nc">&nbsp;      mv.visitEnd();</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
