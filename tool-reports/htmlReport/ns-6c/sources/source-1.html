


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TypePool</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.pool</a>
</div>

<h1>Coverage Summary for Class: TypePool (net.bytebuddy.pool)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">TypePool$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (9/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$AbstractBase$Hierarchical</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (2/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$CacheProvider</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$CacheProvider$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$ClassLoading</td>
<td class="coverageStat">
  <span class="percent">
    71,4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Empty</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Resolution</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    43,5%
  </span>
  <span class="absValue">
    (10/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38,2%
  </span>
  <span class="absValue">
    (21/55)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package net.bytebuddy.pool;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.TypeVariableSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.type.PackageDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.utility.OpenedClassReader;
&nbsp;import net.bytebuddy.jar.asm.*;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureReader;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureVisitor;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.Array;
&nbsp;import java.lang.reflect.GenericSignatureFormatError;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * A type pool allows the retrieval of {@link TypeDescription} by its name.
&nbsp; */
&nbsp;public interface TypePool {
&nbsp;
&nbsp;    /**
&nbsp;     * Locates and describes the given type by its name.
&nbsp;     *
&nbsp;     * @param name The name of the type to describe. The name is to be written as when calling {@link Object#toString()}
&nbsp;     *             on a loaded {@link java.lang.Class}.
&nbsp;     * @return A resolution of the type to describe. If the type to be described was found, the returned
&nbsp;     * {@link net.bytebuddy.pool.TypePool.Resolution} represents this type. Otherwise, an illegal resolution is returned.
&nbsp;     */
&nbsp;    Resolution describe(String name);
&nbsp;
&nbsp;    /**
&nbsp;     * Clears this type pool&#39;s cache.
&nbsp;     */
&nbsp;    void clear();
&nbsp;
&nbsp;    /**
&nbsp;     * A resolution of a {@link net.bytebuddy.pool.TypePool} which was queried for a description.
&nbsp;     */
&nbsp;    interface Resolution {
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if this resolution represents a fully-resolved {@link TypeDescription}.
&nbsp;         *
&nbsp;         * @return {@code true} if the queried type could be resolved.
&nbsp;         */
&nbsp;        boolean isResolved();
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves this resolution to a {@link TypeDescription}. If this resolution is unresolved, this
&nbsp;         * method throws an exception either upon invoking this method or upon invoking at least one method
&nbsp;         * of the returned type description.
&nbsp;         *
&nbsp;         * @return The type description that is represented by this resolution.
&nbsp;         */
&nbsp;        TypeDescription resolve();
&nbsp;
&nbsp;        /**
&nbsp;         * A simple resolution that represents a given {@link TypeDescription}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Simple implements Resolution {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented type description.
&nbsp;             */
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new successful resolution of a given type description.
&nbsp;             *
&nbsp;             * @param typeDescription The represented type description.
&nbsp;             */
&nbsp;            public Simple(TypeDescription typeDescription) {
&nbsp;                this.typeDescription = typeDescription;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isResolved() {
&nbsp;                return true;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription resolve() {
&nbsp;                return typeDescription;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A canonical representation of a non-successful resolution of a {@link net.bytebuddy.pool.TypePool}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Illegal implements Resolution {
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the unresolved type.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new illegal resolution.
&nbsp;             *
&nbsp;             * @param name The name of the unresolved type.
&nbsp;             */
&nbsp;            public Illegal(String name) {
&nbsp;                this.name = name;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isResolved() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription resolve() {
&nbsp;                throw new IllegalStateException(&quot;Cannot resolve type description for &quot; + name);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A cache provider for a {@link net.bytebuddy.pool.TypePool}.
&nbsp;     */
&nbsp;    interface CacheProvider {
&nbsp;
&nbsp;        /**
&nbsp;         * The value that is returned on a cache-miss.
&nbsp;         */
<b class="nc">&nbsp;        Resolution UNRESOLVED = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Attempts to find a resolution in this cache.
&nbsp;         *
&nbsp;         * @param name The name of the type to describe.
&nbsp;         * @return A resolution of the type or {@code null} if no such resolution can be found in the cache..
&nbsp;         */
&nbsp;        Resolution find(String name);
&nbsp;
&nbsp;        /**
&nbsp;         * Registers a resolution in this cache. If a resolution to the given name already exists in the
&nbsp;         * cache, it should be discarded.
&nbsp;         *
&nbsp;         * @param name       The name of the type that is to be registered.
&nbsp;         * @param resolution The resolution to register.
&nbsp;         * @return The oldest version of a resolution that is currently registered in the cache which might
&nbsp;         * be the given resolution or another resolution that was previously registered.
&nbsp;         */
&nbsp;        Resolution register(String name, Resolution resolution);
&nbsp;
&nbsp;        /**
&nbsp;         * Clears this cache.
&nbsp;         */
&nbsp;        void clear();
&nbsp;
&nbsp;        /**
&nbsp;         * A non-operational cache that does not store any type descriptions.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements CacheProvider {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public Resolution find(String name) {
<b class="nc">&nbsp;                return UNRESOLVED;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Resolution register(String name, Resolution resolution) {
<b class="nc">&nbsp;                return resolution;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void clear() {
&nbsp;                /* do nothing */
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A simple, thread-safe type cache based on a {@link java.util.concurrent.ConcurrentHashMap}.
&nbsp;         */
&nbsp;        class Simple implements CacheProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * A map containing all cached resolutions by their names.
&nbsp;             */
&nbsp;            private final ConcurrentMap&lt;String, Resolution&gt; cache;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new simple cache.
&nbsp;             */
&nbsp;            public Simple() {
&nbsp;                cache = new ConcurrentHashMap&lt;String, Resolution&gt;();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a simple cache provider that is prepopulated with the {@link Object} type.
&nbsp;             *
&nbsp;             * @return A simple cache provider that is prepopulated with the {@link Object} type.
&nbsp;             */
&nbsp;            public static CacheProvider withObjectType() {
&nbsp;                CacheProvider cacheProvider = new Simple();
&nbsp;                cacheProvider.register(Object.class.getName(), new Resolution.Simple(TypeDescription.OBJECT));
&nbsp;                return cacheProvider;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Resolution find(String name) {
&nbsp;                return cache.get(name);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Resolution register(String name, Resolution resolution) {
&nbsp;                Resolution cached = cache.putIfAbsent(name, resolution);
&nbsp;                return cached == null
&nbsp;                        ? resolution
&nbsp;                        : cached;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void clear() {
&nbsp;                cache.clear();
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An empty type pool that cannot describe any type.
&nbsp;     */
<b class="fc">&nbsp;    enum Empty implements TypePool {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public Resolution describe(String name) {
<b class="nc">&nbsp;            return new Resolution.Illegal(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void clear() {
&nbsp;            /* do nothing */
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A base implementation of a {@link net.bytebuddy.pool.TypePool} that is managing a cache provider and
&nbsp;     * that handles the description of array and primitive types.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    abstract class AbstractBase implements TypePool {
&nbsp;
&nbsp;        /**
&nbsp;         * A map of primitive types by their name.
&nbsp;         */
&nbsp;        protected static final Map&lt;String, TypeDescription&gt; PRIMITIVE_TYPES;
&nbsp;
&nbsp;        /**
&nbsp;         * A map of primitive types by their descriptor.
&nbsp;         */
&nbsp;        protected static final Map&lt;String, String&gt; PRIMITIVE_DESCRIPTORS;
&nbsp;
&nbsp;        /**
&nbsp;         * The array symbol as used by Java descriptors.
&nbsp;         */
&nbsp;        private static final String ARRAY_SYMBOL = &quot;[&quot;;
&nbsp;
&nbsp;        /*
&nbsp;         * Initializes the maps of primitive type names and descriptors.
&nbsp;         */
&nbsp;        static {
<b class="fc">&nbsp;            Map&lt;String, TypeDescription&gt; primitiveTypes = new HashMap&lt;String, TypeDescription&gt;();</b>
<b class="fc">&nbsp;            Map&lt;String, String&gt; primitiveDescriptors = new HashMap&lt;String, String&gt;();</b>
<b class="fc">&nbsp;            for (Class&lt;?&gt; primitiveType : new Class&lt;?&gt;[]{boolean.class,</b>
&nbsp;                    byte.class,
&nbsp;                    short.class,
&nbsp;                    char.class,
&nbsp;                    int.class,
&nbsp;                    long.class,
&nbsp;                    float.class,
&nbsp;                    double.class,
&nbsp;                    void.class}) {
<b class="fc">&nbsp;                primitiveTypes.put(primitiveType.getName(), TypeDescription.ForLoadedType.of(primitiveType));</b>
<b class="fc">&nbsp;                primitiveDescriptors.put(Type.getDescriptor(primitiveType), primitiveType.getName());</b>
&nbsp;            }
<b class="fc">&nbsp;            PRIMITIVE_TYPES = Collections.unmodifiableMap(primitiveTypes);</b>
<b class="fc">&nbsp;            PRIMITIVE_DESCRIPTORS = Collections.unmodifiableMap(primitiveDescriptors);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The cache provider of this instance.
&nbsp;         */
&nbsp;        protected final CacheProvider cacheProvider;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new instance.
&nbsp;         *
&nbsp;         * @param cacheProvider The cache provider to be used.
&nbsp;         */
<b class="fc">&nbsp;        protected AbstractBase(CacheProvider cacheProvider) {</b>
<b class="fc">&nbsp;            this.cacheProvider = cacheProvider;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Resolution describe(String name) {
<b class="nc">&nbsp;            if (name.contains(&quot;/&quot;)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(name + &quot; contains the illegal character &#39;/&#39;&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            int arity = 0;</b>
<b class="nc">&nbsp;            while (name.startsWith(ARRAY_SYMBOL)) {</b>
<b class="nc">&nbsp;                arity++;</b>
<b class="nc">&nbsp;                name = name.substring(1);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (arity &gt; 0) {</b>
<b class="nc">&nbsp;                String primitiveName = PRIMITIVE_DESCRIPTORS.get(name);</b>
<b class="nc">&nbsp;                name = primitiveName == null</b>
<b class="nc">&nbsp;                        ? name.substring(1, name.length() - 1)</b>
&nbsp;                        : primitiveName;
&nbsp;            }
<b class="nc">&nbsp;            TypeDescription typeDescription = PRIMITIVE_TYPES.get(name);</b>
<b class="nc">&nbsp;            Resolution resolution = typeDescription == null</b>
<b class="nc">&nbsp;                    ? cacheProvider.find(name)</b>
&nbsp;                    : new Resolution.Simple(typeDescription);
<b class="nc">&nbsp;            if (resolution == null) {</b>
<b class="nc">&nbsp;                resolution = doCache(name, doDescribe(name));</b>
&nbsp;            }
<b class="nc">&nbsp;            return ArrayTypeResolution.of(resolution, arity);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Writes the resolution to the cache. This method should be overridden if the directly
&nbsp;         * resolved instance should not be added to the cache.
&nbsp;         *
&nbsp;         * @param name       The name of the type.
&nbsp;         * @param resolution The resolution for this type.
&nbsp;         * @return The actual resolution for the type of this name that is stored in the cache.
&nbsp;         */
&nbsp;        protected Resolution doCache(String name, Resolution resolution) {
<b class="nc">&nbsp;            return cacheProvider.register(name, resolution);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void clear() {
<b class="nc">&nbsp;            cacheProvider.clear();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Determines a resolution to a non-primitive, non-array type.
&nbsp;         *
&nbsp;         * @param name The name of the type to describe.
&nbsp;         * @return A resolution to the type to describe.
&nbsp;         */
&nbsp;        protected abstract Resolution doDescribe(String name);
&nbsp;
&nbsp;        /**
&nbsp;         * Implements a hierarchical view of type pools, similarly to class loader hierarchies. For every lookup, the parent type pool
&nbsp;         * is asked first if it can resolve a type. Only if the parent (and potentially its parents) are unable to resolve a type,
&nbsp;         * this instance is queried for a type description.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        public abstract static class Hierarchical extends AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The parent type pool.
&nbsp;             */
&nbsp;            private final TypePool parent;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a hierarchical type pool.
&nbsp;             *
&nbsp;             * @param cacheProvider The cache provider to be used.
&nbsp;             * @param parent        The parent type pool to be used.
&nbsp;             */
&nbsp;            protected Hierarchical(CacheProvider cacheProvider, TypePool parent) {
<b class="fc">&nbsp;                super(cacheProvider);</b>
<b class="fc">&nbsp;                this.parent = parent;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Resolution describe(String name) {
<b class="nc">&nbsp;                Resolution resolution = parent.describe(name);</b>
<b class="nc">&nbsp;                return resolution.isResolved()</b>
&nbsp;                        ? resolution
<b class="nc">&nbsp;                        : super.describe(name);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void clear() {
&nbsp;                try {
<b class="nc">&nbsp;                    parent.clear();</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    super.clear();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A resolution for a type that, if resolved, represents an array type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class ArrayTypeResolution implements Resolution {
&nbsp;
&nbsp;            /**
&nbsp;             * The underlying resolution that is represented by this instance.
&nbsp;             */
&nbsp;            private final Resolution resolution;
&nbsp;
&nbsp;            /**
&nbsp;             * The arity of the represented array.
&nbsp;             */
&nbsp;            private final int arity;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a wrapper for another resolution that, if resolved, represents an array type.
&nbsp;             *
&nbsp;             * @param resolution The underlying resolution that is represented by this instance.
&nbsp;             * @param arity      The arity of the represented array.
&nbsp;             */
&nbsp;            protected ArrayTypeResolution(Resolution resolution, int arity) {
&nbsp;                this.resolution = resolution;
&nbsp;                this.arity = arity;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a wrapper for another resolution that, if resolved, represents an array type. The wrapper
&nbsp;             * is only created if the arity is not zero. If the arity is zero, the given resolution is simply
&nbsp;             * returned instead.
&nbsp;             *
&nbsp;             * @param resolution The underlying resolution that is represented by this instance.
&nbsp;             * @param arity      The arity of the represented array.
&nbsp;             * @return A wrapper for another resolution that, if resolved, represents an array type or the
&nbsp;             * given resolution if the given arity is zero.
&nbsp;             */
&nbsp;            protected static Resolution of(Resolution resolution, int arity) {
&nbsp;                return arity == 0
&nbsp;                        ? resolution
&nbsp;                        : new ArrayTypeResolution(resolution, arity);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isResolved() {
&nbsp;                return resolution.isResolved();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription resolve() {
&nbsp;                return TypeDescription.ArrayProjection.of(resolution.resolve(), arity);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a nested annotation value.
&nbsp;         */
&nbsp;        protected static class RawAnnotationValue extends AnnotationValue.AbstractBase&lt;AnnotationDescription, Annotation&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The type pool to use for looking up types.
&nbsp;             */
&nbsp;            private final TypePool typePool;
&nbsp;
&nbsp;            /**
&nbsp;             * The annotation token that represents the nested invocation.
&nbsp;             */
&nbsp;            private final Default.LazyTypeDescription.AnnotationToken annotationToken;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new annotation value for a nested annotation.
&nbsp;             *
&nbsp;             * @param typePool        The type pool to use for looking up types.
&nbsp;             * @param annotationToken The token that represents the annotation.
&nbsp;             */
&nbsp;            public RawAnnotationValue(TypePool typePool, Default.LazyTypeDescription.AnnotationToken annotationToken) {
&nbsp;                this.typePool = typePool;
&nbsp;                this.annotationToken = annotationToken;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationDescription resolve() {
&nbsp;                return annotationToken.toAnnotationDescription(typePool).resolve();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            public Loaded&lt;Annotation&gt; load(ClassLoader classLoader) throws ClassNotFoundException {
&nbsp;                Class&lt;?&gt; type = Class.forName(annotationToken.getBinaryName(), false, classLoader);
&nbsp;                if (type.isAnnotation()) {
&nbsp;                    return new ForAnnotationDescription.Loaded&lt;Annotation&gt;(AnnotationDescription.AnnotationInvocationHandler.of(classLoader,
&nbsp;                            (Class&lt;? extends Annotation&gt;) type,
&nbsp;                            annotationToken.getValues()));
&nbsp;                } else {
&nbsp;                    return new ForAnnotationDescription.IncompatibleRuntimeType(type);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
&nbsp;                return this == other || other instanceof AnnotationValue&lt;?, ?&gt; &amp;&amp; resolve().equals(((AnnotationValue&lt;?, ?&gt;) other).resolve());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
&nbsp;                return resolve().hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
&nbsp;                return resolve().toString();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents an enumeration value of an annotation.
&nbsp;         */
&nbsp;        protected static class RawEnumerationValue extends AnnotationValue.AbstractBase&lt;EnumerationDescription, Enum&lt;?&gt;&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The type pool to use for looking up types.
&nbsp;             */
&nbsp;            private final TypePool typePool;
&nbsp;
&nbsp;            /**
&nbsp;             * The descriptor of the enumeration type.
&nbsp;             */
&nbsp;            private final String descriptor;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the enumeration.
&nbsp;             */
&nbsp;            private final String value;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new enumeration value representation.
&nbsp;             *
&nbsp;             * @param typePool   The type pool to use for looking up types.
&nbsp;             * @param descriptor The descriptor of the enumeration type.
&nbsp;             * @param value      The name of the enumeration.
&nbsp;             */
&nbsp;            public RawEnumerationValue(TypePool typePool, String descriptor, String value) {
&nbsp;                this.typePool = typePool;
&nbsp;                this.descriptor = descriptor;
&nbsp;                this.value = value;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public EnumerationDescription resolve() {
&nbsp;                return new LazyEnumerationDescription();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            public Loaded&lt;Enum&lt;?&gt;&gt; load(ClassLoader classLoader) throws ClassNotFoundException {
&nbsp;                Class&lt;?&gt; type = Class.forName(descriptor.substring(1, descriptor.length() - 1).replace(&#39;/&#39;, &#39;.&#39;), false, classLoader);
&nbsp;                try {
&nbsp;                    return type.isEnum()
&nbsp;                            ? new ForEnumerationDescription.Loaded(Enum.valueOf((Class) type, value))
&nbsp;                            : new ForEnumerationDescription.IncompatibleRuntimeType(type);
&nbsp;                } catch (IllegalArgumentException ignored) {
&nbsp;                    return new ForEnumerationDescription.UnknownRuntimeEnumeration((Class) type, value);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
&nbsp;                return this == other || other instanceof AnnotationValue&lt;?, ?&gt; &amp;&amp; resolve().equals(((AnnotationValue&lt;?, ?&gt;) other).resolve());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
&nbsp;                return resolve().hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
&nbsp;                return resolve().toString();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An enumeration description where any type references are only resolved on demand.
&nbsp;             */
&nbsp;            protected class LazyEnumerationDescription extends EnumerationDescription.AbstractBase {
&nbsp;
&nbsp;                @Override
&nbsp;                public String getValue() {
&nbsp;                    return value;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription getEnumerationType() {
&nbsp;                    return typePool.describe(descriptor.substring(1, descriptor.length() - 1).replace(&#39;/&#39;, &#39;.&#39;)).resolve();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public &lt;T extends Enum&lt;T&gt;&gt; T load(Class&lt;T&gt; type) {
&nbsp;                    return Enum.valueOf(type, value);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a type value of an annotation.
&nbsp;         */
&nbsp;        protected static class RawTypeValue extends AnnotationValue.AbstractBase&lt;TypeDescription, Class&lt;?&gt;&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * A convenience reference indicating that a loaded type should not be initialized.
&nbsp;             */
&nbsp;            private static final boolean NO_INITIALIZATION = false;
&nbsp;
&nbsp;            /**
&nbsp;             * The type pool to use for looking up types.
&nbsp;             */
&nbsp;            private final TypePool typePool;
&nbsp;
&nbsp;            /**
&nbsp;             * The binary name of the type.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a type value of an annotation.
&nbsp;             *
&nbsp;             * @param typePool The type pool to use for looking up types.
&nbsp;             * @param type     A type representation of the type that is referenced by the annotation..
&nbsp;             */
&nbsp;            protected RawTypeValue(TypePool typePool, Type type) {
&nbsp;                this.typePool = typePool;
&nbsp;                name = type.getSort() == Type.ARRAY
&nbsp;                        ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;)
&nbsp;                        : type.getClassName();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription resolve() {
&nbsp;                return typePool.describe(name).resolve();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationValue.Loaded&lt;Class&lt;?&gt;&gt; load(ClassLoader classLoader) throws ClassNotFoundException {
&nbsp;                return new Loaded(Class.forName(name, NO_INITIALIZATION, classLoader));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
&nbsp;                return this == other || other instanceof AnnotationValue&lt;?, ?&gt; &amp;&amp; resolve().equals(((AnnotationValue&lt;?, ?&gt;) other).resolve());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
&nbsp;                return resolve().hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
&nbsp;                return RenderingDispatcher.CURRENT.toSourceString(resolve());
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a loaded annotation property that represents a type.
&nbsp;             */
&nbsp;            protected static class Loaded extends AnnotationValue.Loaded.AbstractBase&lt;Class&lt;?&gt;&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type that is represented by an annotation property.
&nbsp;                 */
&nbsp;                private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new representation for an annotation property referencing a type.
&nbsp;                 *
&nbsp;                 * @param type The type that is represented by an annotation property.
&nbsp;                 */
&nbsp;                public Loaded(Class&lt;?&gt; type) {
&nbsp;                    this.type = type;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public State getState() {
&nbsp;                    return State.RESOLVED;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Class&lt;?&gt; resolve() {
&nbsp;                    return type;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean represents(Object value) {
&nbsp;                    return type.equals(value);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean equals(Object other) {
&nbsp;                    if (this == other) {
&nbsp;                        return true;
&nbsp;                    } else if (!(other instanceof AnnotationValue.Loaded&lt;?&gt;)) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                    AnnotationValue.Loaded&lt;?&gt; annotationValue = (AnnotationValue.Loaded&lt;?&gt;) other;
&nbsp;                    return annotationValue.getState().isResolved() &amp;&amp; type.equals(annotationValue.resolve());
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int hashCode() {
&nbsp;                    return type.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String toString() {
&nbsp;                    return RenderingDispatcher.CURRENT.toSourceString(TypeDescription.ForLoadedType.of(type));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents an array that is referenced by an annotation which does not contain primitive values or {@link String}s.
&nbsp;         */
&nbsp;        protected static class RawDescriptionArray extends AnnotationValue.AbstractBase&lt;Object[], Object[]&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The type pool to use for looking up types.
&nbsp;             */
&nbsp;            private final TypePool typePool;
&nbsp;
&nbsp;            /**
&nbsp;             * A reference to the component type.
&nbsp;             */
&nbsp;            private final ComponentTypeReference componentTypeReference;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of all values of this array value in their order.
&nbsp;             */
&nbsp;            private List&lt;AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new array value representation of a complex array.
&nbsp;             *
&nbsp;             * @param typePool               The type pool to use for looking up types.
&nbsp;             * @param componentTypeReference A lazy reference to the component type of this array.
&nbsp;             * @param values                 A list of all values of this annotation.
&nbsp;             */
&nbsp;            public RawDescriptionArray(TypePool typePool,
&nbsp;                                       ComponentTypeReference componentTypeReference,
&nbsp;                                       List&lt;AnnotationValue&lt;?, ?&gt;&gt; values) {
&nbsp;                this.typePool = typePool;
&nbsp;                this.values = values;
&nbsp;                this.componentTypeReference = componentTypeReference;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Object[] resolve() {
&nbsp;                TypeDescription componentTypeDescription = typePool.describe(componentTypeReference.lookup()).resolve();
&nbsp;                Class&lt;?&gt; componentType;
&nbsp;                if (componentTypeDescription.represents(Class.class)) {
&nbsp;                    componentType = TypeDescription.class;
&nbsp;                } else if (componentTypeDescription.isAssignableTo(Enum.class)) { // Enums can implement annotation interfaces, check this first.
&nbsp;                    componentType = EnumerationDescription.class;
&nbsp;                } else if (componentTypeDescription.isAssignableTo(Annotation.class)) {
&nbsp;                    componentType = AnnotationDescription.class;
&nbsp;                } else if (componentTypeDescription.represents(String.class)) {
&nbsp;                    componentType = String.class;
&nbsp;                } else {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected complex array component type &quot; + componentTypeDescription);
&nbsp;                }
&nbsp;                Object[] array = (Object[]) Array.newInstance(componentType, values.size());
&nbsp;                int index = 0;
&nbsp;                for (AnnotationValue&lt;?, ?&gt; annotationValue : values) {
&nbsp;                    Array.set(array, index++, annotationValue.resolve());
&nbsp;                }
&nbsp;                return array;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationValue.Loaded&lt;Object[]&gt; load(ClassLoader classLoader) throws ClassNotFoundException {
&nbsp;                List&lt;AnnotationValue.Loaded&lt;?&gt;&gt; loadedValues = new ArrayList&lt;AnnotationValue.Loaded&lt;?&gt;&gt;(values.size());
&nbsp;                for (AnnotationValue&lt;?, ?&gt; value : values) {
&nbsp;                    loadedValues.add(value.load(classLoader));
&nbsp;                }
&nbsp;                return new Loaded(Class.forName(componentTypeReference.lookup(), false, classLoader), loadedValues);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof AnnotationValue&lt;?, ?&gt;)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;                Object value = ((AnnotationValue&lt;?, ?&gt;) other).resolve();
&nbsp;                return value instanceof Object[] &amp;&amp; Arrays.equals(resolve(), (Object[]) value);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
&nbsp;                return Arrays.hashCode(resolve());
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
&nbsp;                return RenderingDispatcher.CURRENT.toSourceString(values);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy representation of the component type of an array.
&nbsp;             */
&nbsp;            public interface ComponentTypeReference {
&nbsp;
&nbsp;                /**
&nbsp;                 * Lazily returns the binary name of the array component type of an annotation value.
&nbsp;                 *
&nbsp;                 * @return The binary name of the component type.
&nbsp;                 */
&nbsp;                String lookup();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a loaded annotation property representing a complex array.
&nbsp;             */
&nbsp;            protected static class Loaded extends AnnotationValue.Loaded.AbstractBase&lt;Object[]&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The array&#39;s loaded component type.
&nbsp;                 */
&nbsp;                private final Class&lt;?&gt; componentType;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of loaded values of the represented complex array.
&nbsp;                 */
&nbsp;                private final List&lt;AnnotationValue.Loaded&lt;?&gt;&gt; values;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new representation of an annotation property representing an array of
&nbsp;                 * non-trivial values.
&nbsp;                 *
&nbsp;                 * @param componentType The array&#39;s loaded component type.
&nbsp;                 * @param values        A list of loaded values of the represented complex array.
&nbsp;                 */
&nbsp;                public Loaded(Class&lt;?&gt; componentType, List&lt;AnnotationValue.Loaded&lt;?&gt;&gt; values) {
&nbsp;                    this.componentType = componentType;
&nbsp;                    this.values = values;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public State getState() {
&nbsp;                    for (AnnotationValue.Loaded&lt;?&gt; value : values) {
&nbsp;                        if (!value.getState().isResolved()) {
&nbsp;                            return State.UNRESOLVED;
&nbsp;                        }
&nbsp;                    }
&nbsp;                    return State.RESOLVED;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Object[] resolve() {
&nbsp;                    Object[] array = (Object[]) Array.newInstance(componentType, values.size());
&nbsp;                    int index = 0;
&nbsp;                    for (AnnotationValue.Loaded&lt;?&gt; annotationValue : values) {
&nbsp;                        Array.set(array, index++, annotationValue.resolve());
&nbsp;                    }
&nbsp;                    return array;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean represents(Object value) {
&nbsp;                    if (!(value instanceof Object[])) return false;
&nbsp;                    if (value.getClass().getComponentType() != componentType) return false;
&nbsp;                    Object[] array = (Object[]) value;
&nbsp;                    if (values.size() != array.length) return false;
&nbsp;                    Iterator&lt;AnnotationValue.Loaded&lt;?&gt;&gt; iterator = values.iterator();
&nbsp;                    for (Object aValue : array) {
&nbsp;                        AnnotationValue.Loaded&lt;?&gt; self = iterator.next();
&nbsp;                        if (!self.getState().isResolved() || !self.represents(aValue)) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean equals(Object other) {
&nbsp;                    if (this == other) {
&nbsp;                        return true;
&nbsp;                    } else if (!(other instanceof AnnotationValue.Loaded&lt;?&gt;)) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                    AnnotationValue.Loaded&lt;?&gt; annotationValue = (AnnotationValue.Loaded&lt;?&gt;) other;
&nbsp;                    if (!annotationValue.getState().isResolved()) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                    Object value = annotationValue.resolve();
&nbsp;                    if (!(value instanceof Object[])) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                    Object[] arrayValue = (Object[]) value;
&nbsp;                    if (values.size() != arrayValue.length) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                    Iterator&lt;AnnotationValue.Loaded&lt;?&gt;&gt; iterator = values.iterator();
&nbsp;                    for (Object aValue : arrayValue) {
&nbsp;                        AnnotationValue.Loaded&lt;?&gt; self = iterator.next();
&nbsp;                        if (!self.resolve().equals(aValue)) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int hashCode() {
&nbsp;                    int result = 1;
&nbsp;                    for (AnnotationValue.Loaded&lt;?&gt; value : values) {
&nbsp;                        result = 31 * result + value.hashCode();
&nbsp;                    }
&nbsp;                    return result;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String toString() {
&nbsp;                    return RenderingDispatcher.CURRENT.toSourceString(values);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A default implementation of a {@link net.bytebuddy.pool.TypePool} that models binary data in the Java byte code format
&nbsp;     * into a {@link TypeDescription}. The data lookup is delegated to a {@link net.bytebuddy.dynamic.ClassFileLocator}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * {@link Resolution}s that are produced by this type pool are either fully resolved or not resolved at all.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Default extends AbstractBase.Hierarchical {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that a visited method should be ignored.
&nbsp;         */
&nbsp;        private static final MethodVisitor IGNORE_METHOD = null;
&nbsp;
&nbsp;        /**
&nbsp;         * The locator to query for finding binary data of a type.
&nbsp;         */
&nbsp;        protected final ClassFileLocator classFileLocator;
&nbsp;
&nbsp;        /**
&nbsp;         * The reader mode to apply by this default type pool.
&nbsp;         */
&nbsp;        protected final ReaderMode readerMode;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new default type pool without a parent pool.
&nbsp;         *
&nbsp;         * @param cacheProvider    The cache provider to be used.
&nbsp;         * @param classFileLocator The class file locator to be used.
&nbsp;         * @param readerMode       The reader mode to apply by this default type pool.
&nbsp;         */
&nbsp;        public Default(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode) {
&nbsp;            this(cacheProvider, classFileLocator, readerMode, Empty.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new default type pool.
&nbsp;         *
&nbsp;         * @param cacheProvider    The cache provider to be used.
&nbsp;         * @param classFileLocator The class file locator to be used.
&nbsp;         * @param readerMode       The reader mode to apply by this default type pool.
&nbsp;         * @param parentPool       The parent type pool.
&nbsp;         */
&nbsp;        public Default(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode, TypePool parentPool) {
&nbsp;            super(cacheProvider, parentPool);
&nbsp;            this.classFileLocator = classFileLocator;
&nbsp;            this.readerMode = readerMode;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a default {@link net.bytebuddy.pool.TypePool} that looks up data by querying the system class
&nbsp;         * loader. The returned instance is configured to use a fast reading mode and a simple cache.
&nbsp;         *
&nbsp;         * @return A type pool that reads its data from the system class path.
&nbsp;         */
&nbsp;        public static TypePool ofClassPath() {
&nbsp;            return of(ClassFileLocator.ForClassLoader.ofClassPath());
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a type pool for the provided class loader.
&nbsp;         *
&nbsp;         * @param classLoader The class loader for which this class pool is representing types.
&nbsp;         * @return An appropriate type pool.
&nbsp;         */
&nbsp;        public static TypePool of(ClassLoader classLoader) {
&nbsp;            return of(ClassFileLocator.ForClassLoader.of(classLoader));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a default {@link net.bytebuddy.pool.TypePool} that looks up data by querying the supplied class
&nbsp;         * file locator. The returned instance is configured to use a fast reading mode and a simple cache.
&nbsp;         *
&nbsp;         * @param classFileLocator The class file locator to use.
&nbsp;         * @return A type pool that reads its data from the system class path.
&nbsp;         */
&nbsp;        public static TypePool of(ClassFileLocator classFileLocator) {
&nbsp;            return new Default(new CacheProvider.Simple(), classFileLocator, ReaderMode.FAST);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected Resolution doDescribe(String name) {
&nbsp;            try {
&nbsp;                ClassFileLocator.Resolution resolution = classFileLocator.locate(name);
&nbsp;                return resolution.isResolved()
&nbsp;                        ? new Resolution.Simple(parse(resolution.resolve()))
&nbsp;                        : new Resolution.Illegal(name);
&nbsp;            } catch (IOException exception) {
&nbsp;                throw new IllegalStateException(&quot;Error while reading class file&quot;, exception);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Parses a binary representation and transforms it into a type description.
&nbsp;         *
&nbsp;         * @param binaryRepresentation The binary data to be parsed.
&nbsp;         * @return A type description of the binary data.
&nbsp;         */
&nbsp;        private TypeDescription parse(byte[] binaryRepresentation) {
&nbsp;            ClassReader classReader = OpenedClassReader.of(binaryRepresentation);
&nbsp;            TypeExtractor typeExtractor = new TypeExtractor();
&nbsp;            classReader.accept(typeExtractor, readerMode.getFlags());
&nbsp;            return typeExtractor.toTypeDescription();
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the granularity of the class file parsing that is conducted by a {@link net.bytebuddy.pool.TypePool.Default}.
&nbsp;         */
&nbsp;        public enum ReaderMode {
&nbsp;
&nbsp;            /**
&nbsp;             * The extended reader mode parses the code segment of each method in order to detect parameter names
&nbsp;             * that are only stored in a method&#39;s debugging information but are not explicitly included.
&nbsp;             */
&nbsp;            EXTENDED(ClassReader.SKIP_FRAMES),
&nbsp;
&nbsp;            /**
&nbsp;             * The fast reader mode skips the code segment of each method and cannot detect parameter names that are
&nbsp;             * only contained within the debugging information. This mode still detects explicitly included method
&nbsp;             * parameter names.
&nbsp;             */
&nbsp;            FAST(ClassReader.SKIP_CODE);
&nbsp;
&nbsp;            /**
&nbsp;             * The flags to provide to a {@link ClassReader} for parsing a file.
&nbsp;             */
&nbsp;            private final int flags;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new reader mode constant.
&nbsp;             *
&nbsp;             * @param flags The flags to provide to a {@link ClassReader} for parsing a file.
&nbsp;             */
&nbsp;            ReaderMode(int flags) {
&nbsp;                this.flags = flags;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the flags to provide to a {@link ClassReader} for parsing a file.
&nbsp;             *
&nbsp;             * @return The flags to provide to a {@link ClassReader} for parsing a file.
&nbsp;             */
&nbsp;            protected int getFlags() {
&nbsp;                return flags;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if this reader mode represents extended reading.
&nbsp;             *
&nbsp;             * @return {@code true} if this reader mode represents extended reading.
&nbsp;             */
&nbsp;            public boolean isExtended() {
&nbsp;                return this == EXTENDED;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * A variant of {@link TypePool.Default} that resolves type descriptions lazily. A lazy resolution respects this type
&nbsp;         * pool&#39;s {@link CacheProvider} but requeries this cache pool for every access of a property of a {@link TypeDescription}.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * {@link Resolution}s of this type pool are only fully resolved if a property that is not the type&#39;s name is required.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        public static class WithLazyResolution extends Default {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default type pool with lazy resolution and without a parent pool.
&nbsp;             *
&nbsp;             * @param cacheProvider    The cache provider to be used.
&nbsp;             * @param classFileLocator The class file locator to be used.
&nbsp;             * @param readerMode       The reader mode to apply by this default type pool.
&nbsp;             */
&nbsp;            public WithLazyResolution(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode) {
&nbsp;                this(cacheProvider, classFileLocator, readerMode, Empty.INSTANCE);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default type pool with lazy resolution.
&nbsp;             *
&nbsp;             * @param cacheProvider    The cache provider to be used.
&nbsp;             * @param classFileLocator The class file locator to be used.
&nbsp;             * @param readerMode       The reader mode to apply by this default type pool.
&nbsp;             * @param parentPool       The parent type pool.
&nbsp;             */
&nbsp;            public WithLazyResolution(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode, TypePool parentPool) {
&nbsp;                super(cacheProvider, classFileLocator, readerMode, parentPool);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a default {@link net.bytebuddy.pool.TypePool} with lazy resolution that looks up data by querying the system class
&nbsp;             * loader. The returned instance is configured to use a fast reading mode and a simple cache.
&nbsp;             *
&nbsp;             * @return A type pool that reads its data from the system class path.
&nbsp;             */
&nbsp;            public static TypePool ofClassPath() {
&nbsp;                return of(ClassFileLocator.ForClassLoader.ofClassPath());
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a default {@link TypePool} with lazy resolution for the provided class loader.
&nbsp;             *
&nbsp;             * @param classLoader The class loader for which this class pool is representing types.
&nbsp;             * @return An appropriate type pool.
&nbsp;             */
&nbsp;            public static TypePool of(ClassLoader classLoader) {
&nbsp;                return of(ClassFileLocator.ForClassLoader.of(classLoader));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a default {@link net.bytebuddy.pool.TypePool} with lazy resolution that looks up data by querying the supplied class
&nbsp;             * file locator. The returned instance is configured to use a fast reading mode and a simple cache.
&nbsp;             *
&nbsp;             * @param classFileLocator The class file locator to use.
&nbsp;             * @return A type pool that reads its data from the system class path.
&nbsp;             */
&nbsp;            public static TypePool of(ClassFileLocator classFileLocator) {
&nbsp;                return new WithLazyResolution(new CacheProvider.Simple(), classFileLocator, ReaderMode.FAST);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Resolution doDescribe(String name) {
&nbsp;                return new LazyResolution(name);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Resolution doCache(String name, Resolution resolution) {
&nbsp;                return resolution;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Non-lazily resolves a type name.
&nbsp;             *
&nbsp;             * @param name The name of the type to resolve.
&nbsp;             * @return The resolution for the type of this name.
&nbsp;             */
&nbsp;            protected Resolution doResolve(String name) {
&nbsp;                Resolution resolution = cacheProvider.find(name);
&nbsp;                if (resolution == null) {
&nbsp;                    resolution = cacheProvider.register(name, WithLazyResolution.super.doDescribe(name));
&nbsp;                }
&nbsp;                return resolution;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy resolution of a type that the enclosing type pool attempts to resolve.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;            protected class LazyResolution implements Resolution {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s name.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy resolution.
&nbsp;                 *
&nbsp;                 * @param name The type&#39;s name.
&nbsp;                 */
&nbsp;                protected LazyResolution(String name) {
&nbsp;                    this.name = name;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isResolved() {
&nbsp;                    return doResolve(name).isResolved();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription resolve() {
&nbsp;                    return new LazyTypeDescription(name);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy type description that resolves any property that is not the name only when requested.
&nbsp;             */
&nbsp;            protected class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s name.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy type description.
&nbsp;                 *
&nbsp;                 * @param name The type&#39;s name.
&nbsp;                 */
&nbsp;                protected LazyTypeDescription(String name) {
&nbsp;                    this.name = name;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getName() {
&nbsp;                    return name;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected TypeDescription delegate() {
&nbsp;                    return doResolve(name).resolve();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An annotation registrant implements a visitor pattern for reading an unknown amount of values of annotations.
&nbsp;         */
&nbsp;        protected interface AnnotationRegistrant {
&nbsp;
&nbsp;            /**
&nbsp;             * Registers an annotation value.
&nbsp;             *
&nbsp;             * @param name            The name of the annotation value.
&nbsp;             * @param annotationValue The value of the annotation.
&nbsp;             */
&nbsp;            void register(String name, AnnotationValue&lt;?, ?&gt; annotationValue);
&nbsp;
&nbsp;            /**
&nbsp;             * Called once all annotation values are visited.
&nbsp;             */
&nbsp;            void onComplete();
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract base implementation of an annotation registrant.
&nbsp;             */
&nbsp;            abstract class AbstractBase implements AnnotationRegistrant {
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation descriptor.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The values that were collected so far.
&nbsp;                 */
&nbsp;                private final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation registrant.
&nbsp;                 *
&nbsp;                 * @param descriptor The annotation descriptor.
&nbsp;                 */
&nbsp;                protected AbstractBase(String descriptor) {
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    values = new HashMap&lt;String, AnnotationValue&lt;?, ?&gt;&gt;();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void register(String name, AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                    values.put(name, annotationValue);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onComplete() {
&nbsp;                    getTokens().add(new LazyTypeDescription.AnnotationToken(descriptor, values));
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the token list for this collector.
&nbsp;                 *
&nbsp;                 * @return The token list for this collector.
&nbsp;                 */
&nbsp;                protected abstract List&lt;LazyTypeDescription.AnnotationToken&gt; getTokens();
&nbsp;
&nbsp;                /**
&nbsp;                 * A base implementation for a collector for a type variable.
&nbsp;                 */
&nbsp;                protected abstract static class ForTypeVariable extends AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type variable&#39;s type path.
&nbsp;                     */
&nbsp;                    private final String typePath;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation collector.
&nbsp;                     *
&nbsp;                     * @param descriptor The annotation descriptor.
&nbsp;                     * @param typePath   The type variable&#39;s type path.
&nbsp;                     */
&nbsp;                    protected ForTypeVariable(String descriptor, TypePath typePath) {
&nbsp;                        super(descriptor);
&nbsp;                        this.typePath = typePath == null
&nbsp;                                ? LazyTypeDescription.GenericTypeToken.EMPTY_TYPE_PATH
&nbsp;                                : typePath.toString();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected List&lt;LazyTypeDescription.AnnotationToken&gt; getTokens() {
&nbsp;                        Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; pathMap = getPathMap();
&nbsp;                        List&lt;LazyTypeDescription.AnnotationToken&gt; tokens = pathMap.get(typePath);
&nbsp;                        if (tokens == null) {
&nbsp;                            tokens = new ArrayList&lt;LazyTypeDescription.AnnotationToken&gt;();
&nbsp;                            pathMap.put(typePath, tokens);
&nbsp;                        }
&nbsp;                        return tokens;
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns this collector&#39;s path map.
&nbsp;                     *
&nbsp;                     * @return This collector&#39;s path map.
&nbsp;                     */
&nbsp;                    protected abstract Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; getPathMap();
&nbsp;
&nbsp;                    /**
&nbsp;                     * A base implementation for a collector for a type variable with an index.
&nbsp;                     */
&nbsp;                    protected abstract static class WithIndex extends AbstractBase.ForTypeVariable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable&#39;s index.
&nbsp;                         */
&nbsp;                        private final int index;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation collector.
&nbsp;                         *
&nbsp;                         * @param descriptor The annotation descriptor.
&nbsp;                         * @param typePath   The type variable&#39;s type path.
&nbsp;                         * @param index      The type variable&#39;s index.
&nbsp;                         */
&nbsp;                        protected WithIndex(String descriptor, TypePath typePath, int index) {
&nbsp;                            super(descriptor, typePath);
&nbsp;                            this.index = index;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; getPathMap() {
&nbsp;                            Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; indexedPathMap = getIndexedPathMap();
&nbsp;                            Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; pathMap = indexedPathMap.get(index);
&nbsp;                            if (pathMap == null) {
&nbsp;                                pathMap = new HashMap&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;();
&nbsp;                                indexedPathMap.put(index, pathMap);
&nbsp;                            }
&nbsp;                            return pathMap;
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Returns this collector&#39;s indexed path map.
&nbsp;                         *
&nbsp;                         * @return This collector&#39;s indexed path map.
&nbsp;                         */
&nbsp;                        protected abstract Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; getIndexedPathMap();
&nbsp;
&nbsp;                        /**
&nbsp;                         * A base implementation for a collector for a type variable with two indices.
&nbsp;                         */
&nbsp;                        protected abstract static class DoubleIndexed extends WithIndex {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable&#39;s first index.
&nbsp;                             */
&nbsp;                            private final int preIndex;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new annotation collector.
&nbsp;                             *
&nbsp;                             * @param descriptor The annotation descriptor.
&nbsp;                             * @param typePath   The type variable&#39;s type path.
&nbsp;                             * @param index      The type variable&#39;s index.
&nbsp;                             * @param preIndex   The type variable&#39;s first index.
&nbsp;                             */
&nbsp;                            protected DoubleIndexed(String descriptor, TypePath typePath, int index, int preIndex) {
&nbsp;                                super(descriptor, typePath, index);
&nbsp;                                this.preIndex = preIndex;
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            protected Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; getIndexedPathMap() {
&nbsp;                                Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; doubleIndexPathMap = getDoubleIndexedPathMap();
&nbsp;                                Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; indexedPathMap = doubleIndexPathMap.get(preIndex);
&nbsp;                                if (indexedPathMap == null) {
&nbsp;                                    indexedPathMap = new HashMap&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;();
&nbsp;                                    doubleIndexPathMap.put(preIndex, indexedPathMap);
&nbsp;                                }
&nbsp;                                return indexedPathMap;
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Returns this collector&#39;s double indexed path map.
&nbsp;                             *
&nbsp;                             * @return This collector&#39;s double indexed path map.
&nbsp;                             */
&nbsp;                            protected abstract Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; getDoubleIndexedPathMap();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An annotation collector for a byte code element.
&nbsp;             */
&nbsp;            class ForByteCodeElement extends AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The target collection.
&nbsp;                 */
&nbsp;                private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation collector for a byte code element.
&nbsp;                 *
&nbsp;                 * @param descriptor       The annotation descriptor.
&nbsp;                 * @param annotationTokens The target collection.
&nbsp;                 */
&nbsp;                protected ForByteCodeElement(String descriptor, List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens) {
&nbsp;                    super(descriptor);
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected List&lt;LazyTypeDescription.AnnotationToken&gt; getTokens() {
&nbsp;                    return annotationTokens;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An annotation collector for a byte code element with an index.
&nbsp;                 */
&nbsp;                public static class WithIndex extends AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The byte code element&#39;s index.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The target collection.
&nbsp;                     */
&nbsp;                    private final Map&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation collector for a byte code element with an index.
&nbsp;                     *
&nbsp;                     * @param descriptor       The annotation descriptor.
&nbsp;                     * @param index            The byte code element&#39;s index.
&nbsp;                     * @param annotationTokens The target collection.
&nbsp;                     */
&nbsp;                    protected WithIndex(String descriptor, int index, Map&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        super(descriptor);
&nbsp;                        this.index = index;
&nbsp;                        this.annotationTokens = annotationTokens;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected List&lt;LazyTypeDescription.AnnotationToken&gt; getTokens() {
&nbsp;                        List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens = this.annotationTokens.get(index);
&nbsp;                        if (annotationTokens == null) {
&nbsp;                            annotationTokens = new ArrayList&lt;LazyTypeDescription.AnnotationToken&gt;();
&nbsp;                            this.annotationTokens.put(index, annotationTokens);
&nbsp;                        }
&nbsp;                        return annotationTokens;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An annotation collector for a type variable.
&nbsp;             */
&nbsp;            class ForTypeVariable extends AbstractBase.ForTypeVariable {
&nbsp;
&nbsp;                /**
&nbsp;                 * The target collection.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; pathMap;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation collector.
&nbsp;                 *
&nbsp;                 * @param descriptor The annotation descriptor.
&nbsp;                 * @param typePath   The type variable&#39;s type path.
&nbsp;                 * @param pathMap    The target collection.
&nbsp;                 */
&nbsp;                protected ForTypeVariable(String descriptor, TypePath typePath, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; pathMap) {
&nbsp;                    super(descriptor, typePath);
&nbsp;                    this.pathMap = pathMap;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; getPathMap() {
&nbsp;                    return pathMap;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An annotation collector for a type variable with an index.
&nbsp;                 */
&nbsp;                public static class WithIndex extends AbstractBase.ForTypeVariable.WithIndex {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The target collection.
&nbsp;                     */
&nbsp;                    private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; indexedPathMap;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation collector.
&nbsp;                     *
&nbsp;                     * @param descriptor     The annotation descriptor.
&nbsp;                     * @param typePath       The type variable&#39;s type path.
&nbsp;                     * @param index          The target index.
&nbsp;                     * @param indexedPathMap The target collection.
&nbsp;                     */
&nbsp;                    protected WithIndex(String descriptor,
&nbsp;                                        TypePath typePath,
&nbsp;                                        int index,
&nbsp;                                        Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; indexedPathMap) {
&nbsp;                        super(descriptor, typePath, index);
&nbsp;                        this.indexedPathMap = indexedPathMap;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; getIndexedPathMap() {
&nbsp;                        return indexedPathMap;
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotation collector for a type variable with two indices.
&nbsp;                     */
&nbsp;                    public static class DoubleIndexed extends AbstractBase.ForTypeVariable.WithIndex.DoubleIndexed {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The target collection.
&nbsp;                         */
&nbsp;                        private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; doubleIndexedPathMap;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation collector.
&nbsp;                         *
&nbsp;                         * @param descriptor           The annotation descriptor.
&nbsp;                         * @param typePath             The type variable&#39;s type path.
&nbsp;                         * @param index                The target index.
&nbsp;                         * @param preIndex             The initial target index.
&nbsp;                         * @param doubleIndexedPathMap The target collection.
&nbsp;                         */
&nbsp;                        protected DoubleIndexed(String descriptor,
&nbsp;                                                TypePath typePath,
&nbsp;                                                int index,
&nbsp;                                                int preIndex,
&nbsp;                                                Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; doubleIndexedPathMap) {
&nbsp;                            super(descriptor, typePath, index, preIndex);
&nbsp;                            this.doubleIndexedPathMap = doubleIndexedPathMap;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; getDoubleIndexedPathMap() {
&nbsp;                            return doubleIndexedPathMap;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A component type locator allows for the lazy location of an array&#39;s component type.
&nbsp;         */
&nbsp;        protected interface ComponentTypeLocator {
&nbsp;
&nbsp;            /**
&nbsp;             * Binds this component type to a given property name of an annotation.
&nbsp;             *
&nbsp;             * @param name The name of an annotation property which the returned component type reference should
&nbsp;             *             query for resolving an array&#39;s component type.
&nbsp;             * @return A component type reference to an annotation value&#39;s component type.
&nbsp;             */
&nbsp;            RawDescriptionArray.ComponentTypeReference bind(String name);
&nbsp;
&nbsp;            /**
&nbsp;             * A component type locator which cannot legally resolve an array&#39;s component type.
&nbsp;             */
&nbsp;            enum Illegal implements ComponentTypeLocator {
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                @Override
&nbsp;                public RawDescriptionArray.ComponentTypeReference bind(String name) {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected lookup of component type for &quot; + name);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A component type locator that lazily analyses an annotation for resolving an annotation property&#39;s
&nbsp;             * array value&#39;s component type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForAnnotationProperty implements ComponentTypeLocator {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type pool to query for type descriptions.
&nbsp;                 */
&nbsp;                private final TypePool typePool;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the annotation to analyze.
&nbsp;                 */
&nbsp;                private final String annotationName;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new component type locator for an array value.
&nbsp;                 *
&nbsp;                 * @param typePool             The type pool to be used for looking up linked types.
&nbsp;                 * @param annotationDescriptor A descriptor of the annotation to analyze.
&nbsp;                 */
&nbsp;                public ForAnnotationProperty(TypePool typePool, String annotationDescriptor) {
&nbsp;                    this.typePool = typePool;
&nbsp;                    annotationName = annotationDescriptor.substring(1, annotationDescriptor.length() - 1).replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public RawDescriptionArray.ComponentTypeReference bind(String name) {
&nbsp;                    return new Bound(name);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A bound representation of a
&nbsp;                 * {@link net.bytebuddy.pool.TypePool.Default.ComponentTypeLocator.ForAnnotationProperty}.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class Bound implements RawDescriptionArray.ComponentTypeReference {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the annotation property.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new bound component type locator for an annotation property.
&nbsp;                     *
&nbsp;                     * @param name The name of the annotation property.
&nbsp;                     */
&nbsp;                    protected Bound(String name) {
&nbsp;                        this.name = name;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String lookup() {
&nbsp;                        return typePool.describe(annotationName)
&nbsp;                                .resolve()
&nbsp;                                .getDeclaredMethods()
&nbsp;                                .filter(named(name))
&nbsp;                                .getOnly()
&nbsp;                                .getReturnType()
&nbsp;                                .asErasure()
&nbsp;                                .getComponentType()
&nbsp;                                .getName();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A component type locator that locates an array type by a method&#39;s return value from its method descriptor.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForArrayType implements ComponentTypeLocator, RawDescriptionArray.ComponentTypeReference {
&nbsp;
&nbsp;                /**
&nbsp;                 * The resolved component type&#39;s binary name.
&nbsp;                 */
&nbsp;                private final String componentType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new component type locator for an array type.
&nbsp;                 *
&nbsp;                 * @param methodDescriptor The method descriptor to resolve.
&nbsp;                 */
&nbsp;                public ForArrayType(String methodDescriptor) {
&nbsp;                    String arrayType = Type.getMethodType(methodDescriptor).getReturnType().getClassName();
&nbsp;                    componentType = arrayType.substring(0, arrayType.length() - 2);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public RawDescriptionArray.ComponentTypeReference bind(String name) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String lookup() {
&nbsp;                    return componentType;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type registrant allows to register a generic type token.
&nbsp;         */
&nbsp;        protected interface GenericTypeRegistrant {
&nbsp;
&nbsp;            /**
&nbsp;             * Registers a discovered generic type token.
&nbsp;             *
&nbsp;             * @param token The token to be registered.
&nbsp;             */
&nbsp;            void register(LazyTypeDescription.GenericTypeToken token);
&nbsp;
&nbsp;            /**
&nbsp;             * A signature visitor that rejects any discovered generic type.
&nbsp;             */
&nbsp;            class RejectingSignatureVisitor extends SignatureVisitor {
&nbsp;
&nbsp;                /**
&nbsp;                 * The message of the error message.
&nbsp;                 */
&nbsp;                private static final String MESSAGE = &quot;Unexpected token in generic signature&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new rejecting signature visitor.
&nbsp;                 */
&nbsp;                public RejectingSignatureVisitor() {
&nbsp;                    super(OpenedClassReader.ASM_API);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitFormalTypeParameter(String name) {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor visitClassBound() {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor visitInterfaceBound() {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor visitSuperclass() {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor visitInterface() {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor visitParameterType() {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor visitReturnType() {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor visitExceptionType() {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitBaseType(char descriptor) {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitTypeVariable(String name) {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor visitArrayType() {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitClassType(String name) {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitInnerClassType(String name) {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitTypeArgument() {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor visitTypeArgument(char wildcard) {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitEnd() {
&nbsp;                    throw new IllegalStateException(MESSAGE);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A bag for collecting parameter meta information that is stored as debug information for implemented
&nbsp;         * methods.
&nbsp;         */
&nbsp;        protected static class ParameterBag {
&nbsp;
&nbsp;            /**
&nbsp;             * An array of the method&#39;s parameter types.
&nbsp;             */
&nbsp;            private final Type[] parameterType;
&nbsp;
&nbsp;            /**
&nbsp;             * A map containing the tokens that were collected until now.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, String&gt; parameterRegistry;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new bag.
&nbsp;             *
&nbsp;             * @param parameterType An array of parameter types for the method on which this parameter bag
&nbsp;             *                      is used.
&nbsp;             */
&nbsp;            protected ParameterBag(Type[] parameterType) {
&nbsp;                this.parameterType = parameterType;
&nbsp;                parameterRegistry = new HashMap&lt;Integer, String&gt;();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Registers a new parameter.
&nbsp;             *
&nbsp;             * @param offset The offset of the registered entry on the local variable array of the method.
&nbsp;             * @param name   The name of the parameter.
&nbsp;             */
&nbsp;            protected void register(int offset, String name) {
&nbsp;                parameterRegistry.put(offset, name);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the collected parameters as a list of parameter tokens.
&nbsp;             *
&nbsp;             * @param isStatic {@code true} if the analyzed method is static.
&nbsp;             * @return A list of parameter tokens based on the collected information.
&nbsp;             */
&nbsp;            protected List&lt;LazyTypeDescription.MethodToken.ParameterToken&gt; resolve(boolean isStatic) {
&nbsp;                List&lt;LazyTypeDescription.MethodToken.ParameterToken&gt; parameterTokens = new ArrayList&lt;LazyTypeDescription.MethodToken.ParameterToken&gt;(parameterType.length);
&nbsp;                int offset = isStatic
&nbsp;                        ? StackSize.ZERO.getSize()
&nbsp;                        : StackSize.SINGLE.getSize();
&nbsp;                for (Type aParameterType : parameterType) {
&nbsp;                    String name = this.parameterRegistry.get(offset);
&nbsp;                    parameterTokens.add(name == null
&nbsp;                            ? new LazyTypeDescription.MethodToken.ParameterToken()
&nbsp;                            : new LazyTypeDescription.MethodToken.ParameterToken(name));
&nbsp;                    offset += aParameterType.getSize();
&nbsp;                }
&nbsp;                return parameterTokens;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A generic type extractor allows for an iterative extraction of generic type information.
&nbsp;         */
&nbsp;        protected static class GenericTypeExtractor extends GenericTypeRegistrant.RejectingSignatureVisitor implements GenericTypeRegistrant {
&nbsp;
&nbsp;            /**
&nbsp;             * A registrant that receives any discovered type.
&nbsp;             */
&nbsp;            private final GenericTypeRegistrant genericTypeRegistrant;
&nbsp;
&nbsp;            /**
&nbsp;             * The current token that is in the process of creation.
&nbsp;             */
&nbsp;            private IncompleteToken incompleteToken;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new generic type extractor.
&nbsp;             *
&nbsp;             * @param genericTypeRegistrant The target to receive the complete type.
&nbsp;             */
&nbsp;            protected GenericTypeExtractor(GenericTypeRegistrant genericTypeRegistrant) {
&nbsp;                this.genericTypeRegistrant = genericTypeRegistrant;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitBaseType(char descriptor) {
&nbsp;                genericTypeRegistrant.register(LazyTypeDescription.GenericTypeToken.ForPrimitiveType.of(descriptor));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitTypeVariable(String name) {
&nbsp;                genericTypeRegistrant.register(new LazyTypeDescription.GenericTypeToken.ForTypeVariable(name));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public SignatureVisitor visitArrayType() {
&nbsp;                return new GenericTypeExtractor(this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void register(LazyTypeDescription.GenericTypeToken componentTypeToken) {
&nbsp;                genericTypeRegistrant.register(new LazyTypeDescription.GenericTypeToken.ForGenericArray(componentTypeToken));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitClassType(String name) {
&nbsp;                incompleteToken = new IncompleteToken.ForTopLevelType(name);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitInnerClassType(String name) {
&nbsp;                incompleteToken = new IncompleteToken.ForInnerClass(name, incompleteToken);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitTypeArgument() {
&nbsp;                incompleteToken.appendPlaceholder();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public SignatureVisitor visitTypeArgument(char wildcard) {
&nbsp;                switch (wildcard) {
&nbsp;                    case SignatureVisitor.SUPER:
&nbsp;                        return incompleteToken.appendLowerBound();
&nbsp;                    case SignatureVisitor.EXTENDS:
&nbsp;                        return incompleteToken.appendUpperBound();
&nbsp;                    case SignatureVisitor.INSTANCEOF:
&nbsp;                        return incompleteToken.appendDirectBound();
&nbsp;                    default:
&nbsp;                        throw new IllegalArgumentException(&quot;Unknown wildcard: &quot; + wildcard);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitEnd() {
&nbsp;                genericTypeRegistrant.register(incompleteToken.toToken());
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An incomplete {@link LazyTypeDescription.GenericTypeToken}.
&nbsp;             */
&nbsp;            protected interface IncompleteToken {
&nbsp;
&nbsp;                /**
&nbsp;                 * Appends a lower bound to this token.
&nbsp;                 *
&nbsp;                 * @return A signature visitor for visiting the lower bound&#39;s type.
&nbsp;                 */
&nbsp;                SignatureVisitor appendLowerBound();
&nbsp;
&nbsp;                /**
&nbsp;                 * Appends an upper bound to this token.
&nbsp;                 *
&nbsp;                 * @return A signature visitor for visiting the upper bound&#39;s type.
&nbsp;                 */
&nbsp;                SignatureVisitor appendUpperBound();
&nbsp;
&nbsp;                /**
&nbsp;                 * Appends a direct bound to this token.
&nbsp;                 *
&nbsp;                 * @return A signature visitor for visiting the direct bound&#39;s type.
&nbsp;                 */
&nbsp;                SignatureVisitor appendDirectBound();
&nbsp;
&nbsp;                /**
&nbsp;                 * Appends a placeholder to this token.
&nbsp;                 */
&nbsp;                void appendPlaceholder();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns {@code true} if this token describes a type with parameters.
&nbsp;                 *
&nbsp;                 * @return {@code true} if this token describes a type with parameters.
&nbsp;                 */
&nbsp;                boolean isParameterized();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the name of this token.
&nbsp;                 *
&nbsp;                 * @return The name of this token.
&nbsp;                 */
&nbsp;                String getName();
&nbsp;
&nbsp;                /**
&nbsp;                 * Converts this incomplete token to a completed token.
&nbsp;                 *
&nbsp;                 * @return The finalized token.
&nbsp;                 */
&nbsp;                LazyTypeDescription.GenericTypeToken toToken();
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation of an incomplete token.
&nbsp;                 */
&nbsp;                abstract class AbstractBase implements IncompleteToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The parameters of this token.
&nbsp;                     */
&nbsp;                    protected final List&lt;LazyTypeDescription.GenericTypeToken&gt; parameters;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new base implementation of an incomplete token.
&nbsp;                     */
&nbsp;                    public AbstractBase() {
&nbsp;                        parameters = new ArrayList&lt;LazyTypeDescription.GenericTypeToken&gt;();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor appendDirectBound() {
&nbsp;                        return new GenericTypeExtractor(new ForDirectBound());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor appendUpperBound() {
&nbsp;                        return new GenericTypeExtractor(new ForUpperBound());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor appendLowerBound() {
&nbsp;                        return new GenericTypeExtractor(new ForLowerBound());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void appendPlaceholder() {
&nbsp;                        parameters.add(LazyTypeDescription.GenericTypeToken.ForUnboundWildcard.INSTANCE);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token for registering a direct bound.
&nbsp;                     */
&nbsp;                    protected class ForDirectBound implements GenericTypeRegistrant {
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            parameters.add(token);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token for registering a wildcard with an upper bound.
&nbsp;                     */
&nbsp;                    protected class ForUpperBound implements GenericTypeRegistrant {
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            parameters.add(new LazyTypeDescription.GenericTypeToken.ForUpperBoundWildcard(token));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token for registering a wildcard with a lower bound.
&nbsp;                     */
&nbsp;                    protected class ForLowerBound implements GenericTypeRegistrant {
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            parameters.add(new LazyTypeDescription.GenericTypeToken.ForLowerBoundWildcard(token));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An incomplete token representing a generic type without an outer type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForTopLevelType extends AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The internal name of the type.
&nbsp;                     */
&nbsp;                    private final String internalName;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new incomplete token representing a type without an outer type.
&nbsp;                     *
&nbsp;                     * @param internalName The internal name of the type.
&nbsp;                     */
&nbsp;                    public ForTopLevelType(String internalName) {
&nbsp;                        this.internalName = internalName;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public LazyTypeDescription.GenericTypeToken toToken() {
&nbsp;                        return isParameterized()
&nbsp;                                ? new LazyTypeDescription.GenericTypeToken.ForParameterizedType(getName(), parameters)
&nbsp;                                : new LazyTypeDescription.GenericTypeToken.ForRawType(getName());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isParameterized() {
&nbsp;                        return !parameters.isEmpty();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getName() {
&nbsp;                        return internalName.replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An incomplete generic type token representing a type with an outer type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForInnerClass extends AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The separator that indicates an inner type.
&nbsp;                     */
&nbsp;                    private static final char INNER_CLASS_SEPARATOR = &#39;$&#39;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The internal name of the type.
&nbsp;                     */
&nbsp;                    private final String internalName;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The token representing the outer type.
&nbsp;                     */
&nbsp;                    private final IncompleteToken outerTypeToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new incomplete token representing a type without an outer type.
&nbsp;                     *
&nbsp;                     * @param internalName   The internal name of the type.
&nbsp;                     * @param outerTypeToken The incomplete token representing the outer type.
&nbsp;                     */
&nbsp;                    public ForInnerClass(String internalName, IncompleteToken outerTypeToken) {
&nbsp;                        this.internalName = internalName;
&nbsp;                        this.outerTypeToken = outerTypeToken;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public LazyTypeDescription.GenericTypeToken toToken() {
&nbsp;                        return isParameterized() || outerTypeToken.isParameterized()
&nbsp;                                ? new LazyTypeDescription.GenericTypeToken.ForParameterizedType.Nested(getName(), parameters, outerTypeToken.toToken())
&nbsp;                                : new LazyTypeDescription.GenericTypeToken.ForRawType(getName());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isParameterized() {
&nbsp;                        return !parameters.isEmpty() || !outerTypeToken.isParameterized();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getName() {
&nbsp;                        return outerTypeToken.getName() + INNER_CLASS_SEPARATOR + internalName.replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A signature visitor for extracting a generic type resolution.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The type of the resolution this visitor extracts.
&nbsp;             */
&nbsp;            protected abstract static class ForSignature&lt;T extends LazyTypeDescription.GenericTypeToken.Resolution&gt;
&nbsp;                    extends RejectingSignatureVisitor
&nbsp;                    implements GenericTypeRegistrant {
&nbsp;
&nbsp;                /**
&nbsp;                 * The resolved type variable tokens.
&nbsp;                 */
&nbsp;                protected final List&lt;LazyTypeDescription.GenericTypeToken.OfFormalTypeVariable&gt; typeVariableTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the currently constructed type.
&nbsp;                 */
&nbsp;                protected String currentTypeParameter;
&nbsp;
&nbsp;                /**
&nbsp;                 * The bounds of the currently constructed type.
&nbsp;                 */
&nbsp;                protected List&lt;LazyTypeDescription.GenericTypeToken&gt; currentBounds;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new signature visitor.
&nbsp;                 */
&nbsp;                public ForSignature() {
&nbsp;                    typeVariableTokens = new ArrayList&lt;LazyTypeDescription.GenericTypeToken.OfFormalTypeVariable&gt;();
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Applies an extraction of a generic signature given the supplied visitor.
&nbsp;                 *
&nbsp;                 * @param genericSignature The generic signature to interpret.
&nbsp;                 * @param visitor          The visitor to apply.
&nbsp;                 * @param &lt;S&gt;              The type of the generated resolution.
&nbsp;                 * @return The resolution of the supplied signature.
&nbsp;                 */
&nbsp;                protected static &lt;S extends LazyTypeDescription.GenericTypeToken.Resolution&gt; S extract(String genericSignature, ForSignature&lt;S&gt; visitor) {
&nbsp;                    SignatureReader signatureReader = new SignatureReader(genericSignature);
&nbsp;                    signatureReader.accept(visitor);
&nbsp;                    return visitor.resolve();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitFormalTypeParameter(String name) {
&nbsp;                    collectTypeParameter();
&nbsp;                    currentTypeParameter = name;
&nbsp;                    currentBounds = new ArrayList&lt;LazyTypeDescription.GenericTypeToken&gt;();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor visitClassBound() {
&nbsp;                    return new GenericTypeExtractor(this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public SignatureVisitor visitInterfaceBound() {
&nbsp;                    return new GenericTypeExtractor(this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                    if (currentBounds == null) {
&nbsp;                        throw new IllegalStateException(&quot;Did not expect &quot; + token + &quot; before finding formal parameter&quot;);
&nbsp;                    }
&nbsp;                    currentBounds.add(token);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Collects the currently constructed type.
&nbsp;                 */
&nbsp;                protected void collectTypeParameter() {
&nbsp;                    if (currentTypeParameter != null) {
&nbsp;                        typeVariableTokens.add(new LazyTypeDescription.GenericTypeToken.ForTypeVariable.Formal(currentTypeParameter, currentBounds));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Completes the current resolution.
&nbsp;                 *
&nbsp;                 * @return The resolved generic signature.
&nbsp;                 */
&nbsp;                public abstract T resolve();
&nbsp;
&nbsp;                /**
&nbsp;                 * A parser for a generic type signature.
&nbsp;                 */
&nbsp;                protected static class OfType extends ForSignature&lt;LazyTypeDescription.GenericTypeToken.Resolution.ForType&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The interface type&#39;s generic signatures.
&nbsp;                     */
&nbsp;                    private final List&lt;LazyTypeDescription.GenericTypeToken&gt; interfaceTypeTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The super type&#39;s generic signature.
&nbsp;                     */
&nbsp;                    private LazyTypeDescription.GenericTypeToken superClassToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new parser for a type signature.
&nbsp;                     */
&nbsp;                    protected OfType() {
&nbsp;                        interfaceTypeTokens = new ArrayList&lt;LazyTypeDescription.GenericTypeToken&gt;();
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Extracts a generic type resolution of a type signature.
&nbsp;                     *
&nbsp;                     * @param genericSignature The signature to interpret.
&nbsp;                     * @return The interpreted type signature.
&nbsp;                     */
&nbsp;                    public static LazyTypeDescription.GenericTypeToken.Resolution.ForType extract(String genericSignature) {
&nbsp;                        try {
&nbsp;                            return genericSignature == null
&nbsp;                                    ? LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE
&nbsp;                                    : ForSignature.extract(genericSignature, new OfType());
&nbsp;                        } catch (RuntimeException ignored) {
&nbsp;                            return LazyTypeDescription.GenericTypeToken.Resolution.Malformed.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor visitSuperclass() {
&nbsp;                        collectTypeParameter();
&nbsp;                        return new GenericTypeExtractor(new SuperClassRegistrant());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor visitInterface() {
&nbsp;                        return new GenericTypeExtractor(new InterfaceTypeRegistrant());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public LazyTypeDescription.GenericTypeToken.Resolution.ForType resolve() {
&nbsp;                        return new LazyTypeDescription.GenericTypeToken.Resolution.ForType.Tokenized(superClassToken, interfaceTypeTokens, typeVariableTokens);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A registrant for the super type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class SuperClassRegistrant implements GenericTypeRegistrant {
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            superClassToken = token;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A registrant for the interface types.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class InterfaceTypeRegistrant implements GenericTypeRegistrant {
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            interfaceTypeTokens.add(token);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A parser for a generic method signature.
&nbsp;                 */
&nbsp;                protected static class OfMethod extends ForSignature&lt;LazyTypeDescription.GenericTypeToken.Resolution.ForMethod&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic parameter types.
&nbsp;                     */
&nbsp;                    private final List&lt;LazyTypeDescription.GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic exception types.
&nbsp;                     */
&nbsp;                    private final List&lt;LazyTypeDescription.GenericTypeToken&gt; exceptionTypeTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic return type.
&nbsp;                     */
&nbsp;                    private LazyTypeDescription.GenericTypeToken returnTypeToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a parser for a generic method signature.
&nbsp;                     */
&nbsp;                    public OfMethod() {
&nbsp;                        parameterTypeTokens = new ArrayList&lt;LazyTypeDescription.GenericTypeToken&gt;();
&nbsp;                        exceptionTypeTokens = new ArrayList&lt;LazyTypeDescription.GenericTypeToken&gt;();
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Extracts a generic method resolution of a method signature.
&nbsp;                     *
&nbsp;                     * @param genericSignature The signature to interpret.
&nbsp;                     * @return The interpreted method signature.
&nbsp;                     */
&nbsp;                    public static LazyTypeDescription.GenericTypeToken.Resolution.ForMethod extract(String genericSignature) {
&nbsp;                        try {
&nbsp;                            return genericSignature == null
&nbsp;                                    ? LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE
&nbsp;                                    : ForSignature.extract(genericSignature, new OfMethod());
&nbsp;                        } catch (RuntimeException ignored) {
&nbsp;                            return LazyTypeDescription.GenericTypeToken.Resolution.Malformed.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor visitParameterType() {
&nbsp;                        return new GenericTypeExtractor(new ParameterTypeRegistrant());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor visitReturnType() {
&nbsp;                        collectTypeParameter();
&nbsp;                        return new GenericTypeExtractor(new ReturnTypeTypeRegistrant());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public SignatureVisitor visitExceptionType() {
&nbsp;                        return new GenericTypeExtractor(new ExceptionTypeRegistrant());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public LazyTypeDescription.GenericTypeToken.Resolution.ForMethod resolve() {
&nbsp;                        return new LazyTypeDescription.GenericTypeToken.Resolution.ForMethod.Tokenized(returnTypeToken,
&nbsp;                                parameterTypeTokens,
&nbsp;                                exceptionTypeTokens,
&nbsp;                                typeVariableTokens);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A registrant for a parameter type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class ParameterTypeRegistrant implements GenericTypeRegistrant {
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            parameterTypeTokens.add(token);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A registrant for a return type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class ReturnTypeTypeRegistrant implements GenericTypeRegistrant {
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            returnTypeToken = token;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A registrant for an exception type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class ExceptionTypeRegistrant implements GenericTypeRegistrant {
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                            exceptionTypeTokens.add(token);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A parser for a generic field signature.
&nbsp;                 */
&nbsp;                protected static class OfField implements GenericTypeRegistrant {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic field type.
&nbsp;                     */
&nbsp;                    private LazyTypeDescription.GenericTypeToken fieldTypeToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Extracts a generic field resolution of a field signature.
&nbsp;                     *
&nbsp;                     * @param genericSignature The signature to interpret.
&nbsp;                     * @return The interpreted field signature.
&nbsp;                     */
&nbsp;                    public static LazyTypeDescription.GenericTypeToken.Resolution.ForField extract(String genericSignature) {
&nbsp;                        if (genericSignature == null) {
&nbsp;                            return LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE;
&nbsp;                        } else {
&nbsp;                            SignatureReader signatureReader = new SignatureReader(genericSignature);
&nbsp;                            OfField visitor = new OfField();
&nbsp;                            try {
&nbsp;                                signatureReader.acceptType(new GenericTypeExtractor(visitor));
&nbsp;                                return visitor.resolve();
&nbsp;                            } catch (RuntimeException ignored) {
&nbsp;                                return LazyTypeDescription.GenericTypeToken.Resolution.Malformed.INSTANCE;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void register(LazyTypeDescription.GenericTypeToken token) {
&nbsp;                        fieldTypeToken = token;
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Completes the current resolution.
&nbsp;                     *
&nbsp;                     * @return The resolved generic signature.
&nbsp;                     */
&nbsp;                    protected LazyTypeDescription.GenericTypeToken.Resolution.ForField resolve() {
&nbsp;                        return new LazyTypeDescription.GenericTypeToken.Resolution.ForField.Tokenized(fieldTypeToken);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type description that looks up any referenced {@link net.bytebuddy.description.ByteCodeElement} or
&nbsp;         * {@link AnnotationDescription} by querying a type pool at lookup time.
&nbsp;         */
&nbsp;        protected static class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType {
&nbsp;
&nbsp;            /**
&nbsp;             * The index of a super class&#39;s type annotations.
&nbsp;             */
&nbsp;            private static final int SUPER_CLASS_INDEX = -1;
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a type does not exist and does therefore not have a name.
&nbsp;             */
&nbsp;            private static final String NO_TYPE = null;
&nbsp;
&nbsp;            /**
&nbsp;             * The type pool to be used for looking up linked types.
&nbsp;             */
&nbsp;            private final TypePool typePool;
&nbsp;
&nbsp;            /**
&nbsp;             * The actual modifiers of this type.
&nbsp;             */
&nbsp;            private final int actualModifiers;
&nbsp;
&nbsp;            /**
&nbsp;             * The modifiers of this type.
&nbsp;             */
&nbsp;            private final int modifiers;
&nbsp;
&nbsp;            /**
&nbsp;             * The binary name of this type.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * The type&#39;s super type&#39;s descriptor or {@code null} if this type does not define a super type.
&nbsp;             */
&nbsp;            private final String superClassDescriptor;
&nbsp;
&nbsp;            /**
&nbsp;             * The type&#39;s generic signature as found in the class file or {@code null} if the type is not generic.
&nbsp;             */
&nbsp;            private final String genericSignature;
&nbsp;
&nbsp;            /**
&nbsp;             * The resolution of this type&#39;s generic type.
&nbsp;             */
&nbsp;            private final GenericTypeToken.Resolution.ForType signatureResolution;
&nbsp;
&nbsp;            /**
&nbsp;             * The descriptor of this type&#39;s interfaces.
&nbsp;             */
&nbsp;            private final List&lt;String&gt; interfaceTypeDescriptors;
&nbsp;
&nbsp;            /**
&nbsp;             * A definition of this type&#39;s containment within another type or method.
&nbsp;             */
&nbsp;            private final TypeContainment typeContainment;
&nbsp;
&nbsp;            /**
&nbsp;             * The binary name of this type&#39;s declaring type or {@code null} if no such type exists.
&nbsp;             */
&nbsp;            private final String declaringTypeName;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of descriptors representing the types that are declared by this type.
&nbsp;             */
&nbsp;            private final List&lt;String&gt; declaredTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this type is an anonymous type.
&nbsp;             */
&nbsp;            private final boolean anonymousType;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of type annotations for this type&#39;s super type and interface types by their indices.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; superTypeAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of type annotations of the type variables&#39; type annotations by their indices.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of type annotations of the type variables&#39; bounds&#39; type annotations by their indices and each variable&#39;s index.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundsAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of tokens that represent the annotations of this type.
&nbsp;             */
&nbsp;            private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of field tokens describing the field&#39;s of this type.
&nbsp;             */
&nbsp;            private final List&lt;FieldToken&gt; fieldTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of method tokens describing the method&#39;s of this type.
&nbsp;             */
&nbsp;            private final List&lt;MethodToken&gt; methodTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new lazy type description.
&nbsp;             *
&nbsp;             * @param typePool                           The type pool to be used for looking up linked types.
&nbsp;             * @param actualModifiers                    The actual modifiers of this type.
&nbsp;             * @param modifiers                          The modifiers of this type.
&nbsp;             * @param name                               The binary name of this type.
&nbsp;             * @param superClassInternalName             The internal name of this type&#39;s super type or {@code null} if no such super type is defined.
&nbsp;             * @param interfaceInternalName              An array of this type&#39;s interfaces or {@code null} if this type does not define any interfaces.
&nbsp;             * @param genericSignature                   The type&#39;s generic signature as found in the class file or {@code null} if the type is not generic.
&nbsp;             * @param typeContainment                    A definition of this type&#39;s containment within another type or method.
&nbsp;             * @param declaringTypeInternalName          The internal name of this type&#39;s declaring type or {@code null} if no such type exists.
&nbsp;             * @param declaredTypes                      A list of descriptors representing the types that are declared by this type.
&nbsp;             * @param anonymousType                      {@code true} if this type is an anonymous type.
&nbsp;             * @param superTypeAnnotationTokens          A mapping of type annotations for this type&#39;s super type and interface types by their indices.
&nbsp;             * @param typeVariableAnnotationTokens       A mapping of type annotations of the type variables&#39; type annotations by their indices.
&nbsp;             * @param typeVariableBoundsAnnotationTokens A mapping of type annotations of the type variables&#39; bounds&#39; type annotations by their indices
&nbsp;             *                                           and each variable&#39;s index.
&nbsp;             * @param annotationTokens                   A list of tokens that represent the annotations of this type.
&nbsp;             * @param fieldTokens                        A list of field tokens describing the field&#39;s of this type.
&nbsp;             * @param methodTokens                       A list of method tokens describing the method&#39;s of this type.
&nbsp;             */
&nbsp;            protected LazyTypeDescription(TypePool typePool,
&nbsp;                                          int actualModifiers,
&nbsp;                                          int modifiers,
&nbsp;                                          String name,
&nbsp;                                          String superClassInternalName,
&nbsp;                                          String[] interfaceInternalName,
&nbsp;                                          String genericSignature,
&nbsp;                                          TypeContainment typeContainment,
&nbsp;                                          String declaringTypeInternalName,
&nbsp;                                          List&lt;String&gt; declaredTypes,
&nbsp;                                          boolean anonymousType,
&nbsp;                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; superTypeAnnotationTokens,
&nbsp;                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens,
&nbsp;                                          Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundsAnnotationTokens,
&nbsp;                                          List&lt;AnnotationToken&gt; annotationTokens,
&nbsp;                                          List&lt;FieldToken&gt; fieldTokens,
&nbsp;                                          List&lt;MethodToken&gt; methodTokens) {
&nbsp;                this.typePool = typePool;
&nbsp;                this.actualModifiers = actualModifiers &amp; ~Opcodes.ACC_SUPER;
&nbsp;                this.modifiers = modifiers &amp; ~(Opcodes.ACC_SUPER | Opcodes.ACC_DEPRECATED);
&nbsp;                this.name = Type.getObjectType(name).getClassName();
&nbsp;                this.superClassDescriptor = superClassInternalName == null
&nbsp;                        ? NO_TYPE
&nbsp;                        : Type.getObjectType(superClassInternalName).getDescriptor();
&nbsp;                this.genericSignature = genericSignature;
&nbsp;                signatureResolution = RAW_TYPES
&nbsp;                        ? GenericTypeToken.Resolution.Raw.INSTANCE
&nbsp;                        : GenericTypeExtractor.ForSignature.OfType.extract(genericSignature);
&nbsp;                if (interfaceInternalName == null) {
&nbsp;                    interfaceTypeDescriptors = Collections.emptyList();
&nbsp;                } else {
&nbsp;                    interfaceTypeDescriptors = new ArrayList&lt;String&gt;(interfaceInternalName.length);
&nbsp;                    for (String internalName : interfaceInternalName) {
&nbsp;                        interfaceTypeDescriptors.add(Type.getObjectType(internalName).getDescriptor());
&nbsp;                    }
&nbsp;                }
&nbsp;                this.typeContainment = typeContainment;
&nbsp;                declaringTypeName = declaringTypeInternalName == null
&nbsp;                        ? NO_TYPE
&nbsp;                        : declaringTypeInternalName.replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                this.declaredTypes = declaredTypes;
&nbsp;                this.anonymousType = anonymousType;
&nbsp;                this.superTypeAnnotationTokens = superTypeAnnotationTokens;
&nbsp;                this.typeVariableAnnotationTokens = typeVariableAnnotationTokens;
&nbsp;                this.typeVariableBoundsAnnotationTokens = typeVariableBoundsAnnotationTokens;
&nbsp;                this.annotationTokens = annotationTokens;
&nbsp;                this.fieldTokens = fieldTokens;
&nbsp;                this.methodTokens = methodTokens;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Generic getSuperClass() {
&nbsp;                return superClassDescriptor == null || isInterface()
&nbsp;                        ? Generic.UNDEFINED
&nbsp;                        : signatureResolution.resolveSuperClass(superClassDescriptor, typePool, superTypeAnnotationTokens.get(SUPER_CLASS_INDEX), this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                return signatureResolution.resolveInterfaceTypes(interfaceTypeDescriptors, typePool, superTypeAnnotationTokens, this);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodDescription getEnclosingMethod() {
&nbsp;                return typeContainment.getEnclosingMethod(typePool);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription getEnclosingType() {
&nbsp;                return typeContainment.getEnclosingType(typePool);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList getDeclaredTypes() {
&nbsp;                return new LazyTypeList(typePool, declaredTypes);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isAnonymousClass() {
&nbsp;                return anonymousType;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isLocalClass() {
&nbsp;                return !anonymousType &amp;&amp; typeContainment.isLocalType();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isMemberClass() {
&nbsp;                return typeContainment.isMemberClass();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;                return new FieldTokenList();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;                return new MethodTokenList();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public PackageDescription getPackage() {
&nbsp;                String name = getName();
&nbsp;                int index = name.lastIndexOf(&#39;.&#39;);
&nbsp;                return new LazyPackageDescription(typePool, index == -1
&nbsp;                        ? EMPTY_NAME
&nbsp;                        : name.substring(0, index));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getName() {
&nbsp;                return name;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription getDeclaringType() {
&nbsp;                return declaringTypeName == null
&nbsp;                        ? TypeDescription.UNDEFINED
&nbsp;                        : typePool.describe(declaringTypeName).resolve();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int getModifiers() {
&nbsp;                return modifiers;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int getActualModifiers(boolean superFlag) {
&nbsp;                return superFlag ? (actualModifiers | Opcodes.ACC_SUPER) : actualModifiers;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationList getDeclaredAnnotations() {
&nbsp;                return LazyAnnotationDescription.asList(typePool, annotationTokens);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeList.Generic getTypeVariables() {
&nbsp;                return signatureResolution.resolveTypeVariables(typePool, this, typeVariableAnnotationTokens, typeVariableBoundsAnnotationTokens);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getGenericSignature() {
&nbsp;                return genericSignature;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A list of field tokens representing each entry as a field description.
&nbsp;             */
&nbsp;            protected class FieldTokenList extends FieldList.AbstractBase&lt;FieldDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;                @Override
&nbsp;                public FieldDescription.InDefinedShape get(int index) {
&nbsp;                    return fieldTokens.get(index).toFieldDescription(LazyTypeDescription.this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int size() {
&nbsp;                    return fieldTokens.size();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A list of method tokens representing each entry as a method description.
&nbsp;             */
&nbsp;            protected class MethodTokenList extends MethodList.AbstractBase&lt;MethodDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;                @Override
&nbsp;                public MethodDescription.InDefinedShape get(int index) {
&nbsp;                    return methodTokens.get(index).toMethodDescription(LazyTypeDescription.this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int size() {
&nbsp;                    return methodTokens.size();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A declaration context encapsulates information about whether a type was declared within another type
&nbsp;             * or within a method of another type.
&nbsp;             */
&nbsp;            protected interface TypeContainment {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the enclosing method or {@code null} if no such method exists.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to be used for looking up linked types.
&nbsp;                 * @return A method description describing the linked type or {@code null}.
&nbsp;                 */
&nbsp;                MethodDescription getEnclosingMethod(TypePool typePool);
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the enclosing type or {@code null} if no such type exists.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to be used for looking up linked types.
&nbsp;                 * @return A type description describing the linked type or {@code null}.
&nbsp;                 */
&nbsp;                TypeDescription getEnclosingType(TypePool typePool);
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns {@code true} if the type is self-contained.
&nbsp;                 *
&nbsp;                 * @return {@code true} if the type is self-contained.
&nbsp;                 */
&nbsp;                boolean isSelfContained();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns {@code true} if the type is a member type.
&nbsp;                 *
&nbsp;                 * @return {@code true} if the type is a member type.
&nbsp;                 */
&nbsp;                boolean isMemberClass();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns {@code true} if the type is a local type unless it is an anonymous type.
&nbsp;                 *
&nbsp;                 * @return {@code true} if the type is a local type unless it is an anonymous type
&nbsp;                 */
&nbsp;                boolean isLocalType();
&nbsp;
&nbsp;                /**
&nbsp;                 * Describes a type that is not contained within another type, a method or a constructor.
&nbsp;                 */
&nbsp;                enum SelfContained implements TypeContainment {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDescription getEnclosingMethod(TypePool typePool) {
&nbsp;                        return MethodDescription.UNDEFINED;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeDescription getEnclosingType(TypePool typePool) {
&nbsp;                        return TypeDescription.UNDEFINED;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isSelfContained() {
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isMemberClass() {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isLocalType() {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Describes a type that is contained within another type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class WithinType implements TypeContainment {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type&#39;s binary name.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if the type is a local type unless it is an anonymous type.
&nbsp;                     */
&nbsp;                    private final boolean localType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new type containment for a type that is declared within another type.
&nbsp;                     *
&nbsp;                     * @param internalName The type&#39;s internal name.
&nbsp;                     * @param localType    {@code true} if the type is a local type unless it is an anonymous type.
&nbsp;                     */
&nbsp;                    public WithinType(String internalName, boolean localType) {
&nbsp;                        name = internalName.replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                        this.localType = localType;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDescription getEnclosingMethod(TypePool typePool) {
&nbsp;                        return MethodDescription.UNDEFINED;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeDescription getEnclosingType(TypePool typePool) {
&nbsp;                        return typePool.describe(name).resolve();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isSelfContained() {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isMemberClass() {
&nbsp;                        return !localType;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isLocalType() {
&nbsp;                        return localType;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Describes a type that is contained within a method or constructor.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class WithinMethod implements TypeContainment {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method&#39;s declaring type&#39;s internal name.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method&#39;s internal name.
&nbsp;                     */
&nbsp;                    private final String methodName;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method&#39;s descriptor.
&nbsp;                     */
&nbsp;                    private final String methodDescriptor;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new type containment for a type that is declared within a method.
&nbsp;                     *
&nbsp;                     * @param internalName     The method&#39;s declaring type&#39;s internal name.
&nbsp;                     * @param methodName       The method&#39;s internal name.
&nbsp;                     * @param methodDescriptor The method&#39;s descriptor.
&nbsp;                     */
&nbsp;                    public WithinMethod(String internalName, String methodName, String methodDescriptor) {
&nbsp;                        name = internalName.replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                        this.methodName = methodName;
&nbsp;                        this.methodDescriptor = methodDescriptor;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDescription getEnclosingMethod(TypePool typePool) {
&nbsp;                        return getEnclosingType(typePool).getDeclaredMethods().filter(hasMethodName(methodName).and(hasDescriptor(methodDescriptor))).getOnly();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeDescription getEnclosingType(TypePool typePool) {
&nbsp;                        return typePool.describe(name).resolve();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isSelfContained() {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isMemberClass() {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isLocalType() {
&nbsp;                        return true;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A token that represents a generic Java type.
&nbsp;             */
&nbsp;            protected interface GenericTypeToken {
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents an empty type path.
&nbsp;                 */
&nbsp;                String EMPTY_TYPE_PATH = &quot;&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a step to a component type within a type path.
&nbsp;                 */
&nbsp;                char COMPONENT_TYPE_PATH = &#39;[&#39;;
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a wildcard type step within a type path.
&nbsp;                 */
&nbsp;                char WILDCARD_TYPE_PATH = &#39;*&#39;;
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a (reversed) step to an inner class within a type path.
&nbsp;                 */
&nbsp;                char INNER_CLASS_PATH = &#39;.&#39;;
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents an index type delimiter within a type path.
&nbsp;                 */
&nbsp;                char INDEXED_TYPE_DELIMITER = &#39;;&#39;;
&nbsp;
&nbsp;                /**
&nbsp;                 * Transforms this token into a generic type representation.
&nbsp;                 *
&nbsp;                 * @param typePool           The type pool to be used for locating non-generic type descriptions.
&nbsp;                 * @param typeVariableSource The type variable source.
&nbsp;                 * @param typePath           The type path of the resolved generic type.
&nbsp;                 * @param annotationTokens   A mapping of the type&#39;s annotation tokens by their type path.
&nbsp;                 * @return A description of the represented generic type.
&nbsp;                 */
&nbsp;                Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens);
&nbsp;
&nbsp;                /**
&nbsp;                 * Determines if a generic type tokens represents a primary bound of a type variable. This method must only be invoked on types
&nbsp;                 * that represent a {@link Sort#NON_GENERIC},
&nbsp;                 * {@link Sort#PARAMETERIZED} or {@link Sort#VARIABLE}.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to use.
&nbsp;                 * @return {@code true} if this token represents a primary bound.
&nbsp;                 */
&nbsp;                boolean isPrimaryBound(TypePool typePool);
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the type path prefix that needs to be appended to the existing type path before any further navigation on the parameterized
&nbsp;                 * type. This method must only be called on type tokens that represent parameterized type
&nbsp;                 *
&nbsp;                 * @return A type path segment that needs to be appended to the base type path before any further navigation on the parameterized type.
&nbsp;                 */
&nbsp;                String getTypePathPrefix();
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a generic type token for a formal type variable.
&nbsp;                 */
&nbsp;                interface OfFormalTypeVariable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Transforms this token into a generic type representation.
&nbsp;                     *
&nbsp;                     * @param typePool                 The type pool to be used for locating non-generic type descriptions.
&nbsp;                     * @param typeVariableSource       The type variable source.
&nbsp;                     * @param annotationTokens         A mapping of the type variables&#39; type annotations.
&nbsp;                     * @param boundaryAnnotationTokens A mapping of the type variables&#39; bounds&#39; type annotation by their bound index.
&nbsp;                     * @return A generic type representation of this formal type variable.
&nbsp;                     */
&nbsp;                    Generic toGenericType(TypePool typePool,
&nbsp;                                          TypeVariableSource typeVariableSource,
&nbsp;                                          Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; boundaryAnnotationTokens);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token that represents a primitive type.
&nbsp;                 */
&nbsp;                enum ForPrimitiveType implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code boolean} type.
&nbsp;                     */
&nbsp;                    BOOLEAN(boolean.class),
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code byte} type.
&nbsp;                     */
&nbsp;                    BYTE(byte.class),
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code short} type.
&nbsp;                     */
&nbsp;                    SHORT(short.class),
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code char} type.
&nbsp;                     */
&nbsp;                    CHAR(char.class),
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code int} type.
&nbsp;                     */
&nbsp;                    INTEGER(int.class),
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code long} type.
&nbsp;                     */
&nbsp;                    LONG(long.class),
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code float} type.
&nbsp;                     */
&nbsp;                    FLOAT(float.class),
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code double} type.
&nbsp;                     */
&nbsp;                    DOUBLE(double.class),
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code void} type.
&nbsp;                     */
&nbsp;                    VOID(void.class);
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of this primitive type token.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new primitive type token.
&nbsp;                     *
&nbsp;                     * @param type The loaded type representing this primitive.
&nbsp;                     */
&nbsp;                    ForPrimitiveType(Class&lt;?&gt; type) {
&nbsp;                        typeDescription = ForLoadedType.of(type);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves a generic type token of a primitive type.
&nbsp;                     *
&nbsp;                     * @param descriptor The descriptor of the primitive type.
&nbsp;                     * @return The corresponding generic type token.
&nbsp;                     */
&nbsp;                    public static GenericTypeToken of(char descriptor) {
&nbsp;                        switch (descriptor) {
&nbsp;                            case &#39;V&#39;:
&nbsp;                                return VOID;
&nbsp;                            case &#39;Z&#39;:
&nbsp;                                return BOOLEAN;
&nbsp;                            case &#39;B&#39;:
&nbsp;                                return BYTE;
&nbsp;                            case &#39;S&#39;:
&nbsp;                                return SHORT;
&nbsp;                            case &#39;C&#39;:
&nbsp;                                return CHAR;
&nbsp;                            case &#39;I&#39;:
&nbsp;                                return INTEGER;
&nbsp;                            case &#39;J&#39;:
&nbsp;                                return LONG;
&nbsp;                            case &#39;F&#39;:
&nbsp;                                return FLOAT;
&nbsp;                            case &#39;D&#39;:
&nbsp;                                return DOUBLE;
&nbsp;                            default:
&nbsp;                                throw new IllegalArgumentException(&quot;Not a valid primitive type descriptor: &quot; + descriptor);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic toGenericType(TypePool typePool,
&nbsp;                                                 TypeVariableSource typeVariableSource,
&nbsp;                                                 String typePath,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new LazyPrimitiveType(typePool,
&nbsp;                                typePath,
&nbsp;                                annotationTokens == null
&nbsp;                                        ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()
&nbsp;                                        : annotationTokens,
&nbsp;                                typeDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        throw new IllegalStateException(&quot;A primitive type cannot be a type variable bound: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;A primitive type cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A representation of a lazy primitive type.
&nbsp;                     */
&nbsp;                    protected static class LazyPrimitiveType extends Generic.OfNonGenericType {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type path.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type annotation tokens.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented type&#39;s description.
&nbsp;                         */
&nbsp;                        private final TypeDescription typeDescription;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new lazy primitive type.
&nbsp;                         *
&nbsp;                         * @param typePool         The type pool to use.
&nbsp;                         * @param typePath         This type&#39;s type path.
&nbsp;                         * @param annotationTokens This type&#39;s type annotation tokens.
&nbsp;                         * @param typeDescription  The represented type&#39;s description.
&nbsp;                         */
&nbsp;                        protected LazyPrimitiveType(TypePool typePool,
&nbsp;                                                    String typePath,
&nbsp;                                                    Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                    TypeDescription typeDescription) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.typeDescription = typeDescription;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeDescription asErasure() {
&nbsp;                            return typeDescription;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic getOwnerType() {
&nbsp;                            return Generic.UNDEFINED;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic getComponentType() {
&nbsp;                            return Generic.UNDEFINED;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token that represents an unbound wildcard.
&nbsp;                 */
&nbsp;                enum ForUnboundWildcard implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic toGenericType(TypePool typePool,
&nbsp;                                                 TypeVariableSource typeVariableSource,
&nbsp;                                                 String typePath,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new LazyUnboundWildcard(typePool,
&nbsp;                                typePath,
&nbsp;                                annotationTokens == null
&nbsp;                                        ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()
&nbsp;                                        : annotationTokens);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        throw new IllegalStateException(&quot;A wildcard type cannot be a type variable bound: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;An unbound wildcard cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type representation of a generic unbound wildcard.
&nbsp;                     */
&nbsp;                    protected static class LazyUnboundWildcard extends Generic.OfWildcardType {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type path.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type&#39;s type annotations.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new lazy unbound wildcard.
&nbsp;                         *
&nbsp;                         * @param typePool         The type pool to use.
&nbsp;                         * @param typePath         This type&#39;s type path.
&nbsp;                         * @param annotationTokens The type&#39;s type annotations.
&nbsp;                         */
&nbsp;                        protected LazyUnboundWildcard(TypePool typePool, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic getUpperBounds() {
&nbsp;                            return new TypeList.Generic.Explicit(Generic.OBJECT);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic getLowerBounds() {
&nbsp;                            return new TypeList.Generic.Empty();
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolution of a type&#39;s, method&#39;s or field&#39;s generic types.
&nbsp;                 */
&nbsp;                interface Resolution {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves the type variables of the represented element.
&nbsp;                     *
&nbsp;                     * @param typePool              The type pool to be used for locating non-generic type descriptions.
&nbsp;                     * @param typeVariableSource    The type variable source to use for resolving type variables.
&nbsp;                     * @param annotationTokens      A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                     * @param boundAnnotationTokens A mapping of the type variables&#39; bounds&#39; type annotation tokens by their indices
&nbsp;                     *                              and each type variable&#39;s index.
&nbsp;                     * @return A list describing the resolved generic types.
&nbsp;                     */
&nbsp;                    TypeList.Generic resolveTypeVariables(TypePool typePool,
&nbsp;                                                          TypeVariableSource typeVariableSource,
&nbsp;                                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                          Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens);
&nbsp;
&nbsp;                    /**
&nbsp;                     * A resolution of a type&#39;s, method&#39;s or field&#39;s generic types if all of the represented element&#39;s are raw.
&nbsp;                     */
&nbsp;                    enum Raw implements ForType, ForMethod, ForField {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The singleton instance.
&nbsp;                         */
&nbsp;                        INSTANCE;
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic resolveFieldType(String fieldTypeDescriptor,
&nbsp;                                                        TypePool typePool,
&nbsp;                                                        Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                        FieldDescription.InDefinedShape definingField) {
&nbsp;                            return RawAnnotatedType.of(typePool, annotationTokens, fieldTypeDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic resolveReturnType(String returnTypeDescriptor,
&nbsp;                                                         TypePool typePool,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                         MethodDescription.InDefinedShape definingMethod) {
&nbsp;                            return RawAnnotatedType.of(typePool, annotationTokens, returnTypeDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic resolveParameterTypes(List&lt;String&gt; parameterTypeDescriptors,
&nbsp;                                                                      TypePool typePool,
&nbsp;                                                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                      MethodDescription.InDefinedShape definingMethod) {
&nbsp;                            return RawAnnotatedType.LazyRawAnnotatedTypeList.of(typePool, annotationTokens, parameterTypeDescriptors);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic resolveExceptionTypes(List&lt;String&gt; exceptionTypeDescriptors,
&nbsp;                                                                      TypePool typePool,
&nbsp;                                                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                      MethodDescription.InDefinedShape definingMethod) {
&nbsp;                            return RawAnnotatedType.LazyRawAnnotatedTypeList.of(typePool, annotationTokens, exceptionTypeDescriptors);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic resolveSuperClass(String superClassDescriptor,
&nbsp;                                                         TypePool typePool,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                         TypeDescription definingType) {
&nbsp;                            return RawAnnotatedType.of(typePool, annotationTokens, superClassDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic resolveInterfaceTypes(List&lt;String&gt; interfaceTypeDescriptors,
&nbsp;                                                                      TypePool typePool,
&nbsp;                                                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                      TypeDescription definingType) {
&nbsp;                            return RawAnnotatedType.LazyRawAnnotatedTypeList.of(typePool, annotationTokens, interfaceTypeDescriptors);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic resolveTypeVariables(TypePool typePool,
&nbsp;                                                                     TypeVariableSource typeVariableSource,
&nbsp;                                                                     Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                     Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
&nbsp;                            return new TypeList.Generic.Empty();
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Represents a non-generic type that defines type annotations.
&nbsp;                         */
&nbsp;                        protected static class RawAnnotatedType extends Generic.OfNonGenericType {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type pool to use.
&nbsp;                             */
&nbsp;                            private final TypePool typePool;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type&#39;s type path.
&nbsp;                             */
&nbsp;                            private final String typePath;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A mapping of this type&#39;s type annotations.
&nbsp;                             */
&nbsp;                            private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The represented non-generic type.
&nbsp;                             */
&nbsp;                            private final TypeDescription typeDescription;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new raw annotated type.
&nbsp;                             *
&nbsp;                             * @param typePool         The type pool to use.
&nbsp;                             * @param typePath         The type&#39;s type path.
&nbsp;                             * @param annotationTokens A mapping of this type&#39;s type annotations.
&nbsp;                             * @param typeDescription  The represented non-generic type.
&nbsp;                             */
&nbsp;                            protected RawAnnotatedType(TypePool typePool,
&nbsp;                                                       String typePath,
&nbsp;                                                       Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                       TypeDescription typeDescription) {
&nbsp;                                this.typePool = typePool;
&nbsp;                                this.typePath = typePath;
&nbsp;                                this.annotationTokens = annotationTokens;
&nbsp;                                this.typeDescription = typeDescription;
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new raw annotated type.
&nbsp;                             *
&nbsp;                             * @param typePool         The type pool to use.
&nbsp;                             * @param annotationTokens A mapping of this type&#39;s type annotations.
&nbsp;                             * @param descriptor       The descriptor of the represented non-generic type.
&nbsp;                             * @return An annotated non-generic type.
&nbsp;                             */
&nbsp;                            protected static Generic of(TypePool typePool, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens, String descriptor) {
&nbsp;                                return new RawAnnotatedType(typePool,
&nbsp;                                        EMPTY_TYPE_PATH,
&nbsp;                                        annotationTokens == null
&nbsp;                                                ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()
&nbsp;                                                : annotationTokens,
&nbsp;                                        TokenizedGenericType.toErasure(typePool, descriptor));
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeDescription asErasure() {
&nbsp;                                return typeDescription;
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Generic getOwnerType() {
&nbsp;                                TypeDescription declaringType = typeDescription.getDeclaringType();
&nbsp;                                return declaringType == null
&nbsp;                                        ? Generic.UNDEFINED
&nbsp;                                        : new RawAnnotatedType(typePool, typePath, annotationTokens, declaringType);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Generic getComponentType() {
&nbsp;                                TypeDescription componentType = typeDescription.getComponentType();
&nbsp;                                return componentType == null
&nbsp;                                        ? Generic.UNDEFINED
&nbsp;                                        : new RawAnnotatedType(typePool, typePath + COMPONENT_TYPE_PATH, annotationTokens, componentType);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public AnnotationList getDeclaredAnnotations() {
&nbsp;                                StringBuilder typePath = new StringBuilder(this.typePath);
&nbsp;                                for (int index = 0; index &lt; typeDescription.getInnerClassCount(); index++) {
&nbsp;                                    typePath = typePath.append(INNER_CLASS_PATH);
&nbsp;                                }
&nbsp;                                return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath.toString()));
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A generic type list representing raw types.
&nbsp;                             */
&nbsp;                            protected static class LazyRawAnnotatedTypeList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The type pool to use for locating types.
&nbsp;                                 */
&nbsp;                                private final TypePool typePool;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A mapping of the represented types&#39; type annotation tokens by their indices.
&nbsp;                                 */
&nbsp;                                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A list of type descriptors that this list represents.
&nbsp;                                 */
&nbsp;                                private final List&lt;String&gt; descriptors;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a generic type list only representing raw types.
&nbsp;                                 *
&nbsp;                                 * @param typePool         The type pool to use for locating types.
&nbsp;                                 * @param annotationTokens A mapping of the represented types&#39; type annotation tokens by their indices.
&nbsp;                                 * @param descriptors      A list of type descriptors that this list represents.
&nbsp;                                 */
&nbsp;                                protected LazyRawAnnotatedTypeList(TypePool typePool,
&nbsp;                                                                   Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                   List&lt;String&gt; descriptors) {
&nbsp;                                    this.typePool = typePool;
&nbsp;                                    this.annotationTokens = annotationTokens;
&nbsp;                                    this.descriptors = descriptors;
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates generic type list only representing raw types.
&nbsp;                                 *
&nbsp;                                 * @param typePool         The type pool to use for locating types.
&nbsp;                                 * @param annotationTokens A mapping of the represented types&#39; type annotation tokens by their indices or
&nbsp;                                 *                         {@code null} if no type annotations are defined for any type.
&nbsp;                                 * @param descriptors      A list of type descriptors that this list represents.
&nbsp;                                 * @return A generic type list representing the raw types this list represents.
&nbsp;                                 */
&nbsp;                                protected static TypeList.Generic of(TypePool typePool,
&nbsp;                                                                     Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                     List&lt;String&gt; descriptors) {
&nbsp;                                    return new LazyRawAnnotatedTypeList(typePool,
&nbsp;                                            annotationTokens == null
&nbsp;                                                    ? Collections.&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;emptyMap()
&nbsp;                                                    : annotationTokens,
&nbsp;                                            descriptors);
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public Generic get(int index) {
&nbsp;                                    return RawAnnotatedType.of(typePool, annotationTokens.get(index), descriptors.get(index));
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public int size() {
&nbsp;                                    return descriptors.size();
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public TypeList asErasures() {
&nbsp;                                    return new LazyTypeList(typePool, descriptors);
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public TypeList.Generic asRawTypes() {
&nbsp;                                    return this;
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public int getStackSize() {
&nbsp;                                    int stackSize = 0;
&nbsp;                                    for (String descriptor : descriptors) {
&nbsp;                                        stackSize += Type.getType(descriptor).getSize();
&nbsp;                                    }
&nbsp;                                    return stackSize;
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A resolution of a type&#39;s, method&#39;s or field&#39;s generic types if its generic signature is malformed.
&nbsp;                     */
&nbsp;                    enum Malformed implements ForType, ForMethod, ForField {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The singleton instance.
&nbsp;                         */
&nbsp;                        INSTANCE;
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic resolveFieldType(String fieldTypeDescriptor,
&nbsp;                                                        TypePool typePool,
&nbsp;                                                        Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                        FieldDescription.InDefinedShape definingField) {
&nbsp;                            return new TokenizedGenericType.Malformed(typePool, fieldTypeDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic resolveReturnType(String returnTypeDescriptor,
&nbsp;                                                         TypePool typePool,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                         MethodDescription.InDefinedShape definingMethod) {
&nbsp;                            return new TokenizedGenericType.Malformed(typePool, returnTypeDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic resolveParameterTypes(List&lt;String&gt; parameterTypeDescriptors,
&nbsp;                                                                      TypePool typePool,
&nbsp;                                                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                      MethodDescription.InDefinedShape definingMethod) {
&nbsp;                            return new TokenizedGenericType.Malformed.TokenList(typePool, parameterTypeDescriptors);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic resolveExceptionTypes(List&lt;String&gt; exceptionTypeDescriptors,
&nbsp;                                                                      TypePool typePool,
&nbsp;                                                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                      MethodDescription.InDefinedShape definingMethod) {
&nbsp;                            return new TokenizedGenericType.Malformed.TokenList(typePool, exceptionTypeDescriptors);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic resolveSuperClass(String superClassDescriptor,
&nbsp;                                                         TypePool typePool,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                         TypeDescription definingType) {
&nbsp;                            return new TokenizedGenericType.Malformed(typePool, superClassDescriptor);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic resolveInterfaceTypes(List&lt;String&gt; interfaceTypeDescriptors,
&nbsp;                                                                      TypePool typePool,
&nbsp;                                                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                      TypeDescription definingType) {
&nbsp;                            return new TokenizedGenericType.Malformed.TokenList(typePool, interfaceTypeDescriptors);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic resolveTypeVariables(TypePool typePool,
&nbsp;                                                                     TypeVariableSource typeVariableSource,
&nbsp;                                                                     Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                     Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
&nbsp;                            throw new GenericSignatureFormatError();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A resolution of the generic types of a {@link TypeDescription}.
&nbsp;                     */
&nbsp;                    interface ForType extends Resolution {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the generic super type of the represented type.
&nbsp;                         *
&nbsp;                         * @param superClassDescriptor The descriptor of the raw super type.
&nbsp;                         * @param typePool             The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param annotationTokens     A mapping of the super type&#39;s type annotation tokens.
&nbsp;                         * @param definingType         The type that defines this super type.
&nbsp;                         * @return A description of this type&#39;s generic super type.
&nbsp;                         */
&nbsp;                        Generic resolveSuperClass(String superClassDescriptor,
&nbsp;                                                  TypePool typePool,
&nbsp;                                                  Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                  TypeDescription definingType);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the generic interface types of the represented type.
&nbsp;                         *
&nbsp;                         * @param interfaceTypeDescriptors The descriptor of the raw interface types.
&nbsp;                         * @param typePool                 The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param annotationTokens         A mapping of the interface types&#39; type annotation tokens by their indices.
&nbsp;                         * @param definingType             The type that defines these interface type.
&nbsp;                         * @return A description of this type&#39;s generic interface types.
&nbsp;                         */
&nbsp;                        TypeList.Generic resolveInterfaceTypes(List&lt;String&gt; interfaceTypeDescriptors,
&nbsp;                                                               TypePool typePool,
&nbsp;                                                               Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                               TypeDescription definingType);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An implementation of a tokenized resolution of generic types of a {@link TypeDescription}.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class Tokenized implements ForType {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The super type&#39;s generic type token.
&nbsp;                             */
&nbsp;                            private final GenericTypeToken superClassToken;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The interface type&#39;s generic type tokens.
&nbsp;                             */
&nbsp;                            private final List&lt;GenericTypeToken&gt; interfaceTypeTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variables generic type tokens.
&nbsp;                             */
&nbsp;                            private final List&lt;OfFormalTypeVariable&gt; typeVariableTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new tokenized resolution of a {@link TypeDescription}&#39;s generic signatures.
&nbsp;                             *
&nbsp;                             * @param superClassToken     The super class&#39;s generic type token.
&nbsp;                             * @param interfaceTypeTokens The interface type&#39;s generic type tokens.
&nbsp;                             * @param typeVariableTokens  The type variables generic type tokens.
&nbsp;                             */
&nbsp;                            public Tokenized(GenericTypeToken superClassToken,
&nbsp;                                             List&lt;GenericTypeToken&gt; interfaceTypeTokens,
&nbsp;                                             List&lt;OfFormalTypeVariable&gt; typeVariableTokens) {
&nbsp;                                this.superClassToken = superClassToken;
&nbsp;                                this.interfaceTypeTokens = interfaceTypeTokens;
&nbsp;                                this.typeVariableTokens = typeVariableTokens;
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Generic resolveSuperClass(String superClassDescriptor,
&nbsp;                                                             TypePool typePool,
&nbsp;                                                             Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                             TypeDescription definingType) {
&nbsp;                                return TokenizedGenericType.of(typePool, superClassToken, superClassDescriptor, annotationTokens, definingType);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeList.Generic resolveInterfaceTypes(List&lt;String&gt; interfaceTypeDescriptors,
&nbsp;                                                                          TypePool typePool,
&nbsp;                                                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                          TypeDescription definingType) {
&nbsp;                                return new TokenizedGenericType.TokenList(typePool, interfaceTypeTokens, annotationTokens, interfaceTypeDescriptors, definingType);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeList.Generic resolveTypeVariables(TypePool typePool,
&nbsp;                                                                         TypeVariableSource typeVariableSource,
&nbsp;                                                                         Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                         Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
&nbsp;                                return new TokenizedGenericType.TypeVariableList(typePool, typeVariableTokens, typeVariableSource, annotationTokens, boundAnnotationTokens);
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A resolution of the generic types of a {@link MethodDescription}.
&nbsp;                     */
&nbsp;                    interface ForMethod extends Resolution {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the return type of the represented method.
&nbsp;                         *
&nbsp;                         * @param returnTypeDescriptor The descriptor of the raw return type.
&nbsp;                         * @param typePool             The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param annotationTokens     A mapping of the return type&#39;s type annotation tokens.
&nbsp;                         * @param definingMethod       The method that defines this return type.
&nbsp;                         * @return A description of this type&#39;s generic return type.
&nbsp;                         */
&nbsp;                        Generic resolveReturnType(String returnTypeDescriptor,
&nbsp;                                                  TypePool typePool,
&nbsp;                                                  Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                  MethodDescription.InDefinedShape definingMethod);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the generic parameter types of the represented method.
&nbsp;                         *
&nbsp;                         * @param parameterTypeDescriptors The descriptor of the raw parameter types.
&nbsp;                         * @param typePool                 The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param annotationTokens         A mapping of the parameter types&#39; type annotation tokens by their indices.
&nbsp;                         * @param definingMethod           The method that defines these parameter types.
&nbsp;                         * @return A description of this type&#39;s generic interface types.
&nbsp;                         */
&nbsp;                        TypeList.Generic resolveParameterTypes(List&lt;String&gt; parameterTypeDescriptors,
&nbsp;                                                               TypePool typePool,
&nbsp;                                                               Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                               MethodDescription.InDefinedShape definingMethod);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the generic parameter types of the represented method.
&nbsp;                         *
&nbsp;                         * @param exceptionTypeDescriptors The descriptor of the raw exception types.
&nbsp;                         * @param typePool                 The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param annotationTokens         A mapping of the exception types&#39; type annotation tokens by their indices.
&nbsp;                         * @param definingMethod           The method that defines these exception types.
&nbsp;                         * @return A description of this type&#39;s generic interface types.
&nbsp;                         */
&nbsp;                        TypeList.Generic resolveExceptionTypes(List&lt;String&gt; exceptionTypeDescriptors,
&nbsp;                                                               TypePool typePool,
&nbsp;                                                               Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                               MethodDescription.InDefinedShape definingMethod);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An implementation of a tokenized resolution of generic types of a {@link MethodDescription}.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class Tokenized implements ForMethod {
&nbsp;
&nbsp;                            /**
&nbsp;                             * A token describing the represented method&#39;s return type.
&nbsp;                             */
&nbsp;                            private final GenericTypeToken returnTypeToken;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A token describing the represented method&#39;s parameter types.
&nbsp;                             */
&nbsp;                            private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A token describing the represented method&#39;s exception types.
&nbsp;                             */
&nbsp;                            private final List&lt;GenericTypeToken&gt; exceptionTypeTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A token describing the represented method&#39;s type variables.
&nbsp;                             */
&nbsp;                            private final List&lt;OfFormalTypeVariable&gt; typeVariableTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new tokenized resolution of a {@link MethodDescription}&#39;s generic signatures.
&nbsp;                             *
&nbsp;                             * @param returnTypeToken     A token describing the represented method&#39;s return type.
&nbsp;                             * @param parameterTypeTokens A token describing the represented method&#39;s parameter types.
&nbsp;                             * @param exceptionTypeTokens A token describing the represented method&#39;s exception types.
&nbsp;                             * @param typeVariableTokens  A token describing the represented method&#39;s type variables.
&nbsp;                             */
&nbsp;                            public Tokenized(GenericTypeToken returnTypeToken,
&nbsp;                                             List&lt;GenericTypeToken&gt; parameterTypeTokens,
&nbsp;                                             List&lt;GenericTypeToken&gt; exceptionTypeTokens,
&nbsp;                                             List&lt;OfFormalTypeVariable&gt; typeVariableTokens) {
&nbsp;                                this.returnTypeToken = returnTypeToken;
&nbsp;                                this.parameterTypeTokens = parameterTypeTokens;
&nbsp;                                this.exceptionTypeTokens = exceptionTypeTokens;
&nbsp;                                this.typeVariableTokens = typeVariableTokens;
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Generic resolveReturnType(String returnTypeDescriptor,
&nbsp;                                                             TypePool typePool,
&nbsp;                                                             Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                             MethodDescription.InDefinedShape definingMethod) {
&nbsp;                                return TokenizedGenericType.of(typePool, returnTypeToken, returnTypeDescriptor, annotationTokens, definingMethod);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeList.Generic resolveParameterTypes(List&lt;String&gt; parameterTypeDescriptors,
&nbsp;                                                                          TypePool typePool,
&nbsp;                                                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                          MethodDescription.InDefinedShape definingMethod) {
&nbsp;                                return new TokenizedGenericType.TokenList(typePool, parameterTypeTokens, annotationTokens, parameterTypeDescriptors, definingMethod);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeList.Generic resolveExceptionTypes(List&lt;String&gt; exceptionTypeDescriptors,
&nbsp;                                                                          TypePool typePool,
&nbsp;                                                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                          MethodDescription.InDefinedShape definingMethod) {
&nbsp;                                // Generic signatures of methods are optional.
&nbsp;                                return exceptionTypeTokens.isEmpty()
&nbsp;                                        ? Raw.INSTANCE.resolveExceptionTypes(exceptionTypeDescriptors, typePool, annotationTokens, definingMethod)
&nbsp;                                        : new TokenizedGenericType.TokenList(typePool, exceptionTypeTokens, annotationTokens, exceptionTypeDescriptors, definingMethod);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeList.Generic resolveTypeVariables(TypePool typePool,
&nbsp;                                                                         TypeVariableSource typeVariableSource,
&nbsp;                                                                         Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                         Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
&nbsp;                                return new TokenizedGenericType.TypeVariableList(typePool, typeVariableTokens, typeVariableSource, annotationTokens, boundAnnotationTokens);
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A resolution of the generic types of a {@link FieldDescription}.
&nbsp;                     */
&nbsp;                    interface ForField {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the field type of the represented field.
&nbsp;                         *
&nbsp;                         * @param fieldTypeDescriptor The descriptor of the raw field type.
&nbsp;                         * @param annotationTokens    A mapping of the represented types&#39; type annotation tokens.
&nbsp;                         * @param typePool            The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param definingField       The field that defines this type.   @return A description of this field&#39;s type.
&nbsp;                         * @return A generic type representation of the field&#39;s type.
&nbsp;                         */
&nbsp;                        Generic resolveFieldType(String fieldTypeDescriptor,
&nbsp;                                                 TypePool typePool,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                 FieldDescription.InDefinedShape definingField);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An implementation of a tokenized resolution of the generic type of a {@link FieldDescription}.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class Tokenized implements ForField {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The token of the represented field&#39;s type.
&nbsp;                             */
&nbsp;                            private final GenericTypeToken fieldTypeToken;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new tokenized resolution of a {@link FieldDescription}&#39;s type.
&nbsp;                             *
&nbsp;                             * @param fieldTypeToken The token of the represented field&#39;s type.
&nbsp;                             */
&nbsp;                            public Tokenized(GenericTypeToken fieldTypeToken) {
&nbsp;                                this.fieldTypeToken = fieldTypeToken;
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Generic resolveFieldType(String fieldTypeDescriptor,
&nbsp;                                                            TypePool typePool,
&nbsp;                                                            Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                            FieldDescription.InDefinedShape definingField) {
&nbsp;                                return TokenizedGenericType.of(typePool, fieldTypeToken, fieldTypeDescriptor, annotationTokens, definingField.getDeclaringType());
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token that represents a non-generic type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForRawType implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the represented type.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new type token that represents a non-generic type.
&nbsp;                     *
&nbsp;                     * @param name The name of the represented type.
&nbsp;                     */
&nbsp;                    protected ForRawType(String name) {
&nbsp;                        this.name = name;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic toGenericType(TypePool typePool,
&nbsp;                                                 TypeVariableSource typeVariableSource,
&nbsp;                                                 String typePath,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new Resolution.Raw.RawAnnotatedType(typePool,
&nbsp;                                typePath,
&nbsp;                                annotationTokens == null
&nbsp;                                        ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()
&nbsp;                                        : annotationTokens,
&nbsp;                                typePool.describe(name).resolve());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        return !typePool.describe(name).resolve().isInterface();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;A non-generic type cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token that represents a type variable.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForTypeVariable implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * This type variable&#39;s nominal symbol.
&nbsp;                     */
&nbsp;                    private final String symbol;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a generic type token that represents a type variable.
&nbsp;                     *
&nbsp;                     * @param symbol This type variable&#39;s nominal symbol.
&nbsp;                     */
&nbsp;                    protected ForTypeVariable(String symbol) {
&nbsp;                        this.symbol = symbol;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        Generic typeVariable = typeVariableSource.findVariable(symbol);
&nbsp;                        return typeVariable == null
&nbsp;                                ? new UnresolvedTypeVariable(typeVariableSource, typePool, symbol, annotationTokens.get(typePath))
&nbsp;                                : new AnnotatedTypeVariable(typePool, annotationTokens.get(typePath), typeVariable);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;A type variable cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotated representation of a formal type variable.
&nbsp;                     */
&nbsp;                    protected static class AnnotatedTypeVariable extends Generic.OfTypeVariable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented annotation tokens.
&nbsp;                         */
&nbsp;                        private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented type variable.
&nbsp;                         */
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotated type variable.
&nbsp;                         *
&nbsp;                         * @param typePool         The type pool to use.
&nbsp;                         * @param annotationTokens The represented annotation tokens.
&nbsp;                         * @param typeVariable     The represented type variable.
&nbsp;                         */
&nbsp;                        protected AnnotatedTypeVariable(TypePool typePool, List&lt;AnnotationToken&gt; annotationTokens, Generic typeVariable) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.typeVariable = typeVariable;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic getUpperBounds() {
&nbsp;                            return typeVariable.getUpperBounds();
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeVariableSource getTypeVariableSource() {
&nbsp;                            return typeVariable.getTypeVariableSource();
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public String getSymbol() {
&nbsp;                            return typeVariable.getSymbol();
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Represents a type variable that a type references but that does not exist. Such type variables are only emitted by wrongful
&nbsp;                     * compilation either due to the isolated recompilation of outer classes or due to bugs in compilers.
&nbsp;                     */
&nbsp;                    protected static class UnresolvedTypeVariable extends Generic.OfTypeVariable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The undeclared type variable&#39;s source.
&nbsp;                         */
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable&#39;s symbol.
&nbsp;                         */
&nbsp;                        private final String symbol;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable&#39;s annotation tokens.
&nbsp;                         */
&nbsp;                        private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates an unresolved type variable.
&nbsp;                         *
&nbsp;                         * @param typeVariableSource The undeclared type variable&#39;s source.
&nbsp;                         * @param typePool           The type pool to use.
&nbsp;                         * @param symbol             The type variable&#39;s symbol.
&nbsp;                         * @param annotationTokens   The type variable&#39;s annotation tokens.
&nbsp;                         */
&nbsp;                        protected UnresolvedTypeVariable(TypeVariableSource typeVariableSource,
&nbsp;                                                         TypePool typePool,
&nbsp;                                                         String symbol,
&nbsp;                                                         List&lt;AnnotationToken&gt; annotationTokens) {
&nbsp;                            this.typeVariableSource = typeVariableSource;
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.symbol = symbol;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic getUpperBounds() {
&nbsp;                            throw new IllegalStateException(&quot;Cannot resolve bounds of unresolved type variable &quot; + this + &quot; by &quot; + typeVariableSource);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeVariableSource getTypeVariableSource() {
&nbsp;                            return typeVariableSource;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public String getSymbol() {
&nbsp;                            return symbol;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type token that represent a formal type variable, i.e. a type variable including its upper bounds.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class Formal implements GenericTypeToken.OfFormalTypeVariable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type variable&#39;s nominal symbol.
&nbsp;                         */
&nbsp;                        private final String symbol;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A list of tokens that represent this type variable&#39;s upper bounds.
&nbsp;                         */
&nbsp;                        private final List&lt;GenericTypeToken&gt; boundTypeTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates generic type token that represent a formal type variable.
&nbsp;                         *
&nbsp;                         * @param symbol          This type variable&#39;s nominal symbol.
&nbsp;                         * @param boundTypeTokens A list of tokens that represent this type variable&#39;s upper bounds.
&nbsp;                         */
&nbsp;                        protected Formal(String symbol, List&lt;GenericTypeToken&gt; boundTypeTokens) {
&nbsp;                            this.symbol = symbol;
&nbsp;                            this.boundTypeTokens = boundTypeTokens;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic toGenericType(TypePool typePool,
&nbsp;                                                     TypeVariableSource typeVariableSource,
&nbsp;                                                     Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                     Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; boundaryAnnotationTokens) {
&nbsp;                            return new LazyTypeVariable(typePool,
&nbsp;                                    typeVariableSource,
&nbsp;                                    annotationTokens == null
&nbsp;                                            ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()
&nbsp;                                            : annotationTokens,
&nbsp;                                    boundaryAnnotationTokens == null
&nbsp;                                            ? Collections.&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;emptyMap()
&nbsp;                                            : boundaryAnnotationTokens,
&nbsp;                                    symbol,
&nbsp;                                    boundTypeTokens);
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A type description that represents a type variable with bounds that are resolved lazily.
&nbsp;                         */
&nbsp;                        protected static class LazyTypeVariable extends Generic.OfTypeVariable {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type pool to use for locating type descriptions.
&nbsp;                             */
&nbsp;                            private final TypePool typePool;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable source to use for locating type variables.
&nbsp;                             */
&nbsp;                            private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable&#39;s type annotation tokens.
&nbsp;                             */
&nbsp;                            private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A mapping of the type variable bounds&#39; type annotation tokens by their indices.
&nbsp;                             */
&nbsp;                            private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; boundaryAnnotationTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable&#39;s symbol.
&nbsp;                             */
&nbsp;                            private final String symbol;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Tokenized representations of the type variables bound types.
&nbsp;                             */
&nbsp;                            private final List&lt;GenericTypeToken&gt; boundTypeTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a lazy type description of a type variables.
&nbsp;                             *
&nbsp;                             * @param typePool                 The type pool to use for locating type descriptions.
&nbsp;                             * @param typeVariableSource       The type variable source to use for locating type variables.
&nbsp;                             * @param annotationTokens         The type variable&#39;s type annotation tokens.
&nbsp;                             * @param boundaryAnnotationTokens A mapping of the type variable bounds&#39; type annotation tokens by their indices.
&nbsp;                             * @param symbol                   The type variable&#39;s symbol.
&nbsp;                             * @param boundTypeTokens          Tokenized representations of the type variables bound types.
&nbsp;                             */
&nbsp;                            protected LazyTypeVariable(TypePool typePool,
&nbsp;                                                       TypeVariableSource typeVariableSource,
&nbsp;                                                       Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                       Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; boundaryAnnotationTokens,
&nbsp;                                                       String symbol,
&nbsp;                                                       List&lt;GenericTypeToken&gt; boundTypeTokens) {
&nbsp;                                this.typePool = typePool;
&nbsp;                                this.typeVariableSource = typeVariableSource;
&nbsp;                                this.annotationTokens = annotationTokens;
&nbsp;                                this.boundaryAnnotationTokens = boundaryAnnotationTokens;
&nbsp;                                this.symbol = symbol;
&nbsp;                                this.boundTypeTokens = boundTypeTokens;
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeList.Generic getUpperBounds() {
&nbsp;                                return new LazyBoundTokenList(typePool, typeVariableSource, boundaryAnnotationTokens, boundTypeTokens);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeVariableSource getTypeVariableSource() {
&nbsp;                                return typeVariableSource;
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public String getSymbol() {
&nbsp;                                return symbol;
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public AnnotationList getDeclaredAnnotations() {
&nbsp;                                return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(EMPTY_TYPE_PATH));
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A list representing a formal type variable&#39;s bounds.
&nbsp;                             */
&nbsp;                            protected static class LazyBoundTokenList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The type pool to use.
&nbsp;                                 */
&nbsp;                                private final TypePool typePool;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The type variable source for locating type variables.
&nbsp;                                 */
&nbsp;                                private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A mapping of the bound type&#39;s type annotations by their bound index.
&nbsp;                                 */
&nbsp;                                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The bound types in their tokenized form.
&nbsp;                                 */
&nbsp;                                private final List&lt;GenericTypeToken&gt; boundTypeTokens;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new lazy bound token list for a type variable.
&nbsp;                                 *
&nbsp;                                 * @param typePool           The type pool to use.
&nbsp;                                 * @param typeVariableSource The type variable source for locating type variables.
&nbsp;                                 * @param annotationTokens   A mapping of the bound type&#39;s type annotations by their bound index.
&nbsp;                                 * @param boundTypeTokens    The bound types in their tokenized form.
&nbsp;                                 */
&nbsp;                                protected LazyBoundTokenList(TypePool typePool,
&nbsp;                                                             TypeVariableSource typeVariableSource,
&nbsp;                                                             Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                             List&lt;GenericTypeToken&gt; boundTypeTokens) {
&nbsp;                                    this.typePool = typePool;
&nbsp;                                    this.typeVariableSource = typeVariableSource;
&nbsp;                                    this.annotationTokens = annotationTokens;
&nbsp;                                    this.boundTypeTokens = boundTypeTokens;
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public Generic get(int index) {
&nbsp;                                    // Avoid resolution of interface bound type unless a type annotation can be possibly resolved.
&nbsp;                                    Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens = !this.annotationTokens.containsKey(index) &amp;&amp; !this.annotationTokens.containsKey(index + 1)
&nbsp;                                            ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()
&nbsp;                                            : this.annotationTokens.get(index + (boundTypeTokens.get(0).isPrimaryBound(typePool) ? 0 : 1));
&nbsp;                                    return boundTypeTokens.get(index).toGenericType(typePool,
&nbsp;                                            typeVariableSource,
&nbsp;                                            EMPTY_TYPE_PATH,
&nbsp;                                            annotationTokens == null
&nbsp;                                                    ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()
&nbsp;                                                    : annotationTokens);
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public int size() {
&nbsp;                                    return boundTypeTokens.size();
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token that represents a generic array.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForGenericArray implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The array&#39;s component type.
&nbsp;                     */
&nbsp;                    private final GenericTypeToken componentTypeToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a generic type token that represents a generic array.
&nbsp;                     *
&nbsp;                     * @param componentTypeToken The array&#39;s component type.
&nbsp;                     */
&nbsp;                    protected ForGenericArray(GenericTypeToken componentTypeToken) {
&nbsp;                        this.componentTypeToken = componentTypeToken;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new LazyGenericArray(typePool, typeVariableSource, typePath, annotationTokens, componentTypeToken);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        throw new IllegalStateException(&quot;A generic array type cannot be a type variable bound: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;A generic array type cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type representation of a generic array.
&nbsp;                     */
&nbsp;                    protected static class LazyGenericArray extends Generic.OfGenericArray {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable source for locating type variables.
&nbsp;                         */
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type path.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type annotations.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A tokenized representation of this generic arrays&#39;s component type.
&nbsp;                         */
&nbsp;                        private final GenericTypeToken componentTypeToken;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new lazy generic array.
&nbsp;                         *
&nbsp;                         * @param typePool           The type pool to use.
&nbsp;                         * @param typeVariableSource The type variable source for locating type variables.
&nbsp;                         * @param typePath           This type&#39;s type path.
&nbsp;                         * @param annotationTokens   This type&#39;s type annotations.
&nbsp;                         * @param componentTypeToken A tokenized representation of this generic arrays&#39;s component type.
&nbsp;                         */
&nbsp;                        protected LazyGenericArray(TypePool typePool,
&nbsp;                                                   TypeVariableSource typeVariableSource,
&nbsp;                                                   String typePath,
&nbsp;                                                   Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                   GenericTypeToken componentTypeToken) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typeVariableSource = typeVariableSource;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.componentTypeToken = componentTypeToken;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic getComponentType() {
&nbsp;                            return componentTypeToken.toGenericType(typePool, typeVariableSource, typePath + COMPONENT_TYPE_PATH, annotationTokens);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token for a wildcard that is bound below.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForLowerBoundWildcard implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token that represents the wildcard&#39;s lower bound.
&nbsp;                     */
&nbsp;                    private final GenericTypeToken boundTypeToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a generic type token for a wildcard that is bound below.
&nbsp;                     *
&nbsp;                     * @param boundTypeToken A token that represents the wildcard&#39;s lower bound.
&nbsp;                     */
&nbsp;                    protected ForLowerBoundWildcard(GenericTypeToken boundTypeToken) {
&nbsp;                        this.boundTypeToken = boundTypeToken;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new LazyLowerBoundWildcard(typePool, typeVariableSource, typePath, annotationTokens, boundTypeToken);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        throw new IllegalStateException(&quot;A wildcard type cannot be a type variable bound: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;A lower bound wildcard cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type representation of a lower bound wildcard.
&nbsp;                     */
&nbsp;                    protected static class LazyLowerBoundWildcard extends Generic.OfWildcardType {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable source for locating type variables.
&nbsp;                         */
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type path.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type annotations.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A tokenized representation of this wildcard&#39;s bound.
&nbsp;                         */
&nbsp;                        private final GenericTypeToken boundTypeToken;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new lazy lower bound wildcard.
&nbsp;                         *
&nbsp;                         * @param typePool           The type pool to use.
&nbsp;                         * @param typeVariableSource The type variable source for locating type variables.
&nbsp;                         * @param typePath           This type&#39;s type path.
&nbsp;                         * @param annotationTokens   This type&#39;s type annotations.
&nbsp;                         * @param boundTypeToken     A tokenized representation of this wildcard&#39;s bound.
&nbsp;                         */
&nbsp;                        protected LazyLowerBoundWildcard(TypePool typePool,
&nbsp;                                                         TypeVariableSource typeVariableSource,
&nbsp;                                                         String typePath,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                         GenericTypeToken boundTypeToken) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typeVariableSource = typeVariableSource;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.boundTypeToken = boundTypeToken;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic getUpperBounds() {
&nbsp;                            return new TypeList.Generic.Explicit(Generic.OBJECT);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic getLowerBounds() {
&nbsp;                            return new LazyTokenList.ForWildcardBound(typePool, typeVariableSource, typePath, annotationTokens, boundTypeToken);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token for a wildcard that is bound above.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForUpperBoundWildcard implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token that represents the wildcard&#39;s upper bound.
&nbsp;                     */
&nbsp;                    private final GenericTypeToken boundTypeToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a generic type token for a wildcard that is bound above.
&nbsp;                     *
&nbsp;                     * @param boundTypeToken A token that represents the wildcard&#39;s upper bound.
&nbsp;                     */
&nbsp;                    protected ForUpperBoundWildcard(GenericTypeToken boundTypeToken) {
&nbsp;                        this.boundTypeToken = boundTypeToken;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic toGenericType(TypePool typePool,
&nbsp;                                                 TypeVariableSource typeVariableSource,
&nbsp;                                                 String typePath,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new LazyUpperBoundWildcard(typePool, typeVariableSource, typePath, annotationTokens, boundTypeToken);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        throw new IllegalStateException(&quot;A wildcard type cannot be a type variable bound: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        throw new IllegalStateException(&quot;An upper bound wildcard cannot be the owner of a nested type: &quot; + this);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type representation of a tokenized wildcard with an upper bound.
&nbsp;                     */
&nbsp;                    protected static class LazyUpperBoundWildcard extends Generic.OfWildcardType {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable source for locating type variables.
&nbsp;                         */
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type path.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type annotations.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A tokenized representation of this wildcard&#39;s bound.
&nbsp;                         */
&nbsp;                        private final GenericTypeToken boundTypeToken;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new lazy upper bound wildcard.
&nbsp;                         *
&nbsp;                         * @param typePool           The type pool to use.
&nbsp;                         * @param typeVariableSource The type variable source for locating type variables.
&nbsp;                         * @param typePath           This type&#39;s type path.
&nbsp;                         * @param annotationTokens   This type&#39;s type annotations.
&nbsp;                         * @param boundTypeToken     A tokenized representation of this wildcard&#39;s bound.
&nbsp;                         */
&nbsp;                        protected LazyUpperBoundWildcard(TypePool typePool,
&nbsp;                                                         TypeVariableSource typeVariableSource,
&nbsp;                                                         String typePath,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                         GenericTypeToken boundTypeToken) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typeVariableSource = typeVariableSource;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.boundTypeToken = boundTypeToken;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic getUpperBounds() {
&nbsp;                            return new LazyTokenList.ForWildcardBound(typePool, typeVariableSource, typePath, annotationTokens, boundTypeToken);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic getLowerBounds() {
&nbsp;                            return new TypeList.Generic.Empty();
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token that represents a parameterized type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForParameterizedType implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the parameterized type&#39;s erasure.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of tokens that represent the parameters of the represented type.
&nbsp;                     */
&nbsp;                    private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a type token that represents a parameterized type.
&nbsp;                     *
&nbsp;                     * @param name                The name of the parameterized type&#39;s erasure.
&nbsp;                     * @param parameterTypeTokens A list of tokens that represent the parameters of the represented type.
&nbsp;                     */
&nbsp;                    protected ForParameterizedType(String name, List&lt;GenericTypeToken&gt; parameterTypeTokens) {
&nbsp;                        this.name = name;
&nbsp;                        this.parameterTypeTokens = parameterTypeTokens;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic toGenericType(TypePool typePool, TypeVariableSource typeVariableSource, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                        return new LazyParameterizedType(typePool, typeVariableSource, typePath, annotationTokens, name, parameterTypeTokens);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                        return !typePool.describe(name).resolve().isInterface();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getTypePathPrefix() {
&nbsp;                        return String.valueOf(INNER_CLASS_PATH);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type token to describe a parameterized type description with a generic owner type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    public static class Nested implements GenericTypeToken {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The name of the parameterized type&#39;s erasure.
&nbsp;                         */
&nbsp;                        private final String name;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A list of tokens that represent the parameters of the represented type.
&nbsp;                         */
&nbsp;                        private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A token that describes the described parameterized type&#39;s owner type.
&nbsp;                         */
&nbsp;                        private final GenericTypeToken ownerTypeToken;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a type token that represents a parameterized type.
&nbsp;                         *
&nbsp;                         * @param name                The name of the parameterized type&#39;s erasure.
&nbsp;                         * @param parameterTypeTokens A list of tokens that represent the parameters of the represented type.
&nbsp;                         * @param ownerTypeToken      A token that describes the described parameterized type&#39;s owner type.
&nbsp;                         */
&nbsp;                        protected Nested(String name, List&lt;GenericTypeToken&gt; parameterTypeTokens, GenericTypeToken ownerTypeToken) {
&nbsp;                            this.name = name;
&nbsp;                            this.parameterTypeTokens = parameterTypeTokens;
&nbsp;                            this.ownerTypeToken = ownerTypeToken;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic toGenericType(TypePool typePool,
&nbsp;                                                     TypeVariableSource typeVariableSource,
&nbsp;                                                     String typePath,
&nbsp;                                                     Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
&nbsp;                            return new LazyParameterizedType(typePool, typeVariableSource, typePath, annotationTokens, name, parameterTypeTokens, ownerTypeToken);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public String getTypePathPrefix() {
&nbsp;                            return ownerTypeToken.getTypePathPrefix() + INNER_CLASS_PATH;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public boolean isPrimaryBound(TypePool typePool) {
&nbsp;                            return !typePool.describe(name).resolve().isInterface();
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A lazy description of a parameterized type with an owner type.
&nbsp;                         */
&nbsp;                        protected static class LazyParameterizedType extends Generic.OfParameterizedType {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type pool that is used for locating a generic type.
&nbsp;                             */
&nbsp;                            private final TypePool typePool;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable source to use for resolving type variables.
&nbsp;                             */
&nbsp;                            private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                            /**
&nbsp;                             * This type&#39;s type path.
&nbsp;                             */
&nbsp;                            private final String typePath;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A mapping of type annotations for this type.
&nbsp;                             */
&nbsp;                            private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The binary name of this parameterized type&#39;s raw type.
&nbsp;                             */
&nbsp;                            private final String name;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Tokens that represent this parameterized type&#39;s parameters.
&nbsp;                             */
&nbsp;                            private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A token that represents this type&#39;s owner type.
&nbsp;                             */
&nbsp;                            private final GenericTypeToken ownerTypeToken;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new lazy parameterized type.
&nbsp;                             *
&nbsp;                             * @param typePool            The type pool that is used for locating a generic type.
&nbsp;                             * @param typeVariableSource  The type variable source to use for resolving type variables.
&nbsp;                             * @param typePath            This type&#39;s type path.
&nbsp;                             * @param annotationTokens    A mapping of type annotations for this type.
&nbsp;                             * @param name                The binary name of this parameterized type&#39;s raw type.
&nbsp;                             * @param parameterTypeTokens Tokens that represent this parameterized type&#39;s parameters.
&nbsp;                             * @param ownerTypeToken      A token that represents this type&#39;s owner type.
&nbsp;                             */
&nbsp;                            protected LazyParameterizedType(TypePool typePool,
&nbsp;                                                            TypeVariableSource typeVariableSource,
&nbsp;                                                            String typePath,
&nbsp;                                                            Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                            String name,
&nbsp;                                                            List&lt;GenericTypeToken&gt; parameterTypeTokens,
&nbsp;                                                            GenericTypeToken ownerTypeToken) {
&nbsp;                                this.typePool = typePool;
&nbsp;                                this.typeVariableSource = typeVariableSource;
&nbsp;                                this.typePath = typePath;
&nbsp;                                this.annotationTokens = annotationTokens;
&nbsp;                                this.name = name;
&nbsp;                                this.parameterTypeTokens = parameterTypeTokens;
&nbsp;                                this.ownerTypeToken = ownerTypeToken;
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeDescription asErasure() {
&nbsp;                                return typePool.describe(name).resolve();
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeList.Generic getTypeArguments() {
&nbsp;                                return new LazyTokenList(typePool, typeVariableSource, typePath + ownerTypeToken.getTypePathPrefix(), annotationTokens, parameterTypeTokens);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public Generic getOwnerType() {
&nbsp;                                return ownerTypeToken.toGenericType(typePool, typeVariableSource, typePath, annotationTokens);
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public AnnotationList getDeclaredAnnotations() {
&nbsp;                                return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath + ownerTypeToken.getTypePathPrefix()));
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type description that represents a parameterized type &lt;b&gt;without&lt;/b&gt; an enclosing generic owner type.
&nbsp;                     */
&nbsp;                    protected static class LazyParameterizedType extends Generic.OfParameterizedType {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool that is used for locating a generic type.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable source to use for resolving type variables.
&nbsp;                         */
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type path.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A mapping of the represent type&#39;s annotation tokens.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The binary name of the raw type.
&nbsp;                         */
&nbsp;                        private final String name;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A list of type tokens representing this type&#39;s bounds.
&nbsp;                         */
&nbsp;                        private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new description of a parameterized type.
&nbsp;                         *
&nbsp;                         * @param typePool            The type pool that is used for locating a generic type.
&nbsp;                         * @param typeVariableSource  The type variable source to use for resolving type variables.
&nbsp;                         * @param typePath            This type&#39;s type path.
&nbsp;                         * @param annotationTokens    A mapping of the represent type&#39;s annotation tokens,
&nbsp;                         * @param name                The binary name of the raw type.
&nbsp;                         * @param parameterTypeTokens A list of type tokens representing this type&#39;s bounds.
&nbsp;                         */
&nbsp;                        protected LazyParameterizedType(TypePool typePool,
&nbsp;                                                        TypeVariableSource typeVariableSource,
&nbsp;                                                        String typePath,
&nbsp;                                                        Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                        String name,
&nbsp;                                                        List&lt;GenericTypeToken&gt; parameterTypeTokens) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typeVariableSource = typeVariableSource;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.name = name;
&nbsp;                            this.parameterTypeTokens = parameterTypeTokens;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeDescription asErasure() {
&nbsp;                            return typePool.describe(name).resolve();
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList.Generic getTypeArguments() {
&nbsp;                            return new LazyTokenList(typePool, typeVariableSource, typePath, annotationTokens, parameterTypeTokens);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic getOwnerType() {
&nbsp;                            TypeDescription ownerType = typePool.describe(name).resolve().getEnclosingType();
&nbsp;                            return ownerType == null
&nbsp;                                    ? Generic.UNDEFINED
&nbsp;                                    : ownerType.asGenericType();
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy list of type tokens.
&nbsp;                 */
&nbsp;                class LazyTokenList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type pool that is used for locating a generic type.
&nbsp;                     */
&nbsp;                    private final TypePool typePool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type variable source to use for resolving type variables.
&nbsp;                     */
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented types&#39; type path to which an index step is added upon resolution.
&nbsp;                     */
&nbsp;                    private final String typePath;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of the represent types&#39; annotation tokens.
&nbsp;                     */
&nbsp;                    private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of type tokens this list represents.
&nbsp;                     */
&nbsp;                    private final List&lt;GenericTypeToken&gt; genericTypeTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new type list that represents a list of tokenized types.
&nbsp;                     *
&nbsp;                     * @param typePool           The type pool that is used for locating a generic type.
&nbsp;                     * @param typeVariableSource The type variable source to use for resolving type variables.
&nbsp;                     * @param typePath           The represented types&#39; type path to which an index step is added upon resolution.
&nbsp;                     * @param annotationTokens   A mapping of the represent types&#39; annotation tokens,
&nbsp;                     * @param genericTypeTokens  A list of type tokens this list represents.
&nbsp;                     */
&nbsp;                    protected LazyTokenList(TypePool typePool,
&nbsp;                                            TypeVariableSource typeVariableSource,
&nbsp;                                            String typePath,
&nbsp;                                            Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                            List&lt;GenericTypeToken&gt; genericTypeTokens) {
&nbsp;                        this.typePool = typePool;
&nbsp;                        this.typeVariableSource = typeVariableSource;
&nbsp;                        this.typePath = typePath;
&nbsp;                        this.annotationTokens = annotationTokens;
&nbsp;                        this.genericTypeTokens = genericTypeTokens;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic get(int index) {
&nbsp;                        return genericTypeTokens.get(index).toGenericType(typePool, typeVariableSource, typePath + index + INDEXED_TYPE_DELIMITER, annotationTokens);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int size() {
&nbsp;                        return genericTypeTokens.size();
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type description representing a tokenized wildcard bound.
&nbsp;                     */
&nbsp;                    protected static class ForWildcardBound extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool that is used for locating a generic type.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable source to use for resolving type variables.
&nbsp;                         */
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented types&#39; type path to which a wildcard step is added upon resolution.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A mapping of the represent types&#39; annotation tokens.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A token representing the wildcard&#39;s bound.
&nbsp;                         */
&nbsp;                        private final GenericTypeToken genericTypeToken;
&nbsp;
&nbsp;                        /**
&nbsp;                         * @param typePool           The type pool that is used for locating a generic type.
&nbsp;                         * @param typeVariableSource The type variable source to use for resolving type variables.
&nbsp;                         * @param typePath           The represented types&#39; type path to which a wildcard step is added upon resolution.
&nbsp;                         * @param annotationTokens   A mapping of the represent types&#39; annotation tokens,
&nbsp;                         * @param genericTypeToken   A token representing the wildcard&#39;s bound.
&nbsp;                         */
&nbsp;                        protected ForWildcardBound(TypePool typePool,
&nbsp;                                                   TypeVariableSource typeVariableSource,
&nbsp;                                                   String typePath,
&nbsp;                                                   Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                   GenericTypeToken genericTypeToken) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.typeVariableSource = typeVariableSource;
&nbsp;                            this.typePath = typePath;
&nbsp;                            this.annotationTokens = annotationTokens;
&nbsp;                            this.genericTypeToken = genericTypeToken;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic get(int index) {
&nbsp;                            if (index == 0) {
&nbsp;                                return genericTypeToken.toGenericType(typePool, typeVariableSource, typePath + WILDCARD_TYPE_PATH, annotationTokens);
&nbsp;                            } else {
&nbsp;                                throw new IndexOutOfBoundsException(&quot;index = &quot; + index);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public int size() {
&nbsp;                            return 1;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A token for representing collected data on an annotation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class AnnotationToken {
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor of the represented annotation.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * A map of annotation value names to their value representations.
&nbsp;                 */
&nbsp;                private final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation token.
&nbsp;                 *
&nbsp;                 * @param descriptor The descriptor of the represented annotation.
&nbsp;                 * @param values     A map of annotation value names to their value representations.
&nbsp;                 */
&nbsp;                protected AnnotationToken(String descriptor, Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values) {
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.values = values;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a map of annotation value names to their value representations.
&nbsp;                 *
&nbsp;                 * @return A map of annotation value names to their value representations.
&nbsp;                 */
&nbsp;                protected Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; getValues() {
&nbsp;                    return values;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the annotation type&#39;s binary name.
&nbsp;                 *
&nbsp;                 * @return The annotation type&#39;s binary name.
&nbsp;                 */
&nbsp;                protected String getBinaryName() {
&nbsp;                    return descriptor.substring(1, descriptor.length() - 1).replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Transforms this token into an annotation description.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to be used for looking up linked types.
&nbsp;                 * @return An optional description of this annotation&#39;s token.
&nbsp;                 */
&nbsp;                private Resolution toAnnotationDescription(TypePool typePool) {
&nbsp;                    TypePool.Resolution resolution = typePool.describe(getBinaryName());
&nbsp;                    return resolution.isResolved()
&nbsp;                            ? new Resolution.Simple(new LazyAnnotationDescription(typePool, resolution.resolve(), values))
&nbsp;                            : new Resolution.Illegal(getBinaryName());
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolution for an annotation tokens. Any annotation is suppressed if its type is not available.
&nbsp;                 * This conforms to the handling of the Java reflection API.
&nbsp;                 */
&nbsp;                protected interface Resolution {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns {@code true} if the represented annotation could be resolved.
&nbsp;                     *
&nbsp;                     * @return {@code true} if the represented annotation could be resolved.
&nbsp;                     */
&nbsp;                    boolean isResolved();
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the resolved annotation. This method throws an exception if this instance is not resolved.
&nbsp;                     *
&nbsp;                     * @return The resolved annotation. This method throws an exception if this instance is not resolved.
&nbsp;                     */
&nbsp;                    AnnotationDescription resolve();
&nbsp;
&nbsp;                    /**
&nbsp;                     * A simple resolved annotation.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class Simple implements Resolution {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented annotation description.
&nbsp;                         */
&nbsp;                        private final AnnotationDescription annotationDescription;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new simple resolution.
&nbsp;                         *
&nbsp;                         * @param annotationDescription The represented annotation description.
&nbsp;                         */
&nbsp;                        protected Simple(AnnotationDescription annotationDescription) {
&nbsp;                            this.annotationDescription = annotationDescription;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public boolean isResolved() {
&nbsp;                            return true;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationDescription resolve() {
&nbsp;                            return annotationDescription;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An illegal resolution.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class Illegal implements Resolution {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The annotation&#39;s binary type name.
&nbsp;                         */
&nbsp;                        private final String annotationType;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new illegal resolution.
&nbsp;                         *
&nbsp;                         * @param annotationType The annotation&#39;s binary type name.
&nbsp;                         */
&nbsp;                        public Illegal(String annotationType) {
&nbsp;                            this.annotationType = annotationType;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public boolean isResolved() {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationDescription resolve() {
&nbsp;                            throw new IllegalStateException(&quot;Annotation type is not available: &quot; + annotationType);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A token for representing collected data on a field.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class FieldToken {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * The modifiers of the represented field.
&nbsp;                 */
&nbsp;                private final int modifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor of the field.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field&#39;s generic signature as found in the class file or {@code null} if the field is not generic.
&nbsp;                 */
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * The resolution of this field&#39;s generic type.
&nbsp;                 */
&nbsp;                private final GenericTypeToken.Resolution.ForField signatureResolution;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the field type&#39;s type annotation tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of annotation tokens representing the annotations of the represented field.
&nbsp;                 */
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field token.
&nbsp;                 *
&nbsp;                 * @param name                 The name of the field.
&nbsp;                 * @param modifiers            The modifiers of the represented field.
&nbsp;                 * @param descriptor           The descriptor of the field.
&nbsp;                 * @param genericSignature     The field&#39;s generic signature as found in the class file or {@code null} if the field is not generic.
&nbsp;                 * @param typeAnnotationTokens A mapping of the field type&#39;s type annotation tokens.
&nbsp;                 * @param annotationTokens     A list of annotation tokens representing the annotations of the represented field.
&nbsp;                 */
&nbsp;                protected FieldToken(String name,
&nbsp;                                     int modifiers,
&nbsp;                                     String descriptor,
&nbsp;                                     String genericSignature,
&nbsp;                                     Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens,
&nbsp;                                     List&lt;AnnotationToken&gt; annotationTokens) {
&nbsp;                    this.modifiers = modifiers &amp; ~Opcodes.ACC_DEPRECATED;
&nbsp;                    this.name = name;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    signatureResolution = RAW_TYPES
&nbsp;                            ? GenericTypeToken.Resolution.Raw.INSTANCE
&nbsp;                            : GenericTypeExtractor.ForSignature.OfField.extract(genericSignature);
&nbsp;                    this.typeAnnotationTokens = typeAnnotationTokens;
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Transforms this token into a lazy field description.
&nbsp;                 *
&nbsp;                 * @param lazyTypeDescription The lazy type description to attach this field description to.
&nbsp;                 * @return A field description resembling this field token.
&nbsp;                 */
&nbsp;                private LazyFieldDescription toFieldDescription(LazyTypeDescription lazyTypeDescription) {
&nbsp;                    return lazyTypeDescription.new LazyFieldDescription(name,
&nbsp;                            modifiers,
&nbsp;                            descriptor,
&nbsp;                            genericSignature,
&nbsp;                            signatureResolution,
&nbsp;                            typeAnnotationTokens,
&nbsp;                            annotationTokens);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A token for representing collected data on a method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class MethodToken {
&nbsp;
&nbsp;                /**
&nbsp;                 * The internal name of the represented method.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * The modifiers of the represented method.
&nbsp;                 */
&nbsp;                private final int modifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor of the represented method.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The methods&#39;s generic signature as found in the class file or {@code null} if the method is not generic.
&nbsp;                 */
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic type resolution of this method.
&nbsp;                 */
&nbsp;                private final GenericTypeToken.Resolution.ForMethod signatureResolution;
&nbsp;
&nbsp;                /**
&nbsp;                 * An array of internal names of the exceptions of the represented method or {@code null} if there
&nbsp;                 * are no such exceptions.
&nbsp;                 */
&nbsp;                private final String[] exceptionName;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the type variables&#39; type bounds&#39; type annotation tokens by their indices and each variable&#39;s index.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the return type&#39;s type variable tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the parameter types&#39; type annotation tokens by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the exception types&#39; type annotation tokens by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the receiver type&#39;s annotation tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of annotation tokens that are present on the represented method.
&nbsp;                 */
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A map of parameter indices to tokens that represent their annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of tokens describing meta data of the method&#39;s parameters.
&nbsp;                 */
&nbsp;                private final List&lt;ParameterToken&gt; parameterTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * The default value of this method or {@code null} if there is no such value.
&nbsp;                 */
&nbsp;                private final AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new method token.
&nbsp;                 *
&nbsp;                 * @param name                              The name of the method.
&nbsp;                 * @param modifiers                         The modifiers of the represented method.
&nbsp;                 * @param descriptor                        The descriptor of the represented method.
&nbsp;                 * @param genericSignature                  The methods&#39;s generic signature as found in the class file or {@code null} if the method is not generic.
&nbsp;                 * @param exceptionName                     An array of internal names of the exceptions of the represented method or {@code null} if
&nbsp;                 *                                          there are no such exceptions.
&nbsp;                 * @param typeVariableAnnotationTokens      A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                 * @param typeVariableBoundAnnotationTokens A mapping of the type variables&#39; type bounds&#39; type annotation tokens by their
&nbsp;                 *                                          index and each variable&#39;s index.
&nbsp;                 * @param returnTypeAnnotationTokens        A mapping of the return type&#39;s type variable tokens.
&nbsp;                 * @param parameterTypeAnnotationTokens     A mapping of the parameter types&#39; type annotation tokens by their indices.
&nbsp;                 * @param exceptionTypeAnnotationTokens     A mapping of the exception types&#39; type annotation tokens by their indices.
&nbsp;                 * @param receiverTypeAnnotationTokens      A mapping of the receiver type&#39;s annotation tokens.
&nbsp;                 * @param annotationTokens                  A list of annotation tokens that are present on the represented method.
&nbsp;                 * @param parameterAnnotationTokens         A map of parameter indices to tokens that represent their annotations.
&nbsp;                 * @param parameterTokens                   A list of tokens describing meta data of the method&#39;s parameters.
&nbsp;                 * @param defaultValue                      The default value of this method or {@code null} if there is no such value.
&nbsp;                 */
&nbsp;                protected MethodToken(String name,
&nbsp;                                      int modifiers,
&nbsp;                                      String descriptor,
&nbsp;                                      String genericSignature,
&nbsp;                                      String[] exceptionName,
&nbsp;                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens,
&nbsp;                                      Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens,
&nbsp;                                      Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens,
&nbsp;                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens,
&nbsp;                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens,
&nbsp;                                      Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens,
&nbsp;                                      List&lt;AnnotationToken&gt; annotationTokens,
&nbsp;                                      Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens,
&nbsp;                                      List&lt;ParameterToken&gt; parameterTokens,
&nbsp;                                      AnnotationValue&lt;?, ?&gt; defaultValue) {
&nbsp;                    this.modifiers = modifiers &amp; ~Opcodes.ACC_DEPRECATED;
&nbsp;                    this.name = name;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    signatureResolution = RAW_TYPES
&nbsp;                            ? GenericTypeToken.Resolution.Raw.INSTANCE
&nbsp;                            : GenericTypeExtractor.ForSignature.OfMethod.extract(genericSignature);
&nbsp;                    this.exceptionName = exceptionName;
&nbsp;                    this.typeVariableAnnotationTokens = typeVariableAnnotationTokens;
&nbsp;                    this.typeVariableBoundAnnotationTokens = typeVariableBoundAnnotationTokens;
&nbsp;                    this.returnTypeAnnotationTokens = returnTypeAnnotationTokens;
&nbsp;                    this.parameterTypeAnnotationTokens = parameterTypeAnnotationTokens;
&nbsp;                    this.exceptionTypeAnnotationTokens = exceptionTypeAnnotationTokens;
&nbsp;                    this.receiverTypeAnnotationTokens = receiverTypeAnnotationTokens;
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                    this.parameterAnnotationTokens = parameterAnnotationTokens;
&nbsp;                    this.parameterTokens = parameterTokens;
&nbsp;                    this.defaultValue = defaultValue;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Transforms this method token to a method description that is attached to a lazy type description.
&nbsp;                 *
&nbsp;                 * @param lazyTypeDescription The lazy type description to attach this method description to.
&nbsp;                 * @return A method description representing this field token.
&nbsp;                 */
&nbsp;                private MethodDescription.InDefinedShape toMethodDescription(LazyTypeDescription lazyTypeDescription) {
&nbsp;                    return lazyTypeDescription.new LazyMethodDescription(name,
&nbsp;                            modifiers,
&nbsp;                            descriptor,
&nbsp;                            genericSignature,
&nbsp;                            signatureResolution,
&nbsp;                            exceptionName,
&nbsp;                            typeVariableAnnotationTokens,
&nbsp;                            typeVariableBoundAnnotationTokens,
&nbsp;                            returnTypeAnnotationTokens,
&nbsp;                            parameterTypeAnnotationTokens,
&nbsp;                            exceptionTypeAnnotationTokens,
&nbsp;                            receiverTypeAnnotationTokens,
&nbsp;                            annotationTokens,
&nbsp;                            parameterAnnotationTokens,
&nbsp;                            parameterTokens,
&nbsp;                            defaultValue);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A token representing a method&#39;s parameter.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class ParameterToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Donates an unknown name of a parameter.
&nbsp;                     */
&nbsp;                    protected static final String NO_NAME = null;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Donates an unknown modifier of a parameter.
&nbsp;                     */
&nbsp;                    protected static final Integer NO_MODIFIERS = null;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the parameter or {@code null} if no explicit name for this parameter is known.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The modifiers of the parameter or {@code null} if no modifiers are known for this parameter.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                    private final Integer modifiers;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a parameter token for a parameter without an explicit name and without specific modifiers.
&nbsp;                     */
&nbsp;                    protected ParameterToken() {
&nbsp;                        this(NO_NAME);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a parameter token for a parameter with an explicit name and without specific modifiers.
&nbsp;                     *
&nbsp;                     * @param name The name of the parameter.
&nbsp;                     */
&nbsp;                    protected ParameterToken(String name) {
&nbsp;                        this(name, NO_MODIFIERS);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a parameter token for a parameter with an explicit name and with specific modifiers.
&nbsp;                     *
&nbsp;                     * @param name      The name of the parameter.
&nbsp;                     * @param modifiers The modifiers of the parameter.
&nbsp;                     */
&nbsp;                    protected ParameterToken(String name, Integer modifiers) {
&nbsp;                        this.name = name;
&nbsp;                        this.modifiers = modifiers;
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the name of the parameter or {@code null} if there is no such name.
&nbsp;                     *
&nbsp;                     * @return The name of the parameter or {@code null} if there is no such name.
&nbsp;                     */
&nbsp;                    protected String getName() {
&nbsp;                        return name;
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the modifiers of the parameter or {@code null} if no modifiers are known.
&nbsp;                     *
&nbsp;                     * @return The modifiers of the parameter or {@code null} if no modifiers are known.
&nbsp;                     */
&nbsp;                    protected Integer getModifiers() {
&nbsp;                        return modifiers;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy description of an annotation that looks up types from a type pool when required.
&nbsp;             */
&nbsp;            private static class LazyAnnotationDescription extends AnnotationDescription.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type pool for looking up type references.
&nbsp;                 */
&nbsp;                protected final TypePool typePool;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type of this annotation.
&nbsp;                 */
&nbsp;                private final TypeDescription annotationType;
&nbsp;
&nbsp;                /**
&nbsp;                 * A map of annotation values by their property name.
&nbsp;                 */
&nbsp;                protected final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy annotation description.
&nbsp;                 *
&nbsp;                 * @param typePool       The type pool to be used for looking up linked types.
&nbsp;                 * @param annotationType The annotation&#39;s type.
&nbsp;                 * @param values         A map of annotation value names to their value representations.
&nbsp;                 */
&nbsp;                private LazyAnnotationDescription(TypePool typePool, TypeDescription annotationType, Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values) {
&nbsp;                    this.typePool = typePool;
&nbsp;                    this.annotationType = annotationType;
&nbsp;                    this.values = values;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a list of annotation tokens in form of a list of lazy type annotations. Any annotation with
&nbsp;                 * a type that cannot be loaded from the type pool is ignored and not included in the list. If the provided
&nbsp;                 * {@code tokens} are {@code null}, an empty list is returned.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to be used for looking up linked types.
&nbsp;                 * @param tokens   The tokens to represent in the list.
&nbsp;                 * @return A list of the loadable annotations.
&nbsp;                 */
&nbsp;                protected static AnnotationList asListOfNullable(TypePool typePool, List&lt;? extends AnnotationToken&gt; tokens) {
&nbsp;                    return tokens == null
&nbsp;                            ? new AnnotationList.Empty()
&nbsp;                            : asList(typePool, tokens);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a list of annotation tokens in form of a list of lazy type annotations. Any annotation with
&nbsp;                 * a type that cannot be loaded from the type pool is ignored and not included in the list.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to be used for looking up linked types.
&nbsp;                 * @param tokens   The tokens to represent in the list.
&nbsp;                 * @return A list of the loadable annotations.
&nbsp;                 */
&nbsp;                protected static AnnotationList asList(TypePool typePool, List&lt;? extends AnnotationToken&gt; tokens) {
&nbsp;                    List&lt;AnnotationDescription&gt; annotationDescriptions = new ArrayList&lt;AnnotationDescription&gt;(tokens.size());
&nbsp;                    for (AnnotationToken token : tokens) {
&nbsp;                        AnnotationToken.Resolution resolution = token.toAnnotationDescription(typePool);
&nbsp;                        if (resolution.isResolved()) {
&nbsp;                            annotationDescriptions.add(resolution.resolve());
&nbsp;                        }
&nbsp;                    }
&nbsp;                    return new AnnotationList.Explicit(annotationDescriptions);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property) {
&nbsp;                    if (!property.getDeclaringType().asErasure().equals(annotationType)) {
&nbsp;                        throw new IllegalArgumentException(property + &quot; is not declared by &quot; + getAnnotationType());
&nbsp;                    }
&nbsp;                    AnnotationValue&lt;?, ?&gt; annotationValue = values.get(property.getName());
&nbsp;                    if (annotationValue == null) {
&nbsp;                        annotationValue = getAnnotationType().getDeclaredMethods().filter(is(property)).getOnly().getDefaultValue();
&nbsp;                    }
&nbsp;                    if (annotationValue != null) {
&nbsp;                        return annotationValue;
&nbsp;                    }
&nbsp;                    throw new IllegalStateException(property + &quot; is not defined on annotation&quot;);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription getAnnotationType() {
&nbsp;                    return annotationType;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType) {
&nbsp;                    if (!this.annotationType.represents(annotationType)) {
&nbsp;                        throw new IllegalArgumentException(annotationType + &quot; does not represent &quot; + this.annotationType);
&nbsp;                    }
&nbsp;                    return new Loadable&lt;T&gt;(typePool, annotationType, values);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A loadable version of a lazy annotation description.
&nbsp;                 *
&nbsp;                 * @param &lt;S&gt; The annotation type.
&nbsp;                 */
&nbsp;                private static class Loadable&lt;S extends Annotation&gt; extends LazyAnnotationDescription implements AnnotationDescription.Loadable&lt;S&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The loaded annotation type.
&nbsp;                     */
&nbsp;                    private final Class&lt;S&gt; annotationType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new loadable version of a lazy annotation.
&nbsp;                     *
&nbsp;                     * @param typePool       The type pool to be used for looking up linked types.
&nbsp;                     * @param annotationType The annotation&#39;s loaded type.
&nbsp;                     * @param values         A map of annotation value names to their value representations.
&nbsp;                     */
&nbsp;                    private Loadable(TypePool typePool, Class&lt;S&gt; annotationType, Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values) {
&nbsp;                        super(typePool, ForLoadedType.of(annotationType), values);
&nbsp;                        this.annotationType = annotationType;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public S load() throws ClassNotFoundException {
&nbsp;                        return AnnotationInvocationHandler.of(annotationType.getClassLoader(), annotationType, values);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public S loadSilent() {
&nbsp;                        try {
&nbsp;                            return load();
&nbsp;                        } catch (ClassNotFoundException exception) {
&nbsp;                            throw new IllegalStateException(&quot;Could not load annotation type or referenced type&quot;, exception);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation of a {@link PackageDescription} that only
&nbsp;             * loads its annotations on requirement.
&nbsp;             */
&nbsp;            private static class LazyPackageDescription extends PackageDescription.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type pool to use for look-ups.
&nbsp;                 */
&nbsp;                private final TypePool typePool;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the package.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy package description.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to use for look-ups.
&nbsp;                 * @param name     The name of the package.
&nbsp;                 */
&nbsp;                private LazyPackageDescription(TypePool typePool, String name) {
&nbsp;                    this.typePool = typePool;
&nbsp;                    this.name = name;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    Resolution resolution = typePool.describe(name + &quot;.&quot; + PackageDescription.PACKAGE_CLASS_NAME);
&nbsp;                    return resolution.isResolved()
&nbsp;                            ? resolution.resolve().getDeclaredAnnotations()
&nbsp;                            : new AnnotationList.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getName() {
&nbsp;                    return name;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A list that is constructing {@link LazyTypeDescription}s.
&nbsp;             */
&nbsp;            private static class LazyTypeList extends TypeList.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type pool to use for locating types.
&nbsp;                 */
&nbsp;                private final TypePool typePool;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of type descriptors that this list represents.
&nbsp;                 */
&nbsp;                private final List&lt;String&gt; descriptors;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a list of lazy type descriptions.
&nbsp;                 *
&nbsp;                 * @param typePool    The type pool to use for locating types.
&nbsp;                 * @param descriptors A list of type descriptors that this list represents.
&nbsp;                 */
&nbsp;                private LazyTypeList(TypePool typePool, List&lt;String&gt; descriptors) {
&nbsp;                    this.typePool = typePool;
&nbsp;                    this.descriptors = descriptors;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription get(int index) {
&nbsp;                    return TokenizedGenericType.toErasure(typePool, descriptors.get(index));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int size() {
&nbsp;                    return descriptors.size();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String[] toInternalNames() {
&nbsp;                    String[] internalName = new String[descriptors.size()];
&nbsp;                    int index = 0;
&nbsp;                    for (String descriptor : descriptors) {
&nbsp;                        internalName[index++] = Type.getType(descriptor).getInternalName();
&nbsp;                    }
&nbsp;                    return internalName.length == 0
&nbsp;                            ? NO_INTERFACES
&nbsp;                            : internalName;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int getStackSize() {
&nbsp;                    int stackSize = 0;
&nbsp;                    for (String descriptor : descriptors) {
&nbsp;                        stackSize += Type.getType(descriptor).getSize();
&nbsp;                    }
&nbsp;                    return stackSize;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A representation of a generic type that is described by a {@link GenericTypeToken}.
&nbsp;             */
&nbsp;            private static class TokenizedGenericType extends Generic.LazyProjection.WithEagerNavigation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type pool to use for locating referenced types.
&nbsp;                 */
&nbsp;                private final TypePool typePool;
&nbsp;
&nbsp;                /**
&nbsp;                 * The token that describes the represented generic type.
&nbsp;                 */
&nbsp;                private final GenericTypeToken genericTypeToken;
&nbsp;
&nbsp;                /**
&nbsp;                 * A descriptor of the generic type&#39;s raw type.
&nbsp;                 */
&nbsp;                private final String rawTypeDescriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The tokenized type&#39;s type annotation tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * The closest type variable source of this generic type&#39;s declaration context.
&nbsp;                 */
&nbsp;                private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new tokenized generic type.
&nbsp;                 *
&nbsp;                 * @param typePool           The type pool to use for locating referenced types.
&nbsp;                 * @param genericTypeToken   The token that describes the represented generic type.
&nbsp;                 * @param rawTypeDescriptor  A descriptor of the generic type&#39;s erasure.
&nbsp;                 * @param annotationTokens   The tokenized type&#39;s type annotation tokens.
&nbsp;                 * @param typeVariableSource The closest type variable source of this generic type&#39;s declaration context.
&nbsp;                 */
&nbsp;                protected TokenizedGenericType(TypePool typePool,
&nbsp;                                               GenericTypeToken genericTypeToken,
&nbsp;                                               String rawTypeDescriptor,
&nbsp;                                               Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                               TypeVariableSource typeVariableSource) {
&nbsp;                    this.typePool = typePool;
&nbsp;                    this.genericTypeToken = genericTypeToken;
&nbsp;                    this.rawTypeDescriptor = rawTypeDescriptor;
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                    this.typeVariableSource = typeVariableSource;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new generic type description for a tokenized generic type.
&nbsp;                 *
&nbsp;                 * @param typePool           The type pool to use for locating referenced types.
&nbsp;                 * @param genericTypeToken   The token that describes the represented generic type.
&nbsp;                 * @param rawTypeDescriptor  A descriptor of the generic type&#39;s erasure.
&nbsp;                 * @param annotationTokens   The tokenized type&#39;s type annotation tokens or {@code null} if no such annotations are defined.
&nbsp;                 * @param typeVariableSource The closest type variable source of this generic type&#39;s declaration context.
&nbsp;                 * @return A suitable generic type.
&nbsp;                 */
&nbsp;                protected static Generic of(TypePool typePool,
&nbsp;                                            GenericTypeToken genericTypeToken,
&nbsp;                                            String rawTypeDescriptor,
&nbsp;                                            Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                            TypeVariableSource typeVariableSource) {
&nbsp;                    return new TokenizedGenericType(typePool,
&nbsp;                            genericTypeToken,
&nbsp;                            rawTypeDescriptor,
&nbsp;                            annotationTokens == null
&nbsp;                                    ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()
&nbsp;                                    : annotationTokens,
&nbsp;                            typeVariableSource);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a type description from a descriptor by looking up the corresponding type.
&nbsp;                 *
&nbsp;                 * @param typePool   The type pool to use for locating a type.
&nbsp;                 * @param descriptor The descriptor to interpret.
&nbsp;                 * @return A description of the type represented by the descriptor.
&nbsp;                 */
&nbsp;                protected static TypeDescription toErasure(TypePool typePool, String descriptor) {
&nbsp;                    Type type = Type.getType(descriptor);
&nbsp;                    return typePool.describe(type.getSort() == Type.ARRAY
&nbsp;                            ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;)
&nbsp;                            : type.getClassName()).resolve();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic resolve() {
&nbsp;                    return genericTypeToken.toGenericType(typePool, typeVariableSource, GenericTypeToken.EMPTY_TYPE_PATH, annotationTokens);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return toErasure(typePool, rawTypeDescriptor);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return resolve().getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A tokenized list of generic types.
&nbsp;                 */
&nbsp;                protected static class TokenList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type pool to use for locating types.
&nbsp;                     */
&nbsp;                    private final TypePool typePool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Type tokens that describe the represented generic types.
&nbsp;                     */
&nbsp;                    private final List&lt;GenericTypeToken&gt; genericTypeTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of the generic types&#39; erasures.
&nbsp;                     */
&nbsp;                    private final List&lt;String&gt; rawTypeDescriptors;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The closest type variable source of this generic type&#39;s declaration context.
&nbsp;                     */
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of each type&#39;s type annotation tokens by its index.
&nbsp;                     */
&nbsp;                    private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a list of tokenized generic types.
&nbsp;                     *
&nbsp;                     * @param typePool           The type pool to use for locating type descriptions.
&nbsp;                     * @param genericTypeTokens  A list of tokens describing the represented generic types.
&nbsp;                     * @param annotationTokens   A mapping of each type&#39;s type annotation tokens by its index.
&nbsp;                     * @param rawTypeDescriptors A list of the generic types&#39; erasures.
&nbsp;                     * @param typeVariableSource The closest type variable source of this generic type&#39;s declaration context.
&nbsp;                     */
&nbsp;                    private TokenList(TypePool typePool,
&nbsp;                                      List&lt;GenericTypeToken&gt; genericTypeTokens,
&nbsp;                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                      List&lt;String&gt; rawTypeDescriptors,
&nbsp;                                      TypeVariableSource typeVariableSource) {
&nbsp;                        this.typePool = typePool;
&nbsp;                        this.genericTypeTokens = genericTypeTokens;
&nbsp;                        this.annotationTokens = annotationTokens;
&nbsp;                        this.rawTypeDescriptors = rawTypeDescriptors;
&nbsp;                        this.typeVariableSource = typeVariableSource;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic get(int index) {
&nbsp;                        return rawTypeDescriptors.size() == genericTypeTokens.size()
&nbsp;                                ? TokenizedGenericType.of(typePool, genericTypeTokens.get(index), rawTypeDescriptors.get(index), annotationTokens.get(index), typeVariableSource)
&nbsp;                                : TokenizedGenericType.toErasure(typePool, rawTypeDescriptors.get(index)).asGenericType();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int size() {
&nbsp;                        return rawTypeDescriptors.size();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeList asErasures() {
&nbsp;                        return new LazyTypeList(typePool, rawTypeDescriptors);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of tokenized type variables.
&nbsp;                 */
&nbsp;                protected static class TypeVariableList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type pool to use for locating types.
&nbsp;                     */
&nbsp;                    private final TypePool typePool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Type tokens that describe the represented type variables.
&nbsp;                     */
&nbsp;                    private final List&lt;GenericTypeToken.OfFormalTypeVariable&gt; typeVariables;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type variable source of the represented type variables.
&nbsp;                     */
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                     */
&nbsp;                    private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of the type variables&#39; bound types&#39; annotation tokens by their indices and each type variable&#39;s index..
&nbsp;                     */
&nbsp;                    private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a list of type variables.
&nbsp;                     *
&nbsp;                     * @param typePool              The type pool to use for locating types.
&nbsp;                     * @param typeVariables         Type tokens that describe the represented generic types.
&nbsp;                     * @param typeVariableSource    The type variable source of the represented type variables.
&nbsp;                     * @param annotationTokens      A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                     * @param boundAnnotationTokens A mapping of the type variables&#39; bound types&#39; annotation tokens by their indices
&nbsp;                     *                              and each type variable&#39;s index.
&nbsp;                     */
&nbsp;                    protected TypeVariableList(TypePool typePool,
&nbsp;                                               List&lt;GenericTypeToken.OfFormalTypeVariable&gt; typeVariables,
&nbsp;                                               TypeVariableSource typeVariableSource,
&nbsp;                                               Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                               Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
&nbsp;                        this.typePool = typePool;
&nbsp;                        this.typeVariables = typeVariables;
&nbsp;                        this.typeVariableSource = typeVariableSource;
&nbsp;                        this.annotationTokens = annotationTokens;
&nbsp;                        this.boundAnnotationTokens = boundAnnotationTokens;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic get(int index) {
&nbsp;                        return typeVariables.get(index).toGenericType(typePool, typeVariableSource, annotationTokens.get(index), boundAnnotationTokens.get(index));
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int size() {
&nbsp;                        return typeVariables.size();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy description of a non-well-defined described generic type.
&nbsp;                 */
&nbsp;                protected static class Malformed extends LazyProjection.WithEagerNavigation {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type pool to use for locating types.
&nbsp;                     */
&nbsp;                    private final TypePool typePool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The descriptor of the type erasure.
&nbsp;                     */
&nbsp;                    private final String rawTypeDescriptor;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a lazy description of a non-well-defined described generic type.
&nbsp;                     *
&nbsp;                     * @param typePool          The type pool to use for locating types.
&nbsp;                     * @param rawTypeDescriptor The descriptor of the type erasure.
&nbsp;                     */
&nbsp;                    protected Malformed(TypePool typePool, String rawTypeDescriptor) {
&nbsp;                        this.typePool = typePool;
&nbsp;                        this.rawTypeDescriptor = rawTypeDescriptor;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic resolve() {
&nbsp;                        throw new GenericSignatureFormatError();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeDescription asErasure() {
&nbsp;                        return toErasure(typePool, rawTypeDescriptor);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        throw new GenericSignatureFormatError();
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A tokenized list of non-well-defined generic types.
&nbsp;                     */
&nbsp;                    protected static class TokenList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use for locating types.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A list of descriptors of the list&#39;s types&#39; erasures.
&nbsp;                         */
&nbsp;                        private final List&lt;String&gt; rawTypeDescriptors;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new tokenized list of generic types.
&nbsp;                         *
&nbsp;                         * @param typePool           The type pool to use for locating types.
&nbsp;                         * @param rawTypeDescriptors A list of descriptors of the list&#39;s types&#39; erasures.
&nbsp;                         */
&nbsp;                        protected TokenList(TypePool typePool, List&lt;String&gt; rawTypeDescriptors) {
&nbsp;                            this.typePool = typePool;
&nbsp;                            this.rawTypeDescriptors = rawTypeDescriptors;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic get(int index) {
&nbsp;                            return new Malformed(typePool, rawTypeDescriptors.get(index));
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public int size() {
&nbsp;                            return rawTypeDescriptors.size();
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public TypeList asErasures() {
&nbsp;                            return new LazyTypeList(typePool, rawTypeDescriptors);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy field description that only resolved type references when required.
&nbsp;             */
&nbsp;            private class LazyFieldDescription extends FieldDescription.InDefinedShape.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * The modifiers of the field.
&nbsp;                 */
&nbsp;                private final int modifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor of this field&#39;s type.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field&#39;s generic signature as found in the class file or {@code null} if the field is not generic.
&nbsp;                 */
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolution of this field&#39;s generic type.
&nbsp;                 */
&nbsp;                private final GenericTypeToken.Resolution.ForField signatureResolution;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the field type&#39;s type annotation tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of annotation descriptions of this field.
&nbsp;                 */
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy field description.
&nbsp;                 *
&nbsp;                 * @param name                 The name of the field.
&nbsp;                 * @param modifiers            The modifiers of the field.
&nbsp;                 * @param descriptor           The descriptor of this field&#39;s type.
&nbsp;                 * @param genericSignature     The field&#39;s generic signature as found in the class file or {@code null} if the field is not generic.
&nbsp;                 * @param signatureResolution  A resolution of this field&#39;s generic type.
&nbsp;                 * @param typeAnnotationTokens A mapping of the field type&#39;s type annotation tokens.
&nbsp;                 * @param annotationTokens     A list of annotation descriptions of this field.
&nbsp;                 */
&nbsp;                private LazyFieldDescription(String name,
&nbsp;                                             int modifiers,
&nbsp;                                             String descriptor,
&nbsp;                                             String genericSignature,
&nbsp;                                             GenericTypeToken.Resolution.ForField signatureResolution,
&nbsp;                                             Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens,
&nbsp;                                             List&lt;AnnotationToken&gt; annotationTokens) {
&nbsp;                    this.modifiers = modifiers;
&nbsp;                    this.name = name;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    this.signatureResolution = signatureResolution;
&nbsp;                    this.typeAnnotationTokens = typeAnnotationTokens;
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getType() {
&nbsp;                    return signatureResolution.resolveFieldType(descriptor, typePool, typeAnnotationTokens, this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getName() {
&nbsp;                    return name;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return LazyTypeDescription.this;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int getModifiers() {
&nbsp;                    return modifiers;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getGenericSignature() {
&nbsp;                    return genericSignature;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy representation of a method that resolves references to types only on demand.
&nbsp;             */
&nbsp;            private class LazyMethodDescription extends MethodDescription.InDefinedShape.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The internal name of this method.
&nbsp;                 */
&nbsp;                private final String internalName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The modifiers of this method.
&nbsp;                 */
&nbsp;                private final int modifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor of the return type.
&nbsp;                 */
&nbsp;                private final String returnTypeDescriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method&#39;s generic signature as found in the class file or {@code null} if the method is not generic.
&nbsp;                 */
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic type token of this method.
&nbsp;                 */
&nbsp;                private final GenericTypeToken.Resolution.ForMethod signatureResolution;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of type descriptions of this method&#39;s parameters.
&nbsp;                 */
&nbsp;                private final List&lt;String&gt; parameterTypeDescriptors;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of type descriptions of this method&#39;s exception types.
&nbsp;                 */
&nbsp;                private final List&lt;String&gt; exceptionTypeDescriptors;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the type variables&#39; type bounds&#39; type annotation tokens by their indices and each variable&#39;s index.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the return type&#39;s type variable tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the parameter types&#39; type annotation tokens by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the exception types&#39; type annotation tokens by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the receiver type&#39;s type annotation tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation tokens representing the method&#39;s annotations.
&nbsp;                 */
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation tokens representing the parameter&#39;s annotation. Every index can
&nbsp;                 * contain {@code null} if a parameter does not define any annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * An array of parameter names which may be {@code null} if no explicit name is known for a parameter.
&nbsp;                 */
&nbsp;                private final String[] parameterNames;
&nbsp;
&nbsp;                /**
&nbsp;                 * An array of parameter modifiers which may be {@code null} if no modifiers is known.
&nbsp;                 */
&nbsp;                private final Integer[] parameterModifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The default value of this method or {@code null} if no such value exists.
&nbsp;                 */
&nbsp;                private final AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy method description.
&nbsp;                 *
&nbsp;                 * @param internalName                      The internal name of this method.
&nbsp;                 * @param modifiers                         The modifiers of the represented method.
&nbsp;                 * @param descriptor                        The method descriptor of this method.
&nbsp;                 * @param genericSignature                  The method&#39;s generic signature as found in the class file or {@code null} if the method is not generic.
&nbsp;                 * @param signatureResolution               The generic type token of this method.
&nbsp;                 * @param exceptionTypeInternalName         The internal names of the exceptions that are declared by this
&nbsp;                 *                                          method or {@code null} if no exceptions are declared by this
&nbsp;                 *                                          method.
&nbsp;                 * @param typeVariableAnnotationTokens      A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                 * @param typeVariableBoundAnnotationTokens A mapping of the type variables&#39; type bounds&#39; type annotation tokens by their
&nbsp;                 *                                          index and each variable&#39;s index.
&nbsp;                 * @param returnTypeAnnotationTokens        A mapping of the return type&#39;s type variable tokens.
&nbsp;                 * @param parameterTypeAnnotationTokens     A mapping of the parameter types&#39; type annotation tokens by their indices.
&nbsp;                 * @param exceptionTypeAnnotationTokens     A mapping of the exception types&#39; type annotation tokens by their indices.
&nbsp;                 * @param receiverTypeAnnotationTokens      A mapping of the receiver type&#39;s type annotation tokens.
&nbsp;                 * @param annotationTokens                  The annotation tokens representing the method&#39;s annotations.
&nbsp;                 * @param parameterAnnotationTokens         The annotation tokens representing the parameter&#39;s annotation. Every
&nbsp;                 *                                          index can contain {@code null} if a parameter does not define any annotations.
&nbsp;                 * @param parameterTokens                   A list of parameter tokens which might be empty or even out of sync
&nbsp;                 *                                          with the actual parameters if the debugging information found in a
&nbsp;                 *                                          class was corrupt.
&nbsp;                 * @param defaultValue                      The default value of this method or {@code null} if there is no
&nbsp;                 */
&nbsp;                private LazyMethodDescription(String internalName,
&nbsp;                                              int modifiers,
&nbsp;                                              String descriptor,
&nbsp;                                              String genericSignature,
&nbsp;                                              GenericTypeToken.Resolution.ForMethod signatureResolution,
&nbsp;                                              String[] exceptionTypeInternalName,
&nbsp;                                              Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens,
&nbsp;                                              Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens,
&nbsp;                                              Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens,
&nbsp;                                              Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens,
&nbsp;                                              Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens,
&nbsp;                                              Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens,
&nbsp;                                              List&lt;AnnotationToken&gt; annotationTokens,
&nbsp;                                              Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens,
&nbsp;                                              List&lt;MethodToken.ParameterToken&gt; parameterTokens,
&nbsp;                                              AnnotationValue&lt;?, ?&gt; defaultValue) {
&nbsp;                    this.modifiers = modifiers;
&nbsp;                    this.internalName = internalName;
&nbsp;                    Type methodType = Type.getMethodType(descriptor);
&nbsp;                    Type returnType = methodType.getReturnType();
&nbsp;                    Type[] parameterType = methodType.getArgumentTypes();
&nbsp;                    returnTypeDescriptor = returnType.getDescriptor();
&nbsp;                    parameterTypeDescriptors = new ArrayList&lt;String&gt;(parameterType.length);
&nbsp;                    for (Type type : parameterType) {
&nbsp;                        parameterTypeDescriptors.add(type.getDescriptor());
&nbsp;                    }
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    this.signatureResolution = signatureResolution;
&nbsp;                    if (exceptionTypeInternalName == null) {
&nbsp;                        exceptionTypeDescriptors = Collections.emptyList();
&nbsp;                    } else {
&nbsp;                        exceptionTypeDescriptors = new ArrayList&lt;String&gt;(exceptionTypeInternalName.length);
&nbsp;                        for (String anExceptionTypeInternalName : exceptionTypeInternalName) {
&nbsp;                            exceptionTypeDescriptors.add(Type.getObjectType(anExceptionTypeInternalName).getDescriptor());
&nbsp;                        }
&nbsp;                    }
&nbsp;                    this.typeVariableAnnotationTokens = typeVariableAnnotationTokens;
&nbsp;                    this.typeVariableBoundAnnotationTokens = typeVariableBoundAnnotationTokens;
&nbsp;                    this.returnTypeAnnotationTokens = returnTypeAnnotationTokens;
&nbsp;                    this.parameterTypeAnnotationTokens = parameterTypeAnnotationTokens;
&nbsp;                    this.exceptionTypeAnnotationTokens = exceptionTypeAnnotationTokens;
&nbsp;                    this.receiverTypeAnnotationTokens = receiverTypeAnnotationTokens;
&nbsp;                    this.annotationTokens = annotationTokens;
&nbsp;                    this.parameterAnnotationTokens = parameterAnnotationTokens;
&nbsp;                    parameterNames = new String[parameterType.length];
&nbsp;                    parameterModifiers = new Integer[parameterType.length];
&nbsp;                    if (parameterTokens.size() == parameterType.length) {
&nbsp;                        int index = 0;
&nbsp;                        for (MethodToken.ParameterToken parameterToken : parameterTokens) {
&nbsp;                            parameterNames[index] = parameterToken.getName();
&nbsp;                            parameterModifiers[index] = parameterToken.getModifiers();
&nbsp;                            index++;
&nbsp;                        }
&nbsp;                    }
&nbsp;                    this.defaultValue = defaultValue;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getReturnType() {
&nbsp;                    return signatureResolution.resolveReturnType(returnTypeDescriptor, typePool, returnTypeAnnotationTokens, this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getExceptionTypes() {
&nbsp;                    return signatureResolution.resolveExceptionTypes(exceptionTypeDescriptors, typePool, exceptionTypeAnnotationTokens, this);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                    return new LazyParameterList();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return LazyAnnotationDescription.asList(typePool, annotationTokens);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getInternalName() {
&nbsp;                    return internalName;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return LazyTypeDescription.this;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int getModifiers() {
&nbsp;                    return modifiers;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return signatureResolution.resolveTypeVariables(typePool, this, typeVariableAnnotationTokens, typeVariableBoundAnnotationTokens);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                    return defaultValue;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Generic getReceiverType() {
&nbsp;                    if (isStatic()) {
&nbsp;                        return Generic.UNDEFINED;
&nbsp;                    } else if (isConstructor()) {
&nbsp;                        TypeDescription declaringType = getDeclaringType(), enclosingDeclaringType = declaringType.getEnclosingType();
&nbsp;                        if (enclosingDeclaringType == null) {
&nbsp;                            return declaringType.isGenerified()
&nbsp;                                    ? new LazyParameterizedReceiverType(declaringType)
&nbsp;                                    : new LazyNonGenericReceiverType(declaringType);
&nbsp;                        } else {
&nbsp;                            return !declaringType.isStatic() &amp;&amp; declaringType.isGenerified()
&nbsp;                                    ? new LazyParameterizedReceiverType(enclosingDeclaringType)
&nbsp;                                    : new LazyNonGenericReceiverType(enclosingDeclaringType);
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        return LazyTypeDescription.this.isGenerified()
&nbsp;                                ? new LazyParameterizedReceiverType()
&nbsp;                                : new LazyNonGenericReceiverType();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String getGenericSignature() {
&nbsp;                    return genericSignature;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy list of parameter descriptions for the enclosing method description.
&nbsp;                 */
&nbsp;                private class LazyParameterList extends ParameterList.AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;                    @Override
&nbsp;                    public ParameterDescription.InDefinedShape get(int index) {
&nbsp;                        return new LazyParameterDescription(index);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean hasExplicitMetaData() {
&nbsp;                        for (int i = 0; i &lt; size(); i++) {
&nbsp;                            if (parameterNames[i] == null || parameterModifiers[i] == null) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        }
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int size() {
&nbsp;                        return parameterTypeDescriptors.size();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeList.Generic asTypeList() {
&nbsp;                        return signatureResolution.resolveParameterTypes(parameterTypeDescriptors, typePool, parameterTypeAnnotationTokens, LazyMethodDescription.this);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy description of a parameters of the enclosing method.
&nbsp;                 */
&nbsp;                private class LazyParameterDescription extends ParameterDescription.InDefinedShape.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The index of the described parameter.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new description for a given parameter of the enclosing method.
&nbsp;                     *
&nbsp;                     * @param index The index of the described parameter.
&nbsp;                     */
&nbsp;                    protected LazyParameterDescription(int index) {
&nbsp;                        this.index = index;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public MethodDescription.InDefinedShape getDeclaringMethod() {
&nbsp;                        return LazyMethodDescription.this;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int getIndex() {
&nbsp;                        return index;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean isNamed() {
&nbsp;                        return parameterNames[index] != null;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public boolean hasModifiers() {
&nbsp;                        return parameterModifiers[index] != null;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getName() {
&nbsp;                        return isNamed()
&nbsp;                                ? parameterNames[index]
&nbsp;                                : super.getName();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int getModifiers() {
&nbsp;                        return hasModifiers()
&nbsp;                                ? parameterModifiers[index]
&nbsp;                                : super.getModifiers();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic getType() {
&nbsp;                        return signatureResolution.resolveParameterTypes(parameterTypeDescriptors, typePool, parameterTypeAnnotationTokens, LazyMethodDescription.this).get(index);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return LazyAnnotationDescription.asListOfNullable(typePool, parameterAnnotationTokens.get(index));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy description of a parameterized receiver type.
&nbsp;                 */
&nbsp;                private class LazyParameterizedReceiverType extends Generic.OfParameterizedType {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The erasure of the type to be represented as a parameterized receiver type.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy parameterized receiver type of the method&#39;s declaring type.
&nbsp;                     */
&nbsp;                    protected LazyParameterizedReceiverType() {
&nbsp;                        this(LazyTypeDescription.this);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy parameterized receiver type of the supplied receiver type.
&nbsp;                     *
&nbsp;                     * @param typeDescription The erasure of the type to be represented as a parameterized receiver type.
&nbsp;                     */
&nbsp;                    protected LazyParameterizedReceiverType(TypeDescription typeDescription) {
&nbsp;                        this.typeDescription = typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeList.Generic getTypeArguments() {
&nbsp;                        return new TypeArgumentList(typeDescription.getTypeVariables());
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic getOwnerType() {
&nbsp;                        TypeDescription declaringType = typeDescription.getDeclaringType();
&nbsp;                        if (declaringType == null) {
&nbsp;                            return Generic.UNDEFINED;
&nbsp;                        } else {
&nbsp;                            return !typeDescription.isStatic() &amp;&amp; declaringType.isGenerified()
&nbsp;                                    ? new LazyParameterizedReceiverType(declaringType)
&nbsp;                                    : new LazyNonGenericReceiverType(declaringType);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return LazyAnnotationDescription.asListOfNullable(typePool, receiverTypeAnnotationTokens.get(getTypePath()));
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the type path for this type.
&nbsp;                     *
&nbsp;                     * @return This type&#39;s type path.
&nbsp;                     */
&nbsp;                    private String getTypePath() {
&nbsp;                        StringBuilder typePath = new StringBuilder();
&nbsp;                        for (int index = 0; index &lt; typeDescription.getInnerClassCount(); index++) {
&nbsp;                            typePath = typePath.append(GenericTypeToken.INNER_CLASS_PATH);
&nbsp;                        }
&nbsp;                        return typePath.toString();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeDescription asErasure() {
&nbsp;                        return typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of generic types representing the receiver type&#39;s type arguments.
&nbsp;                     */
&nbsp;                    protected class TypeArgumentList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variables of the represented receiver type.
&nbsp;                         */
&nbsp;                        private final List&lt;? extends Generic&gt; typeVariables;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new type argument list.
&nbsp;                         *
&nbsp;                         * @param typeVariables The type variables of the represented receiver type.
&nbsp;                         */
&nbsp;                        protected TypeArgumentList(List&lt;? extends Generic&gt; typeVariables) {
&nbsp;                            this.typeVariables = typeVariables;
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public Generic get(int index) {
&nbsp;                            return new AnnotatedTypeVariable(typeVariables.get(index), index);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public int size() {
&nbsp;                            return typeVariables.size();
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Represents a type variable as a type argument with type annotations.
&nbsp;                         */
&nbsp;                        protected class AnnotatedTypeVariable extends OfTypeVariable {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable&#39;s description.
&nbsp;                             */
&nbsp;                            private final Generic typeVariable;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable&#39;s index.
&nbsp;                             */
&nbsp;                            private final int index;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new description of an annotated type variable as a type argument.
&nbsp;                             *
&nbsp;                             * @param typeVariable The type variable&#39;s description.
&nbsp;                             * @param index        The type variable&#39;s index.
&nbsp;                             */
&nbsp;                            protected AnnotatedTypeVariable(Generic typeVariable, int index) {
&nbsp;                                this.typeVariable = typeVariable;
&nbsp;                                this.index = index;
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeList.Generic getUpperBounds() {
&nbsp;                                return typeVariable.getUpperBounds();
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public TypeVariableSource getTypeVariableSource() {
&nbsp;                                return typeVariable.getTypeVariableSource();
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public String getSymbol() {
&nbsp;                                return typeVariable.getSymbol();
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public AnnotationList getDeclaredAnnotations() {
&nbsp;                                return LazyAnnotationDescription.asListOfNullable(typePool, receiverTypeAnnotationTokens.get(getTypePath()
&nbsp;                                        + index
&nbsp;                                        + GenericTypeToken.INDEXED_TYPE_DELIMITER));
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy description of a non-generic receiver type.
&nbsp;                 */
&nbsp;                protected class LazyNonGenericReceiverType extends Generic.OfNonGenericType {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type description of the non-generic receiver type.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new non-generic receiver type of the method&#39;s declaring type.
&nbsp;                     */
&nbsp;                    protected LazyNonGenericReceiverType() {
&nbsp;                        this(LazyTypeDescription.this);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new non-generic receiver type of the supplied type.
&nbsp;                     *
&nbsp;                     * @param typeDescription The type to represent as a non-generic receiver type.
&nbsp;                     */
&nbsp;                    protected LazyNonGenericReceiverType(TypeDescription typeDescription) {
&nbsp;                        this.typeDescription = typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic getOwnerType() {
&nbsp;                        TypeDescription declaringType = typeDescription.getDeclaringType();
&nbsp;                        return declaringType == null
&nbsp;                                ? Generic.UNDEFINED
&nbsp;                                : new LazyNonGenericReceiverType(declaringType);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Generic getComponentType() {
&nbsp;                        return Generic.UNDEFINED;
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        StringBuilder typePath = new StringBuilder();
&nbsp;                        for (int index = 0; index &lt; typeDescription.getInnerClassCount(); index++) {
&nbsp;                            typePath = typePath.append(GenericTypeToken.INNER_CLASS_PATH);
&nbsp;                        }
&nbsp;                        return LazyAnnotationDescription.asListOfNullable(typePool, receiverTypeAnnotationTokens.get(typePath.toString()));
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public TypeDescription asErasure() {
&nbsp;                        return typeDescription;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type extractor reads a class file and collects data that is relevant to create a type description.
&nbsp;         */
&nbsp;        protected class TypeExtractor extends ClassVisitor {
&nbsp;
&nbsp;            /**
&nbsp;             * A mask that cuts off pseudo flags beyond the second byte that are inserted by ASM.
&nbsp;             */
&nbsp;            private static final int REAL_MODIFIER_MASK = 0xFFFF;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of the super types&#39; type annotation tokens by their indices.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; superTypeAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of the type variables&#39; bounds&#39; type annotation tokens by their indices and each variables index.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundsAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of annotation tokens describing annotations that are found on the visited type.
&nbsp;             */
&nbsp;            private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of field tokens describing fields that are found on the visited type.
&nbsp;             */
&nbsp;            private final List&lt;LazyTypeDescription.FieldToken&gt; fieldTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of method tokens describing annotations that are found on the visited type.
&nbsp;             */
&nbsp;            private final List&lt;LazyTypeDescription.MethodToken&gt; methodTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * The actual modifiers found for this type.
&nbsp;             */
&nbsp;            private int actualModifiers;
&nbsp;
&nbsp;            /**
&nbsp;             * The modifiers found for this type.
&nbsp;             */
&nbsp;            private int modifiers;
&nbsp;
&nbsp;            /**
&nbsp;             * The internal name found for this type.
&nbsp;             */
&nbsp;            private String internalName;
&nbsp;
&nbsp;            /**
&nbsp;             * The internal name of the super type found for this type or {@code null} if no such type exists.
&nbsp;             */
&nbsp;            private String superClassName;
&nbsp;
&nbsp;            /**
&nbsp;             * The generic signature of the type or {@code null} if it is not generic.
&nbsp;             */
&nbsp;            private String genericSignature;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of internal names of interfaces implemented by this type or {@code null} if no interfaces
&nbsp;             * are implemented.
&nbsp;             */
&nbsp;            private String[] interfaceName;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this type was found to represent an anonymous type.
&nbsp;             */
&nbsp;            private boolean anonymousType;
&nbsp;
&nbsp;            /**
&nbsp;             * The declaration context found for this type.
&nbsp;             */
&nbsp;            private LazyTypeDescription.TypeContainment typeContainment;
&nbsp;
&nbsp;            /**
&nbsp;             * The binary name of this type&#39;s declaring type or {@code null} if no such type exists.
&nbsp;             */
&nbsp;            private String declaringTypeName;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of descriptors representing the types that are declared by the parsed type.
&nbsp;             */
&nbsp;            private final List&lt;String&gt; declaredTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new type extractor.
&nbsp;             */
&nbsp;            protected TypeExtractor() {
&nbsp;                super(OpenedClassReader.ASM_API);
&nbsp;                superTypeAnnotationTokens = new HashMap&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;();
&nbsp;                typeVariableAnnotationTokens = new HashMap&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;();
&nbsp;                typeVariableBoundsAnnotationTokens = new HashMap&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt;();
&nbsp;                annotationTokens = new ArrayList&lt;LazyTypeDescription.AnnotationToken&gt;();
&nbsp;                fieldTokens = new ArrayList&lt;LazyTypeDescription.FieldToken&gt;();
&nbsp;                methodTokens = new ArrayList&lt;LazyTypeDescription.MethodToken&gt;();
&nbsp;                anonymousType = false;
&nbsp;                typeContainment = LazyTypeDescription.TypeContainment.SelfContained.INSTANCE;
&nbsp;                declaredTypes = new ArrayList&lt;String&gt;();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP2&quot;, justification = &quot;The array is not to be modified by contract&quot;)
&nbsp;            public void visit(int classFileVersion,
&nbsp;                              int modifiers,
&nbsp;                              String internalName,
&nbsp;                              String genericSignature,
&nbsp;                              String superClassName,
&nbsp;                              String[] interfaceName) {
&nbsp;                this.modifiers = modifiers &amp; REAL_MODIFIER_MASK;
&nbsp;                actualModifiers = modifiers;
&nbsp;                this.internalName = internalName;
&nbsp;                this.genericSignature = genericSignature;
&nbsp;                this.superClassName = superClassName;
&nbsp;                this.interfaceName = interfaceName;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitOuterClass(String typeName, String methodName, String methodDescriptor) {
&nbsp;                if (methodName != null) {
&nbsp;                    typeContainment = new LazyTypeDescription.TypeContainment.WithinMethod(typeName, methodName, methodDescriptor);
&nbsp;                } else if (typeName != null) {
&nbsp;                    typeContainment = new LazyTypeDescription.TypeContainment.WithinType(typeName, true);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitInnerClass(String internalName, String outerName, String innerName, int modifiers) {
&nbsp;                if (internalName.equals(this.internalName)) {
&nbsp;                    this.modifiers = modifiers &amp; REAL_MODIFIER_MASK;
&nbsp;                    if (innerName == null) {
&nbsp;                        anonymousType = true;
&nbsp;                    }
&nbsp;                    if (outerName != null) {
&nbsp;                        declaringTypeName = outerName;
&nbsp;                        if (typeContainment.isSelfContained()) {
&nbsp;                            typeContainment = new LazyTypeDescription.TypeContainment.WithinType(outerName, false);
&nbsp;                        }
&nbsp;                    }
&nbsp;                } else if (outerName != null &amp;&amp; innerName != null &amp;&amp; internalName.equals(this.internalName + &quot;$&quot; + innerName)) {
&nbsp;                    declaredTypes.add(&quot;L&quot; + internalName + &quot;;&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath typePath, String descriptor, boolean visible) {
&nbsp;                AnnotationRegistrant annotationRegistrant;
&nbsp;                TypeReference typeReference = new TypeReference(rawTypeReference);
&nbsp;                switch (typeReference.getSort()) {
&nbsp;                    case TypeReference.CLASS_EXTENDS:
&nbsp;                        annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex(descriptor,
&nbsp;                                typePath,
&nbsp;                                typeReference.getSuperTypeIndex(),
&nbsp;                                superTypeAnnotationTokens);
&nbsp;                        break;
&nbsp;                    case TypeReference.CLASS_TYPE_PARAMETER:
&nbsp;                        annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex(descriptor,
&nbsp;                                typePath,
&nbsp;                                typeReference.getTypeParameterIndex(),
&nbsp;                                typeVariableAnnotationTokens);
&nbsp;                        break;
&nbsp;                    case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
&nbsp;                        annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex.DoubleIndexed(descriptor,
&nbsp;                                typePath,
&nbsp;                                typeReference.getTypeParameterBoundIndex(),
&nbsp;                                typeReference.getTypeParameterIndex(),
&nbsp;                                typeVariableBoundsAnnotationTokens);
&nbsp;                        break;
&nbsp;                    default:
&nbsp;                        throw new IllegalArgumentException(&quot;Unexpected type reference: &quot; + typeReference.getSort());
&nbsp;                }
&nbsp;                return new AnnotationExtractor(annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                return new AnnotationExtractor(descriptor, annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldVisitor visitField(int modifiers, String internalName, String descriptor, String genericSignature, Object defaultValue) {
&nbsp;                return new FieldExtractor(modifiers &amp; REAL_MODIFIER_MASK, internalName, descriptor, genericSignature);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, String genericSignature, String[] exceptionName) {
&nbsp;                return internalName.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)
&nbsp;                        ? IGNORE_METHOD
&nbsp;                        : new MethodExtractor(modifiers &amp; REAL_MODIFIER_MASK, internalName, descriptor, genericSignature, exceptionName);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a type description from all data that is currently collected. This method should only be invoked
&nbsp;             * after a class file was parsed fully.
&nbsp;             *
&nbsp;             * @return A type description reflecting the data that was collected by this instance.
&nbsp;             */
&nbsp;            protected TypeDescription toTypeDescription() {
&nbsp;                return new LazyTypeDescription(Default.this,
&nbsp;                        actualModifiers,
&nbsp;                        modifiers,
&nbsp;                        internalName,
&nbsp;                        superClassName,
&nbsp;                        interfaceName,
&nbsp;                        genericSignature,
&nbsp;                        typeContainment,
&nbsp;                        declaringTypeName,
&nbsp;                        declaredTypes,
&nbsp;                        anonymousType,
&nbsp;                        superTypeAnnotationTokens,
&nbsp;                        typeVariableAnnotationTokens,
&nbsp;                        typeVariableBoundsAnnotationTokens,
&nbsp;                        annotationTokens,
&nbsp;                        fieldTokens,
&nbsp;                        methodTokens);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An annotation extractor reads an annotation found in a class field an collects data that
&nbsp;             * is relevant to creating a related annotation description.
&nbsp;             */
&nbsp;            protected class AnnotationExtractor extends AnnotationVisitor {
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation registrant to register found annotation values on.
&nbsp;                 */
&nbsp;                private final AnnotationRegistrant annotationRegistrant;
&nbsp;
&nbsp;                /**
&nbsp;                 * A locator for the component type of any found annotation value.
&nbsp;                 */
&nbsp;                private final ComponentTypeLocator componentTypeLocator;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation extractor for a byte code element without an index.
&nbsp;                 *
&nbsp;                 * @param descriptor           The annotation descriptor.
&nbsp;                 * @param annotationTokens     The collection for storing any discovered annotation tokens.
&nbsp;                 * @param componentTypeLocator The component type locator to use.
&nbsp;                 */
&nbsp;                protected AnnotationExtractor(String descriptor, List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens, ComponentTypeLocator componentTypeLocator) {
&nbsp;                    this(new AnnotationRegistrant.ForByteCodeElement(descriptor, annotationTokens), componentTypeLocator);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation extractor for a byte code element with an index.
&nbsp;                 *
&nbsp;                 * @param descriptor           The annotation descriptor.
&nbsp;                 * @param index                The index of the element for which the annotations are collected.
&nbsp;                 * @param annotationTokens     The collection for storing any discovered annotation tokens.
&nbsp;                 * @param componentTypeLocator The component type locator to use.
&nbsp;                 */
&nbsp;                protected AnnotationExtractor(String descriptor,
&nbsp;                                              int index,
&nbsp;                                              Map&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                              ComponentTypeLocator componentTypeLocator) {
&nbsp;                    this(new AnnotationRegistrant.ForByteCodeElement.WithIndex(descriptor, index, annotationTokens), componentTypeLocator);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation extractor.
&nbsp;                 *
&nbsp;                 * @param annotationRegistrant The annotation registrant to register found annotation values on.
&nbsp;                 * @param componentTypeLocator A locator for the component type of any found annotation value.
&nbsp;                 */
&nbsp;                protected AnnotationExtractor(AnnotationRegistrant annotationRegistrant, ComponentTypeLocator componentTypeLocator) {
&nbsp;                    super(OpenedClassReader.ASM_API);
&nbsp;                    this.annotationRegistrant = annotationRegistrant;
&nbsp;                    this.componentTypeLocator = componentTypeLocator;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visit(String name, Object value) {
&nbsp;                    annotationRegistrant.register(name, value instanceof Type
&nbsp;                            ? new RawTypeValue(Default.this, (Type) value)
&nbsp;                            : AnnotationValue.ForConstant.of(value));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitEnum(String name, String descriptor, String value) {
&nbsp;                    annotationRegistrant.register(name, new RawEnumerationValue(Default.this, descriptor, value));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitAnnotation(String name, String descriptor) {
&nbsp;                    return new AnnotationExtractor(new AnnotationLookup(descriptor, name),
&nbsp;                            new ComponentTypeLocator.ForAnnotationProperty(TypePool.Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitArray(String name) {
&nbsp;                    return new AnnotationExtractor(new ArrayLookup(name, componentTypeLocator.bind(name)), ComponentTypeLocator.Illegal.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitEnd() {
&nbsp;                    annotationRegistrant.onComplete();
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An annotation registrant for registering values of an array.
&nbsp;                 */
&nbsp;                protected class ArrayLookup implements AnnotationRegistrant {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the annotation property the collected array is representing.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A lazy reference to resolve the component type of the collected array.
&nbsp;                     */
&nbsp;                    private final RawDescriptionArray.ComponentTypeReference componentTypeReference;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of all annotation values that are found on this array.
&nbsp;                     */
&nbsp;                    private final List&lt;AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation registrant for an array lookup.
&nbsp;                     *
&nbsp;                     * @param name                   The name of the annotation property the collected array is representing.
&nbsp;                     * @param componentTypeReference A lazy reference to resolve the component type of the collected array.
&nbsp;                     */
&nbsp;                    protected ArrayLookup(String name, RawDescriptionArray.ComponentTypeReference componentTypeReference) {
&nbsp;                        this.name = name;
&nbsp;                        this.componentTypeReference = componentTypeReference;
&nbsp;                        values = new ArrayList&lt;AnnotationValue&lt;?, ?&gt;&gt;();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void register(String ignored, AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                        values.add(annotationValue);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void onComplete() {
&nbsp;                        annotationRegistrant.register(name, new RawDescriptionArray(Default.this, componentTypeReference, values));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An annotation registrant for registering the values on an array that is itself an annotation property.
&nbsp;                 */
&nbsp;                protected class AnnotationLookup implements AnnotationRegistrant {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The descriptor of the original annotation for which the annotation values are looked up.
&nbsp;                     */
&nbsp;                    private final String descriptor;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the original annotation for which the annotation values are looked up.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * This annotation&#39;s values mapped by their attribute name.
&nbsp;                     */
&nbsp;                    private final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation registrant for a recursive annotation lookup.
&nbsp;                     *
&nbsp;                     * @param name       The name of the original annotation for which the annotation values are looked up.
&nbsp;                     * @param descriptor The descriptor of the original annotation for which the annotation values are looked up.
&nbsp;                     */
&nbsp;                    protected AnnotationLookup(String descriptor, String name) {
&nbsp;                        this.descriptor = descriptor;
&nbsp;                        this.name = name;
&nbsp;                        values = new HashMap&lt;String, AnnotationValue&lt;?, ?&gt;&gt;();
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void register(String name, AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                        values.put(name, annotationValue);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void onComplete() {
&nbsp;                        annotationRegistrant.register(name, new RawAnnotationValue(Default.this, new LazyTypeDescription.AnnotationToken(descriptor, values)));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A field extractor reads a field within a class file and collects data that is relevant
&nbsp;             * to creating a related field description.
&nbsp;             */
&nbsp;            protected class FieldExtractor extends FieldVisitor {
&nbsp;
&nbsp;                /**
&nbsp;                 * The modifiers found on the field.
&nbsp;                 */
&nbsp;                private final int modifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                private final String internalName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor of the field type.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic signature of the field or {@code null} if it is not generic.
&nbsp;                 */
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the field type&#39;s type annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of annotation tokens found for this field.
&nbsp;                 */
&nbsp;                private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field extractor.
&nbsp;                 *
&nbsp;                 * @param modifiers        The modifiers found for this field.
&nbsp;                 * @param internalName     The name of the field.
&nbsp;                 * @param descriptor       The descriptor of the field type.
&nbsp;                 * @param genericSignature The generic signature of the field or {@code null} if it is not generic.
&nbsp;                 */
&nbsp;                protected FieldExtractor(int modifiers,
&nbsp;                                         String internalName,
&nbsp;                                         String descriptor,
&nbsp;                                         String genericSignature) {
&nbsp;                    super(OpenedClassReader.ASM_API);
&nbsp;                    this.modifiers = modifiers;
&nbsp;                    this.internalName = internalName;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    typeAnnotationTokens = new HashMap&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;();
&nbsp;                    annotationTokens = new ArrayList&lt;LazyTypeDescription.AnnotationToken&gt;();
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath typePath, String descriptor, boolean visible) {
&nbsp;                    AnnotationRegistrant annotationRegistrant;
&nbsp;                    TypeReference typeReference = new TypeReference(rawTypeReference);
&nbsp;                    switch (typeReference.getSort()) {
&nbsp;                        case TypeReference.FIELD:
&nbsp;                            annotationRegistrant = new AnnotationRegistrant.ForTypeVariable(descriptor, typePath, typeAnnotationTokens);
&nbsp;                            break;
&nbsp;                        default:
&nbsp;                            throw new IllegalStateException(&quot;Unexpected type reference on field: &quot; + typeReference.getSort());
&nbsp;                    }
&nbsp;                    return new AnnotationExtractor(annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                    return new AnnotationExtractor(descriptor, annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitEnd() {
&nbsp;                    fieldTokens.add(new LazyTypeDescription.FieldToken(internalName,
&nbsp;                            modifiers,
&nbsp;                            descriptor,
&nbsp;                            genericSignature,
&nbsp;                            typeAnnotationTokens,
&nbsp;                            annotationTokens));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method extractor reads a method within a class file and collects data that is relevant
&nbsp;             * to creating a related method description.
&nbsp;             */
&nbsp;            protected class MethodExtractor extends MethodVisitor implements AnnotationRegistrant {
&nbsp;
&nbsp;                /**
&nbsp;                 * The modifiers found for this method.
&nbsp;                 */
&nbsp;                private final int modifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The internal name found for this method.
&nbsp;                 */
&nbsp;                private final String internalName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor found for this method.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic signature of the method or {@code null} if it is not generic.
&nbsp;                 */
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * An array of internal names of the exceptions of the found method
&nbsp;                 * or {@code null} if there are no such exceptions.
&nbsp;                 */
&nbsp;                private final String[] exceptionName;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the method&#39;s type variables&#39; type annotations by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the method&#39;s type variables&#39; bounds&#39; type annotations by their indices and each variable&#39;s index.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the method&#39;s return type&#39;s type annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; returnTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the parameters&#39; type annotations by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the exception types&#39; type annotations by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the receiver type&#39;s type annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; receiverTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of annotation tokens declared on the found method.
&nbsp;                 */
&nbsp;                private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of parameter indices to annotation tokens found for the parameters at these indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; parameterAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of tokens representing meta information of a parameter as it is available for method&#39;s
&nbsp;                 * that are compiled in the Java 8 version format.
&nbsp;                 */
&nbsp;                private final List&lt;LazyTypeDescription.MethodToken.ParameterToken&gt; parameterTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A bag of parameter meta information representing debugging information which allows to extract
&nbsp;                 * a method&#39;s parameter names.
&nbsp;                 */
&nbsp;                private final ParameterBag legacyParameterBag;
&nbsp;
&nbsp;                /**
&nbsp;                 * The first label that is found in the method&#39;s body, if any, denoting the start of the method.
&nbsp;                 * This label can be used to identify names of local variables that describe the method&#39;s parameters.
&nbsp;                 */
&nbsp;                private Label firstLabel;
&nbsp;
&nbsp;                /**
&nbsp;                 * A shift index for visible parameters that indicates a deviation of the actual parameter index.
&nbsp;                 */
&nbsp;                private int visibleParameterShift;
&nbsp;
&nbsp;                /**
&nbsp;                 * A shift index for invisible parameters that indicates a deviation of the actual parameter index.
&nbsp;                 */
&nbsp;                private int invisibleParameterShift;
&nbsp;
&nbsp;                /**
&nbsp;                 * The default value of the found method or {@code null} if no such value exists.
&nbsp;                 */
&nbsp;                private AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a method extractor.
&nbsp;                 *
&nbsp;                 * @param modifiers        The modifiers found for this method.
&nbsp;                 * @param internalName     The internal name found for this method.
&nbsp;                 * @param descriptor       The descriptor found for this method.
&nbsp;                 * @param genericSignature The generic signature of the method or {@code null} if it is not generic.
&nbsp;                 * @param exceptionName    An array of internal names of the exceptions of the found method
&nbsp;                 *                         or {@code null} if there are no such exceptions.
&nbsp;                 */
&nbsp;                protected MethodExtractor(int modifiers,
&nbsp;                                          String internalName,
&nbsp;                                          String descriptor,
&nbsp;                                          String genericSignature,
&nbsp;                                          String[] exceptionName) {
&nbsp;                    super(OpenedClassReader.ASM_API);
&nbsp;                    this.modifiers = modifiers;
&nbsp;                    this.internalName = internalName;
&nbsp;                    this.descriptor = descriptor;
&nbsp;                    this.genericSignature = genericSignature;
&nbsp;                    this.exceptionName = exceptionName;
&nbsp;                    typeVariableAnnotationTokens = new HashMap&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;();
&nbsp;                    typeVariableBoundAnnotationTokens = new HashMap&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt;();
&nbsp;                    returnTypeAnnotationTokens = new HashMap&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;();
&nbsp;                    parameterTypeAnnotationTokens = new HashMap&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;();
&nbsp;                    exceptionTypeAnnotationTokens = new HashMap&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;();
&nbsp;                    receiverTypeAnnotationTokens = new HashMap&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;();
&nbsp;                    annotationTokens = new ArrayList&lt;LazyTypeDescription.AnnotationToken&gt;();
&nbsp;                    parameterAnnotationTokens = new HashMap&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;();
&nbsp;                    parameterTokens = new ArrayList&lt;LazyTypeDescription.MethodToken.ParameterToken&gt;();
&nbsp;                    legacyParameterBag = new ParameterBag(Type.getMethodType(descriptor).getArgumentTypes());
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath typePath, String descriptor, boolean visible) {
&nbsp;                    AnnotationRegistrant annotationRegistrant;
&nbsp;                    TypeReference typeReference = new TypeReference(rawTypeReference);
&nbsp;                    switch (typeReference.getSort()) {
&nbsp;                        case TypeReference.METHOD_TYPE_PARAMETER:
&nbsp;                            annotationRegistrant = new ForTypeVariable.WithIndex(descriptor,
&nbsp;                                    typePath,
&nbsp;                                    typeReference.getTypeParameterIndex(),
&nbsp;                                    typeVariableAnnotationTokens);
&nbsp;                            break;
&nbsp;                        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
&nbsp;                            annotationRegistrant = new ForTypeVariable.WithIndex.DoubleIndexed(descriptor,
&nbsp;                                    typePath,
&nbsp;                                    typeReference.getTypeParameterBoundIndex(),
&nbsp;                                    typeReference.getTypeParameterIndex(),
&nbsp;                                    typeVariableBoundAnnotationTokens);
&nbsp;                            break;
&nbsp;                        case TypeReference.METHOD_RETURN:
&nbsp;                            annotationRegistrant = new ForTypeVariable(descriptor,
&nbsp;                                    typePath,
&nbsp;                                    returnTypeAnnotationTokens);
&nbsp;                            break;
&nbsp;                        case TypeReference.METHOD_FORMAL_PARAMETER:
&nbsp;                            annotationRegistrant = new ForTypeVariable.WithIndex(descriptor,
&nbsp;                                    typePath,
&nbsp;                                    typeReference.getFormalParameterIndex(),
&nbsp;                                    parameterTypeAnnotationTokens);
&nbsp;                            break;
&nbsp;                        case TypeReference.THROWS:
&nbsp;                            annotationRegistrant = new ForTypeVariable.WithIndex(descriptor,
&nbsp;                                    typePath,
&nbsp;                                    typeReference.getExceptionIndex(),
&nbsp;                                    exceptionTypeAnnotationTokens);
&nbsp;                            break;
&nbsp;                        case TypeReference.METHOD_RECEIVER:
&nbsp;                            annotationRegistrant = new ForTypeVariable(descriptor,
&nbsp;                                    typePath,
&nbsp;                                    receiverTypeAnnotationTokens);
&nbsp;                            break;
&nbsp;                        default:
&nbsp;                            throw new IllegalStateException(&quot;Unexpected type reference on method: &quot; + typeReference.getSort());
&nbsp;                    }
&nbsp;                    return new AnnotationExtractor(annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                    return new AnnotationExtractor(descriptor, annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitAnnotableParameterCount(int count, boolean visible) {
&nbsp;                    if (visible) {
&nbsp;                        visibleParameterShift = Type.getMethodType(descriptor).getArgumentTypes().length - count;
&nbsp;                    } else {
&nbsp;                        invisibleParameterShift = Type.getMethodType(descriptor).getArgumentTypes().length - count;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
&nbsp;                    return new AnnotationExtractor(descriptor,
&nbsp;                            index + (visible ? visibleParameterShift : invisibleParameterShift),
&nbsp;                            parameterAnnotationTokens,
&nbsp;                            new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitLabel(Label label) {
&nbsp;                    if (readerMode.isExtended() &amp;&amp; firstLabel == null) {
&nbsp;                        firstLabel = label;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int index) {
&nbsp;                    if (readerMode.isExtended() &amp;&amp; start == firstLabel) {
&nbsp;                        legacyParameterBag.register(index, name);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitParameter(String name, int modifiers) {
&nbsp;                    parameterTokens.add(new LazyTypeDescription.MethodToken.ParameterToken(name, modifiers));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitAnnotationDefault() {
&nbsp;                    return new AnnotationExtractor(this, new ComponentTypeLocator.ForArrayType(descriptor));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void register(String ignored, AnnotationValue&lt;?, ?&gt; annotationValue) {
&nbsp;                    defaultValue = annotationValue;
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onComplete() {
&nbsp;                    /* do nothing, as the register method is called at most once for default values */
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitEnd() {
&nbsp;                    methodTokens.add(new LazyTypeDescription.MethodToken(internalName,
&nbsp;                            modifiers,
&nbsp;                            descriptor,
&nbsp;                            genericSignature,
&nbsp;                            exceptionName,
&nbsp;                            typeVariableAnnotationTokens,
&nbsp;                            typeVariableBoundAnnotationTokens,
&nbsp;                            returnTypeAnnotationTokens,
&nbsp;                            parameterTypeAnnotationTokens,
&nbsp;                            exceptionTypeAnnotationTokens,
&nbsp;                            receiverTypeAnnotationTokens,
&nbsp;                            annotationTokens,
&nbsp;                            parameterAnnotationTokens,
&nbsp;                            parameterTokens.isEmpty()
&nbsp;                                    ? legacyParameterBag.resolve((modifiers &amp; Opcodes.ACC_STATIC) != 0)
&nbsp;                                    : parameterTokens,
&nbsp;                            defaultValue));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A lazy facade of a type pool that delegates any lookups to another type pool only if another value than the type&#39;s name is looked up.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class LazyFacade extends AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The type pool to delegate to.
&nbsp;         */
&nbsp;        private final TypePool typePool;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a lazy facade for a type pool.
&nbsp;         *
&nbsp;         * @param typePool The type pool to delegate to.
&nbsp;         */
&nbsp;        public LazyFacade(TypePool typePool) {
&nbsp;            super(CacheProvider.NoOp.INSTANCE);
&nbsp;            this.typePool = typePool;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected Resolution doDescribe(String name) {
&nbsp;            return new LazyResolution(typePool, name);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void clear() {
&nbsp;            typePool.clear();
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The lazy resolution for a lazy facade for a type pool.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class LazyResolution implements Resolution {
&nbsp;
&nbsp;            /**
&nbsp;             * The type pool to delegate to.
&nbsp;             */
&nbsp;            private final TypePool typePool;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the type that is represented by this resolution.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a lazy resolution for a lazy facade for a type pool.
&nbsp;             *
&nbsp;             * @param typePool The type pool to delegate to.
&nbsp;             * @param name     The name of the type that is represented by this resolution.
&nbsp;             */
&nbsp;            protected LazyResolution(TypePool typePool, String name) {
&nbsp;                this.typePool = typePool;
&nbsp;                this.name = name;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isResolved() {
&nbsp;                return typePool.describe(name).isResolved();
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public TypeDescription resolve() {
&nbsp;                return new LazyTypeDescription(typePool, name);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A description of a type that delegates to another type pool once a property that is not the name is resolved.
&nbsp;         */
&nbsp;        protected static class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {
&nbsp;
&nbsp;            /**
&nbsp;             * The type pool to delegate to.
&nbsp;             */
&nbsp;            private final TypePool typePool;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the type that is represented by this resolution.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new lazy type resolution.
&nbsp;             *
&nbsp;             * @param typePool The type pool to delegate to.
&nbsp;             * @param name     The name of the type.
&nbsp;             */
&nbsp;            protected LazyTypeDescription(TypePool typePool, String name) {
&nbsp;                this.typePool = typePool;
&nbsp;                this.name = name;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getName() {
&nbsp;                return name;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected TypeDescription delegate() {
&nbsp;                return typePool.describe(name).resolve();
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type pool that attempts to load a class.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class ClassLoading extends AbstractBase.Hierarchical {
&nbsp;
&nbsp;        /**
&nbsp;         * Type-safe representation of the bootstrap class loader which is {@code null}.
&nbsp;         */
<b class="fc">&nbsp;        private static final ClassLoader BOOTSTRAP_CLASS_LOADER = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The class loader to query.
&nbsp;         */
&nbsp;        private final ClassLoader classLoader;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a class loadings type pool.
&nbsp;         *
&nbsp;         * @param cacheProvider The cache provider to use.
&nbsp;         * @param parent        The parent type pool.
&nbsp;         * @param classLoader   The class loader to use for locating files.
&nbsp;         */
&nbsp;        public ClassLoading(CacheProvider cacheProvider, TypePool parent, ClassLoader classLoader) {
<b class="fc">&nbsp;            super(cacheProvider, parent);</b>
<b class="fc">&nbsp;            this.classLoader = classLoader;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a type pool that attempts type descriptions by loadings types from the given class loader.
&nbsp;         *
&nbsp;         * @param classLoader The class loader to use.
&nbsp;         * @return An class loading type pool.
&nbsp;         */
&nbsp;        public static TypePool of(ClassLoader classLoader) {
<b class="fc">&nbsp;            return of(classLoader, Empty.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a type pool that attempts type descriptions by loadings types from the given class loader.
&nbsp;         *
&nbsp;         * @param classLoader The class loader to use.
&nbsp;         * @param parent      The parent type pool to use.
&nbsp;         * @return An class loading type pool.
&nbsp;         */
&nbsp;        public static TypePool of(ClassLoader classLoader, TypePool parent) {
<b class="fc">&nbsp;            return new ClassLoading(CacheProvider.NoOp.INSTANCE, parent, classLoader);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a type pool that attempts type descriptions by loadings types from the bootstrap class loader.
&nbsp;         *
&nbsp;         * @return An class loading type pool for the bootstrap class loader.
&nbsp;         */
&nbsp;        public static TypePool ofBootPath() {
<b class="nc">&nbsp;            return of(BOOTSTRAP_CLASS_LOADER);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a type pool that attempts type descriptions by loadings types from the system class loader.
&nbsp;         *
&nbsp;         * @return An class loading type pool for the system class loader.
&nbsp;         */
&nbsp;        public static TypePool ofClassPath() {
<b class="fc">&nbsp;            return of(ClassLoader.getSystemClassLoader());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Resolution doDescribe(String name) {
&nbsp;            try {
<b class="nc">&nbsp;                return new Resolution.Simple(TypeDescription.ForLoadedType.of(Class.forName(name, false, classLoader)));</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException ignored) {</b>
<b class="nc">&nbsp;                return new Resolution.Illegal(name);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type pool that supplies explicitly known type descriptions.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Explicit extends AbstractBase.Hierarchical {
&nbsp;
&nbsp;        /**
&nbsp;         * A mapping from type names to type descriptions of that name.
&nbsp;         */
&nbsp;        private final Map&lt;String, TypeDescription&gt; types;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new explicit type pool without a parent.
&nbsp;         *
&nbsp;         * @param types A mapping from type names to type descriptions of that name.
&nbsp;         */
&nbsp;        public Explicit(Map&lt;String, TypeDescription&gt; types) {
&nbsp;            this(Empty.INSTANCE, types);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new explicit type pool.
&nbsp;         *
&nbsp;         * @param parent The parent type pool.
&nbsp;         * @param types  A mapping from type names to type descriptions of that name.
&nbsp;         */
&nbsp;        public Explicit(TypePool parent, Map&lt;String, TypeDescription&gt; types) {
&nbsp;            super(CacheProvider.NoOp.INSTANCE, parent);
&nbsp;            this.types = types;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected Resolution doDescribe(String name) {
&nbsp;            TypeDescription typeDescription = types.get(name);
&nbsp;            return typeDescription == null
&nbsp;                    ? new Resolution.Illegal(name)
&nbsp;                    : new Resolution.Simple(typeDescription);
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
