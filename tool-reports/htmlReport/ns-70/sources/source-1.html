


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > StringUtils</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.apache.commons.lang</a>
</div>

<h1>Coverage Summary for Class: StringUtils (org.apache.commons.lang)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">StringUtils</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1,7%
  </span>
  <span class="absValue">
    (3/177)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1,1%
  </span>
  <span class="absValue">
    (12/1136)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1,9%
  </span>
  <span class="absValue">
    (23/1239)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
&nbsp; * contributor license agreements.  See the NOTICE file distributed with
&nbsp; * this work for additional information regarding copyright ownership.
&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
&nbsp; * the License.  You may obtain a copy of the License at
&nbsp; * 
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; * 
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.apache.commons.lang;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;
&nbsp;import org.apache.commons.lang.text.StrBuilder;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;Operations on {@link java.lang.String} that are
&nbsp; * &lt;code&gt;null&lt;/code&gt; safe.&lt;/p&gt;
&nbsp; *
&nbsp; * &lt;ul&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;IsEmpty/IsBlank&lt;/b&gt;
&nbsp; *      - checks if a String contains text&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;Trim/Strip&lt;/b&gt;
&nbsp; *      - removes leading and trailing whitespace&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;Equals&lt;/b&gt;
&nbsp; *      - compares two strings null-safe&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;startsWith&lt;/b&gt;
&nbsp; *      - check if a String starts with a prefix null-safe&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;endsWith&lt;/b&gt;
&nbsp; *      - check if a String ends with a suffix null-safe&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;IndexOf/LastIndexOf/Contains&lt;/b&gt;
&nbsp; *      - null-safe index-of checks
&nbsp; *  &lt;li&gt;&lt;b&gt;IndexOfAny/LastIndexOfAny/IndexOfAnyBut/LastIndexOfAnyBut&lt;/b&gt;
&nbsp; *      - index-of any of a set of Strings&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;ContainsOnly/ContainsNone/ContainsAny&lt;/b&gt;
&nbsp; *      - does String contains only/none/any of these characters&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;Substring/Left/Right/Mid&lt;/b&gt;
&nbsp; *      - null-safe substring extractions&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;SubstringBefore/SubstringAfter/SubstringBetween&lt;/b&gt;
&nbsp; *      - substring extraction relative to other strings&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;Split/Join&lt;/b&gt;
&nbsp; *      - splits a String into an array of substrings and vice versa&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;Remove/Delete&lt;/b&gt;
&nbsp; *      - removes part of a String&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;Replace/Overlay&lt;/b&gt;
&nbsp; *      - Searches a String and replaces one String with another&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;Chomp/Chop&lt;/b&gt;
&nbsp; *      - removes the last part of a String&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;LeftPad/RightPad/Center/Repeat&lt;/b&gt;
&nbsp; *      - pads a String&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;UpperCase/LowerCase/SwapCase/Capitalize/Uncapitalize&lt;/b&gt;
&nbsp; *      - changes the case of a String&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;CountMatches&lt;/b&gt;
&nbsp; *      - counts the number of occurrences of one String in another&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;IsAlpha/IsNumeric/IsWhitespace/IsAsciiPrintable&lt;/b&gt;
&nbsp; *      - checks the characters in a String&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;DefaultString&lt;/b&gt;
&nbsp; *      - protects against a null input String&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;Reverse/ReverseDelimited&lt;/b&gt;
&nbsp; *      - reverses a String&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;Abbreviate&lt;/b&gt;
&nbsp; *      - abbreviates a string using ellipsis&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;Difference&lt;/b&gt;
&nbsp; *      - compares Strings and reports on their differences&lt;/li&gt;
&nbsp; *  &lt;li&gt;&lt;b&gt;LevensteinDistance&lt;/b&gt;
&nbsp; *      - the number of changes needed to change one String into another&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;p&gt;The &lt;code&gt;StringUtils&lt;/code&gt; class defines certain words related to
&nbsp; * String handling.&lt;/p&gt;
&nbsp; *
&nbsp; * &lt;ul&gt;
&nbsp; *  &lt;li&gt;null - &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&nbsp; *  &lt;li&gt;empty - a zero-length string (&lt;code&gt;&quot;&quot;&lt;/code&gt;)&lt;/li&gt;
&nbsp; *  &lt;li&gt;space - the space character (&lt;code&gt;&#39; &#39;&lt;/code&gt;, char 32)&lt;/li&gt;
&nbsp; *  &lt;li&gt;whitespace - the characters defined by {@link Character#isWhitespace(char)}&lt;/li&gt;
&nbsp; *  &lt;li&gt;trim - the characters &amp;lt;= 32 as in {@link String#trim()}&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;p&gt;&lt;code&gt;StringUtils&lt;/code&gt; handles &lt;code&gt;null&lt;/code&gt; input Strings quietly.
&nbsp; * That is to say that a &lt;code&gt;null&lt;/code&gt; input will return &lt;code&gt;null&lt;/code&gt;.
&nbsp; * Where a &lt;code&gt;boolean&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt; is being returned
&nbsp; * details vary by method.&lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;A side effect of the &lt;code&gt;null&lt;/code&gt; handling is that a
&nbsp; * &lt;code&gt;NullPointerException&lt;/code&gt; should be considered a bug in
&nbsp; * &lt;code&gt;StringUtils&lt;/code&gt; (except for deprecated methods).&lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;Methods in this class give sample code to explain their operation.
&nbsp; * The symbol &lt;code&gt;*&lt;/code&gt; is used to indicate any input including &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;#ThreadSafe#&lt;/p&gt;
&nbsp; * @see java.lang.String
&nbsp; * @author Apache Software Foundation
&nbsp; * @author &lt;a href=&quot;http://jakarta.apache.org/turbine/&quot;&gt;Apache Jakarta Turbine&lt;/a&gt;
&nbsp; * @author &lt;a href=&quot;mailto:jon@latchkey.com&quot;&gt;Jon S. Stevens&lt;/a&gt;
&nbsp; * @author Daniel L. Rall
&nbsp; * @author &lt;a href=&quot;mailto:gcoladonato@yahoo.com&quot;&gt;Greg Coladonato&lt;/a&gt;
&nbsp; * @author &lt;a href=&quot;mailto:ed@apache.org&quot;&gt;Ed Korthof&lt;/a&gt;
&nbsp; * @author &lt;a href=&quot;mailto:rand_mcneely@yahoo.com&quot;&gt;Rand McNeely&lt;/a&gt;
&nbsp; * @author &lt;a href=&quot;mailto:fredrik@westermarck.com&quot;&gt;Fredrik Westermarck&lt;/a&gt;
&nbsp; * @author Holger Krauth
&nbsp; * @author &lt;a href=&quot;mailto:alex@purpletech.com&quot;&gt;Alexander Day Chaffee&lt;/a&gt;
&nbsp; * @author &lt;a href=&quot;mailto:hps@intermeta.de&quot;&gt;Henning P. Schmiedehausen&lt;/a&gt;
&nbsp; * @author Arun Mammen Thomas
&nbsp; * @author Gary Gregory
&nbsp; * @author Phil Steitz
&nbsp; * @author Al Chou
&nbsp; * @author Michael Davey
&nbsp; * @author Reuben Sivan
&nbsp; * @author Chris Hyzer
&nbsp; * @author Scott Johnson
&nbsp; * @since 1.0
&nbsp; * @version $Id: StringUtils.java 1058365 2011-01-13 00:04:49Z niallp $
&nbsp; */
&nbsp;//@Immutable
&nbsp;public class StringUtils {
&nbsp;    // Performance testing notes (JDK 1.4, Jul03, scolebourne)
&nbsp;    // Whitespace:
&nbsp;    // Character.isWhitespace() is faster than WHITESPACE.indexOf()
&nbsp;    // where WHITESPACE is a string of all whitespace characters
&nbsp;    //
&nbsp;    // Character access:
&nbsp;    // String.charAt(n) versus toCharArray(), then array[n]
&nbsp;    // String.charAt(n) is about 15% worse for a 10K string
&nbsp;    // They are about equal for a length 50 string
&nbsp;    // String.charAt(n) is about 4 times better for a length 3 string
&nbsp;    // String.charAt(n) is best bet overall
&nbsp;    //
&nbsp;    // Append:
&nbsp;    // String.concat about twice as fast as StringBuffer.append
&nbsp;    // (not sure who tested this)
&nbsp;
&nbsp;    /**
&nbsp;     * The empty String &lt;code&gt;&quot;&quot;&lt;/code&gt;.
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static final String EMPTY = &quot;&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a failed index search.
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public static final int INDEX_NOT_FOUND = -1;
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;The maximum size to which the padding constant(s) can expand.&lt;/p&gt;
&nbsp;     */
&nbsp;    private static final int PAD_LIMIT = 8192;
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;&lt;code&gt;StringUtils&lt;/code&gt; instances should NOT be constructed in
&nbsp;     * standard programming. Instead, the class should be used as
&nbsp;     * &lt;code&gt;StringUtils.trim(&quot; foo &quot;);&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;This constructor is public to permit tools that require a JavaBean
&nbsp;     * instance to operate.&lt;/p&gt;
&nbsp;     */
&nbsp;    public StringUtils() {
<b class="nc">&nbsp;        super();</b>
&nbsp;    }
&nbsp;
&nbsp;    // Empty checks
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if a String is empty (&quot;&quot;) or null.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isEmpty(null)      = true
&nbsp;     * StringUtils.isEmpty(&quot;&quot;)        = true
&nbsp;     * StringUtils.isEmpty(&quot; &quot;)       = false
&nbsp;     * StringUtils.isEmpty(&quot;bob&quot;)     = false
&nbsp;     * StringUtils.isEmpty(&quot;  bob  &quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;NOTE: This method changed in Lang version 2.0.
&nbsp;     * It no longer trims the String.
&nbsp;     * That functionality is available in isBlank().&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the String is empty or null
&nbsp;     */
&nbsp;    public static boolean isEmpty(String str) {
<b class="pc">&nbsp;        return str == null || str.length() == 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if a String is not empty (&quot;&quot;) and not null.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isNotEmpty(null)      = false
&nbsp;     * StringUtils.isNotEmpty(&quot;&quot;)        = false
&nbsp;     * StringUtils.isNotEmpty(&quot; &quot;)       = true
&nbsp;     * StringUtils.isNotEmpty(&quot;bob&quot;)     = true
&nbsp;     * StringUtils.isNotEmpty(&quot;  bob  &quot;) = true
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the String is not empty and not null
&nbsp;     */
&nbsp;    public static boolean isNotEmpty(String str) {
<b class="nc">&nbsp;        return !StringUtils.isEmpty(str);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if a String is whitespace, empty (&quot;&quot;) or null.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isBlank(null)      = true
&nbsp;     * StringUtils.isBlank(&quot;&quot;)        = true
&nbsp;     * StringUtils.isBlank(&quot; &quot;)       = true
&nbsp;     * StringUtils.isBlank(&quot;bob&quot;)     = false
&nbsp;     * StringUtils.isBlank(&quot;  bob  &quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the String is null, empty or whitespace
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static boolean isBlank(String str) {
&nbsp;        int strLen;
<b class="nc">&nbsp;        if (str == null || (strLen = str.length()) == 0) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; strLen; i++) {</b>
<b class="nc">&nbsp;            if ((Character.isWhitespace(str.charAt(i)) == false)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if a String is not empty (&quot;&quot;), not null and not whitespace only.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isNotBlank(null)      = false
&nbsp;     * StringUtils.isNotBlank(&quot;&quot;)        = false
&nbsp;     * StringUtils.isNotBlank(&quot; &quot;)       = false
&nbsp;     * StringUtils.isNotBlank(&quot;bob&quot;)     = true
&nbsp;     * StringUtils.isNotBlank(&quot;  bob  &quot;) = true
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the String is
&nbsp;     *  not empty and not null and not whitespace
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static boolean isNotBlank(String str) {
<b class="nc">&nbsp;        return !StringUtils.isBlank(str);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Trim
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Removes control characters (char &amp;lt;= 32) from both
&nbsp;     * ends of this String, handling &lt;code&gt;null&lt;/code&gt; by returning
&nbsp;     * an empty String (&quot;&quot;).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.clean(null)          = &quot;&quot;
&nbsp;     * StringUtils.clean(&quot;&quot;)            = &quot;&quot;
&nbsp;     * StringUtils.clean(&quot;abc&quot;)         = &quot;abc&quot;
&nbsp;     * StringUtils.clean(&quot;    abc    &quot;) = &quot;abc&quot;
&nbsp;     * StringUtils.clean(&quot;     &quot;)       = &quot;&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @see java.lang.String#trim()
&nbsp;     * @param str  the String to clean, may be null
&nbsp;     * @return the trimmed text, never &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @deprecated Use the clearer named {@link #trimToEmpty(String)}.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String clean(String str) {
<b class="nc">&nbsp;        return str == null ? EMPTY : str.trim();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Removes control characters (char &amp;lt;= 32) from both
&nbsp;     * ends of this String, handling &lt;code&gt;null&lt;/code&gt; by returning
&nbsp;     * &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The String is trimmed using {@link String#trim()}.
&nbsp;     * Trim removes start and end characters &amp;lt;= 32.
&nbsp;     * To strip whitespace use {@link #strip(String)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;To trim your choice of characters, use the
&nbsp;     * {@link #strip(String, String)} methods.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.trim(null)          = null
&nbsp;     * StringUtils.trim(&quot;&quot;)            = &quot;&quot;
&nbsp;     * StringUtils.trim(&quot;     &quot;)       = &quot;&quot;
&nbsp;     * StringUtils.trim(&quot;abc&quot;)         = &quot;abc&quot;
&nbsp;     * StringUtils.trim(&quot;    abc    &quot;) = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to be trimmed, may be null
&nbsp;     * @return the trimmed string, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String trim(String str) {
<b class="nc">&nbsp;        return str == null ? null : str.trim();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Removes control characters (char &amp;lt;= 32) from both
&nbsp;     * ends of this String returning &lt;code&gt;null&lt;/code&gt; if the String is
&nbsp;     * empty (&quot;&quot;) after the trim or if it is &lt;code&gt;null&lt;/code&gt;.
&nbsp;     *
&nbsp;     * &lt;p&gt;The String is trimmed using {@link String#trim()}.
&nbsp;     * Trim removes start and end characters &amp;lt;= 32.
&nbsp;     * To strip whitespace use {@link #stripToNull(String)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.trimToNull(null)          = null
&nbsp;     * StringUtils.trimToNull(&quot;&quot;)            = null
&nbsp;     * StringUtils.trimToNull(&quot;     &quot;)       = null
&nbsp;     * StringUtils.trimToNull(&quot;abc&quot;)         = &quot;abc&quot;
&nbsp;     * StringUtils.trimToNull(&quot;    abc    &quot;) = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to be trimmed, may be null
&nbsp;     * @return the trimmed String,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if only chars &amp;lt;= 32, empty or null String input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String trimToNull(String str) {
<b class="nc">&nbsp;        String ts = trim(str);</b>
<b class="nc">&nbsp;        return isEmpty(ts) ? null : ts;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Removes control characters (char &amp;lt;= 32) from both
&nbsp;     * ends of this String returning an empty String (&quot;&quot;) if the String
&nbsp;     * is empty (&quot;&quot;) after the trim or if it is &lt;code&gt;null&lt;/code&gt;.
&nbsp;     *
&nbsp;     * &lt;p&gt;The String is trimmed using {@link String#trim()}.
&nbsp;     * Trim removes start and end characters &amp;lt;= 32.
&nbsp;     * To strip whitespace use {@link #stripToEmpty(String)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.trimToEmpty(null)          = &quot;&quot;
&nbsp;     * StringUtils.trimToEmpty(&quot;&quot;)            = &quot;&quot;
&nbsp;     * StringUtils.trimToEmpty(&quot;     &quot;)       = &quot;&quot;
&nbsp;     * StringUtils.trimToEmpty(&quot;abc&quot;)         = &quot;abc&quot;
&nbsp;     * StringUtils.trimToEmpty(&quot;    abc    &quot;) = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to be trimmed, may be null
&nbsp;     * @return the trimmed String, or an empty String if &lt;code&gt;null&lt;/code&gt; input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String trimToEmpty(String str) {
<b class="nc">&nbsp;        return str == null ? EMPTY : str.trim();</b>
&nbsp;    }
&nbsp;
&nbsp;    // Stripping
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Strips whitespace from the start and end of a String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;This is similar to {@link #trim(String)} but removes whitespace.
&nbsp;     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.strip(null)     = null
&nbsp;     * StringUtils.strip(&quot;&quot;)       = &quot;&quot;
&nbsp;     * StringUtils.strip(&quot;   &quot;)    = &quot;&quot;
&nbsp;     * StringUtils.strip(&quot;abc&quot;)    = &quot;abc&quot;
&nbsp;     * StringUtils.strip(&quot;  abc&quot;)  = &quot;abc&quot;
&nbsp;     * StringUtils.strip(&quot;abc  &quot;)  = &quot;abc&quot;
&nbsp;     * StringUtils.strip(&quot; abc &quot;)  = &quot;abc&quot;
&nbsp;     * StringUtils.strip(&quot; ab c &quot;) = &quot;ab c&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to remove whitespace from, may be null
&nbsp;     * @return the stripped String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String strip(String str) {
<b class="nc">&nbsp;        return strip(str, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Strips whitespace from the start and end of a String  returning
&nbsp;     * &lt;code&gt;null&lt;/code&gt; if the String is empty (&quot;&quot;) after the strip.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;This is similar to {@link #trimToNull(String)} but removes whitespace.
&nbsp;     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.stripToNull(null)     = null
&nbsp;     * StringUtils.stripToNull(&quot;&quot;)       = null
&nbsp;     * StringUtils.stripToNull(&quot;   &quot;)    = null
&nbsp;     * StringUtils.stripToNull(&quot;abc&quot;)    = &quot;abc&quot;
&nbsp;     * StringUtils.stripToNull(&quot;  abc&quot;)  = &quot;abc&quot;
&nbsp;     * StringUtils.stripToNull(&quot;abc  &quot;)  = &quot;abc&quot;
&nbsp;     * StringUtils.stripToNull(&quot; abc &quot;)  = &quot;abc&quot;
&nbsp;     * StringUtils.stripToNull(&quot; ab c &quot;) = &quot;ab c&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to be stripped, may be null
&nbsp;     * @return the stripped String,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if whitespace, empty or null String input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String stripToNull(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        str = strip(str, null);</b>
<b class="nc">&nbsp;        return str.length() == 0 ? null : str;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Strips whitespace from the start and end of a String  returning
&nbsp;     * an empty String if &lt;code&gt;null&lt;/code&gt; input.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;This is similar to {@link #trimToEmpty(String)} but removes whitespace.
&nbsp;     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.stripToEmpty(null)     = &quot;&quot;
&nbsp;     * StringUtils.stripToEmpty(&quot;&quot;)       = &quot;&quot;
&nbsp;     * StringUtils.stripToEmpty(&quot;   &quot;)    = &quot;&quot;
&nbsp;     * StringUtils.stripToEmpty(&quot;abc&quot;)    = &quot;abc&quot;
&nbsp;     * StringUtils.stripToEmpty(&quot;  abc&quot;)  = &quot;abc&quot;
&nbsp;     * StringUtils.stripToEmpty(&quot;abc  &quot;)  = &quot;abc&quot;
&nbsp;     * StringUtils.stripToEmpty(&quot; abc &quot;)  = &quot;abc&quot;
&nbsp;     * StringUtils.stripToEmpty(&quot; ab c &quot;) = &quot;ab c&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to be stripped, may be null
&nbsp;     * @return the trimmed String, or an empty String if &lt;code&gt;null&lt;/code&gt; input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String stripToEmpty(String str) {
<b class="nc">&nbsp;        return str == null ? EMPTY : strip(str, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Strips any of a set of characters from the start and end of a String.
&nbsp;     * This is similar to {@link String#trim()} but allows the characters
&nbsp;     * to be stripped to be controlled.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty string (&quot;&quot;) input returns the empty string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If the stripChars String is &lt;code&gt;null&lt;/code&gt;, whitespace is
&nbsp;     * stripped as defined by {@link Character#isWhitespace(char)}.
&nbsp;     * Alternatively use {@link #strip(String)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.strip(null, *)          = null
&nbsp;     * StringUtils.strip(&quot;&quot;, *)            = &quot;&quot;
&nbsp;     * StringUtils.strip(&quot;abc&quot;, null)      = &quot;abc&quot;
&nbsp;     * StringUtils.strip(&quot;  abc&quot;, null)    = &quot;abc&quot;
&nbsp;     * StringUtils.strip(&quot;abc  &quot;, null)    = &quot;abc&quot;
&nbsp;     * StringUtils.strip(&quot; abc &quot;, null)    = &quot;abc&quot;
&nbsp;     * StringUtils.strip(&quot;  abcyx&quot;, &quot;xyz&quot;) = &quot;  abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to remove characters from, may be null
&nbsp;     * @param stripChars  the characters to remove, null treated as whitespace
&nbsp;     * @return the stripped String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String strip(String str, String stripChars) {
<b class="nc">&nbsp;        if (isEmpty(str)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        str = stripStart(str, stripChars);</b>
<b class="nc">&nbsp;        return stripEnd(str, stripChars);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Strips any of a set of characters from the start of a String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty string (&quot;&quot;) input returns the empty string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If the stripChars String is &lt;code&gt;null&lt;/code&gt;, whitespace is
&nbsp;     * stripped as defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.stripStart(null, *)          = null
&nbsp;     * StringUtils.stripStart(&quot;&quot;, *)            = &quot;&quot;
&nbsp;     * StringUtils.stripStart(&quot;abc&quot;, &quot;&quot;)        = &quot;abc&quot;
&nbsp;     * StringUtils.stripStart(&quot;abc&quot;, null)      = &quot;abc&quot;
&nbsp;     * StringUtils.stripStart(&quot;  abc&quot;, null)    = &quot;abc&quot;
&nbsp;     * StringUtils.stripStart(&quot;abc  &quot;, null)    = &quot;abc  &quot;
&nbsp;     * StringUtils.stripStart(&quot; abc &quot;, null)    = &quot;abc &quot;
&nbsp;     * StringUtils.stripStart(&quot;yxabc  &quot;, &quot;xyz&quot;) = &quot;abc  &quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to remove characters from, may be null
&nbsp;     * @param stripChars  the characters to remove, null treated as whitespace
&nbsp;     * @return the stripped String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String stripStart(String str, String stripChars) {
&nbsp;        int strLen;
<b class="nc">&nbsp;        if (str == null || (strLen = str.length()) == 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        int start = 0;</b>
<b class="nc">&nbsp;        if (stripChars == null) {</b>
<b class="nc">&nbsp;            while ((start != strLen) &amp;&amp; Character.isWhitespace(str.charAt(start))) {</b>
<b class="nc">&nbsp;                start++;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (stripChars.length() == 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            while ((start != strLen) &amp;&amp; (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {</b>
<b class="nc">&nbsp;                start++;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return str.substring(start);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Strips any of a set of characters from the end of a String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty string (&quot;&quot;) input returns the empty string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If the stripChars String is &lt;code&gt;null&lt;/code&gt;, whitespace is
&nbsp;     * stripped as defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.stripEnd(null, *)          = null
&nbsp;     * StringUtils.stripEnd(&quot;&quot;, *)            = &quot;&quot;
&nbsp;     * StringUtils.stripEnd(&quot;abc&quot;, &quot;&quot;)        = &quot;abc&quot;
&nbsp;     * StringUtils.stripEnd(&quot;abc&quot;, null)      = &quot;abc&quot;
&nbsp;     * StringUtils.stripEnd(&quot;  abc&quot;, null)    = &quot;  abc&quot;
&nbsp;     * StringUtils.stripEnd(&quot;abc  &quot;, null)    = &quot;abc&quot;
&nbsp;     * StringUtils.stripEnd(&quot; abc &quot;, null)    = &quot; abc&quot;
&nbsp;     * StringUtils.stripEnd(&quot;  abcyx&quot;, &quot;xyz&quot;) = &quot;  abc&quot;
&nbsp;     * StringUtils.stripEnd(&quot;120.00&quot;, &quot;.0&quot;)   = &quot;12&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to remove characters from, may be null
&nbsp;     * @param stripChars  the set of characters to remove, null treated as whitespace
&nbsp;     * @return the stripped String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String stripEnd(String str, String stripChars) {
&nbsp;        int end;
<b class="nc">&nbsp;        if (str == null || (end = str.length()) == 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (stripChars == null) {</b>
<b class="nc">&nbsp;            while ((end != 0) &amp;&amp; Character.isWhitespace(str.charAt(end - 1))) {</b>
<b class="nc">&nbsp;                end--;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (stripChars.length() == 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            while ((end != 0) &amp;&amp; (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {</b>
<b class="nc">&nbsp;                end--;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return str.substring(0, end);</b>
&nbsp;    }
&nbsp;
&nbsp;    // StripAll
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Strips whitespace from the start and end of every String in an array.
&nbsp;     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A new array is returned each time, except for length zero.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; array will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty array will return itself.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; array entry will be ignored.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.stripAll(null)             = null
&nbsp;     * StringUtils.stripAll([])               = []
&nbsp;     * StringUtils.stripAll([&quot;abc&quot;, &quot;  abc&quot;]) = [&quot;abc&quot;, &quot;abc&quot;]
&nbsp;     * StringUtils.stripAll([&quot;abc  &quot;, null])  = [&quot;abc&quot;, null]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param strs  the array to remove whitespace from, may be null
&nbsp;     * @return the stripped Strings, &lt;code&gt;null&lt;/code&gt; if null array input
&nbsp;     */
&nbsp;    public static String[] stripAll(String[] strs) {
<b class="nc">&nbsp;        return stripAll(strs, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Strips any of a set of characters from the start and end of every
&nbsp;     * String in an array.&lt;/p&gt;
&nbsp;     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A new array is returned each time, except for length zero.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; array will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty array will return itself.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; array entry will be ignored.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; stripChars will strip whitespace as defined by
&nbsp;     * {@link Character#isWhitespace(char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.stripAll(null, *)                = null
&nbsp;     * StringUtils.stripAll([], *)                  = []
&nbsp;     * StringUtils.stripAll([&quot;abc&quot;, &quot;  abc&quot;], null) = [&quot;abc&quot;, &quot;abc&quot;]
&nbsp;     * StringUtils.stripAll([&quot;abc  &quot;, null], null)  = [&quot;abc&quot;, null]
&nbsp;     * StringUtils.stripAll([&quot;abc  &quot;, null], &quot;yz&quot;)  = [&quot;abc  &quot;, null]
&nbsp;     * StringUtils.stripAll([&quot;yabcz&quot;, null], &quot;yz&quot;)  = [&quot;abc&quot;, null]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param strs  the array to remove characters from, may be null
&nbsp;     * @param stripChars  the characters to remove, null treated as whitespace
&nbsp;     * @return the stripped Strings, &lt;code&gt;null&lt;/code&gt; if null array input
&nbsp;     */
&nbsp;    public static String[] stripAll(String[] strs, String stripChars) {
&nbsp;        int strsLen;
<b class="nc">&nbsp;        if (strs == null || (strsLen = strs.length) == 0) {</b>
<b class="nc">&nbsp;            return strs;</b>
&nbsp;        }
<b class="nc">&nbsp;        String[] newArr = new String[strsLen];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; strsLen; i++) {</b>
<b class="nc">&nbsp;            newArr[i] = strip(strs[i], stripChars);</b>
&nbsp;        }
<b class="nc">&nbsp;        return newArr;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Equals
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Compares two Strings, returning &lt;code&gt;true&lt;/code&gt; if they are equal.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt;s are handled without exceptions. Two &lt;code&gt;null&lt;/code&gt;
&nbsp;     * references are considered to be equal. The comparison is case sensitive.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.equals(null, null)   = true
&nbsp;     * StringUtils.equals(null, &quot;abc&quot;)  = false
&nbsp;     * StringUtils.equals(&quot;abc&quot;, null)  = false
&nbsp;     * StringUtils.equals(&quot;abc&quot;, &quot;abc&quot;) = true
&nbsp;     * StringUtils.equals(&quot;abc&quot;, &quot;ABC&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @see java.lang.String#equals(Object)
&nbsp;     * @param str1  the first String, may be null
&nbsp;     * @param str2  the second String, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the Strings are equal, case sensitive, or
&nbsp;     *  both &lt;code&gt;null&lt;/code&gt;
&nbsp;     */
&nbsp;    public static boolean equals(String str1, String str2) {
<b class="nc">&nbsp;        return str1 == null ? str2 == null : str1.equals(str2);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Compares two Strings, returning &lt;code&gt;true&lt;/code&gt; if they are equal ignoring
&nbsp;     * the case.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt;s are handled without exceptions. Two &lt;code&gt;null&lt;/code&gt;
&nbsp;     * references are considered equal. Comparison is case insensitive.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.equalsIgnoreCase(null, null)   = true
&nbsp;     * StringUtils.equalsIgnoreCase(null, &quot;abc&quot;)  = false
&nbsp;     * StringUtils.equalsIgnoreCase(&quot;abc&quot;, null)  = false
&nbsp;     * StringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;abc&quot;) = true
&nbsp;     * StringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;ABC&quot;) = true
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @see java.lang.String#equalsIgnoreCase(String)
&nbsp;     * @param str1  the first String, may be null
&nbsp;     * @param str2  the second String, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the Strings are equal, case insensitive, or
&nbsp;     *  both &lt;code&gt;null&lt;/code&gt;
&nbsp;     */
&nbsp;    public static boolean equalsIgnoreCase(String str1, String str2) {
<b class="nc">&nbsp;        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);</b>
&nbsp;    }
&nbsp;
&nbsp;    // IndexOf
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Finds the first index within a String, handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#indexOf(int)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String will return &lt;code&gt;INDEX_NOT_FOUND (-1)&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOf(null, *)         = -1
&nbsp;     * StringUtils.indexOf(&quot;&quot;, *)           = -1
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &#39;a&#39;) = 0
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &#39;b&#39;) = 2
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchChar  the character to find
&nbsp;     * @return the first index of the search character,
&nbsp;     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int indexOf(String str, char searchChar) {
<b class="nc">&nbsp;        if (isEmpty(str)) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.indexOf(searchChar);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Finds the first index within a String from a start position,
&nbsp;     * handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#indexOf(int, int)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String will return &lt;code&gt;(INDEX_NOT_FOUND) -1&lt;/code&gt;.
&nbsp;     * A negative start position is treated as zero.
&nbsp;     * A start position greater than the string length returns &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOf(null, *, *)          = -1
&nbsp;     * StringUtils.indexOf(&quot;&quot;, *, *)            = -1
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &#39;b&#39;, 0)  = 2
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &#39;b&#39;, 3)  = 5
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &#39;b&#39;, 9)  = -1
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &#39;b&#39;, -1) = 2
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchChar  the character to find
&nbsp;     * @param startPos  the start position, negative treated as zero
&nbsp;     * @return the first index of the search character,
&nbsp;     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int indexOf(String str, char searchChar, int startPos) {
<b class="nc">&nbsp;        if (isEmpty(str)) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.indexOf(searchChar, startPos);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Finds the first index within a String, handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#indexOf(String)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOf(null, *)          = -1
&nbsp;     * StringUtils.indexOf(*, null)          = -1
&nbsp;     * StringUtils.indexOf(&quot;&quot;, &quot;&quot;)           = 0
&nbsp;     * StringUtils.indexOf(&quot;&quot;, *)            = -1 (except when * = &quot;&quot;)
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;a&quot;)  = 0
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;)  = 2
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;ab&quot;) = 1
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;&quot;)   = 0
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @return the first index of the search String,
&nbsp;     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int indexOf(String str, String searchStr) {
<b class="nc">&nbsp;        if (str == null || searchStr == null) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.indexOf(searchStr);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Finds the n-th index within a String, handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#indexOf(String)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.ordinalIndexOf(null, *, *)          = -1
&nbsp;     * StringUtils.ordinalIndexOf(*, null, *)          = -1
&nbsp;     * StringUtils.ordinalIndexOf(&quot;&quot;, &quot;&quot;, *)           = 0
&nbsp;     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 1)  = 0
&nbsp;     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 2)  = 1
&nbsp;     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 1)  = 2
&nbsp;     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 2)  = 5
&nbsp;     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 1) = 1
&nbsp;     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 2) = 4
&nbsp;     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;&quot;, 1)   = 0
&nbsp;     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;&quot;, 2)   = 0
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Note that &#39;head(String str, int n)&#39; may be implemented as: &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     *   str.substring(0, lastOrdinalIndexOf(str, &quot;\n&quot;, n))
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @param ordinal  the n-th &lt;code&gt;searchStr&lt;/code&gt; to find
&nbsp;     * @return the n-th index of the search String,
&nbsp;     *  &lt;code&gt;-1&lt;/code&gt; (&lt;code&gt;INDEX_NOT_FOUND&lt;/code&gt;) if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public static int ordinalIndexOf(String str, String searchStr, int ordinal) {
<b class="nc">&nbsp;        return ordinalIndexOf(str, searchStr, ordinal, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Finds the n-th index within a String, handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#indexOf(String)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @param ordinal  the n-th &lt;code&gt;searchStr&lt;/code&gt; to find
&nbsp;     * @param lastIndex true if lastOrdinalIndexOf() otherwise false if ordinalIndexOf()
&nbsp;     * @return the n-th index of the search String,
&nbsp;     *  &lt;code&gt;-1&lt;/code&gt; (&lt;code&gt;INDEX_NOT_FOUND&lt;/code&gt;) if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     */
&nbsp;    // Shared code between ordinalIndexOf(String,String,int) and lastOrdinalIndexOf(String,String,int)
&nbsp;    private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) {
<b class="nc">&nbsp;        if (str == null || searchStr == null || ordinal &lt;= 0) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (searchStr.length() == 0) {</b>
<b class="nc">&nbsp;            return lastIndex ? str.length() : 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        int found = 0;</b>
<b class="nc">&nbsp;        int index = lastIndex ? str.length() : INDEX_NOT_FOUND;</b>
&nbsp;        do {
<b class="nc">&nbsp;            if(lastIndex) {</b>
<b class="nc">&nbsp;                index = str.lastIndexOf(searchStr, index - 1);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                index = str.indexOf(searchStr, index + 1);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (index &lt; 0) {</b>
<b class="nc">&nbsp;                return index;</b>
&nbsp;            }
<b class="nc">&nbsp;            found++;</b>
<b class="nc">&nbsp;        } while (found &lt; ordinal);</b>
<b class="nc">&nbsp;        return index;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Finds the first index within a String, handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#indexOf(String, int)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A negative start position is treated as zero.
&nbsp;     * An empty (&quot;&quot;) search String always matches.
&nbsp;     * A start position greater than the string length only matches
&nbsp;     * an empty search String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOf(null, *, *)          = -1
&nbsp;     * StringUtils.indexOf(*, null, *)          = -1
&nbsp;     * StringUtils.indexOf(&quot;&quot;, &quot;&quot;, 0)           = 0
&nbsp;     * StringUtils.indexOf(&quot;&quot;, *, 0)            = -1 (except when * = &quot;&quot;)
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 0)  = 0
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 0)  = 2
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 0) = 1
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 3)  = 5
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 9)  = -1
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;, -1) = 2
&nbsp;     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;&quot;, 2)   = 2
&nbsp;     * StringUtils.indexOf(&quot;abc&quot;, &quot;&quot;, 9)        = 3
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @param startPos  the start position, negative treated as zero
&nbsp;     * @return the first index of the search String,
&nbsp;     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int indexOf(String str, String searchStr, int startPos) {
<b class="nc">&nbsp;        if (str == null || searchStr == null) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
&nbsp;        // JDK1.2/JDK1.3 have a bug, when startPos &gt; str.length for &quot;&quot;, hence
<b class="nc">&nbsp;        if (searchStr.length() == 0 &amp;&amp; startPos &gt;= str.length()) {</b>
<b class="nc">&nbsp;            return str.length();</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.indexOf(searchStr, startPos);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Case in-sensitive find of the first index within a String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A negative start position is treated as zero.
&nbsp;     * An empty (&quot;&quot;) search String always matches.
&nbsp;     * A start position greater than the string length only matches
&nbsp;     * an empty search String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOfIgnoreCase(null, *)          = -1
&nbsp;     * StringUtils.indexOfIgnoreCase(*, null)          = -1
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;&quot;, &quot;&quot;)           = 0
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;a&quot;)  = 0
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;b&quot;)  = 2
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;ab&quot;) = 1
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @return the first index of the search String,
&nbsp;     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public static int indexOfIgnoreCase(String str, String searchStr) {
<b class="nc">&nbsp;        return indexOfIgnoreCase(str, searchStr, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Case in-sensitive find of the first index within a String
&nbsp;     * from the specified position.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A negative start position is treated as zero.
&nbsp;     * An empty (&quot;&quot;) search String always matches.
&nbsp;     * A start position greater than the string length only matches
&nbsp;     * an empty search String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOfIgnoreCase(null, *, *)          = -1
&nbsp;     * StringUtils.indexOfIgnoreCase(*, null, *)          = -1
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;&quot;, &quot;&quot;, 0)           = 0
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;A&quot;, 0)  = 0
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;B&quot;, 0)  = 2
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;AB&quot;, 0) = 1
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;B&quot;, 3)  = 5
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;B&quot;, 9)  = -1
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;B&quot;, -1) = 2
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;&quot;, 2)   = 2
&nbsp;     * StringUtils.indexOfIgnoreCase(&quot;abc&quot;, &quot;&quot;, 9)        = 3
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @param startPos  the start position, negative treated as zero
&nbsp;     * @return the first index of the search String,
&nbsp;     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public static int indexOfIgnoreCase(String str, String searchStr, int startPos) {
<b class="nc">&nbsp;        if (str == null || searchStr == null) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (startPos &lt; 0) {</b>
<b class="nc">&nbsp;            startPos = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        int endLimit = (str.length() - searchStr.length()) + 1;</b>
<b class="nc">&nbsp;        if (startPos &gt; endLimit) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (searchStr.length() == 0) {</b>
<b class="nc">&nbsp;            return startPos;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int i = startPos; i &lt; endLimit; i++) {</b>
<b class="nc">&nbsp;            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {</b>
<b class="nc">&nbsp;                return i;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return INDEX_NOT_FOUND;</b>
&nbsp;    }
&nbsp;
&nbsp;    // LastIndexOf
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Finds the last index within a String, handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#lastIndexOf(int)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.lastIndexOf(null, *)         = -1
&nbsp;     * StringUtils.lastIndexOf(&quot;&quot;, *)           = -1
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &#39;a&#39;) = 7
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &#39;b&#39;) = 5
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchChar  the character to find
&nbsp;     * @return the last index of the search character,
&nbsp;     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int lastIndexOf(String str, char searchChar) {
<b class="nc">&nbsp;        if (isEmpty(str)) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.lastIndexOf(searchChar);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Finds the last index within a String from a start position,
&nbsp;     * handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#lastIndexOf(int, int)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A negative start position returns &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A start position greater than the string length searches the whole string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.lastIndexOf(null, *, *)          = -1
&nbsp;     * StringUtils.lastIndexOf(&quot;&quot;, *,  *)           = -1
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &#39;b&#39;, 8)  = 5
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &#39;b&#39;, 4)  = 2
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &#39;b&#39;, 0)  = -1
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &#39;b&#39;, 9)  = 5
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &#39;b&#39;, -1) = -1
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &#39;a&#39;, 0)  = 0
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchChar  the character to find
&nbsp;     * @param startPos  the start position
&nbsp;     * @return the last index of the search character,
&nbsp;     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int lastIndexOf(String str, char searchChar, int startPos) {
<b class="nc">&nbsp;        if (isEmpty(str)) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.lastIndexOf(searchChar, startPos);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Finds the last index within a String, handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#lastIndexOf(String)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.lastIndexOf(null, *)          = -1
&nbsp;     * StringUtils.lastIndexOf(*, null)          = -1
&nbsp;     * StringUtils.lastIndexOf(&quot;&quot;, &quot;&quot;)           = 0
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;)  = 7
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;)  = 5
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;) = 4
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;&quot;)   = 8
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @return the last index of the search String,
&nbsp;     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int lastIndexOf(String str, String searchStr) {
<b class="nc">&nbsp;        if (str == null || searchStr == null) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.lastIndexOf(searchStr);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Finds the n-th last index within a String, handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#lastIndexOf(String)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.lastOrdinalIndexOf(null, *, *)          = -1
&nbsp;     * StringUtils.lastOrdinalIndexOf(*, null, *)          = -1
&nbsp;     * StringUtils.lastOrdinalIndexOf(&quot;&quot;, &quot;&quot;, *)           = 0
&nbsp;     * StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 1)  = 7
&nbsp;     * StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 2)  = 6
&nbsp;     * StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 1)  = 5
&nbsp;     * StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 2)  = 2
&nbsp;     * StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 1) = 4
&nbsp;     * StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 2) = 1
&nbsp;     * StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;&quot;, 1)   = 8
&nbsp;     * StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;&quot;, 2)   = 8
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Note that &#39;tail(String str, int n)&#39; may be implemented as: &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     *   str.substring(lastOrdinalIndexOf(str, &quot;\n&quot;, n) + 1)
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @param ordinal  the n-th last &lt;code&gt;searchStr&lt;/code&gt; to find
&nbsp;     * @return the n-th last index of the search String,
&nbsp;     *  &lt;code&gt;-1&lt;/code&gt; (&lt;code&gt;INDEX_NOT_FOUND&lt;/code&gt;) if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) {
<b class="nc">&nbsp;        return ordinalIndexOf(str, searchStr, ordinal, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Finds the first index within a String, handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#lastIndexOf(String, int)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A negative start position returns &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) search String always matches unless the start position is negative.
&nbsp;     * A start position greater than the string length searches the whole string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.lastIndexOf(null, *, *)          = -1
&nbsp;     * StringUtils.lastIndexOf(*, null, *)          = -1
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 8)  = 7
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 8)  = 5
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 8) = 4
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 9)  = 5
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, -1) = -1
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 0)  = 0
&nbsp;     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 0)  = -1
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @param startPos  the start position, negative treated as zero
&nbsp;     * @return the first index of the search String,
&nbsp;     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int lastIndexOf(String str, String searchStr, int startPos) {
<b class="nc">&nbsp;        if (str == null || searchStr == null) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.lastIndexOf(searchStr, startPos);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Case in-sensitive find of the last index within a String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A negative start position returns &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) search String always matches unless the start position is negative.
&nbsp;     * A start position greater than the string length searches the whole string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;A&quot;)  = 7
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;B&quot;)  = 5
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;AB&quot;) = 4
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @return the first index of the search String,
&nbsp;     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public static int lastIndexOfIgnoreCase(String str, String searchStr) {
<b class="nc">&nbsp;        if (str == null || searchStr == null) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        return lastIndexOfIgnoreCase(str, searchStr, str.length());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Case in-sensitive find of the last index within a String
&nbsp;     * from the specified position.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A negative start position returns &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) search String always matches unless the start position is negative.
&nbsp;     * A start position greater than the string length searches the whole string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;A&quot;, 8)  = 7
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;B&quot;, 8)  = 5
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;AB&quot;, 8) = 4
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;B&quot;, 9)  = 5
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;B&quot;, -1) = -1
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;A&quot;, 0)  = 0
&nbsp;     * StringUtils.lastIndexOfIgnoreCase(&quot;aabaabaa&quot;, &quot;B&quot;, 0)  = -1
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @param startPos  the start position
&nbsp;     * @return the first index of the search String,
&nbsp;     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) {
<b class="nc">&nbsp;        if (str == null || searchStr == null) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (startPos &gt; (str.length() - searchStr.length())) {</b>
<b class="nc">&nbsp;            startPos = str.length() - searchStr.length();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (startPos &lt; 0) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (searchStr.length() == 0) {</b>
<b class="nc">&nbsp;            return startPos;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (int i = startPos; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {</b>
<b class="nc">&nbsp;                return i;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return INDEX_NOT_FOUND;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Contains
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if String contains a search character, handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#indexOf(int)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.contains(null, *)    = false
&nbsp;     * StringUtils.contains(&quot;&quot;, *)      = false
&nbsp;     * StringUtils.contains(&quot;abc&quot;, &#39;a&#39;) = true
&nbsp;     * StringUtils.contains(&quot;abc&quot;, &#39;z&#39;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchChar  the character to find
&nbsp;     * @return true if the String contains the search character,
&nbsp;     *  false if not or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static boolean contains(String str, char searchChar) {
<b class="nc">&nbsp;        if (isEmpty(str)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.indexOf(searchChar) &gt;= 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if String contains a search String, handling &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * This method uses {@link String#indexOf(String)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.contains(null, *)     = false
&nbsp;     * StringUtils.contains(*, null)     = false
&nbsp;     * StringUtils.contains(&quot;&quot;, &quot;&quot;)      = true
&nbsp;     * StringUtils.contains(&quot;abc&quot;, &quot;&quot;)   = true
&nbsp;     * StringUtils.contains(&quot;abc&quot;, &quot;a&quot;)  = true
&nbsp;     * StringUtils.contains(&quot;abc&quot;, &quot;z&quot;)  = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @return true if the String contains the search String,
&nbsp;     *  false if not or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static boolean contains(String str, String searchStr) {
<b class="nc">&nbsp;        if (str == null || searchStr == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.indexOf(searchStr) &gt;= 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if String contains a search String irrespective of case,
&nbsp;     * handling &lt;code&gt;null&lt;/code&gt;. Case-insensitivity is defined as by
&nbsp;     * {@link String#equalsIgnoreCase(String)}.
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.contains(null, *) = false
&nbsp;     * StringUtils.contains(*, null) = false
&nbsp;     * StringUtils.contains(&quot;&quot;, &quot;&quot;) = true
&nbsp;     * StringUtils.contains(&quot;abc&quot;, &quot;&quot;) = true
&nbsp;     * StringUtils.contains(&quot;abc&quot;, &quot;a&quot;) = true
&nbsp;     * StringUtils.contains(&quot;abc&quot;, &quot;z&quot;) = false
&nbsp;     * StringUtils.contains(&quot;abc&quot;, &quot;A&quot;) = true
&nbsp;     * StringUtils.contains(&quot;abc&quot;, &quot;Z&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStr  the String to find, may be null
&nbsp;     * @return true if the String contains the search String irrespective of
&nbsp;     * case or false if not or &lt;code&gt;null&lt;/code&gt; string input
&nbsp;     */
&nbsp;    public static boolean containsIgnoreCase(String str, String searchStr) {
<b class="nc">&nbsp;        if (str == null || searchStr == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int len = searchStr.length();</b>
<b class="nc">&nbsp;        int max = str.length() - len;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt;= max; i++) {</b>
<b class="nc">&nbsp;            if (str.regionMatches(true, i, searchStr, 0, len)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    // IndexOfAny chars
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Search a String to find the first index of any
&nbsp;     * character in the given set of characters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; or zero length search array will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOfAny(null, *)                = -1
&nbsp;     * StringUtils.indexOfAny(&quot;&quot;, *)                  = -1
&nbsp;     * StringUtils.indexOfAny(*, null)                = -1
&nbsp;     * StringUtils.indexOfAny(*, [])                  = -1
&nbsp;     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;,[&#39;z&#39;,&#39;a&#39;]) = 0
&nbsp;     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;,[&#39;b&#39;,&#39;y&#39;]) = 3
&nbsp;     * StringUtils.indexOfAny(&quot;aba&quot;, [&#39;z&#39;])           = -1
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchChars  the chars to search for, may be null
&nbsp;     * @return the index of any of the chars, -1 if no match or null input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int indexOfAny(String str, char[] searchChars) {
<b class="nc">&nbsp;        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        int csLen = str.length();</b>
<b class="nc">&nbsp;        int csLast = csLen - 1;</b>
<b class="nc">&nbsp;        int searchLen = searchChars.length;</b>
<b class="nc">&nbsp;        int searchLast = searchLen - 1;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; csLen; i++) {</b>
<b class="nc">&nbsp;            char ch = str.charAt(i);</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; searchLen; j++) {</b>
<b class="nc">&nbsp;                if (searchChars[j] == ch) {</b>
<b class="nc">&nbsp;                    if (i &lt; csLast &amp;&amp; j &lt; searchLast &amp;&amp; CharUtils.isHighSurrogate(ch)) {</b>
&nbsp;                        // ch is a supplementary character
<b class="nc">&nbsp;                        if (searchChars[j + 1] == str.charAt(i + 1)) {</b>
<b class="nc">&nbsp;                            return i;</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        return i;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return INDEX_NOT_FOUND;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Search a String to find the first index of any
&nbsp;     * character in the given set of characters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; search string will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOfAny(null, *)            = -1
&nbsp;     * StringUtils.indexOfAny(&quot;&quot;, *)              = -1
&nbsp;     * StringUtils.indexOfAny(*, null)            = -1
&nbsp;     * StringUtils.indexOfAny(*, &quot;&quot;)              = -1
&nbsp;     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, &quot;za&quot;) = 0
&nbsp;     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, &quot;by&quot;) = 3
&nbsp;     * StringUtils.indexOfAny(&quot;aba&quot;,&quot;z&quot;)          = -1
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchChars  the chars to search for, may be null
&nbsp;     * @return the index of any of the chars, -1 if no match or null input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int indexOfAny(String str, String searchChars) {
<b class="nc">&nbsp;        if (isEmpty(str) || isEmpty(searchChars)) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        return indexOfAny(str, searchChars.toCharArray());</b>
&nbsp;    }
&nbsp;
&nbsp;    // ContainsAny
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the String contains any character in the given
&nbsp;     * set of characters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; or zero length search array will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.containsAny(null, *)                = false
&nbsp;     * StringUtils.containsAny(&quot;&quot;, *)                  = false
&nbsp;     * StringUtils.containsAny(*, null)                = false
&nbsp;     * StringUtils.containsAny(*, [])                  = false
&nbsp;     * StringUtils.containsAny(&quot;zzabyycdxx&quot;,[&#39;z&#39;,&#39;a&#39;]) = true
&nbsp;     * StringUtils.containsAny(&quot;zzabyycdxx&quot;,[&#39;b&#39;,&#39;y&#39;]) = true
&nbsp;     * StringUtils.containsAny(&quot;aba&quot;, [&#39;z&#39;])           = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchChars  the chars to search for, may be null
&nbsp;     * @return the &lt;code&gt;true&lt;/code&gt; if any of the chars are found,
&nbsp;     * &lt;code&gt;false&lt;/code&gt; if no match or null input
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static boolean containsAny(String str, char[] searchChars) {
<b class="nc">&nbsp;        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int csLength = str.length();</b>
<b class="nc">&nbsp;        int searchLength = searchChars.length;</b>
<b class="nc">&nbsp;        int csLast = csLength - 1;</b>
<b class="nc">&nbsp;        int searchLast = searchLength - 1;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; csLength; i++) {</b>
<b class="nc">&nbsp;            char ch = str.charAt(i);</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; searchLength; j++) {</b>
<b class="nc">&nbsp;                if (searchChars[j] == ch) {</b>
<b class="nc">&nbsp;                    if (CharUtils.isHighSurrogate(ch)) {</b>
<b class="nc">&nbsp;                        if (j == searchLast) {</b>
&nbsp;                            // missing low surrogate, fine, like String.indexOf(String)
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (i &lt; csLast &amp;&amp; searchChars[j + 1] == str.charAt(i + 1)) {</b>
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        // ch is in the Basic Multilingual Plane
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Checks if the String contains any character in the given set of characters.
&nbsp;     * &lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;p&gt;
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;. A &lt;code&gt;null&lt;/code&gt; search string will return
&nbsp;     * &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * &lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.containsAny(null, *)            = false
&nbsp;     * StringUtils.containsAny(&quot;&quot;, *)              = false
&nbsp;     * StringUtils.containsAny(*, null)            = false
&nbsp;     * StringUtils.containsAny(*, &quot;&quot;)              = false
&nbsp;     * StringUtils.containsAny(&quot;zzabyycdxx&quot;, &quot;za&quot;) = true
&nbsp;     * StringUtils.containsAny(&quot;zzabyycdxx&quot;, &quot;by&quot;) = true
&nbsp;     * StringUtils.containsAny(&quot;aba&quot;,&quot;z&quot;)          = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     * 
&nbsp;     * @param str
&nbsp;     *            the String to check, may be null
&nbsp;     * @param searchChars
&nbsp;     *            the chars to search for, may be null
&nbsp;     * @return the &lt;code&gt;true&lt;/code&gt; if any of the chars are found, &lt;code&gt;false&lt;/code&gt; if no match or null input
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static boolean containsAny(String str, String searchChars) {
<b class="nc">&nbsp;        if (searchChars == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return containsAny(str, searchChars.toCharArray());</b>
&nbsp;    }
&nbsp;
&nbsp;    // IndexOfAnyBut chars
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Search a String to find the first index of any
&nbsp;     * character not in the given set of characters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; or zero length search array will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOfAnyBut(null, *)                              = -1
&nbsp;     * StringUtils.indexOfAnyBut(&quot;&quot;, *)                                = -1
&nbsp;     * StringUtils.indexOfAnyBut(*, null)                              = -1
&nbsp;     * StringUtils.indexOfAnyBut(*, [])                                = -1
&nbsp;     * StringUtils.indexOfAnyBut(&quot;zzabyycdxx&quot;, new char[] {&#39;z&#39;, &#39;a&#39;} ) = 3
&nbsp;     * StringUtils.indexOfAnyBut(&quot;aba&quot;, new char[] {&#39;z&#39;} )             = 0
&nbsp;     * StringUtils.indexOfAnyBut(&quot;aba&quot;, new char[] {&#39;a&#39;, &#39;b&#39;} )        = -1
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchChars  the chars to search for, may be null
&nbsp;     * @return the index of any of the chars, -1 if no match or null input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int indexOfAnyBut(String str, char[] searchChars) {
<b class="nc">&nbsp;        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        int csLen = str.length();</b>
<b class="nc">&nbsp;        int csLast = csLen - 1;</b>
<b class="nc">&nbsp;        int searchLen = searchChars.length;</b>
<b class="nc">&nbsp;        int searchLast = searchLen - 1;</b>
&nbsp;        outer:
<b class="nc">&nbsp;        for (int i = 0; i &lt; csLen; i++) {</b>
<b class="nc">&nbsp;            char ch = str.charAt(i);</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; searchLen; j++) {</b>
<b class="nc">&nbsp;                if (searchChars[j] == ch) {</b>
<b class="nc">&nbsp;                    if (i &lt; csLast &amp;&amp; j &lt; searchLast &amp;&amp; CharUtils.isHighSurrogate(ch)) {</b>
<b class="nc">&nbsp;                        if (searchChars[j + 1] == str.charAt(i + 1)) {</b>
<b class="nc">&nbsp;                            continue outer;</b>
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        continue outer;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return i;</b>
&nbsp;        }
<b class="nc">&nbsp;        return INDEX_NOT_FOUND;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Search a String to find the first index of any
&nbsp;     * character not in the given set of characters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; or empty search string will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOfAnyBut(null, *)            = -1
&nbsp;     * StringUtils.indexOfAnyBut(&quot;&quot;, *)              = -1
&nbsp;     * StringUtils.indexOfAnyBut(*, null)            = -1
&nbsp;     * StringUtils.indexOfAnyBut(*, &quot;&quot;)              = -1
&nbsp;     * StringUtils.indexOfAnyBut(&quot;zzabyycdxx&quot;, &quot;za&quot;) = 3
&nbsp;     * StringUtils.indexOfAnyBut(&quot;zzabyycdxx&quot;, &quot;&quot;)   = -1
&nbsp;     * StringUtils.indexOfAnyBut(&quot;aba&quot;,&quot;ab&quot;)         = -1
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchChars  the chars to search for, may be null
&nbsp;     * @return the index of any of the chars, -1 if no match or null input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int indexOfAnyBut(String str, String searchChars) {
<b class="nc">&nbsp;        if (isEmpty(str) || isEmpty(searchChars)) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        int strLen = str.length();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; strLen; i++) {</b>
<b class="nc">&nbsp;            char ch = str.charAt(i);</b>
<b class="nc">&nbsp;            boolean chFound = searchChars.indexOf(ch) &gt;= 0;</b>
<b class="nc">&nbsp;            if (i + 1 &lt; strLen &amp;&amp; CharUtils.isHighSurrogate(ch)) {</b>
<b class="nc">&nbsp;                char ch2 = str.charAt(i + 1);</b>
<b class="nc">&nbsp;                if (chFound &amp;&amp; searchChars.indexOf(ch2) &lt; 0) {</b>
<b class="nc">&nbsp;                    return i;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                if (!chFound) {</b>
<b class="nc">&nbsp;                    return i;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return INDEX_NOT_FOUND;</b>
&nbsp;    }
&nbsp;
&nbsp;    // ContainsOnly
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the String contains only certain characters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; valid character array will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * An empty String (length()=0) always returns &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.containsOnly(null, *)       = false
&nbsp;     * StringUtils.containsOnly(*, null)       = false
&nbsp;     * StringUtils.containsOnly(&quot;&quot;, *)         = true
&nbsp;     * StringUtils.containsOnly(&quot;ab&quot;, &#39;&#39;)      = false
&nbsp;     * StringUtils.containsOnly(&quot;abab&quot;, &#39;abc&#39;) = true
&nbsp;     * StringUtils.containsOnly(&quot;ab1&quot;, &#39;abc&#39;)  = false
&nbsp;     * StringUtils.containsOnly(&quot;abz&quot;, &#39;abc&#39;)  = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param valid  an array of valid chars, may be null
&nbsp;     * @return true if it only contains valid chars and is non-null
&nbsp;     */
&nbsp;    public static boolean containsOnly(String str, char[] valid) {
&nbsp;        // All these pre-checks are to maintain API with an older version
<b class="nc">&nbsp;        if ((valid == null) || (str == null)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (str.length() == 0) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (valid.length == 0) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return indexOfAnyBut(str, valid) == INDEX_NOT_FOUND;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the String contains only certain characters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; valid character String will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * An empty String (length()=0) always returns &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.containsOnly(null, *)       = false
&nbsp;     * StringUtils.containsOnly(*, null)       = false
&nbsp;     * StringUtils.containsOnly(&quot;&quot;, *)         = true
&nbsp;     * StringUtils.containsOnly(&quot;ab&quot;, &quot;&quot;)      = false
&nbsp;     * StringUtils.containsOnly(&quot;abab&quot;, &quot;abc&quot;) = true
&nbsp;     * StringUtils.containsOnly(&quot;ab1&quot;, &quot;abc&quot;)  = false
&nbsp;     * StringUtils.containsOnly(&quot;abz&quot;, &quot;abc&quot;)  = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param validChars  a String of valid chars, may be null
&nbsp;     * @return true if it only contains valid chars and is non-null
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static boolean containsOnly(String str, String validChars) {
<b class="nc">&nbsp;        if (str == null || validChars == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return containsOnly(str, validChars.toCharArray());</b>
&nbsp;    }
&nbsp;
&nbsp;    // ContainsNone
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks that the String does not contain certain characters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;true&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; invalid character array will return &lt;code&gt;true&lt;/code&gt;.
&nbsp;     * An empty String (length()=0) always returns true.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.containsNone(null, *)       = true
&nbsp;     * StringUtils.containsNone(*, null)       = true
&nbsp;     * StringUtils.containsNone(&quot;&quot;, *)         = true
&nbsp;     * StringUtils.containsNone(&quot;ab&quot;, &#39;&#39;)      = true
&nbsp;     * StringUtils.containsNone(&quot;abab&quot;, &#39;xyz&#39;) = true
&nbsp;     * StringUtils.containsNone(&quot;ab1&quot;, &#39;xyz&#39;)  = true
&nbsp;     * StringUtils.containsNone(&quot;abz&quot;, &#39;xyz&#39;)  = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchChars  an array of invalid chars, may be null
&nbsp;     * @return true if it contains none of the invalid chars, or is null
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static boolean containsNone(String str, char[] searchChars) {
<b class="nc">&nbsp;        if (str == null || searchChars == null) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        int csLen = str.length();</b>
<b class="nc">&nbsp;        int csLast = csLen - 1;</b>
<b class="nc">&nbsp;        int searchLen = searchChars.length;</b>
<b class="nc">&nbsp;        int searchLast = searchLen - 1;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; csLen; i++) {</b>
<b class="nc">&nbsp;            char ch = str.charAt(i);</b>
<b class="nc">&nbsp;            for (int j = 0; j &lt; searchLen; j++) {</b>
<b class="nc">&nbsp;                if (searchChars[j] == ch) {</b>
<b class="nc">&nbsp;                    if (CharUtils.isHighSurrogate(ch)) {</b>
<b class="nc">&nbsp;                        if (j == searchLast) {</b>
&nbsp;                            // missing low surrogate, fine, like String.indexOf(String)
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (i &lt; csLast &amp;&amp; searchChars[j + 1] == str.charAt(i + 1)) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        // ch is in the Basic Multilingual Plane
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks that the String does not contain certain characters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;true&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; invalid character array will return &lt;code&gt;true&lt;/code&gt;.
&nbsp;     * An empty String (&quot;&quot;) always returns true.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.containsNone(null, *)       = true
&nbsp;     * StringUtils.containsNone(*, null)       = true
&nbsp;     * StringUtils.containsNone(&quot;&quot;, *)         = true
&nbsp;     * StringUtils.containsNone(&quot;ab&quot;, &quot;&quot;)      = true
&nbsp;     * StringUtils.containsNone(&quot;abab&quot;, &quot;xyz&quot;) = true
&nbsp;     * StringUtils.containsNone(&quot;ab1&quot;, &quot;xyz&quot;)  = true
&nbsp;     * StringUtils.containsNone(&quot;abz&quot;, &quot;xyz&quot;)  = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param invalidChars  a String of invalid chars, may be null
&nbsp;     * @return true if it contains none of the invalid chars, or is null
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static boolean containsNone(String str, String invalidChars) {
<b class="nc">&nbsp;        if (str == null || invalidChars == null) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return containsNone(str, invalidChars.toCharArray());</b>
&nbsp;    }
&nbsp;
&nbsp;    // IndexOfAny strings
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Find the first index of any of a set of potential substrings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; or zero length search array will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; search array entry will be ignored, but a search
&nbsp;     * array containing &quot;&quot; will return &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;str&lt;/code&gt; is not
&nbsp;     * null. This method uses {@link String#indexOf(String)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOfAny(null, *)                     = -1
&nbsp;     * StringUtils.indexOfAny(*, null)                     = -1
&nbsp;     * StringUtils.indexOfAny(*, [])                       = -1
&nbsp;     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, [&quot;ab&quot;,&quot;cd&quot;])   = 2
&nbsp;     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, [&quot;cd&quot;,&quot;ab&quot;])   = 2
&nbsp;     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, [&quot;mn&quot;,&quot;op&quot;])   = -1
&nbsp;     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, [&quot;zab&quot;,&quot;aby&quot;]) = 1
&nbsp;     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, [&quot;&quot;])          = 0
&nbsp;     * StringUtils.indexOfAny(&quot;&quot;, [&quot;&quot;])                    = 0
&nbsp;     * StringUtils.indexOfAny(&quot;&quot;, [&quot;a&quot;])                   = -1
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStrs  the Strings to search for, may be null
&nbsp;     * @return the first index of any of the searchStrs in str, -1 if no match
&nbsp;     */
&nbsp;    public static int indexOfAny(String str, String[] searchStrs) {
<b class="nc">&nbsp;        if ((str == null) || (searchStrs == null)) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = searchStrs.length;</b>
&nbsp;
&nbsp;        // String&#39;s can&#39;t have a MAX_VALUEth index.
<b class="nc">&nbsp;        int ret = Integer.MAX_VALUE;</b>
&nbsp;
<b class="nc">&nbsp;        int tmp = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            String search = searchStrs[i];</b>
<b class="nc">&nbsp;            if (search == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            tmp = str.indexOf(search);</b>
<b class="nc">&nbsp;            if (tmp == INDEX_NOT_FOUND) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (tmp &lt; ret) {</b>
<b class="nc">&nbsp;                ret = tmp;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Find the latest index of any of a set of potential substrings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; search array will return &lt;code&gt;-1&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; or zero length search array entry will be ignored,
&nbsp;     * but a search array containing &quot;&quot; will return the length of &lt;code&gt;str&lt;/code&gt;
&nbsp;     * if &lt;code&gt;str&lt;/code&gt; is not null. This method uses {@link String#indexOf(String)}&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.lastIndexOfAny(null, *)                   = -1
&nbsp;     * StringUtils.lastIndexOfAny(*, null)                   = -1
&nbsp;     * StringUtils.lastIndexOfAny(*, [])                     = -1
&nbsp;     * StringUtils.lastIndexOfAny(*, [null])                 = -1
&nbsp;     * StringUtils.lastIndexOfAny(&quot;zzabyycdxx&quot;, [&quot;ab&quot;,&quot;cd&quot;]) = 6
&nbsp;     * StringUtils.lastIndexOfAny(&quot;zzabyycdxx&quot;, [&quot;cd&quot;,&quot;ab&quot;]) = 6
&nbsp;     * StringUtils.lastIndexOfAny(&quot;zzabyycdxx&quot;, [&quot;mn&quot;,&quot;op&quot;]) = -1
&nbsp;     * StringUtils.lastIndexOfAny(&quot;zzabyycdxx&quot;, [&quot;mn&quot;,&quot;op&quot;]) = -1
&nbsp;     * StringUtils.lastIndexOfAny(&quot;zzabyycdxx&quot;, [&quot;mn&quot;,&quot;&quot;])   = 10
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param searchStrs  the Strings to search for, may be null
&nbsp;     * @return the last index of any of the Strings, -1 if no match
&nbsp;     */
&nbsp;    public static int lastIndexOfAny(String str, String[] searchStrs) {
<b class="nc">&nbsp;        if ((str == null) || (searchStrs == null)) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = searchStrs.length;</b>
<b class="nc">&nbsp;        int ret = INDEX_NOT_FOUND;</b>
<b class="nc">&nbsp;        int tmp = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            String search = searchStrs[i];</b>
<b class="nc">&nbsp;            if (search == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            tmp = str.lastIndexOf(search);</b>
<b class="nc">&nbsp;            if (tmp &gt; ret) {</b>
<b class="nc">&nbsp;                ret = tmp;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return ret;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Substring
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets a substring from the specified String avoiding exceptions.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A negative start position can be used to start &lt;code&gt;n&lt;/code&gt;
&nbsp;     * characters from the end of the String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) String will return &quot;&quot;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.substring(null, *)   = null
&nbsp;     * StringUtils.substring(&quot;&quot;, *)     = &quot;&quot;
&nbsp;     * StringUtils.substring(&quot;abc&quot;, 0)  = &quot;abc&quot;
&nbsp;     * StringUtils.substring(&quot;abc&quot;, 2)  = &quot;c&quot;
&nbsp;     * StringUtils.substring(&quot;abc&quot;, 4)  = &quot;&quot;
&nbsp;     * StringUtils.substring(&quot;abc&quot;, -2) = &quot;bc&quot;
&nbsp;     * StringUtils.substring(&quot;abc&quot;, -4) = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to get the substring from, may be null
&nbsp;     * @param start  the position to start from, negative means
&nbsp;     *  count back from the end of the String by this many characters
&nbsp;     * @return substring from start position, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String substring(String str, int start) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        // handle negatives, which means last n characters
<b class="nc">&nbsp;        if (start &lt; 0) {</b>
<b class="nc">&nbsp;            start = str.length() + start; // remember start is negative</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (start &lt; 0) {</b>
<b class="nc">&nbsp;            start = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (start &gt; str.length()) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return str.substring(start);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets a substring from the specified String avoiding exceptions.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A negative start position can be used to start/end &lt;code&gt;n&lt;/code&gt;
&nbsp;     * characters from the end of the String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The returned substring starts with the character in the &lt;code&gt;start&lt;/code&gt;
&nbsp;     * position and ends before the &lt;code&gt;end&lt;/code&gt; position. All position counting is
&nbsp;     * zero-based -- i.e., to start at the beginning of the string use
&nbsp;     * &lt;code&gt;start = 0&lt;/code&gt;. Negative start and end positions can be used to
&nbsp;     * specify offsets relative to the end of the String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If &lt;code&gt;start&lt;/code&gt; is not strictly to the left of &lt;code&gt;end&lt;/code&gt;, &quot;&quot;
&nbsp;     * is returned.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.substring(null, *, *)    = null
&nbsp;     * StringUtils.substring(&quot;&quot;, * ,  *)    = &quot;&quot;;
&nbsp;     * StringUtils.substring(&quot;abc&quot;, 0, 2)   = &quot;ab&quot;
&nbsp;     * StringUtils.substring(&quot;abc&quot;, 2, 0)   = &quot;&quot;
&nbsp;     * StringUtils.substring(&quot;abc&quot;, 2, 4)   = &quot;c&quot;
&nbsp;     * StringUtils.substring(&quot;abc&quot;, 4, 6)   = &quot;&quot;
&nbsp;     * StringUtils.substring(&quot;abc&quot;, 2, 2)   = &quot;&quot;
&nbsp;     * StringUtils.substring(&quot;abc&quot;, -2, -1) = &quot;b&quot;
&nbsp;     * StringUtils.substring(&quot;abc&quot;, -4, 2)  = &quot;ab&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to get the substring from, may be null
&nbsp;     * @param start  the position to start from, negative means
&nbsp;     *  count back from the end of the String by this many characters
&nbsp;     * @param end  the position to end at (exclusive), negative means
&nbsp;     *  count back from the end of the String by this many characters
&nbsp;     * @return substring from start position to end positon,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String substring(String str, int start, int end) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        // handle negatives
<b class="nc">&nbsp;        if (end &lt; 0) {</b>
<b class="nc">&nbsp;            end = str.length() + end; // remember end is negative</b>
&nbsp;        }
<b class="nc">&nbsp;        if (start &lt; 0) {</b>
<b class="nc">&nbsp;            start = str.length() + start; // remember start is negative</b>
&nbsp;        }
&nbsp;
&nbsp;        // check length next
<b class="nc">&nbsp;        if (end &gt; str.length()) {</b>
<b class="nc">&nbsp;            end = str.length();</b>
&nbsp;        }
&nbsp;
&nbsp;        // if start is greater than end, return &quot;&quot;
<b class="nc">&nbsp;        if (start &gt; end) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (start &lt; 0) {</b>
<b class="nc">&nbsp;            start = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (end &lt; 0) {</b>
<b class="nc">&nbsp;            end = 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return str.substring(start, end);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Left/Right/Mid
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets the leftmost &lt;code&gt;len&lt;/code&gt; characters of a String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If &lt;code&gt;len&lt;/code&gt; characters are not available, or the
&nbsp;     * String is &lt;code&gt;null&lt;/code&gt;, the String will be returned without
&nbsp;     * an exception. An empty String is returned if len is negative.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.left(null, *)    = null
&nbsp;     * StringUtils.left(*, -ve)     = &quot;&quot;
&nbsp;     * StringUtils.left(&quot;&quot;, *)      = &quot;&quot;
&nbsp;     * StringUtils.left(&quot;abc&quot;, 0)   = &quot;&quot;
&nbsp;     * StringUtils.left(&quot;abc&quot;, 2)   = &quot;ab&quot;
&nbsp;     * StringUtils.left(&quot;abc&quot;, 4)   = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to get the leftmost characters from, may be null
&nbsp;     * @param len  the length of the required String
&nbsp;     * @return the leftmost characters, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String left(String str, int len) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (len &lt; 0) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (str.length() &lt;= len) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.substring(0, len);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets the rightmost &lt;code&gt;len&lt;/code&gt; characters of a String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If &lt;code&gt;len&lt;/code&gt; characters are not available, or the String
&nbsp;     * is &lt;code&gt;null&lt;/code&gt;, the String will be returned without an
&nbsp;     * an exception. An empty String is returned if len is negative.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.right(null, *)    = null
&nbsp;     * StringUtils.right(*, -ve)     = &quot;&quot;
&nbsp;     * StringUtils.right(&quot;&quot;, *)      = &quot;&quot;
&nbsp;     * StringUtils.right(&quot;abc&quot;, 0)   = &quot;&quot;
&nbsp;     * StringUtils.right(&quot;abc&quot;, 2)   = &quot;bc&quot;
&nbsp;     * StringUtils.right(&quot;abc&quot;, 4)   = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to get the rightmost characters from, may be null
&nbsp;     * @param len  the length of the required String
&nbsp;     * @return the rightmost characters, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String right(String str, int len) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (len &lt; 0) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (str.length() &lt;= len) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.substring(str.length() - len);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets &lt;code&gt;len&lt;/code&gt; characters from the middle of a String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If &lt;code&gt;len&lt;/code&gt; characters are not available, the remainder
&nbsp;     * of the String will be returned without an exception. If the
&nbsp;     * String is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; will be returned.
&nbsp;     * An empty String is returned if len is negative or exceeds the
&nbsp;     * length of &lt;code&gt;str&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.mid(null, *, *)    = null
&nbsp;     * StringUtils.mid(*, *, -ve)     = &quot;&quot;
&nbsp;     * StringUtils.mid(&quot;&quot;, 0, *)      = &quot;&quot;
&nbsp;     * StringUtils.mid(&quot;abc&quot;, 0, 2)   = &quot;ab&quot;
&nbsp;     * StringUtils.mid(&quot;abc&quot;, 0, 4)   = &quot;abc&quot;
&nbsp;     * StringUtils.mid(&quot;abc&quot;, 2, 4)   = &quot;c&quot;
&nbsp;     * StringUtils.mid(&quot;abc&quot;, 4, 2)   = &quot;&quot;
&nbsp;     * StringUtils.mid(&quot;abc&quot;, -2, 2)  = &quot;ab&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to get the characters from, may be null
&nbsp;     * @param pos  the position to start from, negative treated as zero
&nbsp;     * @param len  the length of the required String
&nbsp;     * @return the middle characters, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String mid(String str, int pos, int len) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (len &lt; 0 || pos &gt; str.length()) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (pos &lt; 0) {</b>
<b class="nc">&nbsp;            pos = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (str.length() &lt;= (pos + len)) {</b>
<b class="nc">&nbsp;            return str.substring(pos);</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.substring(pos, pos + len);</b>
&nbsp;    }
&nbsp;
&nbsp;    // SubStringAfter/SubStringBefore
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets the substring before the first occurrence of a separator.
&nbsp;     * The separator is not returned.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) string input will return the empty string.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separator will return the input string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If nothing is found, the string input is returned.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.substringBefore(null, *)      = null
&nbsp;     * StringUtils.substringBefore(&quot;&quot;, *)        = &quot;&quot;
&nbsp;     * StringUtils.substringBefore(&quot;abc&quot;, &quot;a&quot;)   = &quot;&quot;
&nbsp;     * StringUtils.substringBefore(&quot;abcba&quot;, &quot;b&quot;) = &quot;a&quot;
&nbsp;     * StringUtils.substringBefore(&quot;abc&quot;, &quot;c&quot;)   = &quot;ab&quot;
&nbsp;     * StringUtils.substringBefore(&quot;abc&quot;, &quot;d&quot;)   = &quot;abc&quot;
&nbsp;     * StringUtils.substringBefore(&quot;abc&quot;, &quot;&quot;)    = &quot;&quot;
&nbsp;     * StringUtils.substringBefore(&quot;abc&quot;, null)  = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to get a substring from, may be null
&nbsp;     * @param separator  the String to search for, may be null
&nbsp;     * @return the substring before the first occurrence of the separator,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String substringBefore(String str, String separator) {
<b class="nc">&nbsp;        if (isEmpty(str) || separator == null) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (separator.length() == 0) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        int pos = str.indexOf(separator);</b>
<b class="nc">&nbsp;        if (pos == INDEX_NOT_FOUND) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.substring(0, pos);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets the substring after the first occurrence of a separator.
&nbsp;     * The separator is not returned.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) string input will return the empty string.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separator will return the empty string if the
&nbsp;     * input string is not &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If nothing is found, the empty string is returned.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.substringAfter(null, *)      = null
&nbsp;     * StringUtils.substringAfter(&quot;&quot;, *)        = &quot;&quot;
&nbsp;     * StringUtils.substringAfter(*, null)      = &quot;&quot;
&nbsp;     * StringUtils.substringAfter(&quot;abc&quot;, &quot;a&quot;)   = &quot;bc&quot;
&nbsp;     * StringUtils.substringAfter(&quot;abcba&quot;, &quot;b&quot;) = &quot;cba&quot;
&nbsp;     * StringUtils.substringAfter(&quot;abc&quot;, &quot;c&quot;)   = &quot;&quot;
&nbsp;     * StringUtils.substringAfter(&quot;abc&quot;, &quot;d&quot;)   = &quot;&quot;
&nbsp;     * StringUtils.substringAfter(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to get a substring from, may be null
&nbsp;     * @param separator  the String to search for, may be null
&nbsp;     * @return the substring after the first occurrence of the separator,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String substringAfter(String str, String separator) {
<b class="nc">&nbsp;        if (isEmpty(str)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (separator == null) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        int pos = str.indexOf(separator);</b>
<b class="nc">&nbsp;        if (pos == INDEX_NOT_FOUND) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.substring(pos + separator.length());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets the substring before the last occurrence of a separator.
&nbsp;     * The separator is not returned.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) string input will return the empty string.
&nbsp;     * An empty or &lt;code&gt;null&lt;/code&gt; separator will return the input string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If nothing is found, the string input is returned.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.substringBeforeLast(null, *)      = null
&nbsp;     * StringUtils.substringBeforeLast(&quot;&quot;, *)        = &quot;&quot;
&nbsp;     * StringUtils.substringBeforeLast(&quot;abcba&quot;, &quot;b&quot;) = &quot;abc&quot;
&nbsp;     * StringUtils.substringBeforeLast(&quot;abc&quot;, &quot;c&quot;)   = &quot;ab&quot;
&nbsp;     * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;a&quot;)     = &quot;&quot;
&nbsp;     * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;z&quot;)     = &quot;a&quot;
&nbsp;     * StringUtils.substringBeforeLast(&quot;a&quot;, null)    = &quot;a&quot;
&nbsp;     * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;&quot;)      = &quot;a&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to get a substring from, may be null
&nbsp;     * @param separator  the String to search for, may be null
&nbsp;     * @return the substring before the last occurrence of the separator,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String substringBeforeLast(String str, String separator) {
<b class="nc">&nbsp;        if (isEmpty(str) || isEmpty(separator)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        int pos = str.lastIndexOf(separator);</b>
<b class="nc">&nbsp;        if (pos == INDEX_NOT_FOUND) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.substring(0, pos);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets the substring after the last occurrence of a separator.
&nbsp;     * The separator is not returned.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) string input will return the empty string.
&nbsp;     * An empty or &lt;code&gt;null&lt;/code&gt; separator will return the empty string if
&nbsp;     * the input string is not &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If nothing is found, the empty string is returned.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.substringAfterLast(null, *)      = null
&nbsp;     * StringUtils.substringAfterLast(&quot;&quot;, *)        = &quot;&quot;
&nbsp;     * StringUtils.substringAfterLast(*, &quot;&quot;)        = &quot;&quot;
&nbsp;     * StringUtils.substringAfterLast(*, null)      = &quot;&quot;
&nbsp;     * StringUtils.substringAfterLast(&quot;abc&quot;, &quot;a&quot;)   = &quot;bc&quot;
&nbsp;     * StringUtils.substringAfterLast(&quot;abcba&quot;, &quot;b&quot;) = &quot;a&quot;
&nbsp;     * StringUtils.substringAfterLast(&quot;abc&quot;, &quot;c&quot;)   = &quot;&quot;
&nbsp;     * StringUtils.substringAfterLast(&quot;a&quot;, &quot;a&quot;)     = &quot;&quot;
&nbsp;     * StringUtils.substringAfterLast(&quot;a&quot;, &quot;z&quot;)     = &quot;&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to get a substring from, may be null
&nbsp;     * @param separator  the String to search for, may be null
&nbsp;     * @return the substring after the last occurrence of the separator,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String substringAfterLast(String str, String separator) {
<b class="nc">&nbsp;        if (isEmpty(str)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isEmpty(separator)) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        int pos = str.lastIndexOf(separator);</b>
<b class="nc">&nbsp;        if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.substring(pos + separator.length());</b>
&nbsp;    }
&nbsp;
&nbsp;    // Substring between
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets the String that is nested in between two instances of the
&nbsp;     * same String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; tag returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.substringBetween(null, *)            = null
&nbsp;     * StringUtils.substringBetween(&quot;&quot;, &quot;&quot;)             = &quot;&quot;
&nbsp;     * StringUtils.substringBetween(&quot;&quot;, &quot;tag&quot;)          = null
&nbsp;     * StringUtils.substringBetween(&quot;tagabctag&quot;, null)  = null
&nbsp;     * StringUtils.substringBetween(&quot;tagabctag&quot;, &quot;&quot;)    = &quot;&quot;
&nbsp;     * StringUtils.substringBetween(&quot;tagabctag&quot;, &quot;tag&quot;) = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String containing the substring, may be null
&nbsp;     * @param tag  the String before and after the substring, may be null
&nbsp;     * @return the substring, &lt;code&gt;null&lt;/code&gt; if no match
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String substringBetween(String str, String tag) {
<b class="nc">&nbsp;        return substringBetween(str, tag, tag);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets the String that is nested in between two Strings.
&nbsp;     * Only the first match is returned.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; open/close returns &lt;code&gt;null&lt;/code&gt; (no match).
&nbsp;     * An empty (&quot;&quot;) open and close returns an empty string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.substringBetween(&quot;wx[b]yz&quot;, &quot;[&quot;, &quot;]&quot;) = &quot;b&quot;
&nbsp;     * StringUtils.substringBetween(null, *, *)          = null
&nbsp;     * StringUtils.substringBetween(*, null, *)          = null
&nbsp;     * StringUtils.substringBetween(*, *, null)          = null
&nbsp;     * StringUtils.substringBetween(&quot;&quot;, &quot;&quot;, &quot;&quot;)          = &quot;&quot;
&nbsp;     * StringUtils.substringBetween(&quot;&quot;, &quot;&quot;, &quot;]&quot;)         = null
&nbsp;     * StringUtils.substringBetween(&quot;&quot;, &quot;[&quot;, &quot;]&quot;)        = null
&nbsp;     * StringUtils.substringBetween(&quot;yabcz&quot;, &quot;&quot;, &quot;&quot;)     = &quot;&quot;
&nbsp;     * StringUtils.substringBetween(&quot;yabcz&quot;, &quot;y&quot;, &quot;z&quot;)   = &quot;abc&quot;
&nbsp;     * StringUtils.substringBetween(&quot;yabczyabcz&quot;, &quot;y&quot;, &quot;z&quot;)   = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String containing the substring, may be null
&nbsp;     * @param open  the String before the substring, may be null
&nbsp;     * @param close  the String after the substring, may be null
&nbsp;     * @return the substring, &lt;code&gt;null&lt;/code&gt; if no match
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String substringBetween(String str, String open, String close) {
<b class="nc">&nbsp;        if (str == null || open == null || close == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        int start = str.indexOf(open);</b>
<b class="nc">&nbsp;        if (start != INDEX_NOT_FOUND) {</b>
<b class="nc">&nbsp;            int end = str.indexOf(close, start + open.length());</b>
<b class="nc">&nbsp;            if (end != INDEX_NOT_FOUND) {</b>
<b class="nc">&nbsp;                return str.substring(start + open.length(), end);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Searches a String for substrings delimited by a start and end tag,
&nbsp;     * returning all matching substrings in an array.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; open/close returns &lt;code&gt;null&lt;/code&gt; (no match).
&nbsp;     * An empty (&quot;&quot;) open/close returns &lt;code&gt;null&lt;/code&gt; (no match).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.substringsBetween(&quot;[a][b][c]&quot;, &quot;[&quot;, &quot;]&quot;) = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
&nbsp;     * StringUtils.substringsBetween(null, *, *)            = null
&nbsp;     * StringUtils.substringsBetween(*, null, *)            = null
&nbsp;     * StringUtils.substringsBetween(*, *, null)            = null
&nbsp;     * StringUtils.substringsBetween(&quot;&quot;, &quot;[&quot;, &quot;]&quot;)          = []
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String containing the substrings, null returns null, empty returns empty
&nbsp;     * @param open  the String identifying the start of the substring, empty returns null
&nbsp;     * @param close  the String identifying the end of the substring, empty returns null
&nbsp;     * @return a String Array of substrings, or &lt;code&gt;null&lt;/code&gt; if no match
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    public static String[] substringsBetween(String str, String open, String close) {
<b class="nc">&nbsp;        if (str == null || isEmpty(open) || isEmpty(close)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        int strLen = str.length();</b>
<b class="nc">&nbsp;        if (strLen == 0) {</b>
<b class="nc">&nbsp;            return ArrayUtils.EMPTY_STRING_ARRAY;</b>
&nbsp;        }
<b class="nc">&nbsp;        int closeLen = close.length();</b>
<b class="nc">&nbsp;        int openLen = open.length();</b>
<b class="nc">&nbsp;        List list = new ArrayList();</b>
<b class="nc">&nbsp;        int pos = 0;</b>
<b class="nc">&nbsp;        while (pos &lt; (strLen - closeLen)) {</b>
<b class="nc">&nbsp;            int start = str.indexOf(open, pos);</b>
<b class="nc">&nbsp;            if (start &lt; 0) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            start += openLen;</b>
<b class="nc">&nbsp;            int end = str.indexOf(close, start);</b>
<b class="nc">&nbsp;            if (end &lt; 0) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            list.add(str.substring(start, end));</b>
<b class="nc">&nbsp;            pos = end + closeLen;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (list.isEmpty()) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        } 
<b class="nc">&nbsp;        return (String[]) list.toArray(new String [list.size()]);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Nested extraction
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets the String that is nested in between two instances of the
&nbsp;     * same String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; tag returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.getNestedString(null, *)            = null
&nbsp;     * StringUtils.getNestedString(&quot;&quot;, &quot;&quot;)             = &quot;&quot;
&nbsp;     * StringUtils.getNestedString(&quot;&quot;, &quot;tag&quot;)          = null
&nbsp;     * StringUtils.getNestedString(&quot;tagabctag&quot;, null)  = null
&nbsp;     * StringUtils.getNestedString(&quot;tagabctag&quot;, &quot;&quot;)    = &quot;&quot;
&nbsp;     * StringUtils.getNestedString(&quot;tagabctag&quot;, &quot;tag&quot;) = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String containing nested-string, may be null
&nbsp;     * @param tag  the String before and after nested-string, may be null
&nbsp;     * @return the nested String, &lt;code&gt;null&lt;/code&gt; if no match
&nbsp;     * @deprecated Use the better named {@link #substringBetween(String, String)}.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String getNestedString(String str, String tag) {
<b class="nc">&nbsp;        return substringBetween(str, tag, tag);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Gets the String that is nested in between two Strings.
&nbsp;     * Only the first match is returned.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; open/close returns &lt;code&gt;null&lt;/code&gt; (no match).
&nbsp;     * An empty (&quot;&quot;) open/close returns an empty string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.getNestedString(null, *, *)          = null
&nbsp;     * StringUtils.getNestedString(&quot;&quot;, &quot;&quot;, &quot;&quot;)          = &quot;&quot;
&nbsp;     * StringUtils.getNestedString(&quot;&quot;, &quot;&quot;, &quot;tag&quot;)       = null
&nbsp;     * StringUtils.getNestedString(&quot;&quot;, &quot;tag&quot;, &quot;tag&quot;)    = null
&nbsp;     * StringUtils.getNestedString(&quot;yabcz&quot;, null, null) = null
&nbsp;     * StringUtils.getNestedString(&quot;yabcz&quot;, &quot;&quot;, &quot;&quot;)     = &quot;&quot;
&nbsp;     * StringUtils.getNestedString(&quot;yabcz&quot;, &quot;y&quot;, &quot;z&quot;)   = &quot;abc&quot;
&nbsp;     * StringUtils.getNestedString(&quot;yabczyabcz&quot;, &quot;y&quot;, &quot;z&quot;)   = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String containing nested-string, may be null
&nbsp;     * @param open  the String before nested-string, may be null
&nbsp;     * @param close  the String after nested-string, may be null
&nbsp;     * @return the nested String, &lt;code&gt;null&lt;/code&gt; if no match
&nbsp;     * @deprecated Use the better named {@link #substringBetween(String, String, String)}.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String getNestedString(String str, String open, String close) {
<b class="nc">&nbsp;        return substringBetween(str, open, close);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Splitting
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits the provided text into an array, using whitespace as the
&nbsp;     * separator.
&nbsp;     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The separator is not included in the returned String array.
&nbsp;     * Adjacent separators are treated as one separator.
&nbsp;     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.split(null)       = null
&nbsp;     * StringUtils.split(&quot;&quot;)         = []
&nbsp;     * StringUtils.split(&quot;abc def&quot;)  = [&quot;abc&quot;, &quot;def&quot;]
&nbsp;     * StringUtils.split(&quot;abc  def&quot;) = [&quot;abc&quot;, &quot;def&quot;]
&nbsp;     * StringUtils.split(&quot; abc &quot;)    = [&quot;abc&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be null
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String[] split(String str) {
<b class="nc">&nbsp;        return split(str, null, -1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits the provided text into an array, separator specified.
&nbsp;     * This is an alternative to using StringTokenizer.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The separator is not included in the returned String array.
&nbsp;     * Adjacent separators are treated as one separator.
&nbsp;     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.split(null, *)         = null
&nbsp;     * StringUtils.split(&quot;&quot;, *)           = []
&nbsp;     * StringUtils.split(&quot;a.b.c&quot;, &#39;.&#39;)    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&nbsp;     * StringUtils.split(&quot;a..b.c&quot;, &#39;.&#39;)   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&nbsp;     * StringUtils.split(&quot;a:b:c&quot;, &#39;.&#39;)    = [&quot;a:b:c&quot;]
&nbsp;     * StringUtils.split(&quot;a b c&quot;, &#39; &#39;)    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be null
&nbsp;     * @param separatorChar  the character used as the delimiter
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String[] split(String str, char separatorChar) {
<b class="nc">&nbsp;        return splitWorker(str, separatorChar, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits the provided text into an array, separators specified.
&nbsp;     * This is an alternative to using StringTokenizer.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The separator is not included in the returned String array.
&nbsp;     * Adjacent separators are treated as one separator.
&nbsp;     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.split(null, *)         = null
&nbsp;     * StringUtils.split(&quot;&quot;, *)           = []
&nbsp;     * StringUtils.split(&quot;abc def&quot;, null) = [&quot;abc&quot;, &quot;def&quot;]
&nbsp;     * StringUtils.split(&quot;abc def&quot;, &quot; &quot;)  = [&quot;abc&quot;, &quot;def&quot;]
&nbsp;     * StringUtils.split(&quot;abc  def&quot;, &quot; &quot;) = [&quot;abc&quot;, &quot;def&quot;]
&nbsp;     * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be null
&nbsp;     * @param separatorChars  the characters used as the delimiters,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String[] split(String str, String separatorChars) {
<b class="nc">&nbsp;        return splitWorker(str, separatorChars, -1, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits the provided text into an array with a maximum length,
&nbsp;     * separators specified.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The separator is not included in the returned String array.
&nbsp;     * Adjacent separators are treated as one separator.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If more than &lt;code&gt;max&lt;/code&gt; delimited substrings are found, the last
&nbsp;     * returned string includes all characters after the first &lt;code&gt;max - 1&lt;/code&gt;
&nbsp;     * returned strings (including separator characters).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.split(null, *, *)            = null
&nbsp;     * StringUtils.split(&quot;&quot;, *, *)              = []
&nbsp;     * StringUtils.split(&quot;ab de fg&quot;, null, 0)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.split(&quot;ab   de fg&quot;, null, 0) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;, 0)    = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)    = [&quot;ab&quot;, &quot;cd:ef&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be null
&nbsp;     * @param separatorChars  the characters used as the delimiters,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
&nbsp;     * @param max  the maximum number of elements to include in the
&nbsp;     *  array. A zero or negative value implies no limit
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String[] split(String str, String separatorChars, int max) {
<b class="nc">&nbsp;        return splitWorker(str, separatorChars, max, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits the provided text into an array, separator string specified.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The separator(s) will not be included in the returned String array.
&nbsp;     * Adjacent separators are treated as one separator.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separator splits on whitespace.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.splitByWholeSeparator(null, *)               = null
&nbsp;     * StringUtils.splitByWholeSeparator(&quot;&quot;, *)                 = []
&nbsp;     * StringUtils.splitByWholeSeparator(&quot;ab de fg&quot;, null)      = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
&nbsp;     * StringUtils.splitByWholeSeparator(&quot;ab   de fg&quot;, null)    = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
&nbsp;     * StringUtils.splitByWholeSeparator(&quot;ab:cd:ef&quot;, &quot;:&quot;)       = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitByWholeSeparator(&quot;ab-!-cd-!-ef&quot;, &quot;-!-&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be null
&nbsp;     * @param separator  String containing the String to be used as a delimiter,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String was input
&nbsp;     */
&nbsp;    public static String[] splitByWholeSeparator(String str, String separator) {
<b class="nc">&nbsp;        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits the provided text into an array, separator string specified.
&nbsp;     * Returns a maximum of &lt;code&gt;max&lt;/code&gt; substrings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The separator(s) will not be included in the returned String array.
&nbsp;     * Adjacent separators are treated as one separator.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separator splits on whitespace.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.splitByWholeSeparator(null, *, *)               = null
&nbsp;     * StringUtils.splitByWholeSeparator(&quot;&quot;, *, *)                 = []
&nbsp;     * StringUtils.splitByWholeSeparator(&quot;ab de fg&quot;, null, 0)      = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
&nbsp;     * StringUtils.splitByWholeSeparator(&quot;ab   de fg&quot;, null, 0)    = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
&nbsp;     * StringUtils.splitByWholeSeparator(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)       = [&quot;ab&quot;, &quot;cd:ef&quot;]
&nbsp;     * StringUtils.splitByWholeSeparator(&quot;ab-!-cd-!-ef&quot;, &quot;-!-&quot;, 5) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitByWholeSeparator(&quot;ab-!-cd-!-ef&quot;, &quot;-!-&quot;, 2) = [&quot;ab&quot;, &quot;cd-!-ef&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be null
&nbsp;     * @param separator  String containing the String to be used as a delimiter,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
&nbsp;     * @param max  the maximum number of elements to include in the returned
&nbsp;     *  array. A zero or negative value implies no limit.
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String was input
&nbsp;     */
&nbsp;    public static String[] splitByWholeSeparator( String str, String separator, int max ) {
<b class="nc">&nbsp;        return splitByWholeSeparatorWorker(str, separator, max, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits the provided text into an array, separator string specified. &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The separator is not included in the returned String array.
&nbsp;     * Adjacent separators are treated as separators for empty tokens.
&nbsp;     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separator splits on whitespace.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;&quot;, *)                 = []
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab de fg&quot;, null)      = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab   de fg&quot;, null)    = [&quot;ab&quot;, &quot;&quot;, &quot;&quot;, &quot;de&quot;, &quot;fg&quot;]
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;)       = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab-!-cd-!-ef&quot;, &quot;-!-&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be null
&nbsp;     * @param separator  String containing the String to be used as a delimiter,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String was input
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {
<b class="nc">&nbsp;        return splitByWholeSeparatorWorker(str, separator, -1, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits the provided text into an array, separator string specified.
&nbsp;     * Returns a maximum of &lt;code&gt;max&lt;/code&gt; substrings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The separator is not included in the returned String array.
&nbsp;     * Adjacent separators are treated as separators for empty tokens.
&nbsp;     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separator splits on whitespace.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *, *)               = null
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;&quot;, *, *)                 = []
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab de fg&quot;, null, 0)      = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab   de fg&quot;, null, 0)    = [&quot;ab&quot;, &quot;&quot;, &quot;&quot;, &quot;de&quot;, &quot;fg&quot;]
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)       = [&quot;ab&quot;, &quot;cd:ef&quot;]
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab-!-cd-!-ef&quot;, &quot;-!-&quot;, 5) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab-!-cd-!-ef&quot;, &quot;-!-&quot;, 2) = [&quot;ab&quot;, &quot;cd-!-ef&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be null
&nbsp;     * @param separator  String containing the String to be used as a delimiter,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
&nbsp;     * @param max  the maximum number of elements to include in the returned
&nbsp;     *  array. A zero or negative value implies no limit.
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String was input
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {
<b class="nc">&nbsp;        return splitByWholeSeparatorWorker(str, separator, max, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs the logic for the &lt;code&gt;splitByWholeSeparatorPreserveAllTokens&lt;/code&gt; methods.
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @param separator  String containing the String to be used as a delimiter,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
&nbsp;     * @param max  the maximum number of elements to include in the returned
&nbsp;     *  array. A zero or negative value implies no limit.
&nbsp;     * @param preserveAllTokens if &lt;code&gt;true&lt;/code&gt;, adjacent separators are
&nbsp;     * treated as empty token separators; if &lt;code&gt;false&lt;/code&gt;, adjacent
&nbsp;     * separators are treated as one separator.
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, 
&nbsp;                                                        boolean preserveAllTokens) 
&nbsp;    {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int len = str.length();</b>
&nbsp;
<b class="nc">&nbsp;        if (len == 0) {</b>
<b class="nc">&nbsp;            return ArrayUtils.EMPTY_STRING_ARRAY;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if ((separator == null) || (EMPTY.equals(separator))) {</b>
&nbsp;            // Split on whitespace.
<b class="nc">&nbsp;            return splitWorker(str, null, max, preserveAllTokens);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int separatorLength = separator.length();</b>
&nbsp;
<b class="nc">&nbsp;        ArrayList substrings = new ArrayList();</b>
<b class="nc">&nbsp;        int numberOfSubstrings = 0;</b>
<b class="nc">&nbsp;        int beg = 0;</b>
<b class="nc">&nbsp;        int end = 0;</b>
<b class="nc">&nbsp;        while (end &lt; len) {</b>
<b class="nc">&nbsp;            end = str.indexOf(separator, beg);</b>
&nbsp;
<b class="nc">&nbsp;            if (end &gt; -1) {</b>
<b class="nc">&nbsp;                if (end &gt; beg) {</b>
<b class="nc">&nbsp;                    numberOfSubstrings += 1;</b>
&nbsp;
<b class="nc">&nbsp;                    if (numberOfSubstrings == max) {</b>
<b class="nc">&nbsp;                        end = len;</b>
<b class="nc">&nbsp;                        substrings.add(str.substring(beg));</b>
&nbsp;                    } else {
&nbsp;                        // The following is OK, because String.substring( beg, end ) excludes
&nbsp;                        // the character at the position &#39;end&#39;.
<b class="nc">&nbsp;                        substrings.add(str.substring(beg, end));</b>
&nbsp;
&nbsp;                        // Set the starting point for the next search.
&nbsp;                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,
&nbsp;                        // which is the right calculation:
<b class="nc">&nbsp;                        beg = end + separatorLength;</b>
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    // We found a consecutive occurrence of the separator, so skip it.
<b class="nc">&nbsp;                    if (preserveAllTokens) {</b>
<b class="nc">&nbsp;                        numberOfSubstrings += 1;</b>
<b class="nc">&nbsp;                        if (numberOfSubstrings == max) {</b>
<b class="nc">&nbsp;                            end = len;</b>
<b class="nc">&nbsp;                            substrings.add(str.substring(beg));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            substrings.add(EMPTY);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    beg = end + separatorLength;</b>
&nbsp;                }
&nbsp;            } else {
&nbsp;                // String.substring( beg ) goes from &#39;beg&#39; to the end of the String.
<b class="nc">&nbsp;                substrings.add(str.substring(beg));</b>
<b class="nc">&nbsp;                end = len;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return (String[]) substrings.toArray(new String[substrings.size()]);</b>
&nbsp;    }
&nbsp;
&nbsp;    // -----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits the provided text into an array, using whitespace as the
&nbsp;     * separator, preserving all tokens, including empty tokens created by 
&nbsp;     * adjacent separators. This is an alternative to using StringTokenizer.
&nbsp;     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The separator is not included in the returned String array.
&nbsp;     * Adjacent separators are treated as separators for empty tokens.
&nbsp;     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.splitPreserveAllTokens(null)       = null
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;&quot;)         = []
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;abc def&quot;)  = [&quot;abc&quot;, &quot;def&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;abc  def&quot;) = [&quot;abc&quot;, &quot;&quot;, &quot;def&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot; abc &quot;)    = [&quot;&quot;, &quot;abc&quot;, &quot;&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public static String[] splitPreserveAllTokens(String str) {
<b class="nc">&nbsp;        return splitWorker(str, null, -1, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits the provided text into an array, separator specified,
&nbsp;     * preserving all tokens, including empty tokens created by adjacent
&nbsp;     * separators. This is an alternative to using StringTokenizer.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The separator is not included in the returned String array.
&nbsp;     * Adjacent separators are treated as separators for empty tokens.
&nbsp;     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.splitPreserveAllTokens(null, *)         = null
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;&quot;, *)           = []
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;a.b.c&quot;, &#39;.&#39;)    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;a..b.c&quot;, &#39;.&#39;)   = [&quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;a:b:c&quot;, &#39;.&#39;)    = [&quot;a:b:c&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;a\tb\nc&quot;, null) = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;a b c&quot;, &#39; &#39;)    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;a b c &quot;, &#39; &#39;)   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;a b c  &quot;, &#39; &#39;)   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot; a b c&quot;, &#39; &#39;)   = [&quot;&quot;, a&quot;, &quot;b&quot;, &quot;c&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;  a b c&quot;, &#39; &#39;)  = [&quot;&quot;, &quot;&quot;, a&quot;, &quot;b&quot;, &quot;c&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot; a b c &quot;, &#39; &#39;)  = [&quot;&quot;, a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @param separatorChar  the character used as the delimiter,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public static String[] splitPreserveAllTokens(String str, char separatorChar) {
<b class="fc">&nbsp;        return splitWorker(str, separatorChar, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs the logic for the &lt;code&gt;split&lt;/code&gt; and 
&nbsp;     * &lt;code&gt;splitPreserveAllTokens&lt;/code&gt; methods that do not return a
&nbsp;     * maximum array length.
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @param separatorChar the separate character
&nbsp;     * @param preserveAllTokens if &lt;code&gt;true&lt;/code&gt;, adjacent separators are
&nbsp;     * treated as empty token separators; if &lt;code&gt;false&lt;/code&gt;, adjacent
&nbsp;     * separators are treated as one separator.
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {
&nbsp;        // Performance tuned for 2.0 (JDK1.4)
&nbsp;
<b class="pc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        int len = str.length();</b>
<b class="pc">&nbsp;        if (len == 0) {</b>
<b class="nc">&nbsp;            return ArrayUtils.EMPTY_STRING_ARRAY;</b>
&nbsp;        }
<b class="fc">&nbsp;        List list = new ArrayList();</b>
<b class="fc">&nbsp;        int i = 0, start = 0;</b>
<b class="fc">&nbsp;        boolean match = false;</b>
<b class="fc">&nbsp;        boolean lastMatch = false;</b>
<b class="fc">&nbsp;        while (i &lt; len) {</b>
<b class="fc">&nbsp;            if (str.charAt(i) == separatorChar) {</b>
<b class="pc">&nbsp;                if (match || preserveAllTokens) {</b>
<b class="fc">&nbsp;                    list.add(str.substring(start, i));</b>
<b class="fc">&nbsp;                    match = false;</b>
<b class="fc">&nbsp;                    lastMatch = true;</b>
&nbsp;                }
<b class="fc">&nbsp;                start = ++i;</b>
<b class="fc">&nbsp;                continue;</b>
&nbsp;            }
<b class="fc">&nbsp;            lastMatch = false;</b>
<b class="fc">&nbsp;            match = true;</b>
<b class="fc">&nbsp;            i++;</b>
&nbsp;        }
<b class="pc">&nbsp;        if (match || (preserveAllTokens &amp;&amp; lastMatch)) {</b>
<b class="fc">&nbsp;            list.add(str.substring(start, i));</b>
&nbsp;        }
<b class="fc">&nbsp;        return (String[]) list.toArray(new String[list.size()]);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits the provided text into an array, separators specified, 
&nbsp;     * preserving all tokens, including empty tokens created by adjacent
&nbsp;     * separators. This is an alternative to using StringTokenizer.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The separator is not included in the returned String array.
&nbsp;     * Adjacent separators are treated as separators for empty tokens.
&nbsp;     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.splitPreserveAllTokens(null, *)           = null
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;&quot;, *)             = []
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;abc def&quot;, null)   = [&quot;abc&quot;, &quot;def&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;abc def&quot;, &quot; &quot;)    = [&quot;abc&quot;, &quot;def&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;abc  def&quot;, &quot; &quot;)   = [&quot;abc&quot;, &quot;&quot;, def&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef:&quot;, &quot;:&quot;)  = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;, &quot;&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef::&quot;, &quot;:&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;, &quot;&quot;, &quot;&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;ab::cd:ef&quot;, &quot;:&quot;)  = [&quot;ab&quot;, &quot;&quot;, cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;:cd:ef&quot;, &quot;:&quot;)     = [&quot;&quot;, cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;::cd:ef&quot;, &quot;:&quot;)    = [&quot;&quot;, &quot;&quot;, cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;:cd:ef:&quot;, &quot;:&quot;)    = [&quot;&quot;, cd&quot;, &quot;ef&quot;, &quot;&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @param separatorChars  the characters used as the delimiters,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public static String[] splitPreserveAllTokens(String str, String separatorChars) {
<b class="nc">&nbsp;        return splitWorker(str, separatorChars, -1, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits the provided text into an array with a maximum length,
&nbsp;     * separators specified, preserving all tokens, including empty tokens 
&nbsp;     * created by adjacent separators.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The separator is not included in the returned String array.
&nbsp;     * Adjacent separators are treated as separators for empty tokens.
&nbsp;     * Adjacent separators are treated as one separator.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If more than &lt;code&gt;max&lt;/code&gt; delimited substrings are found, the last
&nbsp;     * returned string includes all characters after the first &lt;code&gt;max - 1&lt;/code&gt;
&nbsp;     * returned strings (including separator characters).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.splitPreserveAllTokens(null, *, *)            = null
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;&quot;, *, *)              = []
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;ab de fg&quot;, null, 0)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 0) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;, 0)    = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)    = [&quot;ab&quot;, &quot;cd:ef&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 2) = [&quot;ab&quot;, &quot;  de fg&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 3) = [&quot;ab&quot;, &quot;&quot;, &quot; de fg&quot;]
&nbsp;     * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 4) = [&quot;ab&quot;, &quot;&quot;, &quot;&quot;, &quot;de fg&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @param separatorChars  the characters used as the delimiters,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
&nbsp;     * @param max  the maximum number of elements to include in the
&nbsp;     *  array. A zero or negative value implies no limit
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {
<b class="nc">&nbsp;        return splitWorker(str, separatorChars, max, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs the logic for the &lt;code&gt;split&lt;/code&gt; and 
&nbsp;     * &lt;code&gt;splitPreserveAllTokens&lt;/code&gt; methods that return a maximum array 
&nbsp;     * length.
&nbsp;     *
&nbsp;     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @param separatorChars the separate character
&nbsp;     * @param max  the maximum number of elements to include in the
&nbsp;     *  array. A zero or negative value implies no limit.
&nbsp;     * @param preserveAllTokens if &lt;code&gt;true&lt;/code&gt;, adjacent separators are
&nbsp;     * treated as empty token separators; if &lt;code&gt;false&lt;/code&gt;, adjacent
&nbsp;     * separators are treated as one separator.
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {
&nbsp;        // Performance tuned for 2.0 (JDK1.4)
&nbsp;        // Direct code is quicker than StringTokenizer.
&nbsp;        // Also, StringTokenizer uses isSpace() not isWhitespace()
&nbsp;
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        int len = str.length();</b>
<b class="nc">&nbsp;        if (len == 0) {</b>
<b class="nc">&nbsp;            return ArrayUtils.EMPTY_STRING_ARRAY;</b>
&nbsp;        }
<b class="nc">&nbsp;        List list = new ArrayList();</b>
<b class="nc">&nbsp;        int sizePlus1 = 1;</b>
<b class="nc">&nbsp;        int i = 0, start = 0;</b>
<b class="nc">&nbsp;        boolean match = false;</b>
<b class="nc">&nbsp;        boolean lastMatch = false;</b>
<b class="nc">&nbsp;        if (separatorChars == null) {</b>
&nbsp;            // Null separator means use whitespace
<b class="nc">&nbsp;            while (i &lt; len) {</b>
<b class="nc">&nbsp;                if (Character.isWhitespace(str.charAt(i))) {</b>
<b class="nc">&nbsp;                    if (match || preserveAllTokens) {</b>
<b class="nc">&nbsp;                        lastMatch = true;</b>
<b class="nc">&nbsp;                        if (sizePlus1++ == max) {</b>
<b class="nc">&nbsp;                            i = len;</b>
<b class="nc">&nbsp;                            lastMatch = false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        list.add(str.substring(start, i));</b>
<b class="nc">&nbsp;                        match = false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    start = ++i;</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                lastMatch = false;</b>
<b class="nc">&nbsp;                match = true;</b>
<b class="nc">&nbsp;                i++;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (separatorChars.length() == 1) {</b>
&nbsp;            // Optimise 1 character case
<b class="nc">&nbsp;            char sep = separatorChars.charAt(0);</b>
<b class="nc">&nbsp;            while (i &lt; len) {</b>
<b class="nc">&nbsp;                if (str.charAt(i) == sep) {</b>
<b class="nc">&nbsp;                    if (match || preserveAllTokens) {</b>
<b class="nc">&nbsp;                        lastMatch = true;</b>
<b class="nc">&nbsp;                        if (sizePlus1++ == max) {</b>
<b class="nc">&nbsp;                            i = len;</b>
<b class="nc">&nbsp;                            lastMatch = false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        list.add(str.substring(start, i));</b>
<b class="nc">&nbsp;                        match = false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    start = ++i;</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                lastMatch = false;</b>
<b class="nc">&nbsp;                match = true;</b>
<b class="nc">&nbsp;                i++;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
&nbsp;            // standard case
<b class="nc">&nbsp;            while (i &lt; len) {</b>
<b class="nc">&nbsp;                if (separatorChars.indexOf(str.charAt(i)) &gt;= 0) {</b>
<b class="nc">&nbsp;                    if (match || preserveAllTokens) {</b>
<b class="nc">&nbsp;                        lastMatch = true;</b>
<b class="nc">&nbsp;                        if (sizePlus1++ == max) {</b>
<b class="nc">&nbsp;                            i = len;</b>
<b class="nc">&nbsp;                            lastMatch = false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        list.add(str.substring(start, i));</b>
<b class="nc">&nbsp;                        match = false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    start = ++i;</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                lastMatch = false;</b>
<b class="nc">&nbsp;                match = true;</b>
<b class="nc">&nbsp;                i++;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (match || (preserveAllTokens &amp;&amp; lastMatch)) {</b>
<b class="nc">&nbsp;            list.add(str.substring(start, i));</b>
&nbsp;        }
<b class="nc">&nbsp;        return (String[]) list.toArray(new String[list.size()]);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits a String by Character type as returned by
&nbsp;     * &lt;code&gt;java.lang.Character.getType(char)&lt;/code&gt;. Groups of contiguous
&nbsp;     * characters of the same type are returned as complete tokens. 
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.splitByCharacterType(null)         = null
&nbsp;     * StringUtils.splitByCharacterType(&quot;&quot;)           = []
&nbsp;     * StringUtils.splitByCharacterType(&quot;ab de fg&quot;)   = [&quot;ab&quot;, &quot; &quot;, &quot;de&quot;, &quot; &quot;, &quot;fg&quot;]
&nbsp;     * StringUtils.splitByCharacterType(&quot;ab   de fg&quot;) = [&quot;ab&quot;, &quot;   &quot;, &quot;de&quot;, &quot; &quot;, &quot;fg&quot;]
&nbsp;     * StringUtils.splitByCharacterType(&quot;ab:cd:ef&quot;)   = [&quot;ab&quot;, &quot;:&quot;, &quot;cd&quot;, &quot;:&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitByCharacterType(&quot;number5&quot;)    = [&quot;number&quot;, &quot;5&quot;]
&nbsp;     * StringUtils.splitByCharacterType(&quot;fooBar&quot;)     = [&quot;foo&quot;, &quot;B&quot;, &quot;ar&quot;]
&nbsp;     * StringUtils.splitByCharacterType(&quot;foo200Bar&quot;)  = [&quot;foo&quot;, &quot;200&quot;, &quot;B&quot;, &quot;ar&quot;]
&nbsp;     * StringUtils.splitByCharacterType(&quot;ASFRules&quot;)   = [&quot;ASFR&quot;, &quot;ules&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @param str the String to split, may be &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static String[] splitByCharacterType(String str) {
<b class="nc">&nbsp;        return splitByCharacterType(str, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits a String by Character type as returned by
&nbsp;     * &lt;code&gt;java.lang.Character.getType(char)&lt;/code&gt;. Groups of contiguous
&nbsp;     * characters of the same type are returned as complete tokens, with the
&nbsp;     * following exception: the character of type
&nbsp;     * &lt;code&gt;Character.UPPERCASE_LETTER&lt;/code&gt;, if any, immediately
&nbsp;     * preceding a token of type &lt;code&gt;Character.LOWERCASE_LETTER&lt;/code&gt;
&nbsp;     * will belong to the following token rather than to the preceding, if any,
&nbsp;     * &lt;code&gt;Character.UPPERCASE_LETTER&lt;/code&gt; token. 
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.splitByCharacterTypeCamelCase(null)         = null
&nbsp;     * StringUtils.splitByCharacterTypeCamelCase(&quot;&quot;)           = []
&nbsp;     * StringUtils.splitByCharacterTypeCamelCase(&quot;ab de fg&quot;)   = [&quot;ab&quot;, &quot; &quot;, &quot;de&quot;, &quot; &quot;, &quot;fg&quot;]
&nbsp;     * StringUtils.splitByCharacterTypeCamelCase(&quot;ab   de fg&quot;) = [&quot;ab&quot;, &quot;   &quot;, &quot;de&quot;, &quot; &quot;, &quot;fg&quot;]
&nbsp;     * StringUtils.splitByCharacterTypeCamelCase(&quot;ab:cd:ef&quot;)   = [&quot;ab&quot;, &quot;:&quot;, &quot;cd&quot;, &quot;:&quot;, &quot;ef&quot;]
&nbsp;     * StringUtils.splitByCharacterTypeCamelCase(&quot;number5&quot;)    = [&quot;number&quot;, &quot;5&quot;]
&nbsp;     * StringUtils.splitByCharacterTypeCamelCase(&quot;fooBar&quot;)     = [&quot;foo&quot;, &quot;Bar&quot;]
&nbsp;     * StringUtils.splitByCharacterTypeCamelCase(&quot;foo200Bar&quot;)  = [&quot;foo&quot;, &quot;200&quot;, &quot;Bar&quot;]
&nbsp;     * StringUtils.splitByCharacterTypeCamelCase(&quot;ASFRules&quot;)   = [&quot;ASF&quot;, &quot;Rules&quot;]
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @param str the String to split, may be &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static String[] splitByCharacterTypeCamelCase(String str) {
<b class="nc">&nbsp;        return splitByCharacterType(str, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Splits a String by Character type as returned by
&nbsp;     * &lt;code&gt;java.lang.Character.getType(char)&lt;/code&gt;. Groups of contiguous
&nbsp;     * characters of the same type are returned as complete tokens, with the
&nbsp;     * following exception: if &lt;code&gt;camelCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;,
&nbsp;     * the character of type &lt;code&gt;Character.UPPERCASE_LETTER&lt;/code&gt;, if any,
&nbsp;     * immediately preceding a token of type &lt;code&gt;Character.LOWERCASE_LETTER&lt;/code&gt;
&nbsp;     * will belong to the following token rather than to the preceding, if any,
&nbsp;     * &lt;code&gt;Character.UPPERCASE_LETTER&lt;/code&gt; token. 
&nbsp;     * @param str the String to split, may be &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @param camelCase whether to use so-called &quot;camel-case&quot; for letter types
&nbsp;     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    private static String[] splitByCharacterType(String str, boolean camelCase) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (str.length() == 0) {</b>
<b class="nc">&nbsp;            return ArrayUtils.EMPTY_STRING_ARRAY;</b>
&nbsp;        }
<b class="nc">&nbsp;        char[] c = str.toCharArray();</b>
<b class="nc">&nbsp;        List list = new ArrayList();</b>
<b class="nc">&nbsp;        int tokenStart = 0;</b>
<b class="nc">&nbsp;        int currentType = Character.getType(c[tokenStart]);</b>
<b class="nc">&nbsp;        for (int pos = tokenStart + 1; pos &lt; c.length; pos++) {</b>
<b class="nc">&nbsp;            int type = Character.getType(c[pos]);</b>
<b class="nc">&nbsp;            if (type == currentType) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (camelCase &amp;&amp; type == Character.LOWERCASE_LETTER &amp;&amp; currentType == Character.UPPERCASE_LETTER) {</b>
<b class="nc">&nbsp;                int newTokenStart = pos - 1;</b>
<b class="nc">&nbsp;                if (newTokenStart != tokenStart) {</b>
<b class="nc">&nbsp;                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));</b>
<b class="nc">&nbsp;                    tokenStart = newTokenStart;</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                list.add(new String(c, tokenStart, pos - tokenStart));</b>
<b class="nc">&nbsp;                tokenStart = pos;</b>
&nbsp;            }
<b class="nc">&nbsp;            currentType = type;</b>
&nbsp;        }
<b class="nc">&nbsp;        list.add(new String(c, tokenStart, c.length - tokenStart));</b>
<b class="nc">&nbsp;        return (String[]) list.toArray(new String[list.size()]);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Joining
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Joins the provided elements into a single String. &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;No separator is added to the joined String.
&nbsp;     * Null objects or empty string elements are represented by
&nbsp;     * empty strings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.concatenate(null)            = null
&nbsp;     * StringUtils.concatenate([])              = &quot;&quot;
&nbsp;     * StringUtils.concatenate([null])          = &quot;&quot;
&nbsp;     * StringUtils.concatenate([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) = &quot;abc&quot;
&nbsp;     * StringUtils.concatenate([null, &quot;&quot;, &quot;a&quot;]) = &quot;a&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param array  the array of values to concatenate, may be null
&nbsp;     * @return the concatenated String, &lt;code&gt;null&lt;/code&gt; if null array input
&nbsp;     * @deprecated Use the better named {@link #join(Object[])} instead.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String concatenate(Object[] array) {
<b class="nc">&nbsp;        return join(array, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Joins the elements of the provided array into a single String
&nbsp;     * containing the provided list of elements.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;No separator is added to the joined String.
&nbsp;     * Null objects or empty strings within the array are represented by
&nbsp;     * empty strings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.join(null)            = null
&nbsp;     * StringUtils.join([])              = &quot;&quot;
&nbsp;     * StringUtils.join([null])          = &quot;&quot;
&nbsp;     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) = &quot;abc&quot;
&nbsp;     * StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) = &quot;a&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param array  the array of values to join together, may be null
&nbsp;     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String join(Object[] array) {
<b class="nc">&nbsp;        return join(array, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Joins the elements of the provided array into a single String
&nbsp;     * containing the provided list of elements.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;No delimiter is added before or after the list.
&nbsp;     * Null objects or empty strings within the array are represented by
&nbsp;     * empty strings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.join(null, *)               = null
&nbsp;     * StringUtils.join([], *)                 = &quot;&quot;
&nbsp;     * StringUtils.join([null], *)             = &quot;&quot;
&nbsp;     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &#39;;&#39;)  = &quot;a;b;c&quot;
&nbsp;     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null) = &quot;abc&quot;
&nbsp;     * StringUtils.join([null, &quot;&quot;, &quot;a&quot;], &#39;;&#39;)  = &quot;;;a&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param array  the array of values to join together, may be null
&nbsp;     * @param separator  the separator character to use
&nbsp;     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String join(Object[] array, char separator) {
<b class="nc">&nbsp;        if (array == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return join(array, separator, 0, array.length);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Joins the elements of the provided array into a single String
&nbsp;     * containing the provided list of elements.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;No delimiter is added before or after the list.
&nbsp;     * Null objects or empty strings within the array are represented by
&nbsp;     * empty strings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.join(null, *)               = null
&nbsp;     * StringUtils.join([], *)                 = &quot;&quot;
&nbsp;     * StringUtils.join([null], *)             = &quot;&quot;
&nbsp;     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &#39;;&#39;)  = &quot;a;b;c&quot;
&nbsp;     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null) = &quot;abc&quot;
&nbsp;     * StringUtils.join([null, &quot;&quot;, &quot;a&quot;], &#39;;&#39;)  = &quot;;;a&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param array  the array of values to join together, may be null
&nbsp;     * @param separator  the separator character to use
&nbsp;     * @param startIndex the first index to start joining from.  It is
&nbsp;     * an error to pass in an end index past the end of the array
&nbsp;     * @param endIndex the index to stop joining from (exclusive). It is
&nbsp;     * an error to pass in an end index past the end of the array
&nbsp;     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String join(Object[] array, char separator, int startIndex, int endIndex) {
<b class="nc">&nbsp;        if (array == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        int bufSize = (endIndex - startIndex);</b>
<b class="nc">&nbsp;        if (bufSize &lt;= 0) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);</b>
<b class="nc">&nbsp;        StrBuilder buf = new StrBuilder(bufSize);</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = startIndex; i &lt; endIndex; i++) {</b>
<b class="nc">&nbsp;            if (i &gt; startIndex) {</b>
<b class="nc">&nbsp;                buf.append(separator);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (array[i] != null) {</b>
<b class="nc">&nbsp;                buf.append(array[i]);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return buf.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Joins the elements of the provided array into a single String
&nbsp;     * containing the provided list of elements.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;No delimiter is added before or after the list.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separator is the same as an empty String (&quot;&quot;).
&nbsp;     * Null objects or empty strings within the array are represented by
&nbsp;     * empty strings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.join(null, *)                = null
&nbsp;     * StringUtils.join([], *)                  = &quot;&quot;
&nbsp;     * StringUtils.join([null], *)              = &quot;&quot;
&nbsp;     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;--&quot;)  = &quot;a--b--c&quot;
&nbsp;     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null)  = &quot;abc&quot;
&nbsp;     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;)    = &quot;abc&quot;
&nbsp;     * StringUtils.join([null, &quot;&quot;, &quot;a&quot;], &#39;,&#39;)   = &quot;,,a&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param array  the array of values to join together, may be null
&nbsp;     * @param separator  the separator character to use, null treated as &quot;&quot;
&nbsp;     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
&nbsp;     */
&nbsp;    public static String join(Object[] array, String separator) {
<b class="nc">&nbsp;        if (array == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return join(array, separator, 0, array.length);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Joins the elements of the provided array into a single String
&nbsp;     * containing the provided list of elements.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;No delimiter is added before or after the list.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separator is the same as an empty String (&quot;&quot;).
&nbsp;     * Null objects or empty strings within the array are represented by
&nbsp;     * empty strings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.join(null, *)                = null
&nbsp;     * StringUtils.join([], *)                  = &quot;&quot;
&nbsp;     * StringUtils.join([null], *)              = &quot;&quot;
&nbsp;     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;--&quot;)  = &quot;a--b--c&quot;
&nbsp;     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null)  = &quot;abc&quot;
&nbsp;     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;)    = &quot;abc&quot;
&nbsp;     * StringUtils.join([null, &quot;&quot;, &quot;a&quot;], &#39;,&#39;)   = &quot;,,a&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param array  the array of values to join together, may be null
&nbsp;     * @param separator  the separator character to use, null treated as &quot;&quot;
&nbsp;     * @param startIndex the first index to start joining from.  It is
&nbsp;     * an error to pass in an end index past the end of the array
&nbsp;     * @param endIndex the index to stop joining from (exclusive). It is
&nbsp;     * an error to pass in an end index past the end of the array
&nbsp;     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
&nbsp;     */
&nbsp;    public static String join(Object[] array, String separator, int startIndex, int endIndex) {
<b class="nc">&nbsp;        if (array == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (separator == null) {</b>
<b class="nc">&nbsp;            separator = EMPTY;</b>
&nbsp;        }
&nbsp;
&nbsp;        // endIndex - startIndex &gt; 0:   Len = NofStrings *(len(firstString) + len(separator))
&nbsp;        //           (Assuming that all Strings are roughly equally long)
<b class="nc">&nbsp;        int bufSize = (endIndex - startIndex);</b>
<b class="nc">&nbsp;        if (bufSize &lt;= 0) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length())</b>
&nbsp;                        + separator.length());
&nbsp;
<b class="nc">&nbsp;        StrBuilder buf = new StrBuilder(bufSize);</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = startIndex; i &lt; endIndex; i++) {</b>
<b class="nc">&nbsp;            if (i &gt; startIndex) {</b>
<b class="nc">&nbsp;                buf.append(separator);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (array[i] != null) {</b>
<b class="nc">&nbsp;                buf.append(array[i]);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return buf.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Joins the elements of the provided &lt;code&gt;Iterator&lt;/code&gt; into
&nbsp;     * a single String containing the provided elements.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;No delimiter is added before or after the list. Null objects or empty
&nbsp;     * strings within the iteration are represented by empty strings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;See the examples here: {@link #join(Object[],char)}. &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param iterator  the &lt;code&gt;Iterator&lt;/code&gt; of values to join together, may be null
&nbsp;     * @param separator  the separator character to use
&nbsp;     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null iterator input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String join(Iterator iterator, char separator) {
&nbsp;
&nbsp;        // handle null, zero and one elements before building a buffer
<b class="nc">&nbsp;        if (iterator == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!iterator.hasNext()) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        Object first = iterator.next();</b>
<b class="nc">&nbsp;        if (!iterator.hasNext()) {</b>
<b class="nc">&nbsp;            return ObjectUtils.toString(first);</b>
&nbsp;        }
&nbsp;
&nbsp;        // two or more elements
<b class="nc">&nbsp;        StrBuilder buf = new StrBuilder(256); // Java default is 16, probably too small</b>
<b class="nc">&nbsp;        if (first != null) {</b>
<b class="nc">&nbsp;            buf.append(first);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        while (iterator.hasNext()) {</b>
<b class="nc">&nbsp;            buf.append(separator);</b>
<b class="nc">&nbsp;            Object obj = iterator.next();</b>
<b class="nc">&nbsp;            if (obj != null) {</b>
<b class="nc">&nbsp;                buf.append(obj);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return buf.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Joins the elements of the provided &lt;code&gt;Iterator&lt;/code&gt; into
&nbsp;     * a single String containing the provided elements.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;No delimiter is added before or after the list.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separator is the same as an empty String (&quot;&quot;).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;See the examples here: {@link #join(Object[],String)}. &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param iterator  the &lt;code&gt;Iterator&lt;/code&gt; of values to join together, may be null
&nbsp;     * @param separator  the separator character to use, null treated as &quot;&quot;
&nbsp;     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null iterator input
&nbsp;     */
&nbsp;    public static String join(Iterator iterator, String separator) {
&nbsp;
&nbsp;        // handle null, zero and one elements before building a buffer
<b class="nc">&nbsp;        if (iterator == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!iterator.hasNext()) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        Object first = iterator.next();</b>
<b class="nc">&nbsp;        if (!iterator.hasNext()) {</b>
<b class="nc">&nbsp;            return ObjectUtils.toString(first);</b>
&nbsp;        }
&nbsp;
&nbsp;        // two or more elements
<b class="nc">&nbsp;        StrBuilder buf = new StrBuilder(256); // Java default is 16, probably too small</b>
<b class="nc">&nbsp;        if (first != null) {</b>
<b class="nc">&nbsp;            buf.append(first);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        while (iterator.hasNext()) {</b>
<b class="nc">&nbsp;            if (separator != null) {</b>
<b class="nc">&nbsp;                buf.append(separator);</b>
&nbsp;            }
<b class="nc">&nbsp;            Object obj = iterator.next();</b>
<b class="nc">&nbsp;            if (obj != null) {</b>
<b class="nc">&nbsp;                buf.append(obj);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return buf.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Joins the elements of the provided &lt;code&gt;Collection&lt;/code&gt; into
&nbsp;     * a single String containing the provided elements.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;No delimiter is added before or after the list. Null objects or empty
&nbsp;     * strings within the iteration are represented by empty strings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;See the examples here: {@link #join(Object[],char)}. &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param collection  the &lt;code&gt;Collection&lt;/code&gt; of values to join together, may be null
&nbsp;     * @param separator  the separator character to use
&nbsp;     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null iterator input
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    public static String join(Collection collection, char separator) {
<b class="nc">&nbsp;        if (collection == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return join(collection.iterator(), separator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Joins the elements of the provided &lt;code&gt;Collection&lt;/code&gt; into
&nbsp;     * a single String containing the provided elements.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;No delimiter is added before or after the list.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; separator is the same as an empty String (&quot;&quot;).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;See the examples here: {@link #join(Object[],String)}. &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param collection  the &lt;code&gt;Collection&lt;/code&gt; of values to join together, may be null
&nbsp;     * @param separator  the separator character to use, null treated as &quot;&quot;
&nbsp;     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null iterator input
&nbsp;     * @since 2.3
&nbsp;     */
&nbsp;    public static String join(Collection collection, String separator) {
<b class="nc">&nbsp;        if (collection == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return join(collection.iterator(), separator);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Delete
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Deletes all &#39;space&#39; characters from a String as defined by
&nbsp;     * {@link Character#isSpace(char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;This is the only StringUtils method that uses the
&nbsp;     * &lt;code&gt;isSpace&lt;/code&gt; definition. You are advised to use
&nbsp;     * {@link #deleteWhitespace(String)} instead as whitespace is much
&nbsp;     * better localized.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.deleteSpaces(null)           = null
&nbsp;     * StringUtils.deleteSpaces(&quot;&quot;)             = &quot;&quot;
&nbsp;     * StringUtils.deleteSpaces(&quot;abc&quot;)          = &quot;abc&quot;
&nbsp;     * StringUtils.deleteSpaces(&quot; \t  abc \n &quot;) = &quot;abc&quot;
&nbsp;     * StringUtils.deleteSpaces(&quot;ab  c&quot;)        = &quot;abc&quot;
&nbsp;     * StringUtils.deleteSpaces(&quot;a\nb\tc     &quot;) = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Spaces are defined as &lt;code&gt;{&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;, &#39;\b&#39;}&lt;/code&gt;
&nbsp;     * in line with the deprecated &lt;code&gt;isSpace&lt;/code&gt; method.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to delete spaces from, may be null
&nbsp;     * @return the String without &#39;spaces&#39;, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @deprecated Use the better localized {@link #deleteWhitespace(String)}.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String deleteSpaces(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return CharSetUtils.delete(str, &quot; \t\r\n\b&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Deletes all whitespaces from a String as defined by
&nbsp;     * {@link Character#isWhitespace(char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.deleteWhitespace(null)         = null
&nbsp;     * StringUtils.deleteWhitespace(&quot;&quot;)           = &quot;&quot;
&nbsp;     * StringUtils.deleteWhitespace(&quot;abc&quot;)        = &quot;abc&quot;
&nbsp;     * StringUtils.deleteWhitespace(&quot;   ab  c  &quot;) = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to delete whitespace from, may be null
&nbsp;     * @return the String without whitespaces, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String deleteWhitespace(String str) {
<b class="nc">&nbsp;        if (isEmpty(str)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = str.length();</b>
<b class="nc">&nbsp;        char[] chs = new char[sz];</b>
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            if (!Character.isWhitespace(str.charAt(i))) {</b>
<b class="nc">&nbsp;                chs[count++] = str.charAt(i);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (count == sz) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new String(chs, 0, count);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Remove
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Removes a substring only if it is at the begining of a source string,
&nbsp;     * otherwise returns the source string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source string will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) source string will return the empty string.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; search string will return the source string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.removeStart(null, *)      = null
&nbsp;     * StringUtils.removeStart(&quot;&quot;, *)        = &quot;&quot;
&nbsp;     * StringUtils.removeStart(*, null)      = *
&nbsp;     * StringUtils.removeStart(&quot;www.domain.com&quot;, &quot;www.&quot;)   = &quot;domain.com&quot;
&nbsp;     * StringUtils.removeStart(&quot;domain.com&quot;, &quot;www.&quot;)       = &quot;domain.com&quot;
&nbsp;     * StringUtils.removeStart(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
&nbsp;     * StringUtils.removeStart(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the source String to search, may be null
&nbsp;     * @param remove  the String to search for and remove, may be null
&nbsp;     * @return the substring with the string removed if found,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public static String removeStart(String str, String remove) {
<b class="nc">&nbsp;        if (isEmpty(str) || isEmpty(remove)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (str.startsWith(remove)){</b>
<b class="nc">&nbsp;            return str.substring(remove.length());</b>
&nbsp;        }
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Case insensitive removal of a substring if it is at the begining of a source string,
&nbsp;     * otherwise returns the source string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source string will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) source string will return the empty string.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; search string will return the source string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.removeStartIgnoreCase(null, *)      = null
&nbsp;     * StringUtils.removeStartIgnoreCase(&quot;&quot;, *)        = &quot;&quot;
&nbsp;     * StringUtils.removeStartIgnoreCase(*, null)      = *
&nbsp;     * StringUtils.removeStartIgnoreCase(&quot;www.domain.com&quot;, &quot;www.&quot;)   = &quot;domain.com&quot;
&nbsp;     * StringUtils.removeStartIgnoreCase(&quot;www.domain.com&quot;, &quot;WWW.&quot;)   = &quot;domain.com&quot;
&nbsp;     * StringUtils.removeStartIgnoreCase(&quot;domain.com&quot;, &quot;www.&quot;)       = &quot;domain.com&quot;
&nbsp;     * StringUtils.removeStartIgnoreCase(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
&nbsp;     * StringUtils.removeStartIgnoreCase(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the source String to search, may be null
&nbsp;     * @param remove  the String to search for (case insensitive) and remove, may be null
&nbsp;     * @return the substring with the string removed if found,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static String removeStartIgnoreCase(String str, String remove) {
<b class="nc">&nbsp;        if (isEmpty(str) || isEmpty(remove)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (startsWithIgnoreCase(str, remove)) {</b>
<b class="nc">&nbsp;            return str.substring(remove.length());</b>
&nbsp;        }
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Removes a substring only if it is at the end of a source string,
&nbsp;     * otherwise returns the source string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source string will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) source string will return the empty string.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; search string will return the source string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.removeEnd(null, *)      = null
&nbsp;     * StringUtils.removeEnd(&quot;&quot;, *)        = &quot;&quot;
&nbsp;     * StringUtils.removeEnd(*, null)      = *
&nbsp;     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;.com.&quot;)  = &quot;www.domain.com&quot;
&nbsp;     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;.com&quot;)   = &quot;www.domain&quot;
&nbsp;     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
&nbsp;     * StringUtils.removeEnd(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the source String to search, may be null
&nbsp;     * @param remove  the String to search for and remove, may be null
&nbsp;     * @return the substring with the string removed if found,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public static String removeEnd(String str, String remove) {
<b class="nc">&nbsp;        if (isEmpty(str) || isEmpty(remove)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (str.endsWith(remove)) {</b>
<b class="nc">&nbsp;            return str.substring(0, str.length() - remove.length());</b>
&nbsp;        }
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Case insensitive removal of a substring if it is at the end of a source string,
&nbsp;     * otherwise returns the source string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source string will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) source string will return the empty string.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; search string will return the source string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.removeEndIgnoreCase(null, *)      = null
&nbsp;     * StringUtils.removeEndIgnoreCase(&quot;&quot;, *)        = &quot;&quot;
&nbsp;     * StringUtils.removeEndIgnoreCase(*, null)      = *
&nbsp;     * StringUtils.removeEndIgnoreCase(&quot;www.domain.com&quot;, &quot;.com.&quot;)  = &quot;www.domain.com&quot;
&nbsp;     * StringUtils.removeEndIgnoreCase(&quot;www.domain.com&quot;, &quot;.com&quot;)   = &quot;www.domain&quot;
&nbsp;     * StringUtils.removeEndIgnoreCase(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
&nbsp;     * StringUtils.removeEndIgnoreCase(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
&nbsp;     * StringUtils.removeEndIgnoreCase(&quot;www.domain.com&quot;, &quot;.COM&quot;) = &quot;www.domain&quot;)
&nbsp;     * StringUtils.removeEndIgnoreCase(&quot;www.domain.COM&quot;, &quot;.com&quot;) = &quot;www.domain&quot;)
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the source String to search, may be null
&nbsp;     * @param remove  the String to search for (case insensitive) and remove, may be null
&nbsp;     * @return the substring with the string removed if found,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static String removeEndIgnoreCase(String str, String remove) {
<b class="nc">&nbsp;        if (isEmpty(str) || isEmpty(remove)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (endsWithIgnoreCase(str, remove)) {</b>
<b class="nc">&nbsp;            return str.substring(0, str.length() - remove.length());</b>
&nbsp;        }
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Removes all occurrences of a substring from within the source string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source string will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) source string will return the empty string.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; remove string will return the source string.
&nbsp;     * An empty (&quot;&quot;) remove string will return the source string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.remove(null, *)        = null
&nbsp;     * StringUtils.remove(&quot;&quot;, *)          = &quot;&quot;
&nbsp;     * StringUtils.remove(*, null)        = *
&nbsp;     * StringUtils.remove(*, &quot;&quot;)          = *
&nbsp;     * StringUtils.remove(&quot;queued&quot;, &quot;ue&quot;) = &quot;qd&quot;
&nbsp;     * StringUtils.remove(&quot;queued&quot;, &quot;zz&quot;) = &quot;queued&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the source String to search, may be null
&nbsp;     * @param remove  the String to search for and remove, may be null
&nbsp;     * @return the substring with the string removed if found,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public static String remove(String str, String remove) {
<b class="nc">&nbsp;        if (isEmpty(str) || isEmpty(remove)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        return replace(str, remove, EMPTY, -1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Removes all occurrences of a character from within the source string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source string will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) source string will return the empty string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.remove(null, *)       = null
&nbsp;     * StringUtils.remove(&quot;&quot;, *)         = &quot;&quot;
&nbsp;     * StringUtils.remove(&quot;queued&quot;, &#39;u&#39;) = &quot;qeed&quot;
&nbsp;     * StringUtils.remove(&quot;queued&quot;, &#39;z&#39;) = &quot;queued&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the source String to search, may be null
&nbsp;     * @param remove  the char to search for and remove, may be null
&nbsp;     * @return the substring with the char removed if found,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public static String remove(String str, char remove) {
<b class="nc">&nbsp;        if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        char[] chars = str.toCharArray();</b>
<b class="nc">&nbsp;        int pos = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; chars.length; i++) {</b>
<b class="nc">&nbsp;            if (chars[i] != remove) {</b>
<b class="nc">&nbsp;                chars[pos++] = chars[i];</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return new String(chars, 0, pos);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Replacing
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Replaces a String with another String inside a larger String, once.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.replaceOnce(null, *, *)        = null
&nbsp;     * StringUtils.replaceOnce(&quot;&quot;, *, *)          = &quot;&quot;
&nbsp;     * StringUtils.replaceOnce(&quot;any&quot;, null, *)    = &quot;any&quot;
&nbsp;     * StringUtils.replaceOnce(&quot;any&quot;, *, null)    = &quot;any&quot;
&nbsp;     * StringUtils.replaceOnce(&quot;any&quot;, &quot;&quot;, *)      = &quot;any&quot;
&nbsp;     * StringUtils.replaceOnce(&quot;aba&quot;, &quot;a&quot;, null)  = &quot;aba&quot;
&nbsp;     * StringUtils.replaceOnce(&quot;aba&quot;, &quot;a&quot;, &quot;&quot;)    = &quot;ba&quot;
&nbsp;     * StringUtils.replaceOnce(&quot;aba&quot;, &quot;a&quot;, &quot;z&quot;)   = &quot;zba&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @see #replace(String text, String searchString, String replacement, int max)
&nbsp;     * @param text  text to search and replace in, may be null
&nbsp;     * @param searchString  the String to search for, may be null
&nbsp;     * @param replacement  the String to replace with, may be null
&nbsp;     * @return the text with any replacements processed,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String replaceOnce(String text, String searchString, String replacement) {
<b class="nc">&nbsp;        return replace(text, searchString, replacement, 1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Replaces all occurrences of a String within another String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.replace(null, *, *)        = null
&nbsp;     * StringUtils.replace(&quot;&quot;, *, *)          = &quot;&quot;
&nbsp;     * StringUtils.replace(&quot;any&quot;, null, *)    = &quot;any&quot;
&nbsp;     * StringUtils.replace(&quot;any&quot;, *, null)    = &quot;any&quot;
&nbsp;     * StringUtils.replace(&quot;any&quot;, &quot;&quot;, *)      = &quot;any&quot;
&nbsp;     * StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, null)  = &quot;aba&quot;
&nbsp;     * StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, &quot;&quot;)    = &quot;b&quot;
&nbsp;     * StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, &quot;z&quot;)   = &quot;zbz&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @see #replace(String text, String searchString, String replacement, int max)
&nbsp;     * @param text  text to search and replace in, may be null
&nbsp;     * @param searchString  the String to search for, may be null
&nbsp;     * @param replacement  the String to replace it with, may be null
&nbsp;     * @return the text with any replacements processed,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String replace(String text, String searchString, String replacement) {
<b class="nc">&nbsp;        return replace(text, searchString, replacement, -1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Replaces a String with another String inside a larger String,
&nbsp;     * for the first &lt;code&gt;max&lt;/code&gt; values of the search String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.replace(null, *, *, *)         = null
&nbsp;     * StringUtils.replace(&quot;&quot;, *, *, *)           = &quot;&quot;
&nbsp;     * StringUtils.replace(&quot;any&quot;, null, *, *)     = &quot;any&quot;
&nbsp;     * StringUtils.replace(&quot;any&quot;, *, null, *)     = &quot;any&quot;
&nbsp;     * StringUtils.replace(&quot;any&quot;, &quot;&quot;, *, *)       = &quot;any&quot;
&nbsp;     * StringUtils.replace(&quot;any&quot;, *, *, 0)        = &quot;any&quot;
&nbsp;     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, null, -1) = &quot;abaa&quot;
&nbsp;     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;&quot;, -1)   = &quot;b&quot;
&nbsp;     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 0)   = &quot;abaa&quot;
&nbsp;     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 1)   = &quot;zbaa&quot;
&nbsp;     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 2)   = &quot;zbza&quot;
&nbsp;     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, -1)  = &quot;zbzz&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param text  text to search and replace in, may be null
&nbsp;     * @param searchString  the String to search for, may be null
&nbsp;     * @param replacement  the String to replace it with, may be null
&nbsp;     * @param max  maximum number of values to replace, or &lt;code&gt;-1&lt;/code&gt; if no maximum
&nbsp;     * @return the text with any replacements processed,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String replace(String text, String searchString, String replacement, int max) {
<b class="nc">&nbsp;        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {</b>
<b class="nc">&nbsp;            return text;</b>
&nbsp;        }
<b class="nc">&nbsp;        int start = 0;</b>
<b class="nc">&nbsp;        int end = text.indexOf(searchString, start);</b>
<b class="nc">&nbsp;        if (end == INDEX_NOT_FOUND) {</b>
<b class="nc">&nbsp;            return text;</b>
&nbsp;        }
<b class="nc">&nbsp;        int replLength = searchString.length();</b>
<b class="nc">&nbsp;        int increase = replacement.length() - replLength;</b>
<b class="nc">&nbsp;        increase = (increase &lt; 0 ? 0 : increase);</b>
<b class="nc">&nbsp;        increase *= (max &lt; 0 ? 16 : (max &gt; 64 ? 64 : max));</b>
<b class="nc">&nbsp;        StrBuilder buf = new StrBuilder(text.length() + increase);</b>
<b class="nc">&nbsp;        while (end != INDEX_NOT_FOUND) {</b>
<b class="nc">&nbsp;            buf.append(text.substring(start, end)).append(replacement);</b>
<b class="nc">&nbsp;            start = end + replLength;</b>
<b class="nc">&nbsp;            if (--max == 0) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            end = text.indexOf(searchString, start);</b>
&nbsp;        }
<b class="nc">&nbsp;        buf.append(text.substring(start));</b>
<b class="nc">&nbsp;        return buf.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Replaces all occurrences of Strings within another String.
&nbsp;     * &lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;p&gt;
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op, or if
&nbsp;     * any &quot;search string&quot; or &quot;string to replace&quot; is null, that replace will be
&nbsp;     * ignored. This will not repeat. For repeating replaces, call the
&nbsp;     * overloaded method.
&nbsp;     * &lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;pre&gt;
&nbsp;     *  StringUtils.replaceEach(null, *, *)        = null
&nbsp;     *  StringUtils.replaceEach(&quot;&quot;, *, *)          = &quot;&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, null, null) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, new String[0], null) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, null, new String[0]) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, null)  = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, new String[]{&quot;&quot;})  = &quot;b&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{null}, new String[]{&quot;a&quot;})  = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;w&quot;, &quot;t&quot;})  = &quot;wcte&quot;
&nbsp;     *  (example of how it does not repeat)
&nbsp;     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;})  = &quot;dcte&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     * 
&nbsp;     * @param text
&nbsp;     *            text to search and replace in, no-op if null
&nbsp;     * @param searchList
&nbsp;     *            the Strings to search for, no-op if null
&nbsp;     * @param replacementList
&nbsp;     *            the Strings to replace them with, no-op if null
&nbsp;     * @return the text with any replacements processed, &lt;code&gt;null&lt;/code&gt; if
&nbsp;     *         null String input
&nbsp;     * @throws IndexOutOfBoundsException
&nbsp;     *             if the lengths of the arrays are not the same (null is ok,
&nbsp;     *             and/or size 0)
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static String replaceEach(String text, String[] searchList, String[] replacementList) {
<b class="nc">&nbsp;        return replaceEach(text, searchList, replacementList, false, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Replaces all occurrences of Strings within another String.
&nbsp;     * &lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;p&gt;
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op, or if
&nbsp;     * any &quot;search string&quot; or &quot;string to replace&quot; is null, that replace will be
&nbsp;     * ignored. This will not repeat. For repeating replaces, call the
&nbsp;     * overloaded method.
&nbsp;     * &lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;pre&gt;
&nbsp;     *  StringUtils.replaceEach(null, *, *, *) = null
&nbsp;     *  StringUtils.replaceEach(&quot;&quot;, *, *, *) = &quot;&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, null, null, *) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, new String[0], null, *) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, null, new String[0], *) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, null, *) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, new String[]{&quot;&quot;}, *) = &quot;b&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{null}, new String[]{&quot;a&quot;}, *) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;w&quot;, &quot;t&quot;}, *) = &quot;wcte&quot;
&nbsp;     *  (example of how it repeats)
&nbsp;     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;}, false) = &quot;dcte&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;}, true) = &quot;tcte&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;ab&quot;}, true) = IllegalArgumentException
&nbsp;     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;ab&quot;}, false) = &quot;dcabe&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     * 
&nbsp;     * @param text
&nbsp;     *            text to search and replace in, no-op if null
&nbsp;     * @param searchList
&nbsp;     *            the Strings to search for, no-op if null
&nbsp;     * @param replacementList
&nbsp;     *            the Strings to replace them with, no-op if null
&nbsp;     * @return the text with any replacements processed, &lt;code&gt;null&lt;/code&gt; if
&nbsp;     *         null String input
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *             if the search is repeating and there is an endless loop due
&nbsp;     *             to outputs of one being inputs to another
&nbsp;     * @throws IndexOutOfBoundsException
&nbsp;     *             if the lengths of the arrays are not the same (null is ok,
&nbsp;     *             and/or size 0)
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
&nbsp;        // timeToLive should be 0 if not used or nothing to replace, else it&#39;s
&nbsp;        // the length of the replace array
<b class="nc">&nbsp;        int timeToLive = searchList == null ? 0 : searchList.length;</b>
<b class="nc">&nbsp;        return replaceEach(text, searchList, replacementList, true, timeToLive);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Replaces all occurrences of Strings within another String.
&nbsp;     * &lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;p&gt;
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op, or if
&nbsp;     * any &quot;search string&quot; or &quot;string to replace&quot; is null, that replace will be
&nbsp;     * ignored. 
&nbsp;     * &lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;pre&gt;
&nbsp;     *  StringUtils.replaceEach(null, *, *, *) = null
&nbsp;     *  StringUtils.replaceEach(&quot;&quot;, *, *, *) = &quot;&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, null, null, *) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, new String[0], null, *) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, null, new String[0], *) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, null, *) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, new String[]{&quot;&quot;}, *) = &quot;b&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{null}, new String[]{&quot;a&quot;}, *) = &quot;aba&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;w&quot;, &quot;t&quot;}, *) = &quot;wcte&quot;
&nbsp;     *  (example of how it repeats)
&nbsp;     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;}, false) = &quot;dcte&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;}, true) = &quot;tcte&quot;
&nbsp;     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;ab&quot;}, *) = IllegalArgumentException
&nbsp;     * &lt;/pre&gt;
&nbsp;     * 
&nbsp;     * @param text
&nbsp;     *            text to search and replace in, no-op if null
&nbsp;     * @param searchList
&nbsp;     *            the Strings to search for, no-op if null
&nbsp;     * @param replacementList
&nbsp;     *            the Strings to replace them with, no-op if null
&nbsp;     * @param repeat if true, then replace repeatedly 
&nbsp;     *       until there are no more possible replacements or timeToLive &lt; 0
&nbsp;     * @param timeToLive
&nbsp;     *            if less than 0 then there is a circular reference and endless
&nbsp;     *            loop
&nbsp;     * @return the text with any replacements processed, &lt;code&gt;null&lt;/code&gt; if
&nbsp;     *         null String input
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *             if the search is repeating and there is an endless loop due
&nbsp;     *             to outputs of one being inputs to another
&nbsp;     * @throws IndexOutOfBoundsException
&nbsp;     *             if the lengths of the arrays are not the same (null is ok,
&nbsp;     *             and/or size 0)
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    private static String replaceEach(String text, String[] searchList, String[] replacementList, 
&nbsp;                                      boolean repeat, int timeToLive) 
&nbsp;    {
&nbsp;
&nbsp;        // mchyzer Performance note: This creates very few new objects (one major goal)
&nbsp;        // let me know if there are performance requests, we can create a harness to measure
&nbsp;
<b class="nc">&nbsp;        if (text == null || text.length() == 0 || searchList == null || </b>
&nbsp;            searchList.length == 0 || replacementList == null || replacementList.length == 0) 
&nbsp;        {
<b class="nc">&nbsp;            return text;</b>
&nbsp;        }
&nbsp;
&nbsp;        // if recursing, this shouldnt be less than 0
<b class="nc">&nbsp;        if (timeToLive &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;TimeToLive of &quot; + timeToLive + &quot; is less than 0: &quot; + text);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int searchLength = searchList.length;</b>
<b class="nc">&nbsp;        int replacementLength = replacementList.length;</b>
&nbsp;
&nbsp;        // make sure lengths are ok, these need to be equal
<b class="nc">&nbsp;        if (searchLength != replacementLength) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Search and Replace array lengths don&#39;t match: &quot;</b>
&nbsp;                + searchLength
&nbsp;                + &quot; vs &quot;
&nbsp;                + replacementLength);
&nbsp;        }
&nbsp;
&nbsp;        // keep track of which still have matches
<b class="nc">&nbsp;        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];</b>
&nbsp;
&nbsp;        // index on index that the match was found
<b class="nc">&nbsp;        int textIndex = -1;</b>
<b class="nc">&nbsp;        int replaceIndex = -1;</b>
<b class="nc">&nbsp;        int tempIndex = -1;</b>
&nbsp;
&nbsp;        // index of replace array that will replace the search string found
&nbsp;        // NOTE: logic duplicated below START
<b class="nc">&nbsp;        for (int i = 0; i &lt; searchLength; i++) {</b>
<b class="nc">&nbsp;            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || </b>
&nbsp;                searchList[i].length() == 0 || replacementList[i] == null) 
&nbsp;            {
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            tempIndex = text.indexOf(searchList[i]);</b>
&nbsp;
&nbsp;            // see if we need to keep searching for this
<b class="nc">&nbsp;            if (tempIndex == -1) {</b>
<b class="nc">&nbsp;                noMoreMatchesForReplIndex[i] = true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                if (textIndex == -1 || tempIndex &lt; textIndex) {</b>
<b class="nc">&nbsp;                    textIndex = tempIndex;</b>
<b class="nc">&nbsp;                    replaceIndex = i;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        // NOTE: logic mostly below END
&nbsp;
&nbsp;        // no search strings found, we are done
<b class="nc">&nbsp;        if (textIndex == -1) {</b>
<b class="nc">&nbsp;            return text;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int start = 0;</b>
&nbsp;
&nbsp;        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
<b class="nc">&nbsp;        int increase = 0;</b>
&nbsp;
&nbsp;        // count the replacement text elements that are larger than their corresponding text being replaced
<b class="nc">&nbsp;        for (int i = 0; i &lt; searchList.length; i++) {</b>
<b class="nc">&nbsp;            if (searchList[i] == null || replacementList[i] == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            int greater = replacementList[i].length() - searchList[i].length();</b>
<b class="nc">&nbsp;            if (greater &gt; 0) {</b>
<b class="nc">&nbsp;                increase += 3 * greater; // assume 3 matches</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // have upper-bound at 20% increase, then let Java take over
<b class="nc">&nbsp;        increase = Math.min(increase, text.length() / 5);</b>
&nbsp;
<b class="nc">&nbsp;        StrBuilder buf = new StrBuilder(text.length() + increase);</b>
&nbsp;
<b class="nc">&nbsp;        while (textIndex != -1) {</b>
&nbsp;
<b class="nc">&nbsp;            for (int i = start; i &lt; textIndex; i++) {</b>
<b class="nc">&nbsp;                buf.append(text.charAt(i));</b>
&nbsp;            }
<b class="nc">&nbsp;            buf.append(replacementList[replaceIndex]);</b>
&nbsp;
<b class="nc">&nbsp;            start = textIndex + searchList[replaceIndex].length();</b>
&nbsp;
<b class="nc">&nbsp;            textIndex = -1;</b>
<b class="nc">&nbsp;            replaceIndex = -1;</b>
<b class="nc">&nbsp;            tempIndex = -1;</b>
&nbsp;            // find the next earliest match
&nbsp;            // NOTE: logic mostly duplicated above START
<b class="nc">&nbsp;            for (int i = 0; i &lt; searchLength; i++) {</b>
<b class="nc">&nbsp;                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || </b>
&nbsp;                    searchList[i].length() == 0 || replacementList[i] == null) 
&nbsp;                {
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                tempIndex = text.indexOf(searchList[i], start);</b>
&nbsp;
&nbsp;                // see if we need to keep searching for this
<b class="nc">&nbsp;                if (tempIndex == -1) {</b>
<b class="nc">&nbsp;                    noMoreMatchesForReplIndex[i] = true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (textIndex == -1 || tempIndex &lt; textIndex) {</b>
<b class="nc">&nbsp;                        textIndex = tempIndex;</b>
<b class="nc">&nbsp;                        replaceIndex = i;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            // NOTE: logic duplicated above END
&nbsp;
&nbsp;        }
<b class="nc">&nbsp;        int textLength = text.length();</b>
<b class="nc">&nbsp;        for (int i = start; i &lt; textLength; i++) {</b>
<b class="nc">&nbsp;            buf.append(text.charAt(i));</b>
&nbsp;        }
<b class="nc">&nbsp;        String result = buf.toString();</b>
<b class="nc">&nbsp;        if (!repeat) {</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Replace, character based
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Replaces all occurrences of a character in a String with another.
&nbsp;     * This is a null-safe version of {@link String#replace(char, char)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) string input returns an empty string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.replaceChars(null, *, *)        = null
&nbsp;     * StringUtils.replaceChars(&quot;&quot;, *, *)          = &quot;&quot;
&nbsp;     * StringUtils.replaceChars(&quot;abcba&quot;, &#39;b&#39;, &#39;y&#39;) = &quot;aycya&quot;
&nbsp;     * StringUtils.replaceChars(&quot;abcba&quot;, &#39;z&#39;, &#39;y&#39;) = &quot;abcba&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  String to replace characters in, may be null
&nbsp;     * @param searchChar  the character to search for, may be null
&nbsp;     * @param replaceChar  the character to replace, may be null
&nbsp;     * @return modified String, &lt;code&gt;null&lt;/code&gt; if null string input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String replaceChars(String str, char searchChar, char replaceChar) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.replace(searchChar, replaceChar);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Replaces multiple characters in a String in one go.
&nbsp;     * This method can also be used to delete characters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;For example:&lt;br /&gt;
&nbsp;     * &lt;code&gt;replaceChars(&amp;quot;hello&amp;quot;, &amp;quot;ho&amp;quot;, &amp;quot;jy&amp;quot;) = jelly&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * An empty (&quot;&quot;) string input returns an empty string.
&nbsp;     * A null or empty set of search characters returns the input string.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The length of the search characters should normally equal the length
&nbsp;     * of the replace characters.
&nbsp;     * If the search characters is longer, then the extra search characters
&nbsp;     * are deleted.
&nbsp;     * If the search characters is shorter, then the extra replace characters
&nbsp;     * are ignored.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.replaceChars(null, *, *)           = null
&nbsp;     * StringUtils.replaceChars(&quot;&quot;, *, *)             = &quot;&quot;
&nbsp;     * StringUtils.replaceChars(&quot;abc&quot;, null, *)       = &quot;abc&quot;
&nbsp;     * StringUtils.replaceChars(&quot;abc&quot;, &quot;&quot;, *)         = &quot;abc&quot;
&nbsp;     * StringUtils.replaceChars(&quot;abc&quot;, &quot;b&quot;, null)     = &quot;ac&quot;
&nbsp;     * StringUtils.replaceChars(&quot;abc&quot;, &quot;b&quot;, &quot;&quot;)       = &quot;ac&quot;
&nbsp;     * StringUtils.replaceChars(&quot;abcba&quot;, &quot;bc&quot;, &quot;yz&quot;)  = &quot;ayzya&quot;
&nbsp;     * StringUtils.replaceChars(&quot;abcba&quot;, &quot;bc&quot;, &quot;y&quot;)   = &quot;ayya&quot;
&nbsp;     * StringUtils.replaceChars(&quot;abcba&quot;, &quot;bc&quot;, &quot;yzx&quot;) = &quot;ayzya&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  String to replace characters in, may be null
&nbsp;     * @param searchChars  a set of characters to search for, may be null
&nbsp;     * @param replaceChars  a set of characters to replace, may be null
&nbsp;     * @return modified String, &lt;code&gt;null&lt;/code&gt; if null string input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String replaceChars(String str, String searchChars, String replaceChars) {
<b class="nc">&nbsp;        if (isEmpty(str) || isEmpty(searchChars)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (replaceChars == null) {</b>
<b class="nc">&nbsp;            replaceChars = EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean modified = false;</b>
<b class="nc">&nbsp;        int replaceCharsLength = replaceChars.length();</b>
<b class="nc">&nbsp;        int strLength = str.length();</b>
<b class="nc">&nbsp;        StrBuilder buf = new StrBuilder(strLength);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; strLength; i++) {</b>
<b class="nc">&nbsp;            char ch = str.charAt(i);</b>
<b class="nc">&nbsp;            int index = searchChars.indexOf(ch);</b>
<b class="nc">&nbsp;            if (index &gt;= 0) {</b>
<b class="nc">&nbsp;                modified = true;</b>
<b class="nc">&nbsp;                if (index &lt; replaceCharsLength) {</b>
<b class="nc">&nbsp;                    buf.append(replaceChars.charAt(index));</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                buf.append(ch);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (modified) {</b>
<b class="nc">&nbsp;            return buf.toString();</b>
&nbsp;        }
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Overlay
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Overlays part of a String with another String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.overlayString(null, *, *, *)           = NullPointerException
&nbsp;     * StringUtils.overlayString(*, null, *, *)           = NullPointerException
&nbsp;     * StringUtils.overlayString(&quot;&quot;, &quot;abc&quot;, 0, 0)         = &quot;abc&quot;
&nbsp;     * StringUtils.overlayString(&quot;abcdef&quot;, null, 2, 4)    = &quot;abef&quot;
&nbsp;     * StringUtils.overlayString(&quot;abcdef&quot;, &quot;&quot;, 2, 4)      = &quot;abef&quot;
&nbsp;     * StringUtils.overlayString(&quot;abcdef&quot;, &quot;zzzz&quot;, 2, 4)  = &quot;abzzzzef&quot;
&nbsp;     * StringUtils.overlayString(&quot;abcdef&quot;, &quot;zzzz&quot;, 4, 2)  = &quot;abcdzzzzcdef&quot;
&nbsp;     * StringUtils.overlayString(&quot;abcdef&quot;, &quot;zzzz&quot;, -1, 4) = IndexOutOfBoundsException
&nbsp;     * StringUtils.overlayString(&quot;abcdef&quot;, &quot;zzzz&quot;, 2, 8)  = IndexOutOfBoundsException
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param text  the String to do overlaying in, may be null
&nbsp;     * @param overlay  the String to overlay, may be null
&nbsp;     * @param start  the position to start overlaying at, must be valid
&nbsp;     * @param end  the position to stop overlaying before, must be valid
&nbsp;     * @return overlayed String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @throws NullPointerException if text or overlay is null
&nbsp;     * @throws IndexOutOfBoundsException if either position is invalid
&nbsp;     * @deprecated Use better named {@link #overlay(String, String, int, int)} instead.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String overlayString(String text, String overlay, int start, int end) {
<b class="nc">&nbsp;        return new StrBuilder(start + overlay.length() + text.length() - end + 1)</b>
&nbsp;            .append(text.substring(0, start))
&nbsp;            .append(overlay)
&nbsp;            .append(text.substring(end))
&nbsp;            .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Overlays part of a String with another String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A negative index is treated as zero.
&nbsp;     * An index greater than the string length is treated as the string length.
&nbsp;     * The start index is always the smaller of the two indices.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.overlay(null, *, *, *)            = null
&nbsp;     * StringUtils.overlay(&quot;&quot;, &quot;abc&quot;, 0, 0)          = &quot;abc&quot;
&nbsp;     * StringUtils.overlay(&quot;abcdef&quot;, null, 2, 4)     = &quot;abef&quot;
&nbsp;     * StringUtils.overlay(&quot;abcdef&quot;, &quot;&quot;, 2, 4)       = &quot;abef&quot;
&nbsp;     * StringUtils.overlay(&quot;abcdef&quot;, &quot;&quot;, 4, 2)       = &quot;abef&quot;
&nbsp;     * StringUtils.overlay(&quot;abcdef&quot;, &quot;zzzz&quot;, 2, 4)   = &quot;abzzzzef&quot;
&nbsp;     * StringUtils.overlay(&quot;abcdef&quot;, &quot;zzzz&quot;, 4, 2)   = &quot;abzzzzef&quot;
&nbsp;     * StringUtils.overlay(&quot;abcdef&quot;, &quot;zzzz&quot;, -1, 4)  = &quot;zzzzef&quot;
&nbsp;     * StringUtils.overlay(&quot;abcdef&quot;, &quot;zzzz&quot;, 2, 8)   = &quot;abzzzz&quot;
&nbsp;     * StringUtils.overlay(&quot;abcdef&quot;, &quot;zzzz&quot;, -2, -3) = &quot;zzzzabcdef&quot;
&nbsp;     * StringUtils.overlay(&quot;abcdef&quot;, &quot;zzzz&quot;, 8, 10)  = &quot;abcdefzzzz&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to do overlaying in, may be null
&nbsp;     * @param overlay  the String to overlay, may be null
&nbsp;     * @param start  the position to start overlaying at
&nbsp;     * @param end  the position to stop overlaying before
&nbsp;     * @return overlayed String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String overlay(String str, String overlay, int start, int end) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (overlay == null) {</b>
<b class="nc">&nbsp;            overlay = EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        int len = str.length();</b>
<b class="nc">&nbsp;        if (start &lt; 0) {</b>
<b class="nc">&nbsp;            start = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (start &gt; len) {</b>
<b class="nc">&nbsp;            start = len;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (end &lt; 0) {</b>
<b class="nc">&nbsp;            end = 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (end &gt; len) {</b>
<b class="nc">&nbsp;            end = len;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (start &gt; end) {</b>
<b class="nc">&nbsp;            int temp = start;</b>
<b class="nc">&nbsp;            start = end;</b>
<b class="nc">&nbsp;            end = temp;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new StrBuilder(len + start - end + overlay.length() + 1)</b>
&nbsp;            .append(str.substring(0, start))
&nbsp;            .append(overlay)
&nbsp;            .append(str.substring(end))
&nbsp;            .toString();
&nbsp;    }
&nbsp;
&nbsp;    // Chomping
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Removes one newline from end of a String if it&#39;s there,
&nbsp;     * otherwise leave it alone.  A newline is &amp;quot;&lt;code&gt;\n&lt;/code&gt;&amp;quot;,
&nbsp;     * &amp;quot;&lt;code&gt;\r&lt;/code&gt;&amp;quot;, or &amp;quot;&lt;code&gt;\r\n&lt;/code&gt;&amp;quot;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;NOTE: This method changed in 2.0.
&nbsp;     * It now more closely matches Perl chomp.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.chomp(null)          = null
&nbsp;     * StringUtils.chomp(&quot;&quot;)            = &quot;&quot;
&nbsp;     * StringUtils.chomp(&quot;abc \r&quot;)      = &quot;abc &quot;
&nbsp;     * StringUtils.chomp(&quot;abc\n&quot;)       = &quot;abc&quot;
&nbsp;     * StringUtils.chomp(&quot;abc\r\n&quot;)     = &quot;abc&quot;
&nbsp;     * StringUtils.chomp(&quot;abc\r\n\r\n&quot;) = &quot;abc\r\n&quot;
&nbsp;     * StringUtils.chomp(&quot;abc\n\r&quot;)     = &quot;abc\n&quot;
&nbsp;     * StringUtils.chomp(&quot;abc\n\rabc&quot;)  = &quot;abc\n\rabc&quot;
&nbsp;     * StringUtils.chomp(&quot;\r&quot;)          = &quot;&quot;
&nbsp;     * StringUtils.chomp(&quot;\n&quot;)          = &quot;&quot;
&nbsp;     * StringUtils.chomp(&quot;\r\n&quot;)        = &quot;&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to chomp a newline from, may be null
&nbsp;     * @return String without newline, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String chomp(String str) {
<b class="nc">&nbsp;        if (isEmpty(str)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (str.length() == 1) {</b>
<b class="nc">&nbsp;            char ch = str.charAt(0);</b>
<b class="nc">&nbsp;            if (ch == CharUtils.CR || ch == CharUtils.LF) {</b>
<b class="nc">&nbsp;                return EMPTY;</b>
&nbsp;            }
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int lastIdx = str.length() - 1;</b>
<b class="nc">&nbsp;        char last = str.charAt(lastIdx);</b>
&nbsp;
<b class="nc">&nbsp;        if (last == CharUtils.LF) {</b>
<b class="nc">&nbsp;            if (str.charAt(lastIdx - 1) == CharUtils.CR) {</b>
<b class="nc">&nbsp;                lastIdx--;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (last != CharUtils.CR) {</b>
<b class="nc">&nbsp;            lastIdx++;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.substring(0, lastIdx);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Removes &lt;code&gt;separator&lt;/code&gt; from the end of
&nbsp;     * &lt;code&gt;str&lt;/code&gt; if it&#39;s there, otherwise leave it alone.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;NOTE: This method changed in version 2.0.
&nbsp;     * It now more closely matches Perl chomp.
&nbsp;     * For the previous behavior, use {@link #substringBeforeLast(String, String)}.
&nbsp;     * This method uses {@link String#endsWith(String)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.chomp(null, *)         = null
&nbsp;     * StringUtils.chomp(&quot;&quot;, *)           = &quot;&quot;
&nbsp;     * StringUtils.chomp(&quot;foobar&quot;, &quot;bar&quot;) = &quot;foo&quot;
&nbsp;     * StringUtils.chomp(&quot;foobar&quot;, &quot;baz&quot;) = &quot;foobar&quot;
&nbsp;     * StringUtils.chomp(&quot;foo&quot;, &quot;foo&quot;)    = &quot;&quot;
&nbsp;     * StringUtils.chomp(&quot;foo &quot;, &quot;foo&quot;)   = &quot;foo &quot;
&nbsp;     * StringUtils.chomp(&quot; foo&quot;, &quot;foo&quot;)   = &quot; &quot;
&nbsp;     * StringUtils.chomp(&quot;foo&quot;, &quot;foooo&quot;)  = &quot;foo&quot;
&nbsp;     * StringUtils.chomp(&quot;foo&quot;, &quot;&quot;)       = &quot;foo&quot;
&nbsp;     * StringUtils.chomp(&quot;foo&quot;, null)     = &quot;foo&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to chomp from, may be null
&nbsp;     * @param separator  separator String, may be null
&nbsp;     * @return String without trailing separator, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String chomp(String str, String separator) {
<b class="nc">&nbsp;        if (isEmpty(str) || separator == null) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (str.endsWith(separator)) {</b>
<b class="nc">&nbsp;            return str.substring(0, str.length() - separator.length());</b>
&nbsp;        }
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Remove any &amp;quot;\n&amp;quot; if and only if it is at the end
&nbsp;     * of the supplied String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to chomp from, must not be null
&nbsp;     * @return String without chomped ending
&nbsp;     * @throws NullPointerException if str is &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @deprecated Use {@link #chomp(String)} instead.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String chompLast(String str) {
<b class="nc">&nbsp;        return chompLast(str, &quot;\n&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Remove a value if and only if the String ends with that value.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to chomp from, must not be null
&nbsp;     * @param sep  the String to chomp, must not be null
&nbsp;     * @return String without chomped ending
&nbsp;     * @throws NullPointerException if str or sep is &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @deprecated Use {@link #chomp(String,String)} instead.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String chompLast(String str, String sep) {
<b class="nc">&nbsp;        if (str.length() == 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        String sub = str.substring(str.length() - sep.length());</b>
<b class="nc">&nbsp;        if (sep.equals(sub)) {</b>
<b class="nc">&nbsp;            return str.substring(0, str.length() - sep.length());</b>
&nbsp;        }
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Remove everything and return the last value of a supplied String, and
&nbsp;     * everything after it from a String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to chomp from, must not be null
&nbsp;     * @param sep  the String to chomp, must not be null
&nbsp;     * @return String chomped
&nbsp;     * @throws NullPointerException if str or sep is &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @deprecated Use {@link #substringAfterLast(String, String)} instead
&nbsp;     *             (although this doesn&#39;t include the separator)
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String getChomp(String str, String sep) {
<b class="nc">&nbsp;        int idx = str.lastIndexOf(sep);</b>
<b class="nc">&nbsp;        if (idx == str.length() - sep.length()) {</b>
<b class="nc">&nbsp;            return sep;</b>
<b class="nc">&nbsp;        } else if (idx != -1) {</b>
<b class="nc">&nbsp;            return str.substring(idx);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Remove the first value of a supplied String, and everything before it
&nbsp;     * from a String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to chomp from, must not be null
&nbsp;     * @param sep  the String to chomp, must not be null
&nbsp;     * @return String without chomped beginning
&nbsp;     * @throws NullPointerException if str or sep is &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @deprecated Use {@link #substringAfter(String,String)} instead.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String prechomp(String str, String sep) {
<b class="nc">&nbsp;        int idx = str.indexOf(sep);</b>
<b class="nc">&nbsp;        if (idx == -1) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }             
<b class="nc">&nbsp;        return str.substring(idx + sep.length());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Remove and return everything before the first value of a
&nbsp;     * supplied String from another String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to chomp from, must not be null
&nbsp;     * @param sep  the String to chomp, must not be null
&nbsp;     * @return String prechomped
&nbsp;     * @throws NullPointerException if str or sep is &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @deprecated Use {@link #substringBefore(String,String)} instead
&nbsp;     *             (although this doesn&#39;t include the separator).
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String getPrechomp(String str, String sep) {
<b class="nc">&nbsp;        int idx = str.indexOf(sep);</b>
<b class="nc">&nbsp;        if (idx == -1) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        } 
<b class="nc">&nbsp;        return str.substring(0, idx + sep.length());</b>
&nbsp;    }
&nbsp;
&nbsp;    // Chopping
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Remove the last character from a String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If the String ends in &lt;code&gt;\r\n&lt;/code&gt;, then remove both
&nbsp;     * of them.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.chop(null)          = null
&nbsp;     * StringUtils.chop(&quot;&quot;)            = &quot;&quot;
&nbsp;     * StringUtils.chop(&quot;abc \r&quot;)      = &quot;abc &quot;
&nbsp;     * StringUtils.chop(&quot;abc\n&quot;)       = &quot;abc&quot;
&nbsp;     * StringUtils.chop(&quot;abc\r\n&quot;)     = &quot;abc&quot;
&nbsp;     * StringUtils.chop(&quot;abc&quot;)         = &quot;ab&quot;
&nbsp;     * StringUtils.chop(&quot;abc\nabc&quot;)    = &quot;abc\nab&quot;
&nbsp;     * StringUtils.chop(&quot;a&quot;)           = &quot;&quot;
&nbsp;     * StringUtils.chop(&quot;\r&quot;)          = &quot;&quot;
&nbsp;     * StringUtils.chop(&quot;\n&quot;)          = &quot;&quot;
&nbsp;     * StringUtils.chop(&quot;\r\n&quot;)        = &quot;&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to chop last character from, may be null
&nbsp;     * @return String without last character, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String chop(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        int strLen = str.length();</b>
<b class="nc">&nbsp;        if (strLen &lt; 2) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        int lastIdx = strLen - 1;</b>
<b class="nc">&nbsp;        String ret = str.substring(0, lastIdx);</b>
<b class="nc">&nbsp;        char last = str.charAt(lastIdx);</b>
<b class="nc">&nbsp;        if (last == CharUtils.LF) {</b>
<b class="nc">&nbsp;            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {</b>
<b class="nc">&nbsp;                return ret.substring(0, lastIdx - 1);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return ret;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Removes &lt;code&gt;\n&lt;/code&gt; from end of a String if it&#39;s there.
&nbsp;     * If a &lt;code&gt;\r&lt;/code&gt; precedes it, then remove that too.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to chop a newline from, must not be null
&nbsp;     * @return String without newline
&nbsp;     * @throws NullPointerException if str is &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @deprecated Use {@link #chomp(String)} instead.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String chopNewline(String str) {
<b class="nc">&nbsp;        int lastIdx = str.length() - 1;</b>
<b class="nc">&nbsp;        if (lastIdx &lt;= 0) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        char last = str.charAt(lastIdx);</b>
<b class="nc">&nbsp;        if (last == CharUtils.LF) {</b>
<b class="nc">&nbsp;            if (str.charAt(lastIdx - 1) == CharUtils.CR) {</b>
<b class="nc">&nbsp;                lastIdx--;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            lastIdx++;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.substring(0, lastIdx);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Conversion
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Escapes any values it finds into their String form.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;So a tab becomes the characters &lt;code&gt;&#39;\\&#39;&lt;/code&gt; and
&nbsp;     * &lt;code&gt;&#39;t&#39;&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;As of Lang 2.0, this calls {@link StringEscapeUtils#escapeJava(String)}
&nbsp;     * behind the scenes.
&nbsp;     * &lt;/p&gt;
&nbsp;     * @see StringEscapeUtils#escapeJava(java.lang.String)
&nbsp;     * @param str String to escape values in
&nbsp;     * @return String with escaped values
&nbsp;     * @throws NullPointerException if str is &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @deprecated Use {@link StringEscapeUtils#escapeJava(String)}
&nbsp;     *             This method will be removed in Commons Lang 3.0
&nbsp;     */
&nbsp;    public static String escape(String str) {
<b class="nc">&nbsp;        return StringEscapeUtils.escapeJava(str);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Padding
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Repeat a String &lt;code&gt;repeat&lt;/code&gt; times to form a
&nbsp;     * new String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.repeat(null, 2) = null
&nbsp;     * StringUtils.repeat(&quot;&quot;, 0)   = &quot;&quot;
&nbsp;     * StringUtils.repeat(&quot;&quot;, 2)   = &quot;&quot;
&nbsp;     * StringUtils.repeat(&quot;a&quot;, 3)  = &quot;aaa&quot;
&nbsp;     * StringUtils.repeat(&quot;ab&quot;, 2) = &quot;abab&quot;
&nbsp;     * StringUtils.repeat(&quot;a&quot;, -2) = &quot;&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to repeat, may be null
&nbsp;     * @param repeat  number of times to repeat str, negative treated as zero
&nbsp;     * @return a new String consisting of the original String repeated,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String repeat(String str, int repeat) {
&nbsp;        // Performance tuned for 2.0 (JDK1.4)
&nbsp;
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (repeat &lt;= 0) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        int inputLength = str.length();</b>
<b class="nc">&nbsp;        if (repeat == 1 || inputLength == 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (inputLength == 1 &amp;&amp; repeat &lt;= PAD_LIMIT) {</b>
<b class="nc">&nbsp;            return padding(repeat, str.charAt(0));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int outputLength = inputLength * repeat;</b>
<b class="nc">&nbsp;        switch (inputLength) {</b>
&nbsp;            case 1 :
<b class="nc">&nbsp;                char ch = str.charAt(0);</b>
<b class="nc">&nbsp;                char[] output1 = new char[outputLength];</b>
<b class="nc">&nbsp;                for (int i = repeat - 1; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;                    output1[i] = ch;</b>
&nbsp;                }
<b class="nc">&nbsp;                return new String(output1);</b>
&nbsp;            case 2 :
<b class="nc">&nbsp;                char ch0 = str.charAt(0);</b>
<b class="nc">&nbsp;                char ch1 = str.charAt(1);</b>
<b class="nc">&nbsp;                char[] output2 = new char[outputLength];</b>
<b class="nc">&nbsp;                for (int i = repeat * 2 - 2; i &gt;= 0; i--, i--) {</b>
<b class="nc">&nbsp;                    output2[i] = ch0;</b>
<b class="nc">&nbsp;                    output2[i + 1] = ch1;</b>
&nbsp;                }
<b class="nc">&nbsp;                return new String(output2);</b>
&nbsp;            default :
<b class="nc">&nbsp;                StrBuilder buf = new StrBuilder(outputLength);</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; repeat; i++) {</b>
<b class="nc">&nbsp;                    buf.append(str);</b>
&nbsp;                }
<b class="nc">&nbsp;                return buf.toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Repeat a String &lt;code&gt;repeat&lt;/code&gt; times to form a
&nbsp;     * new String, with a String separator injected each time. &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.repeat(null, null, 2) = null
&nbsp;     * StringUtils.repeat(null, &quot;x&quot;, 2)  = null
&nbsp;     * StringUtils.repeat(&quot;&quot;, null, 0)   = &quot;&quot;
&nbsp;     * StringUtils.repeat(&quot;&quot;, &quot;&quot;, 2)     = &quot;&quot;
&nbsp;     * StringUtils.repeat(&quot;&quot;, &quot;x&quot;, 3)    = &quot;xxx&quot;
&nbsp;     * StringUtils.repeat(&quot;?&quot;, &quot;, &quot;, 3)  = &quot;?, ?, ?&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str        the String to repeat, may be null
&nbsp;     * @param separator  the String to inject, may be null
&nbsp;     * @param repeat     number of times to repeat str, negative treated as zero
&nbsp;     * @return a new String consisting of the original String repeated,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public static String repeat(String str, String separator, int repeat) {
<b class="nc">&nbsp;        if(str == null || separator == null) {</b>
<b class="nc">&nbsp;            return repeat(str, repeat);</b>
&nbsp;        } else {
&nbsp;            // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it
<b class="nc">&nbsp;            String result = repeat(str + separator, repeat);</b>
<b class="nc">&nbsp;            return removeEnd(result, separator);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Returns padding using the specified delimiter repeated
&nbsp;     * to a given length.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.padding(0, &#39;e&#39;)  = &quot;&quot;
&nbsp;     * StringUtils.padding(3, &#39;e&#39;)  = &quot;eee&quot;
&nbsp;     * StringUtils.padding(-2, &#39;e&#39;) = IndexOutOfBoundsException
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Note: this method doesn&#39;t not support padding with
&nbsp;     * &lt;a href=&quot;http://www.unicode.org/glossary/#supplementary_character&quot;&gt;Unicode Supplementary Characters&lt;/a&gt;
&nbsp;     * as they require a pair of &lt;code&gt;char&lt;/code&gt;s to be represented.
&nbsp;     * If you are needing to support full I18N of your applications
&nbsp;     * consider using {@link #repeat(String, int)} instead. 
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param repeat  number of times to repeat delim
&nbsp;     * @param padChar  character to repeat
&nbsp;     * @return String with repeated character
&nbsp;     * @throws IndexOutOfBoundsException if &lt;code&gt;repeat &amp;lt; 0&lt;/code&gt;
&nbsp;     * @see #repeat(String, int)
&nbsp;     */
&nbsp;    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {
<b class="nc">&nbsp;        if (repeat &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IndexOutOfBoundsException(&quot;Cannot pad a negative amount: &quot; + repeat);</b>
&nbsp;        }
<b class="nc">&nbsp;        final char[] buf = new char[repeat];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; buf.length; i++) {</b>
<b class="nc">&nbsp;            buf[i] = padChar;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new String(buf);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Right pad a String with spaces (&#39; &#39;).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.rightPad(null, *)   = null
&nbsp;     * StringUtils.rightPad(&quot;&quot;, 3)     = &quot;   &quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, 3)  = &quot;bat&quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, 5)  = &quot;bat  &quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, 1)  = &quot;bat&quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, -1) = &quot;bat&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to pad out, may be null
&nbsp;     * @param size  the size to pad to
&nbsp;     * @return right padded String or original String if no padding is necessary,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String rightPad(String str, int size) {
<b class="nc">&nbsp;        return rightPad(str, size, &#39; &#39;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Right pad a String with a specified character.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.rightPad(null, *, *)     = null
&nbsp;     * StringUtils.rightPad(&quot;&quot;, 3, &#39;z&#39;)     = &quot;zzz&quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, 3, &#39;z&#39;)  = &quot;bat&quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, 5, &#39;z&#39;)  = &quot;batzz&quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, 1, &#39;z&#39;)  = &quot;bat&quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, -1, &#39;z&#39;) = &quot;bat&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to pad out, may be null
&nbsp;     * @param size  the size to pad to
&nbsp;     * @param padChar  the character to pad with
&nbsp;     * @return right padded String or original String if no padding is necessary,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String rightPad(String str, int size, char padChar) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        int pads = size - str.length();</b>
<b class="nc">&nbsp;        if (pads &lt;= 0) {</b>
<b class="nc">&nbsp;            return str; // returns original String when possible</b>
&nbsp;        }
<b class="nc">&nbsp;        if (pads &gt; PAD_LIMIT) {</b>
<b class="nc">&nbsp;            return rightPad(str, size, String.valueOf(padChar));</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.concat(padding(pads, padChar));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Right pad a String with a specified String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.rightPad(null, *, *)      = null
&nbsp;     * StringUtils.rightPad(&quot;&quot;, 3, &quot;z&quot;)      = &quot;zzz&quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, 3, &quot;yz&quot;)  = &quot;bat&quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, 5, &quot;yz&quot;)  = &quot;batyz&quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, 8, &quot;yz&quot;)  = &quot;batyzyzy&quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, 1, &quot;yz&quot;)  = &quot;bat&quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, -1, &quot;yz&quot;) = &quot;bat&quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, 5, null)  = &quot;bat  &quot;
&nbsp;     * StringUtils.rightPad(&quot;bat&quot;, 5, &quot;&quot;)    = &quot;bat  &quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to pad out, may be null
&nbsp;     * @param size  the size to pad to
&nbsp;     * @param padStr  the String to pad with, null or empty treated as single space
&nbsp;     * @return right padded String or original String if no padding is necessary,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String rightPad(String str, int size, String padStr) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isEmpty(padStr)) {</b>
<b class="nc">&nbsp;            padStr = &quot; &quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        int padLen = padStr.length();</b>
<b class="nc">&nbsp;        int strLen = str.length();</b>
<b class="nc">&nbsp;        int pads = size - strLen;</b>
<b class="nc">&nbsp;        if (pads &lt;= 0) {</b>
<b class="nc">&nbsp;            return str; // returns original String when possible</b>
&nbsp;        }
<b class="nc">&nbsp;        if (padLen == 1 &amp;&amp; pads &lt;= PAD_LIMIT) {</b>
<b class="nc">&nbsp;            return rightPad(str, size, padStr.charAt(0));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (pads == padLen) {</b>
<b class="nc">&nbsp;            return str.concat(padStr);</b>
<b class="nc">&nbsp;        } else if (pads &lt; padLen) {</b>
<b class="nc">&nbsp;            return str.concat(padStr.substring(0, pads));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            char[] padding = new char[pads];</b>
<b class="nc">&nbsp;            char[] padChars = padStr.toCharArray();</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; pads; i++) {</b>
<b class="nc">&nbsp;                padding[i] = padChars[i % padLen];</b>
&nbsp;            }
<b class="nc">&nbsp;            return str.concat(new String(padding));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Left pad a String with spaces (&#39; &#39;).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.leftPad(null, *)   = null
&nbsp;     * StringUtils.leftPad(&quot;&quot;, 3)     = &quot;   &quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, 3)  = &quot;bat&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, 5)  = &quot;  bat&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, 1)  = &quot;bat&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, -1) = &quot;bat&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to pad out, may be null
&nbsp;     * @param size  the size to pad to
&nbsp;     * @return left padded String or original String if no padding is necessary,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String leftPad(String str, int size) {
<b class="nc">&nbsp;        return leftPad(str, size, &#39; &#39;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Left pad a String with a specified character.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Pad to a size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.leftPad(null, *, *)     = null
&nbsp;     * StringUtils.leftPad(&quot;&quot;, 3, &#39;z&#39;)     = &quot;zzz&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, 3, &#39;z&#39;)  = &quot;bat&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, 5, &#39;z&#39;)  = &quot;zzbat&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, 1, &#39;z&#39;)  = &quot;bat&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, -1, &#39;z&#39;) = &quot;bat&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to pad out, may be null
&nbsp;     * @param size  the size to pad to
&nbsp;     * @param padChar  the character to pad with
&nbsp;     * @return left padded String or original String if no padding is necessary,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String leftPad(String str, int size, char padChar) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        int pads = size - str.length();</b>
<b class="nc">&nbsp;        if (pads &lt;= 0) {</b>
<b class="nc">&nbsp;            return str; // returns original String when possible</b>
&nbsp;        }
<b class="nc">&nbsp;        if (pads &gt; PAD_LIMIT) {</b>
<b class="nc">&nbsp;            return leftPad(str, size, String.valueOf(padChar));</b>
&nbsp;        }
<b class="nc">&nbsp;        return padding(pads, padChar).concat(str);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Left pad a String with a specified String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Pad to a size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.leftPad(null, *, *)      = null
&nbsp;     * StringUtils.leftPad(&quot;&quot;, 3, &quot;z&quot;)      = &quot;zzz&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, 3, &quot;yz&quot;)  = &quot;bat&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, 5, &quot;yz&quot;)  = &quot;yzbat&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, 8, &quot;yz&quot;)  = &quot;yzyzybat&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, 1, &quot;yz&quot;)  = &quot;bat&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, -1, &quot;yz&quot;) = &quot;bat&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, 5, null)  = &quot;  bat&quot;
&nbsp;     * StringUtils.leftPad(&quot;bat&quot;, 5, &quot;&quot;)    = &quot;  bat&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to pad out, may be null
&nbsp;     * @param size  the size to pad to
&nbsp;     * @param padStr  the String to pad with, null or empty treated as single space
&nbsp;     * @return left padded String or original String if no padding is necessary,
&nbsp;     *  &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String leftPad(String str, int size, String padStr) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isEmpty(padStr)) {</b>
<b class="nc">&nbsp;            padStr = &quot; &quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        int padLen = padStr.length();</b>
<b class="nc">&nbsp;        int strLen = str.length();</b>
<b class="nc">&nbsp;        int pads = size - strLen;</b>
<b class="nc">&nbsp;        if (pads &lt;= 0) {</b>
<b class="nc">&nbsp;            return str; // returns original String when possible</b>
&nbsp;        }
<b class="nc">&nbsp;        if (padLen == 1 &amp;&amp; pads &lt;= PAD_LIMIT) {</b>
<b class="nc">&nbsp;            return leftPad(str, size, padStr.charAt(0));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (pads == padLen) {</b>
<b class="nc">&nbsp;            return padStr.concat(str);</b>
<b class="nc">&nbsp;        } else if (pads &lt; padLen) {</b>
<b class="nc">&nbsp;            return padStr.substring(0, pads).concat(str);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            char[] padding = new char[pads];</b>
<b class="nc">&nbsp;            char[] padChars = padStr.toCharArray();</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; pads; i++) {</b>
<b class="nc">&nbsp;                padding[i] = padChars[i % padLen];</b>
&nbsp;            }
<b class="nc">&nbsp;            return new String(padding).concat(str);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a String&#39;s length or &lt;code&gt;0&lt;/code&gt; if the String is &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * 
&nbsp;     * @param str
&nbsp;     *            a String or &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @return String length or &lt;code&gt;0&lt;/code&gt; if the String is &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static int length(String str) {
<b class="nc">&nbsp;        return str == null ? 0 : str.length();</b>
&nbsp;    }
&nbsp;    
&nbsp;    // Centering
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Centers a String in a larger String of size &lt;code&gt;size&lt;/code&gt;
&nbsp;     * using the space character (&#39; &#39;).&lt;p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If the size is less than the String length, the String is returned.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A negative size is treated as zero.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Equivalent to &lt;code&gt;center(str, size, &quot; &quot;)&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.center(null, *)   = null
&nbsp;     * StringUtils.center(&quot;&quot;, 4)     = &quot;    &quot;
&nbsp;     * StringUtils.center(&quot;ab&quot;, -1)  = &quot;ab&quot;
&nbsp;     * StringUtils.center(&quot;ab&quot;, 4)   = &quot; ab &quot;
&nbsp;     * StringUtils.center(&quot;abcd&quot;, 2) = &quot;abcd&quot;
&nbsp;     * StringUtils.center(&quot;a&quot;, 4)    = &quot; a  &quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to center, may be null
&nbsp;     * @param size  the int size of new String, negative treated as zero
&nbsp;     * @return centered String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String center(String str, int size) {
<b class="nc">&nbsp;        return center(str, size, &#39; &#39;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Centers a String in a larger String of size &lt;code&gt;size&lt;/code&gt;.
&nbsp;     * Uses a supplied character as the value to pad the String with.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If the size is less than the String length, the String is returned.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A negative size is treated as zero.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.center(null, *, *)     = null
&nbsp;     * StringUtils.center(&quot;&quot;, 4, &#39; &#39;)     = &quot;    &quot;
&nbsp;     * StringUtils.center(&quot;ab&quot;, -1, &#39; &#39;)  = &quot;ab&quot;
&nbsp;     * StringUtils.center(&quot;ab&quot;, 4, &#39; &#39;)   = &quot; ab&quot;
&nbsp;     * StringUtils.center(&quot;abcd&quot;, 2, &#39; &#39;) = &quot;abcd&quot;
&nbsp;     * StringUtils.center(&quot;a&quot;, 4, &#39; &#39;)    = &quot; a  &quot;
&nbsp;     * StringUtils.center(&quot;a&quot;, 4, &#39;y&#39;)    = &quot;yayy&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to center, may be null
&nbsp;     * @param size  the int size of new String, negative treated as zero
&nbsp;     * @param padChar  the character to pad the new String with
&nbsp;     * @return centered String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String center(String str, int size, char padChar) {
<b class="nc">&nbsp;        if (str == null || size &lt;= 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        int strLen = str.length();</b>
<b class="nc">&nbsp;        int pads = size - strLen;</b>
<b class="nc">&nbsp;        if (pads &lt;= 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        str = leftPad(str, strLen + pads / 2, padChar);</b>
<b class="nc">&nbsp;        str = rightPad(str, size, padChar);</b>
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Centers a String in a larger String of size &lt;code&gt;size&lt;/code&gt;.
&nbsp;     * Uses a supplied String as the value to pad the String with.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If the size is less than the String length, the String is returned.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; String returns &lt;code&gt;null&lt;/code&gt;.
&nbsp;     * A negative size is treated as zero.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.center(null, *, *)     = null
&nbsp;     * StringUtils.center(&quot;&quot;, 4, &quot; &quot;)     = &quot;    &quot;
&nbsp;     * StringUtils.center(&quot;ab&quot;, -1, &quot; &quot;)  = &quot;ab&quot;
&nbsp;     * StringUtils.center(&quot;ab&quot;, 4, &quot; &quot;)   = &quot; ab&quot;
&nbsp;     * StringUtils.center(&quot;abcd&quot;, 2, &quot; &quot;) = &quot;abcd&quot;
&nbsp;     * StringUtils.center(&quot;a&quot;, 4, &quot; &quot;)    = &quot; a  &quot;
&nbsp;     * StringUtils.center(&quot;a&quot;, 4, &quot;yz&quot;)   = &quot;yayz&quot;
&nbsp;     * StringUtils.center(&quot;abc&quot;, 7, null) = &quot;  abc  &quot;
&nbsp;     * StringUtils.center(&quot;abc&quot;, 7, &quot;&quot;)   = &quot;  abc  &quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to center, may be null
&nbsp;     * @param size  the int size of new String, negative treated as zero
&nbsp;     * @param padStr  the String to pad the new String with, must not be null or empty
&nbsp;     * @return centered String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @throws IllegalArgumentException if padStr is &lt;code&gt;null&lt;/code&gt; or empty
&nbsp;     */
&nbsp;    public static String center(String str, int size, String padStr) {
<b class="nc">&nbsp;        if (str == null || size &lt;= 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isEmpty(padStr)) {</b>
<b class="nc">&nbsp;            padStr = &quot; &quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        int strLen = str.length();</b>
<b class="nc">&nbsp;        int pads = size - strLen;</b>
<b class="nc">&nbsp;        if (pads &lt;= 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        str = leftPad(str, strLen + pads / 2, padStr);</b>
<b class="nc">&nbsp;        str = rightPad(str, size, padStr);</b>
<b class="nc">&nbsp;        return str;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Case conversion
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Converts a String to upper case as per {@link String#toUpperCase()}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.upperCase(null)  = null
&nbsp;     * StringUtils.upperCase(&quot;&quot;)    = &quot;&quot;
&nbsp;     * StringUtils.upperCase(&quot;aBc&quot;) = &quot;ABC&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; As described in the documentation for {@link String#toUpperCase()},
&nbsp;     * the result of this method is affected by the current locale.
&nbsp;     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
&nbsp;     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to upper case, may be null
&nbsp;     * @return the upper cased String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String upperCase(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.toUpperCase();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Converts a String to upper case as per {@link String#toUpperCase(Locale)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.upperCase(null, Locale.ENGLISH)  = null
&nbsp;     * StringUtils.upperCase(&quot;&quot;, Locale.ENGLISH)    = &quot;&quot;
&nbsp;     * StringUtils.upperCase(&quot;aBc&quot;, Locale.ENGLISH) = &quot;ABC&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to upper case, may be null
&nbsp;     * @param locale  the locale that defines the case transformation rules, must not be null
&nbsp;     * @return the upper cased String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public static String upperCase(String str, Locale locale) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.toUpperCase(locale);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Converts a String to lower case as per {@link String#toLowerCase()}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.lowerCase(null)  = null
&nbsp;     * StringUtils.lowerCase(&quot;&quot;)    = &quot;&quot;
&nbsp;     * StringUtils.lowerCase(&quot;aBc&quot;) = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; As described in the documentation for {@link String#toLowerCase()},
&nbsp;     * the result of this method is affected by the current locale.
&nbsp;     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
&nbsp;     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to lower case, may be null
&nbsp;     * @return the lower cased String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String lowerCase(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.toLowerCase();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Converts a String to lower case as per {@link String#toLowerCase(Locale)}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.lowerCase(null, Locale.ENGLISH)  = null
&nbsp;     * StringUtils.lowerCase(&quot;&quot;, Locale.ENGLISH)    = &quot;&quot;
&nbsp;     * StringUtils.lowerCase(&quot;aBc&quot;, Locale.ENGLISH) = &quot;abc&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to lower case, may be null
&nbsp;     * @param locale  the locale that defines the case transformation rules, must not be null
&nbsp;     * @return the lower cased String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public static String lowerCase(String str, Locale locale) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.toLowerCase(locale);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Capitalizes a String changing the first letter to title case as
&nbsp;     * per {@link Character#toTitleCase(char)}. No other letters are changed.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;For a word based algorithm, see {@link WordUtils#capitalize(String)}.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.capitalize(null)  = null
&nbsp;     * StringUtils.capitalize(&quot;&quot;)    = &quot;&quot;
&nbsp;     * StringUtils.capitalize(&quot;cat&quot;) = &quot;Cat&quot;
&nbsp;     * StringUtils.capitalize(&quot;cAt&quot;) = &quot;CAt&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to capitalize, may be null
&nbsp;     * @return the capitalized String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @see WordUtils#capitalize(String)
&nbsp;     * @see #uncapitalize(String)
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String capitalize(String str) {
&nbsp;        int strLen;
<b class="nc">&nbsp;        if (str == null || (strLen = str.length()) == 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new StrBuilder(strLen)</b>
&nbsp;            .append(Character.toTitleCase(str.charAt(0)))
&nbsp;            .append(str.substring(1))
&nbsp;            .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Capitalizes a String changing the first letter to title case as
&nbsp;     * per {@link Character#toTitleCase(char)}. No other letters are changed.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to capitalize, may be null
&nbsp;     * @return the capitalized String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @deprecated Use the standardly named {@link #capitalize(String)}.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String capitalise(String str) {
<b class="nc">&nbsp;        return capitalize(str);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Uncapitalizes a String changing the first letter to title case as
&nbsp;     * per {@link Character#toLowerCase(char)}. No other letters are changed.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;For a word based algorithm, see {@link WordUtils#uncapitalize(String)}.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.uncapitalize(null)  = null
&nbsp;     * StringUtils.uncapitalize(&quot;&quot;)    = &quot;&quot;
&nbsp;     * StringUtils.uncapitalize(&quot;Cat&quot;) = &quot;cat&quot;
&nbsp;     * StringUtils.uncapitalize(&quot;CAT&quot;) = &quot;cAT&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to uncapitalize, may be null
&nbsp;     * @return the uncapitalized String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @see WordUtils#uncapitalize(String)
&nbsp;     * @see #capitalize(String)
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String uncapitalize(String str) {
&nbsp;        int strLen;
<b class="nc">&nbsp;        if (str == null || (strLen = str.length()) == 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new StrBuilder(strLen)</b>
&nbsp;            .append(Character.toLowerCase(str.charAt(0)))
&nbsp;            .append(str.substring(1))
&nbsp;            .toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Uncapitalizes a String changing the first letter to title case as
&nbsp;     * per {@link Character#toLowerCase(char)}. No other letters are changed.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to uncapitalize, may be null
&nbsp;     * @return the uncapitalized String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @deprecated Use the standardly named {@link #uncapitalize(String)}.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String uncapitalise(String str) {
<b class="nc">&nbsp;        return uncapitalize(str);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Swaps the case of a String changing upper and title case to
&nbsp;     * lower case, and lower case to upper case.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;ul&gt;
&nbsp;     *  &lt;li&gt;Upper case character converts to Lower case&lt;/li&gt;
&nbsp;     *  &lt;li&gt;Title case character converts to Lower case&lt;/li&gt;
&nbsp;     *  &lt;li&gt;Lower case character converts to Upper case&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;For a word based algorithm, see {@link WordUtils#swapCase(String)}.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.swapCase(null)                 = null
&nbsp;     * StringUtils.swapCase(&quot;&quot;)                   = &quot;&quot;
&nbsp;     * StringUtils.swapCase(&quot;The dog has a BONE&quot;) = &quot;tHE DOG HAS A bone&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;NOTE: This method changed in Lang version 2.0.
&nbsp;     * It no longer performs a word based algorithm.
&nbsp;     * If you only use ASCII, you will notice no change.
&nbsp;     * That functionality is available in WordUtils.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to swap case, may be null
&nbsp;     * @return the changed String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String swapCase(String str) {
&nbsp;        int strLen;
<b class="nc">&nbsp;        if (str == null || (strLen = str.length()) == 0) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        StrBuilder buffer = new StrBuilder(strLen);</b>
&nbsp;
<b class="nc">&nbsp;        char ch = 0;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; strLen; i++) {</b>
<b class="nc">&nbsp;            ch = str.charAt(i);</b>
<b class="nc">&nbsp;            if (Character.isUpperCase(ch)) {</b>
<b class="nc">&nbsp;                ch = Character.toLowerCase(ch);</b>
<b class="nc">&nbsp;            } else if (Character.isTitleCase(ch)) {</b>
<b class="nc">&nbsp;                ch = Character.toLowerCase(ch);</b>
<b class="nc">&nbsp;            } else if (Character.isLowerCase(ch)) {</b>
<b class="nc">&nbsp;                ch = Character.toUpperCase(ch);</b>
&nbsp;            }
<b class="nc">&nbsp;            buffer.append(ch);</b>
&nbsp;        }
<b class="nc">&nbsp;        return buffer.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Capitalizes all the whitespace separated words in a String.
&nbsp;     * Only the first letter of each word is changed.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Whitespace is defined by {@link Character#isWhitespace(char)}.
&nbsp;     * A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param str  the String to capitalize, may be null
&nbsp;     * @return capitalized String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @deprecated Use the relocated {@link WordUtils#capitalize(String)}.
&nbsp;     *             Method will be removed in Commons Lang 3.0.
&nbsp;     */
&nbsp;    public static String capitaliseAllWords(String str) {
<b class="nc">&nbsp;        return WordUtils.capitalize(str);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Count matches
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Counts how many times the substring appears in the larger String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String input returns &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.countMatches(null, *)       = 0
&nbsp;     * StringUtils.countMatches(&quot;&quot;, *)         = 0
&nbsp;     * StringUtils.countMatches(&quot;abba&quot;, null)  = 0
&nbsp;     * StringUtils.countMatches(&quot;abba&quot;, &quot;&quot;)    = 0
&nbsp;     * StringUtils.countMatches(&quot;abba&quot;, &quot;a&quot;)   = 2
&nbsp;     * StringUtils.countMatches(&quot;abba&quot;, &quot;ab&quot;)  = 1
&nbsp;     * StringUtils.countMatches(&quot;abba&quot;, &quot;xxx&quot;) = 0
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param sub  the substring to count, may be null
&nbsp;     * @return the number of occurrences, 0 if either String is &lt;code&gt;null&lt;/code&gt;
&nbsp;     */
&nbsp;    public static int countMatches(String str, String sub) {
<b class="nc">&nbsp;        if (isEmpty(str) || isEmpty(sub)) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        int idx = 0;</b>
<b class="nc">&nbsp;        while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) {</b>
<b class="nc">&nbsp;            count++;</b>
<b class="nc">&nbsp;            idx += sub.length();</b>
&nbsp;        }
<b class="nc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Character Tests
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the String contains only unicode letters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * An empty String (length()=0) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isAlpha(null)   = false
&nbsp;     * StringUtils.isAlpha(&quot;&quot;)     = true
&nbsp;     * StringUtils.isAlpha(&quot;  &quot;)   = false
&nbsp;     * StringUtils.isAlpha(&quot;abc&quot;)  = true
&nbsp;     * StringUtils.isAlpha(&quot;ab2c&quot;) = false
&nbsp;     * StringUtils.isAlpha(&quot;ab-c&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if only contains letters, and is non-null
&nbsp;     */
&nbsp;    public static boolean isAlpha(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = str.length();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            if (Character.isLetter(str.charAt(i)) == false) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the String contains only unicode letters and
&nbsp;     * space (&#39; &#39;).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;
&nbsp;     * An empty String (length()=0) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isAlphaSpace(null)   = false
&nbsp;     * StringUtils.isAlphaSpace(&quot;&quot;)     = true
&nbsp;     * StringUtils.isAlphaSpace(&quot;  &quot;)   = true
&nbsp;     * StringUtils.isAlphaSpace(&quot;abc&quot;)  = true
&nbsp;     * StringUtils.isAlphaSpace(&quot;ab c&quot;) = true
&nbsp;     * StringUtils.isAlphaSpace(&quot;ab2c&quot;) = false
&nbsp;     * StringUtils.isAlphaSpace(&quot;ab-c&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if only contains letters and space,
&nbsp;     *  and is non-null
&nbsp;     */
&nbsp;    public static boolean isAlphaSpace(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = str.length();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            if ((Character.isLetter(str.charAt(i)) == false) &amp;&amp; (str.charAt(i) != &#39; &#39;)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the String contains only unicode letters or digits.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * An empty String (length()=0) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isAlphanumeric(null)   = false
&nbsp;     * StringUtils.isAlphanumeric(&quot;&quot;)     = true
&nbsp;     * StringUtils.isAlphanumeric(&quot;  &quot;)   = false
&nbsp;     * StringUtils.isAlphanumeric(&quot;abc&quot;)  = true
&nbsp;     * StringUtils.isAlphanumeric(&quot;ab c&quot;) = false
&nbsp;     * StringUtils.isAlphanumeric(&quot;ab2c&quot;) = true
&nbsp;     * StringUtils.isAlphanumeric(&quot;ab-c&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if only contains letters or digits,
&nbsp;     *  and is non-null
&nbsp;     */
&nbsp;    public static boolean isAlphanumeric(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = str.length();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            if (Character.isLetterOrDigit(str.charAt(i)) == false) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the String contains only unicode letters, digits
&nbsp;     * or space (&lt;code&gt;&#39; &#39;&lt;/code&gt;).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * An empty String (length()=0) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isAlphanumeric(null)   = false
&nbsp;     * StringUtils.isAlphanumeric(&quot;&quot;)     = true
&nbsp;     * StringUtils.isAlphanumeric(&quot;  &quot;)   = true
&nbsp;     * StringUtils.isAlphanumeric(&quot;abc&quot;)  = true
&nbsp;     * StringUtils.isAlphanumeric(&quot;ab c&quot;) = true
&nbsp;     * StringUtils.isAlphanumeric(&quot;ab2c&quot;) = true
&nbsp;     * StringUtils.isAlphanumeric(&quot;ab-c&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if only contains letters, digits or space,
&nbsp;     *  and is non-null
&nbsp;     */
&nbsp;    public static boolean isAlphanumericSpace(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = str.length();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            if ((Character.isLetterOrDigit(str.charAt(i)) == false) &amp;&amp; (str.charAt(i) != &#39; &#39;)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the string contains only ASCII printable characters.&lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * An empty String (length()=0) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isAsciiPrintable(null)     = false
&nbsp;     * StringUtils.isAsciiPrintable(&quot;&quot;)       = true
&nbsp;     * StringUtils.isAsciiPrintable(&quot; &quot;)      = true
&nbsp;     * StringUtils.isAsciiPrintable(&quot;Ceki&quot;)   = true
&nbsp;     * StringUtils.isAsciiPrintable(&quot;ab2c&quot;)   = true
&nbsp;     * StringUtils.isAsciiPrintable(&quot;!ab-c~&quot;) = true
&nbsp;     * StringUtils.isAsciiPrintable(&quot;\u0020&quot;) = true
&nbsp;     * StringUtils.isAsciiPrintable(&quot;\u0021&quot;) = true
&nbsp;     * StringUtils.isAsciiPrintable(&quot;\u007e&quot;) = true
&nbsp;     * StringUtils.isAsciiPrintable(&quot;\u007f&quot;) = false
&nbsp;     * StringUtils.isAsciiPrintable(&quot;Ceki G\u00fclc\u00fc&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str the string to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if every character is in the range
&nbsp;     *  32 thru 126
&nbsp;     * @since 2.1
&nbsp;     */
&nbsp;    public static boolean isAsciiPrintable(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = str.length();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            if (CharUtils.isAsciiPrintable(str.charAt(i)) == false) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the String contains only unicode digits.
&nbsp;     * A decimal point is not a unicode digit and returns false.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * An empty String (length()=0) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isNumeric(null)   = false
&nbsp;     * StringUtils.isNumeric(&quot;&quot;)     = true
&nbsp;     * StringUtils.isNumeric(&quot;  &quot;)   = false
&nbsp;     * StringUtils.isNumeric(&quot;123&quot;)  = true
&nbsp;     * StringUtils.isNumeric(&quot;12 3&quot;) = false
&nbsp;     * StringUtils.isNumeric(&quot;ab2c&quot;) = false
&nbsp;     * StringUtils.isNumeric(&quot;12-3&quot;) = false
&nbsp;     * StringUtils.isNumeric(&quot;12.3&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if only contains digits, and is non-null
&nbsp;     */
&nbsp;    public static boolean isNumeric(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = str.length();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            if (Character.isDigit(str.charAt(i)) == false) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the String contains only unicode digits or space
&nbsp;     * (&lt;code&gt;&#39; &#39;&lt;/code&gt;).
&nbsp;     * A decimal point is not a unicode digit and returns false.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * An empty String (length()=0) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isNumeric(null)   = false
&nbsp;     * StringUtils.isNumeric(&quot;&quot;)     = true
&nbsp;     * StringUtils.isNumeric(&quot;  &quot;)   = true
&nbsp;     * StringUtils.isNumeric(&quot;123&quot;)  = true
&nbsp;     * StringUtils.isNumeric(&quot;12 3&quot;) = true
&nbsp;     * StringUtils.isNumeric(&quot;ab2c&quot;) = false
&nbsp;     * StringUtils.isNumeric(&quot;12-3&quot;) = false
&nbsp;     * StringUtils.isNumeric(&quot;12.3&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if only contains digits or space,
&nbsp;     *  and is non-null
&nbsp;     */
&nbsp;    public static boolean isNumericSpace(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = str.length();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            if ((Character.isDigit(str.charAt(i)) == false) &amp;&amp; (str.charAt(i) != &#39; &#39;)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the String contains only whitespace.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * An empty String (length()=0) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isWhitespace(null)   = false
&nbsp;     * StringUtils.isWhitespace(&quot;&quot;)     = true
&nbsp;     * StringUtils.isWhitespace(&quot;  &quot;)   = true
&nbsp;     * StringUtils.isWhitespace(&quot;abc&quot;)  = false
&nbsp;     * StringUtils.isWhitespace(&quot;ab2c&quot;) = false
&nbsp;     * StringUtils.isWhitespace(&quot;ab-c&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if only contains whitespace, and is non-null
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static boolean isWhitespace(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = str.length();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            if ((Character.isWhitespace(str.charAt(i)) == false)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the String contains only lowercase characters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * An empty String (length()=0) will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isAllLowerCase(null)   = false
&nbsp;     * StringUtils.isAllLowerCase(&quot;&quot;)     = false
&nbsp;     * StringUtils.isAllLowerCase(&quot;  &quot;)   = false
&nbsp;     * StringUtils.isAllLowerCase(&quot;abc&quot;)  = true
&nbsp;     * StringUtils.isAllLowerCase(&quot;abC&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if only contains lowercase characters, and is non-null
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public static boolean isAllLowerCase(String str) {
<b class="nc">&nbsp;        if (str == null || isEmpty(str)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = str.length();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            if (Character.isLowerCase(str.charAt(i)) == false) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Checks if the String contains only uppercase characters.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     * An empty String (length()=0) will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.isAllUpperCase(null)   = false
&nbsp;     * StringUtils.isAllUpperCase(&quot;&quot;)     = false
&nbsp;     * StringUtils.isAllUpperCase(&quot;  &quot;)   = false
&nbsp;     * StringUtils.isAllUpperCase(&quot;ABC&quot;)  = true
&nbsp;     * StringUtils.isAllUpperCase(&quot;aBC&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if only contains uppercase characters, and is non-null
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public static boolean isAllUpperCase(String str) {
<b class="nc">&nbsp;        if (str == null || isEmpty(str)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int sz = str.length();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            if (Character.isUpperCase(str.charAt(i)) == false) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Defaults
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Returns either the passed in String,
&nbsp;     * or if the String is &lt;code&gt;null&lt;/code&gt;, an empty String (&quot;&quot;).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.defaultString(null)  = &quot;&quot;
&nbsp;     * StringUtils.defaultString(&quot;&quot;)    = &quot;&quot;
&nbsp;     * StringUtils.defaultString(&quot;bat&quot;) = &quot;bat&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @see ObjectUtils#toString(Object)
&nbsp;     * @see String#valueOf(Object)
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @return the passed in String, or the empty String if it
&nbsp;     *  was &lt;code&gt;null&lt;/code&gt;
&nbsp;     */
&nbsp;    public static String defaultString(String str) {
<b class="nc">&nbsp;        return str == null ? EMPTY : str;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Returns either the passed in String, or if the String is
&nbsp;     * &lt;code&gt;null&lt;/code&gt;, the value of &lt;code&gt;defaultStr&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.defaultString(null, &quot;NULL&quot;)  = &quot;NULL&quot;
&nbsp;     * StringUtils.defaultString(&quot;&quot;, &quot;NULL&quot;)    = &quot;&quot;
&nbsp;     * StringUtils.defaultString(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @see ObjectUtils#toString(Object,String)
&nbsp;     * @see String#valueOf(Object)
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param defaultStr  the default String to return
&nbsp;     *  if the input is &lt;code&gt;null&lt;/code&gt;, may be null
&nbsp;     * @return the passed in String, or the default if it was &lt;code&gt;null&lt;/code&gt;
&nbsp;     */
&nbsp;    public static String defaultString(String str, String defaultStr) {
<b class="nc">&nbsp;        return str == null ? defaultStr : str;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Returns either the passed in String, or if the String is
&nbsp;     * whitespace, empty (&quot;&quot;) or &lt;code&gt;null&lt;/code&gt;, the value of &lt;code&gt;defaultStr&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.defaultIfBlank(null, &quot;NULL&quot;)  = &quot;NULL&quot;
&nbsp;     * StringUtils.defaultIfBlank(&quot;&quot;, &quot;NULL&quot;)    = &quot;NULL&quot;
&nbsp;     * StringUtils.defaultIfBlank(&quot; &quot;, &quot;NULL&quot;)   = &quot;NULL&quot;
&nbsp;     * StringUtils.defaultIfBlank(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;
&nbsp;     * StringUtils.defaultIfBlank(&quot;&quot;, null)      = null
&nbsp;     * &lt;/pre&gt;
&nbsp;     * @param str the String to check, may be null
&nbsp;     * @param defaultStr  the default String to return
&nbsp;     *  if the input is whitespace, empty (&quot;&quot;) or &lt;code&gt;null&lt;/code&gt;, may be null
&nbsp;     * @return the passed in String, or the default
&nbsp;     * @see StringUtils#defaultString(String, String)
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public static String defaultIfBlank(String str, String defaultStr) {
<b class="nc">&nbsp;        return StringUtils.isBlank(str) ? defaultStr : str;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Returns either the passed in String, or if the String is
&nbsp;     * empty or &lt;code&gt;null&lt;/code&gt;, the value of &lt;code&gt;defaultStr&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.defaultIfEmpty(null, &quot;NULL&quot;)  = &quot;NULL&quot;
&nbsp;     * StringUtils.defaultIfEmpty(&quot;&quot;, &quot;NULL&quot;)    = &quot;NULL&quot;
&nbsp;     * StringUtils.defaultIfEmpty(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;
&nbsp;     * StringUtils.defaultIfEmpty(&quot;&quot;, null)      = null
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param defaultStr  the default String to return
&nbsp;     *  if the input is empty (&quot;&quot;) or &lt;code&gt;null&lt;/code&gt;, may be null
&nbsp;     * @return the passed in String, or the default
&nbsp;     * @see StringUtils#defaultString(String, String)
&nbsp;     */
&nbsp;    public static String defaultIfEmpty(String str, String defaultStr) {
<b class="nc">&nbsp;        return StringUtils.isEmpty(str) ? defaultStr : str;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Reversing
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Reverses a String as per {@link StrBuilder#reverse()}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.reverse(null)  = null
&nbsp;     * StringUtils.reverse(&quot;&quot;)    = &quot;&quot;
&nbsp;     * StringUtils.reverse(&quot;bat&quot;) = &quot;tab&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to reverse, may be null
&nbsp;     * @return the reversed String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     */
&nbsp;    public static String reverse(String str) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new StrBuilder(str).reverse().toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Reverses a String that is delimited by a specific character.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The Strings between the delimiters are not reversed.
&nbsp;     * Thus java.lang.String becomes String.lang.java (if the delimiter
&nbsp;     * is &lt;code&gt;&#39;.&#39;&lt;/code&gt;).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.reverseDelimited(null, *)      = null
&nbsp;     * StringUtils.reverseDelimited(&quot;&quot;, *)        = &quot;&quot;
&nbsp;     * StringUtils.reverseDelimited(&quot;a.b.c&quot;, &#39;x&#39;) = &quot;a.b.c&quot;
&nbsp;     * StringUtils.reverseDelimited(&quot;a.b.c&quot;, &quot;.&quot;) = &quot;c.b.a&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to reverse, may be null
&nbsp;     * @param separatorChar  the separator character to use
&nbsp;     * @return the reversed String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String reverseDelimited(String str, char separatorChar) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        // could implement manually, but simple way is to reuse other,
&nbsp;        // probably slower, methods.
<b class="nc">&nbsp;        String[] strs = split(str, separatorChar);</b>
<b class="nc">&nbsp;        ArrayUtils.reverse(strs);</b>
<b class="nc">&nbsp;        return join(strs, separatorChar);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Reverses a String that is delimited by a specific character.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The Strings between the delimiters are not reversed.
&nbsp;     * Thus java.lang.String becomes String.lang.java (if the delimiter
&nbsp;     * is &lt;code&gt;&quot;.&quot;&lt;/code&gt;).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.reverseDelimitedString(null, *)       = null
&nbsp;     * StringUtils.reverseDelimitedString(&quot;&quot;,*)          = &quot;&quot;
&nbsp;     * StringUtils.reverseDelimitedString(&quot;a.b.c&quot;, null) = &quot;a.b.c&quot;
&nbsp;     * StringUtils.reverseDelimitedString(&quot;a.b.c&quot;, &quot;.&quot;)  = &quot;c.b.a&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to reverse, may be null
&nbsp;     * @param separatorChars  the separator characters to use, null treated as whitespace
&nbsp;     * @return the reversed String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @deprecated Use {@link #reverseDelimited(String, char)} instead.
&nbsp;     *      This method is broken as the join doesn&#39;t know which char to use.
&nbsp;     *      Method will be removed in Commons Lang 3.0.
&nbsp;     *
&nbsp;     */
&nbsp;    public static String reverseDelimitedString(String str, String separatorChars) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        // could implement manually, but simple way is to reuse other,
&nbsp;        // probably slower, methods.
<b class="nc">&nbsp;        String[] strs = split(str, separatorChars);</b>
<b class="nc">&nbsp;        ArrayUtils.reverse(strs);</b>
<b class="nc">&nbsp;        if (separatorChars == null) {</b>
<b class="nc">&nbsp;            return join(strs, &#39; &#39;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return join(strs, separatorChars);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Abbreviating
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Abbreviates a String using ellipses. This will turn
&nbsp;     * &quot;Now is the time for all good men&quot; into &quot;Now is the time for...&quot;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Specifically:
&nbsp;     * &lt;ul&gt;
&nbsp;     *   &lt;li&gt;If &lt;code&gt;str&lt;/code&gt; is less than &lt;code&gt;maxWidth&lt;/code&gt; characters
&nbsp;     *       long, return it.&lt;/li&gt;
&nbsp;     *   &lt;li&gt;Else abbreviate it to &lt;code&gt;(substring(str, 0, max-3) + &quot;...&quot;)&lt;/code&gt;.&lt;/li&gt;
&nbsp;     *   &lt;li&gt;If &lt;code&gt;maxWidth&lt;/code&gt; is less than &lt;code&gt;4&lt;/code&gt;, throw an
&nbsp;     *       &lt;code&gt;IllegalArgumentException&lt;/code&gt;.&lt;/li&gt;
&nbsp;     *   &lt;li&gt;In no case will it return a String of length greater than
&nbsp;     *       &lt;code&gt;maxWidth&lt;/code&gt;.&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.abbreviate(null, *)      = null
&nbsp;     * StringUtils.abbreviate(&quot;&quot;, 4)        = &quot;&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefg&quot;, 6) = &quot;abc...&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefg&quot;, 7) = &quot;abcdefg&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefg&quot;, 8) = &quot;abcdefg&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefg&quot;, 4) = &quot;a...&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefg&quot;, 3) = IllegalArgumentException
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param maxWidth  maximum length of result String, must be at least 4
&nbsp;     * @return abbreviated String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @throws IllegalArgumentException if the width is too small
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String abbreviate(String str, int maxWidth) {
<b class="nc">&nbsp;        return abbreviate(str, 0, maxWidth);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Abbreviates a String using ellipses. This will turn
&nbsp;     * &quot;Now is the time for all good men&quot; into &quot;...is the time for...&quot;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Works like &lt;code&gt;abbreviate(String, int)&lt;/code&gt;, but allows you to specify
&nbsp;     * a &quot;left edge&quot; offset.  Note that this left edge is not necessarily going to
&nbsp;     * be the leftmost character in the result, or the first character following the
&nbsp;     * ellipses, but it will appear somewhere in the result.
&nbsp;     *
&nbsp;     * &lt;p&gt;In no case will it return a String of length greater than
&nbsp;     * &lt;code&gt;maxWidth&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.abbreviate(null, *, *)                = null
&nbsp;     * StringUtils.abbreviate(&quot;&quot;, 0, 4)                  = &quot;&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, -1, 10) = &quot;abcdefg...&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 0, 10)  = &quot;abcdefg...&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 1, 10)  = &quot;abcdefg...&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 4, 10)  = &quot;abcdefg...&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 5, 10)  = &quot;...fghi...&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 6, 10)  = &quot;...ghij...&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 8, 10)  = &quot;...ijklmno&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 10, 10) = &quot;...ijklmno&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 12, 10) = &quot;...ijklmno&quot;
&nbsp;     * StringUtils.abbreviate(&quot;abcdefghij&quot;, 0, 3)        = IllegalArgumentException
&nbsp;     * StringUtils.abbreviate(&quot;abcdefghij&quot;, 5, 6)        = IllegalArgumentException
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param offset  left edge of source String
&nbsp;     * @param maxWidth  maximum length of result String, must be at least 4
&nbsp;     * @return abbreviated String, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * @throws IllegalArgumentException if the width is too small
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String abbreviate(String str, int offset, int maxWidth) {
<b class="nc">&nbsp;        if (str == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (maxWidth &lt; 4) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Minimum abbreviation width is 4&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (str.length() &lt;= maxWidth) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (offset &gt; str.length()) {</b>
<b class="nc">&nbsp;            offset = str.length();</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((str.length() - offset) &lt; (maxWidth - 3)) {</b>
<b class="nc">&nbsp;            offset = str.length() - (maxWidth - 3);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (offset &lt;= 4) {</b>
<b class="nc">&nbsp;            return str.substring(0, maxWidth - 3) + &quot;...&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (maxWidth &lt; 7) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Minimum abbreviation width with offset is 7&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((offset + (maxWidth - 3)) &lt; str.length()) {</b>
<b class="nc">&nbsp;            return &quot;...&quot; + abbreviate(str.substring(offset), maxWidth - 3);</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;...&quot; + str.substring(str.length() - (maxWidth - 3));</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * &lt;p&gt;Abbreviates a String to the length passed, replacing the middle characters with the supplied
&nbsp;     * replacement String.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;This abbreviation only occurs if the following criteria is met:
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;Neither the String for abbreviation nor the replacement String are null or empty &lt;/li&gt;
&nbsp;     * &lt;li&gt;The length to truncate to is less than the length of the supplied String&lt;/li&gt;
&nbsp;     * &lt;li&gt;The length to truncate to is greater than 0&lt;/li&gt;
&nbsp;     * &lt;li&gt;The abbreviated String will have enough room for the length supplied replacement String
&nbsp;     * and the first and last characters of the supplied String for abbreviation&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * Otherwise, the returned String will be the same as the supplied String for abbreviation.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.abbreviateMiddle(null, null, 0)      = null
&nbsp;     * StringUtils.abbreviateMiddle(&quot;abc&quot;, null, 0)      = &quot;abc&quot;
&nbsp;     * StringUtils.abbreviateMiddle(&quot;abc&quot;, &quot;.&quot;, 0)      = &quot;abc&quot;
&nbsp;     * StringUtils.abbreviateMiddle(&quot;abc&quot;, &quot;.&quot;, 3)      = &quot;abc&quot;
&nbsp;     * StringUtils.abbreviateMiddle(&quot;abcdef&quot;, &quot;.&quot;, 4)     = &quot;ab.f&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str  the String to abbreviate, may be null
&nbsp;     * @param middle the String to replace the middle characters with, may be null
&nbsp;     * @param length the length to abbreviate &lt;code&gt;str&lt;/code&gt; to.
&nbsp;     * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public static String abbreviateMiddle(String str, String middle, int length) {
<b class="nc">&nbsp;        if (isEmpty(str) || isEmpty(middle)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
&nbsp;      
<b class="nc">&nbsp;        if (length &gt;= str.length() || length &lt; (middle.length()+2)) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int targetSting = length-middle.length();</b>
<b class="nc">&nbsp;        int startOffset = targetSting/2+targetSting%2;</b>
<b class="nc">&nbsp;        int endOffset = str.length()-targetSting/2;</b>
&nbsp;        
<b class="nc">&nbsp;        StrBuilder builder = new StrBuilder(length);</b>
<b class="nc">&nbsp;        builder.append(str.substring(0,startOffset));</b>
<b class="nc">&nbsp;        builder.append(middle);</b>
<b class="nc">&nbsp;        builder.append(str.substring(endOffset));</b>
&nbsp;        
<b class="nc">&nbsp;        return builder.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    // Difference
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Compares two Strings, and returns the portion where they differ.
&nbsp;     * (More precisely, return the remainder of the second String,
&nbsp;     * starting from where it&#39;s different from the first.)&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;For example,
&nbsp;     * &lt;code&gt;difference(&quot;i am a machine&quot;, &quot;i am a robot&quot;) -&gt; &quot;robot&quot;&lt;/code&gt;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.difference(null, null) = null
&nbsp;     * StringUtils.difference(&quot;&quot;, &quot;&quot;) = &quot;&quot;
&nbsp;     * StringUtils.difference(&quot;&quot;, &quot;abc&quot;) = &quot;abc&quot;
&nbsp;     * StringUtils.difference(&quot;abc&quot;, &quot;&quot;) = &quot;&quot;
&nbsp;     * StringUtils.difference(&quot;abc&quot;, &quot;abc&quot;) = &quot;&quot;
&nbsp;     * StringUtils.difference(&quot;ab&quot;, &quot;abxyz&quot;) = &quot;xyz&quot;
&nbsp;     * StringUtils.difference(&quot;abcde&quot;, &quot;abxyz&quot;) = &quot;xyz&quot;
&nbsp;     * StringUtils.difference(&quot;abcde&quot;, &quot;xyz&quot;) = &quot;xyz&quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str1  the first String, may be null
&nbsp;     * @param str2  the second String, may be null
&nbsp;     * @return the portion of str2 where it differs from str1; returns the
&nbsp;     * empty String if they are equal
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static String difference(String str1, String str2) {
<b class="nc">&nbsp;        if (str1 == null) {</b>
<b class="nc">&nbsp;            return str2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (str2 == null) {</b>
<b class="nc">&nbsp;            return str1;</b>
&nbsp;        }
<b class="nc">&nbsp;        int at = indexOfDifference(str1, str2);</b>
<b class="nc">&nbsp;        if (at == INDEX_NOT_FOUND) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str2.substring(at);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Compares two Strings, and returns the index at which the
&nbsp;     * Strings begin to differ.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;For example,
&nbsp;     * &lt;code&gt;indexOfDifference(&quot;i am a machine&quot;, &quot;i am a robot&quot;) -&gt; 7&lt;/code&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOfDifference(null, null) = -1
&nbsp;     * StringUtils.indexOfDifference(&quot;&quot;, &quot;&quot;) = -1
&nbsp;     * StringUtils.indexOfDifference(&quot;&quot;, &quot;abc&quot;) = 0
&nbsp;     * StringUtils.indexOfDifference(&quot;abc&quot;, &quot;&quot;) = 0
&nbsp;     * StringUtils.indexOfDifference(&quot;abc&quot;, &quot;abc&quot;) = -1
&nbsp;     * StringUtils.indexOfDifference(&quot;ab&quot;, &quot;abxyz&quot;) = 2
&nbsp;     * StringUtils.indexOfDifference(&quot;abcde&quot;, &quot;abxyz&quot;) = 2
&nbsp;     * StringUtils.indexOfDifference(&quot;abcde&quot;, &quot;xyz&quot;) = 0
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param str1  the first String, may be null
&nbsp;     * @param str2  the second String, may be null
&nbsp;     * @return the index where str2 and str1 begin to differ; -1 if they are equal
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    public static int indexOfDifference(String str1, String str2) {
<b class="nc">&nbsp;        if (str1 == str2) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (str1 == null || str2 == null) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;        int i;
<b class="nc">&nbsp;        for (i = 0; i &lt; str1.length() &amp;&amp; i &lt; str2.length(); ++i) {</b>
<b class="nc">&nbsp;            if (str1.charAt(i) != str2.charAt(i)) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (i &lt; str2.length() || i &lt; str1.length()) {</b>
<b class="nc">&nbsp;            return i;</b>
&nbsp;        }
<b class="nc">&nbsp;        return INDEX_NOT_FOUND;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Compares all Strings in an array and returns the index at which the
&nbsp;     * Strings begin to differ.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;For example,
&nbsp;     * &lt;code&gt;indexOfDifference(new String[] {&quot;i am a machine&quot;, &quot;i am a robot&quot;}) -&gt; 7&lt;/code&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.indexOfDifference(null) = -1
&nbsp;     * StringUtils.indexOfDifference(new String[] {}) = -1
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;abc&quot;}) = -1
&nbsp;     * StringUtils.indexOfDifference(new String[] {null, null}) = -1
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;&quot;, &quot;&quot;}) = -1
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;&quot;, null}) = 0
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;abc&quot;, null, null}) = 0
&nbsp;     * StringUtils.indexOfDifference(new String[] {null, null, &quot;abc&quot;}) = 0
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;&quot;, &quot;abc&quot;}) = 0
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;abc&quot;, &quot;&quot;}) = 0
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;abc&quot;, &quot;abc&quot;}) = -1
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;abc&quot;, &quot;a&quot;}) = 1
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;ab&quot;, &quot;abxyz&quot;}) = 2
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;abcde&quot;, &quot;abxyz&quot;}) = 2
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;abcde&quot;, &quot;xyz&quot;}) = 0
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;xyz&quot;, &quot;abcde&quot;}) = 0
&nbsp;     * StringUtils.indexOfDifference(new String[] {&quot;i am a machine&quot;, &quot;i am a robot&quot;}) = 7
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param strs  array of strings, entries may be null
&nbsp;     * @return the index where the strings begin to differ; -1 if they are all equal
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static int indexOfDifference(String[] strs) {
<b class="nc">&nbsp;        if (strs == null || strs.length &lt;= 1) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean anyStringNull = false;</b>
<b class="nc">&nbsp;        boolean allStringsNull = true;</b>
<b class="nc">&nbsp;        int arrayLen = strs.length;</b>
<b class="nc">&nbsp;        int shortestStrLen = Integer.MAX_VALUE;</b>
<b class="nc">&nbsp;        int longestStrLen = 0;</b>
&nbsp;
&nbsp;        // find the min and max string lengths; this avoids checking to make
&nbsp;        // sure we are not exceeding the length of the string each time through
&nbsp;        // the bottom loop.
<b class="nc">&nbsp;        for (int i = 0; i &lt; arrayLen; i++) {</b>
<b class="nc">&nbsp;            if (strs[i] == null) {</b>
<b class="nc">&nbsp;                anyStringNull = true;</b>
<b class="nc">&nbsp;                shortestStrLen = 0;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                allStringsNull = false;</b>
<b class="nc">&nbsp;                shortestStrLen = Math.min(strs[i].length(), shortestStrLen);</b>
<b class="nc">&nbsp;                longestStrLen = Math.max(strs[i].length(), longestStrLen);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // handle lists containing all nulls or all empty strings
<b class="nc">&nbsp;        if (allStringsNull || (longestStrLen == 0 &amp;&amp; !anyStringNull)) {</b>
<b class="nc">&nbsp;            return INDEX_NOT_FOUND;</b>
&nbsp;        }
&nbsp;
&nbsp;        // handle lists containing some nulls or some empty strings
<b class="nc">&nbsp;        if (shortestStrLen == 0) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // find the position with the first difference across all strings
<b class="nc">&nbsp;        int firstDiff = -1;</b>
<b class="nc">&nbsp;        for (int stringPos = 0; stringPos &lt; shortestStrLen; stringPos++) {</b>
<b class="nc">&nbsp;            char comparisonChar = strs[0].charAt(stringPos);</b>
<b class="nc">&nbsp;            for (int arrayPos = 1; arrayPos &lt; arrayLen; arrayPos++) {</b>
<b class="nc">&nbsp;                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {</b>
<b class="nc">&nbsp;                    firstDiff = stringPos;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (firstDiff != -1) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (firstDiff == -1 &amp;&amp; shortestStrLen != longestStrLen) {</b>
&nbsp;            // we compared all of the characters up to the length of the
&nbsp;            // shortest string and didn&#39;t find a match, but the string lengths
&nbsp;            // vary, so return the length of the shortest string.
<b class="nc">&nbsp;            return shortestStrLen;</b>
&nbsp;        }
<b class="nc">&nbsp;        return firstDiff;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * &lt;p&gt;Compares all Strings in an array and returns the initial sequence of 
&nbsp;     * characters that is common to all of them.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;For example,
&nbsp;     * &lt;code&gt;getCommonPrefix(new String[] {&quot;i am a machine&quot;, &quot;i am a robot&quot;}) -&gt; &quot;i am a &quot;&lt;/code&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.getCommonPrefix(null) = &quot;&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {}) = &quot;&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;abc&quot;}) = &quot;abc&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {null, null}) = &quot;&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;&quot;, &quot;&quot;}) = &quot;&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;&quot;, null}) = &quot;&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;abc&quot;, null, null}) = &quot;&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {null, null, &quot;abc&quot;}) = &quot;&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;&quot;, &quot;abc&quot;}) = &quot;&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;abc&quot;, &quot;&quot;}) = &quot;&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;abc&quot;, &quot;abc&quot;}) = &quot;abc&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;abc&quot;, &quot;a&quot;}) = &quot;a&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;ab&quot;, &quot;abxyz&quot;}) = &quot;ab&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;abcde&quot;, &quot;abxyz&quot;}) = &quot;ab&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;abcde&quot;, &quot;xyz&quot;}) = &quot;&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;xyz&quot;, &quot;abcde&quot;}) = &quot;&quot;
&nbsp;     * StringUtils.getCommonPrefix(new String[] {&quot;i am a machine&quot;, &quot;i am a robot&quot;}) = &quot;i am a &quot;
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param strs  array of String objects, entries may be null
&nbsp;     * @return the initial sequence of characters that are common to all Strings
&nbsp;     * in the array; empty String if the array is null, the elements are all null 
&nbsp;     * or if there is no common prefix. 
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static String getCommonPrefix(String[] strs) {
<b class="nc">&nbsp;        if (strs == null || strs.length == 0) {</b>
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        }
<b class="nc">&nbsp;        int smallestIndexOfDiff = indexOfDifference(strs);</b>
<b class="nc">&nbsp;        if (smallestIndexOfDiff == INDEX_NOT_FOUND) {</b>
&nbsp;            // all strings were identical
<b class="nc">&nbsp;            if (strs[0] == null) {</b>
<b class="nc">&nbsp;                return EMPTY;</b>
&nbsp;            }
<b class="nc">&nbsp;            return strs[0];</b>
<b class="nc">&nbsp;        } else if (smallestIndexOfDiff == 0) {</b>
&nbsp;            // there were no common initial characters
<b class="nc">&nbsp;            return EMPTY;</b>
&nbsp;        } else {
&nbsp;            // we found a common initial character sequence
<b class="nc">&nbsp;            return strs[0].substring(0, smallestIndexOfDiff);</b>
&nbsp;        }
&nbsp;    }  
&nbsp;    
&nbsp;    // Misc
&nbsp;    //-----------------------------------------------------------------------
&nbsp;    /**
&nbsp;     * &lt;p&gt;Find the Levenshtein distance between two Strings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;This is the number of changes needed to change one String into
&nbsp;     * another, where each change is a single character modification (deletion,
&nbsp;     * insertion or substitution).&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;The previous implementation of the Levenshtein distance algorithm
&nbsp;     * was from &lt;a href=&quot;http://www.merriampark.com/ld.htm&quot;&gt;http://www.merriampark.com/ld.htm&lt;/a&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
&nbsp;     * which can occur when my Java implementation is used with very large strings.&lt;br&gt;
&nbsp;     * This implementation of the Levenshtein distance algorithm
&nbsp;     * is from &lt;a href=&quot;http://www.merriampark.com/ldjava.htm&quot;&gt;http://www.merriampark.com/ldjava.htm&lt;/a&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
&nbsp;     * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
&nbsp;     * StringUtils.getLevenshteinDistance(&quot;&quot;,&quot;&quot;)               = 0
&nbsp;     * StringUtils.getLevenshteinDistance(&quot;&quot;,&quot;a&quot;)              = 1
&nbsp;     * StringUtils.getLevenshteinDistance(&quot;aaapppp&quot;, &quot;&quot;)       = 7
&nbsp;     * StringUtils.getLevenshteinDistance(&quot;frog&quot;, &quot;fog&quot;)       = 1
&nbsp;     * StringUtils.getLevenshteinDistance(&quot;fly&quot;, &quot;ant&quot;)        = 3
&nbsp;     * StringUtils.getLevenshteinDistance(&quot;elephant&quot;, &quot;hippo&quot;) = 7
&nbsp;     * StringUtils.getLevenshteinDistance(&quot;hippo&quot;, &quot;elephant&quot;) = 7
&nbsp;     * StringUtils.getLevenshteinDistance(&quot;hippo&quot;, &quot;zzzzzzzz&quot;) = 8
&nbsp;     * StringUtils.getLevenshteinDistance(&quot;hello&quot;, &quot;hallo&quot;)    = 1
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param s  the first String, must not be null
&nbsp;     * @param t  the second String, must not be null
&nbsp;     * @return result distance
&nbsp;     * @throws IllegalArgumentException if either String input &lt;code&gt;null&lt;/code&gt;
&nbsp;     */
&nbsp;    public static int getLevenshteinDistance(String s, String t) {
<b class="nc">&nbsp;        if (s == null || t == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Strings must not be null&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        /*
&nbsp;           The difference between this impl. and the previous is that, rather 
&nbsp;           than creating and retaining a matrix of size s.length()+1 by t.length()+1, 
&nbsp;           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,
&nbsp;           is the &#39;current working&#39; distance array that maintains the newest distance cost
&nbsp;           counts as we iterate through the characters of String s.  Each time we increment
&nbsp;           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
&nbsp;           allows us to retain the previous cost counts as required by the algorithm (taking 
&nbsp;           the minimum of the cost count to the left, up one, and diagonally up and to the left
&nbsp;           of the current cost count being calculated).  (Note that the arrays aren&#39;t really 
&nbsp;           copied anymore, just switched...this is clearly much better than cloning an array 
&nbsp;           or doing a System.arraycopy() each time  through the outer loop.)
&nbsp;
&nbsp;           Effectively, the difference between the two implementations is this one does not 
&nbsp;           cause an out of memory condition when calculating the LD over two very large strings.
&nbsp;         */
&nbsp;
<b class="nc">&nbsp;        int n = s.length(); // length of s</b>
<b class="nc">&nbsp;        int m = t.length(); // length of t</b>
&nbsp;
<b class="nc">&nbsp;        if (n == 0) {</b>
<b class="nc">&nbsp;            return m;</b>
<b class="nc">&nbsp;        } else if (m == 0) {</b>
<b class="nc">&nbsp;            return n;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (n &gt; m) {</b>
&nbsp;            // swap the input strings to consume less memory
<b class="nc">&nbsp;            String tmp = s;</b>
<b class="nc">&nbsp;            s = t;</b>
<b class="nc">&nbsp;            t = tmp;</b>
<b class="nc">&nbsp;            n = m;</b>
<b class="nc">&nbsp;            m = t.length();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int p[] = new int[n+1]; //&#39;previous&#39; cost array, horizontally</b>
<b class="nc">&nbsp;        int d[] = new int[n+1]; // cost array, horizontally</b>
&nbsp;        int _d[]; //placeholder to assist in swapping p and d
&nbsp;
&nbsp;        // indexes into strings s and t
&nbsp;        int i; // iterates through s
&nbsp;        int j; // iterates through t
&nbsp;
&nbsp;        char t_j; // jth character of t
&nbsp;
&nbsp;        int cost; // cost
&nbsp;
<b class="nc">&nbsp;        for (i = 0; i&lt;=n; i++) {</b>
<b class="nc">&nbsp;            p[i] = i;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (j = 1; j&lt;=m; j++) {</b>
<b class="nc">&nbsp;            t_j = t.charAt(j-1);</b>
<b class="nc">&nbsp;            d[0] = j;</b>
&nbsp;
<b class="nc">&nbsp;            for (i=1; i&lt;=n; i++) {</b>
<b class="nc">&nbsp;                cost = s.charAt(i-1)==t_j ? 0 : 1;</b>
&nbsp;                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
<b class="nc">&nbsp;                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);</b>
&nbsp;            }
&nbsp;
&nbsp;            // copy current distance counts to &#39;previous row&#39; distance counts
<b class="nc">&nbsp;            _d = p;</b>
<b class="nc">&nbsp;            p = d;</b>
<b class="nc">&nbsp;            d = _d;</b>
&nbsp;        }
&nbsp;
&nbsp;        // our last action in the above loop was to switch d and p, so p now 
&nbsp;        // actually has the most recent cost counts
<b class="nc">&nbsp;        return p[n];</b>
&nbsp;    }
&nbsp;
&nbsp;    // startsWith
&nbsp;    //-----------------------------------------------------------------------
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Check if a String starts with a specified prefix.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt;s are handled without exceptions. Two &lt;code&gt;null&lt;/code&gt;
&nbsp;     * references are considered to be equal. The comparison is case sensitive.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.startsWith(null, null)      = true
&nbsp;     * StringUtils.startsWith(null, &quot;abc&quot;)     = false
&nbsp;     * StringUtils.startsWith(&quot;abcdef&quot;, null)  = false
&nbsp;     * StringUtils.startsWith(&quot;abcdef&quot;, &quot;abc&quot;) = true
&nbsp;     * StringUtils.startsWith(&quot;ABCDEF&quot;, &quot;abc&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @see java.lang.String#startsWith(String)
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param prefix the prefix to find, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the String starts with the prefix, case sensitive, or
&nbsp;     *  both &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static boolean startsWith(String str, String prefix) {
<b class="nc">&nbsp;        return startsWith(str, prefix, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Case insensitive check if a String starts with a specified prefix.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt;s are handled without exceptions. Two &lt;code&gt;null&lt;/code&gt;
&nbsp;     * references are considered to be equal. The comparison is case insensitive.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.startsWithIgnoreCase(null, null)      = true
&nbsp;     * StringUtils.startsWithIgnoreCase(null, &quot;abc&quot;)     = false
&nbsp;     * StringUtils.startsWithIgnoreCase(&quot;abcdef&quot;, null)  = false
&nbsp;     * StringUtils.startsWithIgnoreCase(&quot;abcdef&quot;, &quot;abc&quot;) = true
&nbsp;     * StringUtils.startsWithIgnoreCase(&quot;ABCDEF&quot;, &quot;abc&quot;) = true
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @see java.lang.String#startsWith(String)
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param prefix the prefix to find, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the String starts with the prefix, case insensitive, or
&nbsp;     *  both &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static boolean startsWithIgnoreCase(String str, String prefix) {
<b class="nc">&nbsp;        return startsWith(str, prefix, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Check if a String starts with a specified prefix (optionally case insensitive).&lt;/p&gt;
&nbsp;     *
&nbsp;     * @see java.lang.String#startsWith(String)
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param prefix the prefix to find, may be null
&nbsp;     * @param ignoreCase inidicates whether the compare should ignore case
&nbsp;     *  (case insensitive) or not.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the String starts with the prefix or
&nbsp;     *  both &lt;code&gt;null&lt;/code&gt;
&nbsp;     */
&nbsp;    private static boolean startsWith(String str, String prefix, boolean ignoreCase) {
<b class="nc">&nbsp;        if (str == null || prefix == null) {</b>
<b class="nc">&nbsp;            return (str == null &amp;&amp; prefix == null);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (prefix.length() &gt; str.length()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * &lt;p&gt;Check if a String starts with any of an array of specified strings.&lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.startsWithAny(null, null)      = false
&nbsp;     * StringUtils.startsWithAny(null, new String[] {&quot;abc&quot;})  = false
&nbsp;     * StringUtils.startsWithAny(&quot;abcxyz&quot;, null)     = false
&nbsp;     * StringUtils.startsWithAny(&quot;abcxyz&quot;, new String[] {&quot;&quot;}) = false
&nbsp;     * StringUtils.startsWithAny(&quot;abcxyz&quot;, new String[] {&quot;abc&quot;}) = true
&nbsp;     * StringUtils.startsWithAny(&quot;abcxyz&quot;, new String[] {null, &quot;xyz&quot;, &quot;abc&quot;}) = true
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @see #startsWith(String, String)
&nbsp;     * @param string  the String to check, may be null
&nbsp;     * @param searchStrings the Strings to find, may be null or empty
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the String starts with any of the the prefixes, case insensitive, or
&nbsp;     *  both &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @since 2.5
&nbsp;     */
&nbsp;    public static boolean startsWithAny(String string, String[] searchStrings) {
<b class="nc">&nbsp;        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; searchStrings.length; i++) {</b>
<b class="nc">&nbsp;            String searchString = searchStrings[i];</b>
<b class="nc">&nbsp;            if (StringUtils.startsWith(string, searchString)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    // endsWith
&nbsp;    //-----------------------------------------------------------------------
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Check if a String ends with a specified suffix.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt;s are handled without exceptions. Two &lt;code&gt;null&lt;/code&gt;
&nbsp;     * references are considered to be equal. The comparison is case sensitive.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.endsWith(null, null)      = true
&nbsp;     * StringUtils.endsWith(null, &quot;def&quot;)     = false
&nbsp;     * StringUtils.endsWith(&quot;abcdef&quot;, null)  = false
&nbsp;     * StringUtils.endsWith(&quot;abcdef&quot;, &quot;def&quot;) = true
&nbsp;     * StringUtils.endsWith(&quot;ABCDEF&quot;, &quot;def&quot;) = false
&nbsp;     * StringUtils.endsWith(&quot;ABCDEF&quot;, &quot;cde&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @see java.lang.String#endsWith(String)
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param suffix the suffix to find, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the String ends with the suffix, case sensitive, or
&nbsp;     *  both &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static boolean endsWith(String str, String suffix) {
<b class="nc">&nbsp;        return endsWith(str, suffix, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Case insensitive check if a String ends with a specified suffix.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt;s are handled without exceptions. Two &lt;code&gt;null&lt;/code&gt;
&nbsp;     * references are considered to be equal. The comparison is case insensitive.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.endsWithIgnoreCase(null, null)      = true
&nbsp;     * StringUtils.endsWithIgnoreCase(null, &quot;def&quot;)     = false
&nbsp;     * StringUtils.endsWithIgnoreCase(&quot;abcdef&quot;, null)  = false
&nbsp;     * StringUtils.endsWithIgnoreCase(&quot;abcdef&quot;, &quot;def&quot;) = true
&nbsp;     * StringUtils.endsWithIgnoreCase(&quot;ABCDEF&quot;, &quot;def&quot;) = true
&nbsp;     * StringUtils.endsWithIgnoreCase(&quot;ABCDEF&quot;, &quot;cde&quot;) = false
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @see java.lang.String#endsWith(String)
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param suffix the suffix to find, may be null
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the String ends with the suffix, case insensitive, or
&nbsp;     *  both &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    public static boolean endsWithIgnoreCase(String str, String suffix) {
<b class="nc">&nbsp;        return endsWith(str, suffix, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Check if a String ends with a specified suffix (optionally case insensitive).&lt;/p&gt;
&nbsp;     *
&nbsp;     * @see java.lang.String#endsWith(String)
&nbsp;     * @param str  the String to check, may be null
&nbsp;     * @param suffix the suffix to find, may be null
&nbsp;     * @param ignoreCase inidicates whether the compare should ignore case
&nbsp;     *  (case insensitive) or not.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the String starts with the prefix or
&nbsp;     *  both &lt;code&gt;null&lt;/code&gt;
&nbsp;     */
&nbsp;    private static boolean endsWith(String str, String suffix, boolean ignoreCase) {
<b class="nc">&nbsp;        if (str == null || suffix == null) {</b>
<b class="nc">&nbsp;            return (str == null &amp;&amp; suffix == null);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (suffix.length() &gt; str.length()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        int strOffset = str.length() - suffix.length();</b>
<b class="nc">&nbsp;        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Similar to &lt;a
&nbsp;     * href=&quot;http://www.w3.org/TR/xpath/#function-normalize-space&quot;&gt;http://www.w3.org/TR/xpath/#function-normalize
&nbsp;     * -space&lt;/a&gt;
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * The function returns the argument string with whitespace normalized by using
&nbsp;     * &lt;code&gt;{@link #trim(String)}&lt;/code&gt; to remove leading and trailing whitespace
&nbsp;     * and then replacing sequences of whitespace characters by a single space.
&nbsp;     * &lt;/p&gt;
&nbsp;     * In XML Whitespace characters are the same as those allowed by the &lt;a
&nbsp;     * href=&quot;http://www.w3.org/TR/REC-xml/#NT-S&quot;&gt;S&lt;/a&gt; production, which is S ::= (#x20 | #x9 | #xD | #xA)+
&nbsp;     * &lt;p&gt;
&nbsp;     * See Java&#39;s {@link Character#isWhitespace(char)} for which characters are considered whitespace.
&nbsp;     * &lt;p&gt;
&nbsp;     * The difference is that Java&#39;s whitespace includes vertical tab and form feed, which this functional will also
&nbsp;     * normalize. Additonally &lt;code&gt;{@link #trim(String)}&lt;/code&gt; removes control characters (char &amp;lt;= 32) from both
&nbsp;     * ends of this String.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Character#isWhitespace(char)
&nbsp;     * @see #trim(String)
&nbsp;     * @see &lt;ahref=&quot;http://www.w3.org/TR/xpath/#function-normalize-space&quot;&gt;
&nbsp;     *              http://www.w3.org/TR/xpath/#function-normalize-space&lt;/a&gt;
&nbsp;     * @param str the source String to normalize whitespaces from, may be null
&nbsp;     * @return the modified string with whitespace normalized, &lt;code&gt;null&lt;/code&gt; if null String input
&nbsp;     * 
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public static String normalizeSpace(String str) {
<b class="nc">&nbsp;        str = strip(str);</b>
<b class="nc">&nbsp;        if(str == null || str.length() &lt;= 2) {</b>
<b class="nc">&nbsp;            return str;</b>
&nbsp;        }
<b class="nc">&nbsp;        StrBuilder b = new StrBuilder(str.length());</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; str.length(); i++) {</b>
<b class="nc">&nbsp;            char c = str.charAt(i);</b>
<b class="nc">&nbsp;            if (Character.isWhitespace(c)) {</b>
<b class="nc">&nbsp;                if (i &gt; 0 &amp;&amp; !Character.isWhitespace(str.charAt(i - 1))) {</b>
<b class="nc">&nbsp;                    b.append(&#39; &#39;);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                b.append(c);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return b.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;Check if a String ends with any of an array of specified strings.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * StringUtils.endsWithAny(null, null)      = false
&nbsp;     * StringUtils.endsWithAny(null, new String[] {&quot;abc&quot;})  = false
&nbsp;     * StringUtils.endsWithAny(&quot;abcxyz&quot;, null)     = false
&nbsp;     * StringUtils.endsWithAny(&quot;abcxyz&quot;, new String[] {&quot;&quot;}) = true
&nbsp;     * StringUtils.endsWithAny(&quot;abcxyz&quot;, new String[] {&quot;xyz&quot;}) = true
&nbsp;     * StringUtils.endsWithAny(&quot;abcxyz&quot;, new String[] {null, &quot;xyz&quot;, &quot;abc&quot;}) = true
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param string  the String to check, may be null
&nbsp;     * @param searchStrings the Strings to find, may be null or empty
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the String ends with any of the the prefixes, case insensitive, or
&nbsp;     *  both &lt;code&gt;null&lt;/code&gt;
&nbsp;     * @since 2.6
&nbsp;     */
&nbsp;    public static boolean endsWithAny(String string, String[] searchStrings) {
<b class="nc">&nbsp;        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; searchStrings.length; i++) {</b>
<b class="nc">&nbsp;            String searchString = searchStrings[i];</b>
<b class="nc">&nbsp;            if (StringUtils.endsWith(string, searchString)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
