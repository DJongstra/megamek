


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Category</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.apache.log4j</a>
</div>

<h1>Coverage Summary for Class: Category (org.apache.log4j)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Category</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (11/55)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5,1%
  </span>
  <span class="absValue">
    (7/138)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12,6%
  </span>
  <span class="absValue">
    (20/159)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
&nbsp; * contributor license agreements.  See the NOTICE file distributed with
&nbsp; * this work for additional information regarding copyright ownership.
&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
&nbsp; * the License.  You may obtain a copy of the License at
&nbsp; * 
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; * 
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;// Contibutors: Alex Blewitt &lt;Alex.Blewitt@ioshq.com&gt;
&nbsp;//              Markus Oestreicher &lt;oes@zurich.ibm.com&gt;
&nbsp;//              Frank Hoering &lt;fhr@zurich.ibm.com&gt;
&nbsp;//              Nelson Minar &lt;nelson@media.mit.edu&gt;
&nbsp;//              Jim Cakalic &lt;jim_cakalic@na.biomerieux.com&gt;
&nbsp;//              Avy Sharell &lt;asharell@club-internet.fr&gt;
&nbsp;//              Ciaran Treanor &lt;ciaran@xelector.com&gt;
&nbsp;//              Jeff Turner &lt;jeff@socialchange.net.au&gt;
&nbsp;//              Michael Horwitz &lt;MHorwitz@siemens.co.za&gt;
&nbsp;//              Calvin Chan &lt;calvin.chan@hic.gov.au&gt;
&nbsp;//              Aaron Greenhouse &lt;aarong@cs.cmu.edu&gt;
&nbsp;//              Beat Meier &lt;bmeier@infovia.com.ar&gt;
&nbsp;//              Colin Sampaleanu &lt;colinml1@exis.com&gt;
&nbsp;
&nbsp;package org.apache.log4j;
&nbsp;
&nbsp;import org.apache.log4j.spi.AppenderAttachable;
&nbsp;import org.apache.log4j.spi.LoggingEvent;
&nbsp;import org.apache.log4j.spi.LoggerRepository;
&nbsp;import org.apache.log4j.spi.HierarchyEventListener;
&nbsp;import org.apache.log4j.helpers.NullEnumeration;
&nbsp;import org.apache.log4j.helpers.AppenderAttachableImpl;
&nbsp;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.MissingResourceException;
&nbsp;import java.util.ResourceBundle;
&nbsp;import java.util.Vector;
&nbsp;
&nbsp;
&nbsp;/**
&nbsp;  * &lt;font color=&quot;#AA2222&quot;&gt;&lt;b&gt;This class has been deprecated and
&nbsp;  * replaced by the {@link Logger} &lt;em&gt;subclass&lt;/em&gt;&lt;/b&gt;&lt;/font&gt;. It
&nbsp;  * will be kept around to preserve backward compatibility until mid
&nbsp;  * 2003.
&nbsp;  * 
&nbsp;  * &lt;p&gt;&lt;code&gt;Logger&lt;/code&gt; is a subclass of Category, i.e. it extends
&nbsp;  * Category. In other words, a logger &lt;em&gt;is&lt;/em&gt; a category. Thus,
&nbsp;  * all operations that can be performed on a category can be
&nbsp;  * performed on a logger. Internally, whenever log4j is asked to
&nbsp;  * produce a Category object, it will instead produce a Logger
&nbsp;  * object. Log4j 1.2 will &lt;em&gt;never&lt;/em&gt; produce Category objects but
&nbsp;  * only &lt;code&gt;Logger&lt;/code&gt; instances. In order to preserve backward
&nbsp;  * compatibility, methods that previously accepted category objects
&nbsp;  * still continue to accept category objects.
&nbsp;  * 
&nbsp;  * &lt;p&gt;For example, the following are all legal and will work as
&nbsp;  * expected.
&nbsp;  * 
&nbsp;   &lt;pre&gt;
&nbsp;    &amp;nbsp;&amp;nbsp;&amp;nbsp;// Deprecated form:
&nbsp;    &amp;nbsp;&amp;nbsp;&amp;nbsp;Category cat = Category.getInstance(&quot;foo.bar&quot;)
&nbsp;   
&nbsp;    &amp;nbsp;&amp;nbsp;&amp;nbsp;// Preferred form for retrieving loggers:
&nbsp;    &amp;nbsp;&amp;nbsp;&amp;nbsp;Logger logger = Logger.getLogger(&quot;foo.bar&quot;)
&nbsp;   &lt;/pre&gt;
&nbsp;   
&nbsp;  *  &lt;p&gt;The first form is deprecated and should be avoided.
&nbsp;  * 
&nbsp;  *  &lt;p&gt;&lt;b&gt;There is absolutely no need for new client code to use or
&nbsp;  *  refer to the &lt;code&gt;Category&lt;/code&gt; class.&lt;/b&gt; Whenever possible,
&nbsp;  *  please avoid referring to it or using it.
&nbsp;  * 
&nbsp;  * &lt;p&gt;See the &lt;a href=&quot;../../../../manual.html&quot;&gt;short manual&lt;/a&gt; for an
&nbsp;  * introduction on this class.
&nbsp;  * &lt;p&gt;
&nbsp;  * See the document entitled &lt;a href=&quot;http://www.qos.ch/logging/preparingFor13.html&quot;&gt;preparing
&nbsp;  *  for log4j 1.3&lt;/a&gt; for a more detailed discussion.
&nbsp;  *
&nbsp;  * @author Ceki G&amp;uuml;lc&amp;uuml;
&nbsp;  * @author Anders Kristensen 
&nbsp;  */
&nbsp;public class Category implements AppenderAttachable {
&nbsp;
&nbsp;  /**
&nbsp;     The hierarchy where categories are attached to by default.
&nbsp;  */
&nbsp;  //static
&nbsp;  //public
&nbsp;  //final Hierarchy defaultHierarchy = new Hierarchy(new
&nbsp;  //					   RootCategory(Level.DEBUG));
&nbsp;
&nbsp;  /**
&nbsp;     The name of this category.
&nbsp;  */
&nbsp;  protected String   name;
&nbsp;
&nbsp;  /**
&nbsp;     The assigned level of this category.  The
&nbsp;     &lt;code&gt;level&lt;/code&gt; variable need not be assigned a value in
&nbsp;     which case it is inherited form the hierarchy.  */
&nbsp;  volatile protected Level level;
&nbsp;
&nbsp;  /**
&nbsp;     The parent of this category. All categories have at least one
&nbsp;     ancestor which is the root category. */
&nbsp;  volatile protected Category parent;
&nbsp;
&nbsp;  /**
&nbsp;     The fully qualified name of the Category class. See also the
&nbsp;     getFQCN method. */
<b class="fc">&nbsp;  private static final String FQCN = Category.class.getName();</b>
&nbsp;
&nbsp;  protected ResourceBundle resourceBundle;
&nbsp;
&nbsp;  // Categories need to know what Hierarchy they are in
&nbsp;  protected LoggerRepository repository;
&nbsp;
&nbsp;
&nbsp;  AppenderAttachableImpl aai;
&nbsp;
&nbsp;  /** Additivity is set to true by default, that is children inherit
&nbsp;      the appenders of their ancestors by default. If this variable is
&nbsp;      set to &lt;code&gt;false&lt;/code&gt; then the appenders found in the
&nbsp;      ancestors of this category are not used. However, the children
&nbsp;      of this category will inherit its appenders, unless the children
&nbsp;      have their additivity flag set to &lt;code&gt;false&lt;/code&gt; too. See
&nbsp;      the user manual for more details. */
<b class="fc">&nbsp;  protected boolean additive = true;</b>
&nbsp;
&nbsp;  /**
&nbsp;     This constructor created a new &lt;code&gt;Category&lt;/code&gt; instance and
&nbsp;     sets its name.
&nbsp;
&nbsp;     &lt;p&gt;It is intended to be used by sub-classes only. You should not
&nbsp;     create categories directly.
&nbsp;
&nbsp;     @param name The name of the category.
&nbsp;  */
&nbsp;  protected
<b class="fc">&nbsp;  Category(String name) {</b>
<b class="fc">&nbsp;    this.name = name;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Add &lt;code&gt;newAppender&lt;/code&gt; to the list of appenders of this
&nbsp;     Category instance.
&nbsp;
&nbsp;     &lt;p&gt;If &lt;code&gt;newAppender&lt;/code&gt; is already in the list of
&nbsp;     appenders, then it won&#39;t be added again.
&nbsp;  */
&nbsp;  synchronized
&nbsp;  public
&nbsp;  void addAppender(Appender newAppender) {
<b class="pc">&nbsp;    if(aai == null) {</b>
<b class="fc">&nbsp;      aai = new AppenderAttachableImpl();</b>
&nbsp;    }
<b class="fc">&nbsp;    aai.addAppender(newAppender);</b>
<b class="fc">&nbsp;    repository.fireAddAppenderEvent(this, newAppender);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     If &lt;code&gt;assertion&lt;/code&gt; parameter is &lt;code&gt;false&lt;/code&gt;, then
&nbsp;     logs &lt;code&gt;msg&lt;/code&gt; as an {@link #error(Object) error} statement.
&nbsp;
&nbsp;     &lt;p&gt;The &lt;code&gt;assert&lt;/code&gt; method has been renamed to
&nbsp;     &lt;code&gt;assertLog&lt;/code&gt; because &lt;code&gt;assert&lt;/code&gt; is a language
&nbsp;     reserved word in JDK 1.4.
&nbsp;
&nbsp;     @param assertion
&nbsp;     @param msg The message to print if &lt;code&gt;assertion&lt;/code&gt; is
&nbsp;     false.
&nbsp;
&nbsp;     @since 1.2 */
&nbsp;  public
&nbsp;  void assertLog(boolean assertion, String msg) {
<b class="nc">&nbsp;    if(!assertion)</b>
<b class="nc">&nbsp;      this.error(msg);</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Call the appenders in the hierrachy starting at
&nbsp;     &lt;code&gt;this&lt;/code&gt;.  If no appenders could be found, emit a
&nbsp;     warning.
&nbsp;
&nbsp;     &lt;p&gt;This method calls all the appenders inherited from the
&nbsp;     hierarchy circumventing any evaluation of whether to log or not
&nbsp;     to log the particular log request.
&nbsp;
&nbsp;     @param event the event to log.  */
&nbsp;  public
&nbsp;  void callAppenders(LoggingEvent event) {
<b class="nc">&nbsp;    int writes = 0;</b>
&nbsp;
<b class="nc">&nbsp;    for(Category c = this; c != null; c=c.parent) {</b>
&nbsp;      // Protected against simultaneous call to addAppender, removeAppender,...
<b class="nc">&nbsp;      synchronized(c) {</b>
<b class="nc">&nbsp;	if(c.aai != null) {</b>
<b class="nc">&nbsp;	  writes += c.aai.appendLoopOnAppenders(event);</b>
&nbsp;	}
<b class="nc">&nbsp;	if(!c.additive) {</b>
<b class="nc">&nbsp;	  break;</b>
&nbsp;	}
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if(writes == 0) {</b>
<b class="nc">&nbsp;      repository.emitNoAppenderWarning(this);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Close all attached appenders implementing the AppenderAttachable
&nbsp;     interface.
&nbsp;     @since 1.0
&nbsp;  */
&nbsp;  synchronized
&nbsp;  void closeNestedAppenders() {
<b class="nc">&nbsp;    Enumeration enumeration = this.getAllAppenders();</b>
<b class="nc">&nbsp;    if(enumeration != null) {</b>
<b class="nc">&nbsp;      while(enumeration.hasMoreElements()) {</b>
<b class="nc">&nbsp;	Appender a = (Appender) enumeration.nextElement();</b>
<b class="nc">&nbsp;	if(a instanceof AppenderAttachable) {</b>
<b class="nc">&nbsp;	  a.close();</b>
&nbsp;	}
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;    Log a message object with the {@link Level#DEBUG DEBUG} level.
&nbsp;
&nbsp;    &lt;p&gt;This method first checks if this category is &lt;code&gt;DEBUG&lt;/code&gt;
&nbsp;    enabled by comparing the level of this category with the {@link
&nbsp;    Level#DEBUG DEBUG} level. If this category is
&nbsp;    &lt;code&gt;DEBUG&lt;/code&gt; enabled, then it converts the message object
&nbsp;    (passed as parameter) to a string by invoking the appropriate
&nbsp;    {@link org.apache.log4j.or.ObjectRenderer}. It then proceeds to call all the
&nbsp;    registered appenders in this category and also higher in the
&nbsp;    hierarchy depending on the value of the additivity flag.
&nbsp;
&nbsp;    &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt; Note that passing a {@link Throwable} to this
&nbsp;    method will print the name of the &lt;code&gt;Throwable&lt;/code&gt; but no
&nbsp;    stack trace. To print a stack trace use the {@link #debug(Object,
&nbsp;    Throwable)} form instead.
&nbsp;
&nbsp;    @param message the message object to log. */
&nbsp;  public
&nbsp;  void debug(Object message) {
<b class="nc">&nbsp;    if(repository.isDisabled(Level.DEBUG_INT))</b>
&nbsp;      return;
<b class="nc">&nbsp;    if(Level.DEBUG.isGreaterOrEqual(this.getEffectiveLevel())) {</b>
<b class="nc">&nbsp;      forcedLog(FQCN, Level.DEBUG, message, null);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;   Log a message object with the &lt;code&gt;DEBUG&lt;/code&gt; level including
&nbsp;   the stack trace of the {@link Throwable} &lt;code&gt;t&lt;/code&gt; passed as
&nbsp;   parameter.
&nbsp;
&nbsp;   &lt;p&gt;See {@link #debug(Object)} form for more detailed information.
&nbsp;
&nbsp;   @param message the message object to log.
&nbsp;   @param t the exception to log, including its stack trace.  */
&nbsp;  public
&nbsp;  void debug(Object message, Throwable t) {
<b class="nc">&nbsp;    if(repository.isDisabled(Level.DEBUG_INT))</b>
&nbsp;      return;
<b class="nc">&nbsp;    if(Level.DEBUG.isGreaterOrEqual(this.getEffectiveLevel()))</b>
<b class="nc">&nbsp;      forcedLog(FQCN, Level.DEBUG, message, t);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;    Log a message object with the {@link Level#ERROR ERROR} Level.
&nbsp;
&nbsp;    &lt;p&gt;This method first checks if this category is &lt;code&gt;ERROR&lt;/code&gt;
&nbsp;    enabled by comparing the level of this category with {@link
&nbsp;    Level#ERROR ERROR} Level. If this category is &lt;code&gt;ERROR&lt;/code&gt;
&nbsp;    enabled, then it converts the message object passed as parameter
&nbsp;    to a string by invoking the appropriate {@link
&nbsp;    org.apache.log4j.or.ObjectRenderer}. It proceeds to call all the
&nbsp;    registered appenders in this category and also higher in the
&nbsp;    hierarchy depending on the value of the additivity flag.
&nbsp;
&nbsp;    &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt; Note that passing a {@link Throwable} to this
&nbsp;    method will print the name of the &lt;code&gt;Throwable&lt;/code&gt; but no
&nbsp;    stack trace. To print a stack trace use the {@link #error(Object,
&nbsp;    Throwable)} form instead.
&nbsp;
&nbsp;    @param message the message object to log */
&nbsp;  public
&nbsp;  void error(Object message) {
<b class="nc">&nbsp;    if(repository.isDisabled(Level.ERROR_INT))</b>
&nbsp;      return;
<b class="nc">&nbsp;    if(Level.ERROR.isGreaterOrEqual(this.getEffectiveLevel()))</b>
<b class="nc">&nbsp;      forcedLog(FQCN, Level.ERROR, message, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   Log a message object with the &lt;code&gt;ERROR&lt;/code&gt; level including
&nbsp;   the stack trace of the {@link Throwable} &lt;code&gt;t&lt;/code&gt; passed as
&nbsp;   parameter.
&nbsp;
&nbsp;   &lt;p&gt;See {@link #error(Object)} form for more detailed information.
&nbsp;
&nbsp;   @param message the message object to log.
&nbsp;   @param t the exception to log, including its stack trace.  */
&nbsp;  public
&nbsp;  void error(Object message, Throwable t) {
<b class="nc">&nbsp;    if(repository.isDisabled(Level.ERROR_INT))</b>
&nbsp;      return;
<b class="nc">&nbsp;    if(Level.ERROR.isGreaterOrEqual(this.getEffectiveLevel()))</b>
<b class="nc">&nbsp;      forcedLog(FQCN, Level.ERROR, message, t);</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     If the named category exists (in the default hierarchy) then it
&nbsp;     returns a reference to the category, otherwise it returns
&nbsp;     &lt;code&gt;null&lt;/code&gt;.
&nbsp;
&nbsp;     @deprecated Please use {@link LogManager#exists} instead.
&nbsp;
&nbsp;     @since 0.8.5 */
&nbsp;  public
&nbsp;  static
&nbsp;  Logger exists(String name) {
<b class="nc">&nbsp;    return LogManager.exists(name);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;    Log a message object with the {@link Level#FATAL FATAL} Level.
&nbsp;
&nbsp;    &lt;p&gt;This method first checks if this category is &lt;code&gt;FATAL&lt;/code&gt;
&nbsp;    enabled by comparing the level of this category with {@link
&nbsp;    Level#FATAL FATAL} Level. If the category is &lt;code&gt;FATAL&lt;/code&gt;
&nbsp;    enabled, then it converts the message object passed as parameter
&nbsp;    to a string by invoking the appropriate
&nbsp;    {@link org.apache.log4j.or.ObjectRenderer}. It
&nbsp;    proceeds to call all the registered appenders in this category and
&nbsp;    also higher in the hierarchy depending on the value of the
&nbsp;    additivity flag.
&nbsp;
&nbsp;    &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt; Note that passing a {@link Throwable} to this
&nbsp;    method will print the name of the Throwable but no stack trace. To
&nbsp;    print a stack trace use the {@link #fatal(Object, Throwable)} form
&nbsp;    instead.
&nbsp;
&nbsp;    @param message the message object to log */
&nbsp;  public
&nbsp;  void fatal(Object message) {
<b class="nc">&nbsp;    if(repository.isDisabled(Level.FATAL_INT))</b>
&nbsp;      return;
<b class="nc">&nbsp;    if(Level.FATAL.isGreaterOrEqual(this.getEffectiveLevel()))</b>
<b class="nc">&nbsp;      forcedLog(FQCN, Level.FATAL, message, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   Log a message object with the &lt;code&gt;FATAL&lt;/code&gt; level including
&nbsp;   the stack trace of the {@link Throwable} &lt;code&gt;t&lt;/code&gt; passed as
&nbsp;   parameter.
&nbsp;
&nbsp;   &lt;p&gt;See {@link #fatal(Object)} for more detailed information.
&nbsp;
&nbsp;   @param message the message object to log.
&nbsp;   @param t the exception to log, including its stack trace.  */
&nbsp;  public
&nbsp;  void fatal(Object message, Throwable t) {
<b class="nc">&nbsp;    if(repository.isDisabled(Level.FATAL_INT))</b>
&nbsp;      return;
<b class="nc">&nbsp;    if(Level.FATAL.isGreaterOrEqual(this.getEffectiveLevel()))</b>
<b class="nc">&nbsp;      forcedLog(FQCN, Level.FATAL, message, t);</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     This method creates a new logging event and logs the event
&nbsp;     without further checks.  */
&nbsp;  protected
&nbsp;  void forcedLog(String fqcn, Priority level, Object message, Throwable t) {
<b class="nc">&nbsp;    callAppenders(new LoggingEvent(fqcn, this, level, message, t));</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Get the additivity flag for this Category instance.
&nbsp;  */
&nbsp;  public
&nbsp;  boolean getAdditivity() {
<b class="nc">&nbsp;    return additive;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Get the appenders contained in this category as an {@link
&nbsp;     Enumeration}. If no appenders can be found, then a {@link NullEnumeration}
&nbsp;     is returned.
&nbsp;
&nbsp;     @return Enumeration An enumeration of the appenders in this category.  */
&nbsp;  synchronized
&nbsp;  public
&nbsp;  Enumeration getAllAppenders() {
<b class="pc">&nbsp;    if(aai == null)</b>
<b class="fc">&nbsp;      return NullEnumeration.getInstance();</b>
&nbsp;    else
<b class="nc">&nbsp;      return aai.getAllAppenders();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Look for the appender named as &lt;code&gt;name&lt;/code&gt;.
&nbsp;
&nbsp;     &lt;p&gt;Return the appender with that name if in the list. Return
&nbsp;     &lt;code&gt;null&lt;/code&gt; otherwise.  */
&nbsp;  synchronized
&nbsp;  public
&nbsp;  Appender getAppender(String name) {
<b class="nc">&nbsp;     if(aai == null || name == null)</b>
<b class="nc">&nbsp;      return null;</b>
&nbsp;
<b class="nc">&nbsp;     return aai.getAppender(name);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Starting from this category, search the category hierarchy for a
&nbsp;     non-null level and return it. Otherwise, return the level of the
&nbsp;     root category.
&nbsp;
&nbsp;     &lt;p&gt;The Category class is designed so that this method executes as
&nbsp;     quickly as possible.
&nbsp;   */
&nbsp;  public
&nbsp;  Level getEffectiveLevel() {
<b class="pc">&nbsp;    for(Category c = this; c != null; c=c.parent) {</b>
<b class="fc">&nbsp;      if(c.level != null)</b>
<b class="fc">&nbsp;	return c.level;</b>
&nbsp;    }
<b class="nc">&nbsp;    return null; // If reached will cause an NullPointerException.</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;    *
&nbsp;    * @deprecated Please use the the {@link #getEffectiveLevel} method
&nbsp;    * instead.  
&nbsp;    * */
&nbsp;  public
&nbsp;  Priority getChainedPriority() {
<b class="nc">&nbsp;    for(Category c = this; c != null; c=c.parent) {</b>
<b class="nc">&nbsp;      if(c.level != null)</b>
<b class="nc">&nbsp;	return c.level;</b>
&nbsp;    }
<b class="nc">&nbsp;    return null; // If reached will cause an NullPointerException.</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Returns all the currently defined categories in the default
&nbsp;     hierarchy as an {@link java.util.Enumeration Enumeration}.
&nbsp;
&nbsp;     &lt;p&gt;The root category is &lt;em&gt;not&lt;/em&gt; included in the returned
&nbsp;     {@link Enumeration}.
&nbsp;
&nbsp;     @deprecated Please use {@link LogManager#getCurrentLoggers()} instead.
&nbsp;  */
&nbsp;  public
&nbsp;  static
&nbsp;  Enumeration getCurrentCategories() {
<b class="nc">&nbsp;    return LogManager.getCurrentLoggers();</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Return the default Hierarchy instance.
&nbsp;
&nbsp;     @deprecated Please use {@link LogManager#getLoggerRepository()} instead.
&nbsp;
&nbsp;     @since 1.0
&nbsp;   */
&nbsp;  public
&nbsp;  static
&nbsp;  LoggerRepository getDefaultHierarchy() {
<b class="nc">&nbsp;    return LogManager.getLoggerRepository();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Return the the {@link Hierarchy} where this &lt;code&gt;Category&lt;/code&gt;
&nbsp;     instance is attached.
&nbsp;
&nbsp;     @deprecated Please use {@link #getLoggerRepository} instead.
&nbsp;
&nbsp;     @since 1.1 */
&nbsp;  public
&nbsp;  LoggerRepository  getHierarchy() {
<b class="nc">&nbsp;    return repository;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Return the the {@link LoggerRepository} where this
&nbsp;     &lt;code&gt;Category&lt;/code&gt; is attached.
&nbsp;
&nbsp;     @since 1.2 */
&nbsp;  public
&nbsp;  LoggerRepository  getLoggerRepository() {
<b class="nc">&nbsp;    return repository;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp; /**
&nbsp;  * @deprecated Make sure to use {@link Logger#getLogger(String)} instead.
&nbsp;  */
&nbsp;  public
&nbsp;  static
&nbsp;  Category getInstance(String name) {
<b class="nc">&nbsp;    return LogManager.getLogger(name);</b>
&nbsp;  }
&nbsp;
&nbsp; /**
&nbsp;  * @deprecated Please make sure to use {@link Logger#getLogger(Class)} instead.
&nbsp;  */ 
&nbsp;  public
&nbsp;  static
&nbsp;  Category getInstance(Class clazz) {
<b class="nc">&nbsp;    return LogManager.getLogger(clazz);</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Return the category name.  */
&nbsp;  public
&nbsp;  final
&nbsp;  String getName() {
<b class="fc">&nbsp;    return name;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Returns the parent of this category. Note that the parent of a
&nbsp;     given category may change during the lifetime of the category.
&nbsp;
&nbsp;     &lt;p&gt;The root category will return &lt;code&gt;null&lt;/code&gt;.
&nbsp;
&nbsp;     @since 1.2
&nbsp;  */
&nbsp;  final
&nbsp;  public
&nbsp;  Category getParent() {
<b class="nc">&nbsp;    return this.parent;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Returns the assigned {@link Level}, if any, for this Category.
&nbsp;
&nbsp;     @return Level - the assigned Level, can be &lt;code&gt;null&lt;/code&gt;.
&nbsp;  */
&nbsp;  final
&nbsp;  public
&nbsp;  Level getLevel() {
<b class="fc">&nbsp;    return this.level;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     @deprecated Please use {@link #getLevel} instead.
&nbsp;  */
&nbsp;  final
&nbsp;  public
&nbsp;  Level getPriority() {
<b class="nc">&nbsp;    return this.level;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;   *  @deprecated Please use {@link Logger#getRootLogger()} instead.
&nbsp;   */
&nbsp;  final
&nbsp;  public
&nbsp;  static
&nbsp;  Category getRoot() {
<b class="nc">&nbsp;    return LogManager.getRootLogger();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Return the &lt;em&gt;inherited&lt;/em&gt; {@link ResourceBundle} for this
&nbsp;     category.
&nbsp;
&nbsp;     &lt;p&gt;This method walks the hierarchy to find the appropriate
&nbsp;     resource bundle. It will return the resource bundle attached to
&nbsp;     the closest ancestor of this category, much like the way
&nbsp;     priorities are searched. In case there is no bundle in the
&nbsp;     hierarchy then &lt;code&gt;null&lt;/code&gt; is returned.
&nbsp;
&nbsp;     @since 0.9.0 */
&nbsp;  public
&nbsp;  ResourceBundle getResourceBundle() {
<b class="nc">&nbsp;    for(Category c = this; c != null; c=c.parent) {</b>
<b class="nc">&nbsp;      if(c.resourceBundle != null)</b>
<b class="nc">&nbsp;	return c.resourceBundle;</b>
&nbsp;    }
&nbsp;    // It might be the case that there is no resource bundle
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Returns the string resource coresponding to &lt;code&gt;key&lt;/code&gt; in
&nbsp;     this category&#39;s inherited resource bundle. See also {@link
&nbsp;     #getResourceBundle}.
&nbsp;
&nbsp;     &lt;p&gt;If the resource cannot be found, then an {@link #error error}
&nbsp;     message will be logged complaining about the missing resource.
&nbsp;  */
&nbsp;  protected
&nbsp;  String getResourceBundleString(String key) {
<b class="nc">&nbsp;    ResourceBundle rb = getResourceBundle();</b>
&nbsp;    // This is one of the rare cases where we can use logging in order
&nbsp;    // to report errors from within log4j.
<b class="nc">&nbsp;    if(rb == null) {</b>
&nbsp;      //if(!hierarchy.emittedNoResourceBundleWarning) {
&nbsp;      //error(&quot;No resource bundle has been set for category &quot;+name);
&nbsp;      //hierarchy.emittedNoResourceBundleWarning = true;
&nbsp;      //}
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;    else {
&nbsp;      try {
<b class="nc">&nbsp;	return rb.getString(key);</b>
&nbsp;      }
<b class="nc">&nbsp;      catch(MissingResourceException mre) {</b>
<b class="nc">&nbsp;	error(&quot;No resource is associated with key \&quot;&quot;+key+&quot;\&quot;.&quot;);</b>
<b class="nc">&nbsp;	return null;</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;    Log a message object with the {@link Level#INFO INFO} Level.
&nbsp;
&nbsp;    &lt;p&gt;This method first checks if this category is &lt;code&gt;INFO&lt;/code&gt;
&nbsp;    enabled by comparing the level of this category with {@link
&nbsp;    Level#INFO INFO} Level. If the category is &lt;code&gt;INFO&lt;/code&gt;
&nbsp;    enabled, then it converts the message object passed as parameter
&nbsp;    to a string by invoking the appropriate
&nbsp;    {@link org.apache.log4j.or.ObjectRenderer}. It
&nbsp;    proceeds to call all the registered appenders in this category and
&nbsp;    also higher in the hierarchy depending on the value of the
&nbsp;    additivity flag.
&nbsp;
&nbsp;    &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt; Note that passing a {@link Throwable} to this
&nbsp;    method will print the name of the Throwable but no stack trace. To
&nbsp;    print a stack trace use the {@link #info(Object, Throwable)} form
&nbsp;    instead.
&nbsp;
&nbsp;    @param message the message object to log */
&nbsp;  public
&nbsp;  void info(Object message) {
<b class="nc">&nbsp;    if(repository.isDisabled(Level.INFO_INT))</b>
&nbsp;      return;
<b class="nc">&nbsp;    if(Level.INFO.isGreaterOrEqual(this.getEffectiveLevel()))</b>
<b class="nc">&nbsp;      forcedLog(FQCN, Level.INFO, message, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   Log a message object with the &lt;code&gt;INFO&lt;/code&gt; level including
&nbsp;   the stack trace of the {@link Throwable} &lt;code&gt;t&lt;/code&gt; passed as
&nbsp;   parameter.
&nbsp;
&nbsp;   &lt;p&gt;See {@link #info(Object)} for more detailed information.
&nbsp;
&nbsp;   @param message the message object to log.
&nbsp;   @param t the exception to log, including its stack trace.  */
&nbsp;  public
&nbsp;  void info(Object message, Throwable t) {
<b class="nc">&nbsp;    if(repository.isDisabled(Level.INFO_INT))</b>
&nbsp;      return;
<b class="nc">&nbsp;    if(Level.INFO.isGreaterOrEqual(this.getEffectiveLevel()))</b>
<b class="nc">&nbsp;      forcedLog(FQCN, Level.INFO, message, t);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Is the appender passed as parameter attached to this category?
&nbsp;   */
&nbsp;  public
&nbsp;  boolean isAttached(Appender appender) {
<b class="nc">&nbsp;    if(appender == null || aai == null)</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    else {
<b class="nc">&nbsp;      return aai.isAttached(appender);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;    *  Check whether this category is enabled for the &lt;code&gt;DEBUG&lt;/code&gt;
&nbsp;    *  Level.
&nbsp;    *
&nbsp;    *  &lt;p&gt; This function is intended to lessen the computational cost of
&nbsp;    *  disabled log debug statements.
&nbsp;    *
&nbsp;    *  &lt;p&gt; For some &lt;code&gt;cat&lt;/code&gt; Category object, when you write,
&nbsp;    *  &lt;pre&gt;
&nbsp;    *      cat.debug(&quot;This is entry number: &quot; + i );
&nbsp;    *  &lt;/pre&gt;
&nbsp;    *
&nbsp;    *  &lt;p&gt;You incur the cost constructing the message, concatenatiion in
&nbsp;    *  this case, regardless of whether the message is logged or not.
&nbsp;    *
&nbsp;    *  &lt;p&gt;If you are worried about speed, then you should write
&nbsp;    *  &lt;pre&gt;
&nbsp;    * 	 if(cat.isDebugEnabled()) {
&nbsp;    * 	   cat.debug(&quot;This is entry number: &quot; + i );
&nbsp;    * 	 }
&nbsp;    *  &lt;/pre&gt;
&nbsp;    *
&nbsp;    *  &lt;p&gt;This way you will not incur the cost of parameter
&nbsp;    *  construction if debugging is disabled for &lt;code&gt;cat&lt;/code&gt;. On
&nbsp;    *  the other hand, if the &lt;code&gt;cat&lt;/code&gt; is debug enabled, you
&nbsp;    *  will incur the cost of evaluating whether the category is debug
&nbsp;    *  enabled twice. Once in &lt;code&gt;isDebugEnabled&lt;/code&gt; and once in
&nbsp;    *  the &lt;code&gt;debug&lt;/code&gt;.  This is an insignificant overhead
&nbsp;    *  since evaluating a category takes about 1%% of the time it
&nbsp;    *  takes to actually log.
&nbsp;    *
&nbsp;    *  @return boolean - &lt;code&gt;true&lt;/code&gt; if this category is debug
&nbsp;    *  enabled, &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;    *   */
&nbsp;  public
&nbsp;  boolean isDebugEnabled() {
<b class="nc">&nbsp;    if(repository.isDisabled( Level.DEBUG_INT))</b>
<b class="nc">&nbsp;      return false;</b>
<b class="nc">&nbsp;    return Level.DEBUG.isGreaterOrEqual(this.getEffectiveLevel());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Check whether this category is enabled for a given {@link
&nbsp;     Level} passed as parameter.
&nbsp;
&nbsp;     See also {@link #isDebugEnabled}.
&nbsp;
&nbsp;     @return boolean True if this category is enabled for &lt;code&gt;level&lt;/code&gt;.
&nbsp;  */
&nbsp;  public
&nbsp;  boolean isEnabledFor(Priority level) {
<b class="pc">&nbsp;    if(repository.isDisabled(level.level))</b>
<b class="nc">&nbsp;      return false;</b>
<b class="fc">&nbsp;    return level.isGreaterOrEqual(this.getEffectiveLevel());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;    Check whether this category is enabled for the info Level.
&nbsp;    See also {@link #isDebugEnabled}.
&nbsp;
&nbsp;    @return boolean - &lt;code&gt;true&lt;/code&gt; if this category is enabled
&nbsp;    for level info, &lt;code&gt;false&lt;/code&gt; otherwise.
&nbsp;  */
&nbsp;  public
&nbsp;  boolean isInfoEnabled() {
<b class="nc">&nbsp;    if(repository.isDisabled(Level.INFO_INT))</b>
<b class="nc">&nbsp;      return false;</b>
<b class="nc">&nbsp;    return Level.INFO.isGreaterOrEqual(this.getEffectiveLevel());</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Log a localized message. The user supplied parameter
&nbsp;     &lt;code&gt;key&lt;/code&gt; is replaced by its localized version from the
&nbsp;     resource bundle.
&nbsp;
&nbsp;     @see #setResourceBundle
&nbsp;
&nbsp;     @since 0.8.4 */
&nbsp;  public
&nbsp;  void l7dlog(Priority priority, String key, Throwable t) {
<b class="nc">&nbsp;    if(repository.isDisabled(priority.level)) {</b>
&nbsp;      return;
&nbsp;    }
<b class="nc">&nbsp;    if(priority.isGreaterOrEqual(this.getEffectiveLevel())) {</b>
<b class="nc">&nbsp;      String msg = getResourceBundleString(key);</b>
&nbsp;      // if message corresponding to &#39;key&#39; could not be found in the
&nbsp;      // resource bundle, then default to &#39;key&#39;.
<b class="nc">&nbsp;      if(msg == null) {</b>
<b class="nc">&nbsp;	msg = key;</b>
&nbsp;      }
<b class="nc">&nbsp;      forcedLog(FQCN, priority, msg, t);</b>
&nbsp;    }
&nbsp;  }
&nbsp;  /**
&nbsp;     Log a localized and parameterized message. First, the user
&nbsp;     supplied &lt;code&gt;key&lt;/code&gt; is searched in the resource
&nbsp;     bundle. Next, the resulting pattern is formatted using
&nbsp;     {@link java.text.MessageFormat#format(String,Object[])} method with the
&nbsp;     user supplied object array &lt;code&gt;params&lt;/code&gt;.
&nbsp;
&nbsp;     @since 0.8.4
&nbsp;  */
&nbsp;  public
&nbsp;  void l7dlog(Priority priority, String key,  Object[] params, Throwable t) {
<b class="nc">&nbsp;    if(repository.isDisabled(priority.level)) {</b>
&nbsp;      return;
&nbsp;    }
<b class="nc">&nbsp;    if(priority.isGreaterOrEqual(this.getEffectiveLevel())) {</b>
<b class="nc">&nbsp;      String pattern = getResourceBundleString(key);</b>
&nbsp;      String msg;
<b class="nc">&nbsp;      if(pattern == null)</b>
<b class="nc">&nbsp;	msg = key;</b>
&nbsp;      else
<b class="nc">&nbsp;	msg = java.text.MessageFormat.format(pattern, params);</b>
<b class="nc">&nbsp;      forcedLog(FQCN, priority, msg, t);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     This generic form is intended to be used by wrappers.
&nbsp;   */
&nbsp;  public
&nbsp;  void log(Priority priority, Object message, Throwable t) {
<b class="nc">&nbsp;    if(repository.isDisabled(priority.level)) {</b>
&nbsp;      return;
&nbsp;    }
<b class="nc">&nbsp;    if(priority.isGreaterOrEqual(this.getEffectiveLevel()))</b>
<b class="nc">&nbsp;      forcedLog(FQCN, priority, message, t);</b>
&nbsp;  }
&nbsp;
&nbsp; /**
&nbsp;    This generic form is intended to be used by wrappers.
&nbsp; */
&nbsp;  public
&nbsp;  void log(Priority priority, Object message) {
<b class="nc">&nbsp;    if(repository.isDisabled(priority.level)) {</b>
&nbsp;      return;
&nbsp;    }
<b class="nc">&nbsp;    if(priority.isGreaterOrEqual(this.getEffectiveLevel()))</b>
<b class="nc">&nbsp;      forcedLog(FQCN, priority, message, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;
&nbsp;     This is the most generic printing method. It is intended to be
&nbsp;     invoked by &lt;b&gt;wrapper&lt;/b&gt; classes.
&nbsp;
&nbsp;     @param callerFQCN The wrapper class&#39; fully qualified class name.
&nbsp;     @param level The level of the logging request.
&nbsp;     @param message The message of the logging request.
&nbsp;     @param t The throwable of the logging request, may be null.  */
&nbsp;  public
&nbsp;  void log(String callerFQCN, Priority level, Object message, Throwable t) {
<b class="nc">&nbsp;    if(repository.isDisabled(level.level)) {</b>
&nbsp;      return;
&nbsp;    }
<b class="nc">&nbsp;    if(level.isGreaterOrEqual(this.getEffectiveLevel())) {</b>
<b class="nc">&nbsp;      forcedLog(callerFQCN, level, message, t);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;    /**
&nbsp;      *  LoggerRepository forgot the fireRemoveAppenderEvent method,
&nbsp;      *     if using the stock Hierarchy implementation, then call its fireRemove.
&nbsp;      *     Custom repositories can implement HierarchyEventListener if they
&nbsp;      *     want remove notifications.
&nbsp;     * @param appender appender, may be null.
&nbsp;     */
&nbsp;   private void fireRemoveAppenderEvent(final Appender appender) {
<b class="nc">&nbsp;       if (appender != null) {</b>
<b class="nc">&nbsp;         if (repository instanceof Hierarchy) {</b>
<b class="nc">&nbsp;           ((Hierarchy) repository).fireRemoveAppenderEvent(this, appender);</b>
<b class="nc">&nbsp;         } else if (repository instanceof HierarchyEventListener) {</b>
<b class="nc">&nbsp;             ((HierarchyEventListener) repository).removeAppenderEvent(this, appender);</b>
&nbsp;         }
&nbsp;       }
&nbsp;   }
&nbsp;
&nbsp;  /**
&nbsp;     Remove all previously added appenders from this Category
&nbsp;     instance.
&nbsp;
&nbsp;     &lt;p&gt;This is useful when re-reading configuration information.
&nbsp;  */
&nbsp;  synchronized
&nbsp;  public
&nbsp;  void removeAllAppenders() {
<b class="pc">&nbsp;    if(aai != null) {</b>
<b class="nc">&nbsp;      Vector appenders = new Vector();</b>
<b class="nc">&nbsp;      for (Enumeration iter = aai.getAllAppenders(); iter != null &amp;&amp; iter.hasMoreElements();) {</b>
<b class="nc">&nbsp;          appenders.add(iter.nextElement());</b>
&nbsp;      }
<b class="nc">&nbsp;      aai.removeAllAppenders();</b>
<b class="nc">&nbsp;      for(Enumeration iter = appenders.elements(); iter.hasMoreElements();) {</b>
<b class="nc">&nbsp;          fireRemoveAppenderEvent((Appender) iter.nextElement());</b>
&nbsp;      }
<b class="nc">&nbsp;      aai = null;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Remove the appender passed as parameter form the list of appenders.
&nbsp;
&nbsp;     @since 0.8.2
&nbsp;  */
&nbsp;  synchronized
&nbsp;  public
&nbsp;  void removeAppender(Appender appender) {
<b class="nc">&nbsp;    if(appender == null || aai == null)</b>
&nbsp;      return;
<b class="nc">&nbsp;    boolean wasAttached = aai.isAttached(appender);</b>
<b class="nc">&nbsp;    aai.removeAppender(appender);</b>
<b class="nc">&nbsp;    if (wasAttached) {</b>
<b class="nc">&nbsp;        fireRemoveAppenderEvent(appender);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Remove the appender with the name passed as parameter form the
&nbsp;     list of appenders.
&nbsp;
&nbsp;     @since 0.8.2 */
&nbsp;  synchronized
&nbsp;  public
&nbsp;  void removeAppender(String name) {
<b class="nc">&nbsp;    if(name == null || aai == null) return;</b>
<b class="nc">&nbsp;    Appender appender = aai.getAppender(name);</b>
<b class="nc">&nbsp;    aai.removeAppender(name);</b>
<b class="nc">&nbsp;    if (appender != null) {</b>
<b class="nc">&nbsp;        fireRemoveAppenderEvent(appender);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Set the additivity flag for this Category instance.
&nbsp;     @since 0.8.1
&nbsp;   */
&nbsp;  public
&nbsp;  void setAdditivity(boolean additive) {
<b class="nc">&nbsp;    this.additive = additive;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Only the Hiearchy class can set the hiearchy of a
&nbsp;     category. Default package access is MANDATORY here.  */
&nbsp;  final
&nbsp;  void setHierarchy(LoggerRepository repository) {
<b class="fc">&nbsp;    this.repository = repository;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Set the level of this Category. If you are passing any of
&nbsp;     &lt;code&gt;Level.DEBUG&lt;/code&gt;, &lt;code&gt;Level.INFO&lt;/code&gt;,
&nbsp;     &lt;code&gt;Level.WARN&lt;/code&gt;, &lt;code&gt;Level.ERROR&lt;/code&gt;,
&nbsp;     &lt;code&gt;Level.FATAL&lt;/code&gt; as a parameter, you need to case them as
&nbsp;     Level.
&nbsp;
&nbsp;     &lt;p&gt;As in &lt;pre&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;logger.setLevel((Level) Level.DEBUG); &lt;/pre&gt;
&nbsp;
&nbsp;
&nbsp;     &lt;p&gt;Null values are admitted.  */
&nbsp;  public
&nbsp;  void setLevel(Level level) {
<b class="fc">&nbsp;    this.level = level;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Set the level of this Category.
&nbsp;
&nbsp;     &lt;p&gt;Null values are admitted.
&nbsp;
&nbsp;     @deprecated Please use {@link #setLevel} instead.
&nbsp;  */
&nbsp;  public
&nbsp;  void setPriority(Priority priority) {
<b class="nc">&nbsp;    this.level = (Level) priority;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Set the resource bundle to be used with localized logging
&nbsp;     methods {@link #l7dlog(Priority,String,Throwable)} and {@link
&nbsp;     #l7dlog(Priority,String,Object[],Throwable)}.
&nbsp;
&nbsp;     @since 0.8.4
&nbsp;   */
&nbsp;  public
&nbsp;  void setResourceBundle(ResourceBundle bundle) {
<b class="nc">&nbsp;    resourceBundle = bundle;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Calling this method will &lt;em&gt;safely&lt;/em&gt; close and remove all
&nbsp;     appenders in all the categories including root contained in the
&nbsp;     default hierachy.
&nbsp;
&nbsp;     &lt;p&gt;Some appenders such as {@link org.apache.log4j.net.SocketAppender}
&nbsp;     and {@link AsyncAppender} need to be closed before the
&nbsp;     application exists. Otherwise, pending logging events might be
&nbsp;     lost.
&nbsp;
&nbsp;     &lt;p&gt;The &lt;code&gt;shutdown&lt;/code&gt; method is careful to close nested
&nbsp;     appenders before closing regular appenders. This is allows
&nbsp;     configurations where a regular appender is attached to a category
&nbsp;     and again to a nested appender.
&nbsp;
&nbsp;     @deprecated Please use {@link LogManager#shutdown()} instead.
&nbsp;
&nbsp;     @since 1.0
&nbsp;  */
&nbsp;  public
&nbsp;  static
&nbsp;  void shutdown() {
<b class="nc">&nbsp;    LogManager.shutdown();</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;    Log a message object with the {@link Level#WARN WARN} Level.
&nbsp;
&nbsp;    &lt;p&gt;This method first checks if this category is &lt;code&gt;WARN&lt;/code&gt;
&nbsp;    enabled by comparing the level of this category with {@link
&nbsp;    Level#WARN WARN} Level. If the category is &lt;code&gt;WARN&lt;/code&gt;
&nbsp;    enabled, then it converts the message object passed as parameter
&nbsp;    to a string by invoking the appropriate
&nbsp;    {@link org.apache.log4j.or.ObjectRenderer}. It
&nbsp;    proceeds to call all the registered appenders in this category and
&nbsp;    also higher in the hieararchy depending on the value of the
&nbsp;    additivity flag.
&nbsp;
&nbsp;    &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt; Note that passing a {@link Throwable} to this
&nbsp;    method will print the name of the Throwable but no stack trace. To
&nbsp;    print a stack trace use the {@link #warn(Object, Throwable)} form
&nbsp;    instead.  &lt;p&gt;
&nbsp;
&nbsp;    @param message the message object to log.  */
&nbsp;  public
&nbsp;  void warn(Object message) {
<b class="nc">&nbsp;    if(repository.isDisabled( Level.WARN_INT))</b>
&nbsp;      return;
&nbsp;
<b class="nc">&nbsp;    if(Level.WARN.isGreaterOrEqual(this.getEffectiveLevel()))</b>
<b class="nc">&nbsp;      forcedLog(FQCN, Level.WARN, message, null);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   Log a message with the &lt;code&gt;WARN&lt;/code&gt; level including the
&nbsp;   stack trace of the {@link Throwable} &lt;code&gt;t&lt;/code&gt; passed as
&nbsp;   parameter.
&nbsp;
&nbsp;   &lt;p&gt;See {@link #warn(Object)} for more detailed information.
&nbsp;
&nbsp;   @param message the message object to log.
&nbsp;   @param t the exception to log, including its stack trace.  */
&nbsp;  public
&nbsp;  void warn(Object message, Throwable t) {
<b class="nc">&nbsp;    if(repository.isDisabled(Level.WARN_INT))</b>
&nbsp;      return;
<b class="nc">&nbsp;    if(Level.WARN.isGreaterOrEqual(this.getEffectiveLevel()))</b>
<b class="nc">&nbsp;      forcedLog(FQCN, Level.WARN, message, t);</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
