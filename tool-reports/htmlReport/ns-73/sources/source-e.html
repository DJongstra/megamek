


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > PatternParser</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.apache.log4j.helpers</a>
</div>

<h1>Coverage Summary for Class: PatternParser (org.apache.log4j.helpers)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PatternParser</td>
<td class="coverageStat">
  <span class="percent">
    87,5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25,4%
  </span>
  <span class="absValue">
    (29/114)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    52,3%
  </span>
  <span class="absValue">
    (79/151)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PatternParser$BasicPatternConverter</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22,2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PatternParser$CategoryPatternConverter</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PatternParser$ClassNamePatternConverter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PatternParser$DatePatternConverter</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    30%
  </span>
  <span class="absValue">
    (3/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PatternParser$LiteralPatternConverter</td>
<td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PatternParser$LocationPatternConverter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PatternParser$MDCPatternConverter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PatternParser$NamedPatternConverter</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16,7%
  </span>
  <span class="absValue">
    (2/12)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    48%
  </span>
  <span class="absValue">
    (12/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21%
  </span>
  <span class="absValue">
    (29/138)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40,5%
  </span>
  <span class="absValue">
    (90/222)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
&nbsp; * contributor license agreements.  See the NOTICE file distributed with
&nbsp; * this work for additional information regarding copyright ownership.
&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
&nbsp; * the License.  You may obtain a copy of the License at
&nbsp; * 
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; * 
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.apache.log4j.helpers;
&nbsp;
&nbsp;import org.apache.log4j.Layout;
&nbsp;import org.apache.log4j.spi.LoggingEvent;
&nbsp;import org.apache.log4j.spi.LocationInfo;
&nbsp;import java.text.DateFormat;
&nbsp;import java.text.SimpleDateFormat;
&nbsp;import java.util.Date;
&nbsp;import java.util.Map;
&nbsp;import java.util.Arrays;
&nbsp;
&nbsp;// Contributors:   Nelson Minar &lt;(nelson@monkey.org&gt;
&nbsp;//                 Igor E. Poteryaev &lt;jah@mail.ru&gt;
&nbsp;//                 Reinhard Deschler &lt;reinhard.deschler@web.de&gt;
&nbsp;
&nbsp;/**
&nbsp;   Most of the work of the {@link org.apache.log4j.PatternLayout} class
&nbsp;   is delegated to the PatternParser class.
&nbsp;
&nbsp;   &lt;p&gt;It is this class that parses conversion patterns and creates
&nbsp;   a chained list of {@link OptionConverter OptionConverters}.
&nbsp;
&nbsp;   @author &lt;a href=mailto:&quot;cakalijp@Maritz.com&quot;&gt;James P. Cakalic&lt;/a&gt;
&nbsp;   @author Ceki G&amp;uuml;lc&amp;uuml;
&nbsp;   @author Anders Kristensen
&nbsp;
&nbsp;   @since 0.8.2
&nbsp;*/
&nbsp;public class PatternParser {
&nbsp;
&nbsp;  private static final char ESCAPE_CHAR = &#39;%&#39;;
&nbsp;
&nbsp;  private static final int LITERAL_STATE = 0;
&nbsp;  private static final int CONVERTER_STATE = 1;
&nbsp;  private static final int DOT_STATE = 3;
&nbsp;  private static final int MIN_STATE = 4;
&nbsp;  private static final int MAX_STATE = 5;
&nbsp;
&nbsp;  static final int FULL_LOCATION_CONVERTER = 1000;
&nbsp;  static final int METHOD_LOCATION_CONVERTER = 1001;
&nbsp;  static final int CLASS_LOCATION_CONVERTER = 1002;
&nbsp;  static final int LINE_LOCATION_CONVERTER = 1003;
&nbsp;  static final int FILE_LOCATION_CONVERTER = 1004;
&nbsp;
&nbsp;  static final int RELATIVE_TIME_CONVERTER = 2000;
&nbsp;  static final int THREAD_CONVERTER = 2001;
&nbsp;  static final int LEVEL_CONVERTER = 2002;
&nbsp;  static final int NDC_CONVERTER = 2003;
&nbsp;  static final int MESSAGE_CONVERTER = 2004;
&nbsp;
&nbsp;  int state;
<b class="fc">&nbsp;  protected StringBuffer currentLiteral = new StringBuffer(32);</b>
&nbsp;  protected int patternLength;
&nbsp;  protected int i;
&nbsp;  PatternConverter head;
&nbsp;  PatternConverter tail;
<b class="fc">&nbsp;  protected FormattingInfo formattingInfo = new FormattingInfo();</b>
&nbsp;  protected String pattern;
&nbsp;
&nbsp;  public
<b class="fc">&nbsp;  PatternParser(String pattern) {</b>
<b class="fc">&nbsp;    this.pattern = pattern;</b>
<b class="fc">&nbsp;    patternLength =  pattern.length();</b>
<b class="fc">&nbsp;    state = LITERAL_STATE;</b>
&nbsp;  }
&nbsp;
&nbsp;  private
&nbsp;  void  addToList(PatternConverter pc) {
<b class="fc">&nbsp;    if(head == null) {</b>
<b class="fc">&nbsp;      head = tail = pc;</b>
&nbsp;    } else {
<b class="fc">&nbsp;      tail.next = pc;</b>
<b class="fc">&nbsp;      tail = pc;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  protected
&nbsp;  String extractOption() {
<b class="pc">&nbsp;    if((i &lt; patternLength) &amp;&amp; (pattern.charAt(i) == &#39;{&#39;)) {</b>
<b class="fc">&nbsp;      int end = pattern.indexOf(&#39;}&#39;, i);</b>
<b class="pc">&nbsp;      if (end &gt; i) {</b>
<b class="fc">&nbsp;	String r = pattern.substring(i + 1, end);</b>
<b class="fc">&nbsp;	i = end+1;</b>
<b class="fc">&nbsp;	return r;</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     The option is expected to be in decimal and positive. In case of
&nbsp;     error, zero is returned.  */
&nbsp;  protected
&nbsp;  int extractPrecisionOption() {
<b class="fc">&nbsp;    String opt = extractOption();</b>
<b class="fc">&nbsp;    int r = 0;</b>
<b class="pc">&nbsp;    if(opt != null) {</b>
&nbsp;      try {
<b class="nc">&nbsp;	r = Integer.parseInt(opt);</b>
<b class="nc">&nbsp;	if(r &lt;= 0) {</b>
<b class="nc">&nbsp;	    LogLog.error(</b>
&nbsp;	        &quot;Precision option (&quot; + opt + &quot;) isn&#39;t a positive integer.&quot;);
<b class="nc">&nbsp;	    r = 0;</b>
&nbsp;	}
&nbsp;      }
<b class="nc">&nbsp;      catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;	LogLog.error(&quot;Category option \&quot;&quot;+opt+&quot;\&quot; not a decimal integer.&quot;, e);</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
<b class="fc">&nbsp;    return r;</b>
&nbsp;  }
&nbsp;
&nbsp;  public
&nbsp;  PatternConverter parse() {
&nbsp;    char c;
<b class="fc">&nbsp;    i = 0;</b>
<b class="fc">&nbsp;    while(i &lt; patternLength) {</b>
<b class="fc">&nbsp;      c = pattern.charAt(i++);</b>
<b class="pc">&nbsp;      switch(state) {</b>
&nbsp;      case LITERAL_STATE:
&nbsp;        // In literal state, the last char is always a literal.
<b class="pc">&nbsp;        if(i == patternLength) {</b>
<b class="nc">&nbsp;          currentLiteral.append(c);</b>
<b class="nc">&nbsp;          continue;</b>
&nbsp;        }
<b class="fc">&nbsp;        if(c == ESCAPE_CHAR) {</b>
&nbsp;          // peek at the next char.
<b class="pc">&nbsp;          switch(pattern.charAt(i)) {</b>
&nbsp;          case ESCAPE_CHAR:
<b class="nc">&nbsp;            currentLiteral.append(c);</b>
<b class="nc">&nbsp;            i++; // move pointer</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &#39;n&#39;:
<b class="fc">&nbsp;            currentLiteral.append(Layout.LINE_SEP);</b>
<b class="fc">&nbsp;            i++; // move pointer</b>
<b class="fc">&nbsp;            break;</b>
&nbsp;          default:
<b class="fc">&nbsp;            if(currentLiteral.length() != 0) {</b>
<b class="fc">&nbsp;              addToList(new LiteralPatternConverter(</b>
&nbsp;                                                  currentLiteral.toString()));
&nbsp;              //LogLog.debug(&quot;Parsed LITERAL converter: \&quot;&quot;
&nbsp;              //           +currentLiteral+&quot;\&quot;.&quot;);
&nbsp;            }
<b class="fc">&nbsp;            currentLiteral.setLength(0);</b>
<b class="fc">&nbsp;            currentLiteral.append(c); // append %</b>
<b class="fc">&nbsp;            state = CONVERTER_STATE;</b>
<b class="fc">&nbsp;            formattingInfo.reset();</b>
&nbsp;          }
&nbsp;        }
&nbsp;        else {
<b class="fc">&nbsp;          currentLiteral.append(c);</b>
&nbsp;        }
<b class="fc">&nbsp;        break;</b>
&nbsp;      case CONVERTER_STATE:
<b class="fc">&nbsp;	currentLiteral.append(c);</b>
<b class="pc">&nbsp;	switch(c) {</b>
&nbsp;	case &#39;-&#39;:
<b class="nc">&nbsp;	  formattingInfo.leftAlign = true;</b>
<b class="nc">&nbsp;	  break;</b>
&nbsp;	case &#39;.&#39;:
<b class="nc">&nbsp;	  state = DOT_STATE;</b>
<b class="nc">&nbsp;	  break;</b>
&nbsp;	default:
<b class="pc">&nbsp;	  if(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {</b>
<b class="nc">&nbsp;	    formattingInfo.min = c - &#39;0&#39;;</b>
<b class="nc">&nbsp;	    state = MIN_STATE;</b>
&nbsp;	  }
&nbsp;	  else
<b class="fc">&nbsp;	    finalizeConverter(c);</b>
&nbsp;	} // switch
<b class="fc">&nbsp;	break;</b>
&nbsp;      case MIN_STATE:
<b class="nc">&nbsp;	currentLiteral.append(c);</b>
<b class="nc">&nbsp;	if(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)</b>
<b class="nc">&nbsp;	  formattingInfo.min = formattingInfo.min*10 + (c - &#39;0&#39;);</b>
<b class="nc">&nbsp;	else if(c == &#39;.&#39;)</b>
<b class="nc">&nbsp;	  state = DOT_STATE;</b>
&nbsp;	else {
<b class="nc">&nbsp;	  finalizeConverter(c);</b>
&nbsp;	}
<b class="nc">&nbsp;	break;</b>
&nbsp;      case DOT_STATE:
<b class="nc">&nbsp;	currentLiteral.append(c);</b>
<b class="nc">&nbsp;	if(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {</b>
<b class="nc">&nbsp;	  formattingInfo.max = c - &#39;0&#39;;</b>
<b class="nc">&nbsp;	   state = MAX_STATE;</b>
&nbsp;	}
&nbsp;	else {
<b class="nc">&nbsp;	  LogLog.error(&quot;Error occured in position &quot;+i</b>
&nbsp;		     +&quot;.\n Was expecting digit, instead got char \&quot;&quot;+c+&quot;\&quot;.&quot;);
<b class="nc">&nbsp;	  state = LITERAL_STATE;</b>
&nbsp;	}
<b class="nc">&nbsp;	break;</b>
&nbsp;      case MAX_STATE:
<b class="nc">&nbsp;	currentLiteral.append(c);</b>
<b class="nc">&nbsp;	if(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)</b>
<b class="nc">&nbsp;	  formattingInfo.max = formattingInfo.max*10 + (c - &#39;0&#39;);</b>
&nbsp;	else {
<b class="nc">&nbsp;	  finalizeConverter(c);</b>
<b class="nc">&nbsp;	  state = LITERAL_STATE;</b>
&nbsp;	}
<b class="fc">&nbsp;	break;</b>
&nbsp;      } // switch
&nbsp;    } // while
<b class="pc">&nbsp;    if(currentLiteral.length() != 0) {</b>
<b class="fc">&nbsp;      addToList(new LiteralPatternConverter(currentLiteral.toString()));</b>
&nbsp;      //LogLog.debug(&quot;Parsed LITERAL converter: \&quot;&quot;+currentLiteral+&quot;\&quot;.&quot;);
&nbsp;    }
<b class="fc">&nbsp;    return head;</b>
&nbsp;  }
&nbsp;
&nbsp;  protected
&nbsp;  void finalizeConverter(char c) {
<b class="fc">&nbsp;    PatternConverter pc = null;</b>
<b class="pc">&nbsp;    switch(c) {</b>
&nbsp;    case &#39;c&#39;:
<b class="fc">&nbsp;      pc = new CategoryPatternConverter(formattingInfo,</b>
&nbsp;					extractPrecisionOption());
&nbsp;      //LogLog.debug(&quot;CATEGORY converter.&quot;);
&nbsp;      //formattingInfo.dump();
<b class="fc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="fc">&nbsp;      break;</b>
&nbsp;    case &#39;C&#39;:
<b class="nc">&nbsp;      pc = new ClassNamePatternConverter(formattingInfo,</b>
&nbsp;					 extractPrecisionOption());
&nbsp;      //LogLog.debug(&quot;CLASS_NAME converter.&quot;);
&nbsp;      //formattingInfo.dump();
<b class="nc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="nc">&nbsp;      break;</b>
&nbsp;    case &#39;d&#39;:
<b class="fc">&nbsp;      String dateFormatStr = AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT;</b>
&nbsp;      DateFormat df;
<b class="fc">&nbsp;      String dOpt = extractOption();</b>
<b class="pc">&nbsp;      if(dOpt != null)</b>
<b class="fc">&nbsp;	dateFormatStr = dOpt;</b>
&nbsp;
<b class="pc">&nbsp;      if(dateFormatStr.equalsIgnoreCase(</b>
&nbsp;                                    AbsoluteTimeDateFormat.ISO8601_DATE_FORMAT))
<b class="nc">&nbsp;	df = new  ISO8601DateFormat();</b>
<b class="pc">&nbsp;      else if(dateFormatStr.equalsIgnoreCase(</b>
&nbsp;                                   AbsoluteTimeDateFormat.ABS_TIME_DATE_FORMAT))
<b class="nc">&nbsp;	df = new AbsoluteTimeDateFormat();</b>
<b class="pc">&nbsp;      else if(dateFormatStr.equalsIgnoreCase(</b>
&nbsp;                              AbsoluteTimeDateFormat.DATE_AND_TIME_DATE_FORMAT))
<b class="nc">&nbsp;	df = new DateTimeDateFormat();</b>
&nbsp;      else {
&nbsp;	try {
<b class="fc">&nbsp;	  df = new SimpleDateFormat(dateFormatStr);</b>
&nbsp;	}
<b class="nc">&nbsp;	catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;	  LogLog.error(&quot;Could not instantiate SimpleDateFormat with &quot; +</b>
&nbsp;		       dateFormatStr, e);
<b class="nc">&nbsp;	  df = (DateFormat) OptionConverter.instantiateByClassName(</b>
&nbsp;			           &quot;org.apache.log4j.helpers.ISO8601DateFormat&quot;,
<b class="nc">&nbsp;				   DateFormat.class, null);</b>
<b class="fc">&nbsp;	}</b>
&nbsp;      }
<b class="fc">&nbsp;      pc = new DatePatternConverter(formattingInfo, df);</b>
&nbsp;      //LogLog.debug(&quot;DATE converter {&quot;+dateFormatStr+&quot;}.&quot;);
&nbsp;      //formattingInfo.dump();
<b class="fc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="fc">&nbsp;      break;</b>
&nbsp;    case &#39;F&#39;:
<b class="nc">&nbsp;      pc = new LocationPatternConverter(formattingInfo,</b>
&nbsp;					FILE_LOCATION_CONVERTER);
&nbsp;      //LogLog.debug(&quot;File name converter.&quot;);
&nbsp;      //formattingInfo.dump();
<b class="nc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="nc">&nbsp;      break;</b>
&nbsp;    case &#39;l&#39;:
<b class="nc">&nbsp;      pc = new LocationPatternConverter(formattingInfo,</b>
&nbsp;					FULL_LOCATION_CONVERTER);
&nbsp;      //LogLog.debug(&quot;Location converter.&quot;);
&nbsp;      //formattingInfo.dump();
<b class="nc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="nc">&nbsp;      break;</b>
&nbsp;    case &#39;L&#39;:
<b class="nc">&nbsp;      pc = new LocationPatternConverter(formattingInfo,</b>
&nbsp;					LINE_LOCATION_CONVERTER);
&nbsp;      //LogLog.debug(&quot;LINE NUMBER converter.&quot;);
&nbsp;      //formattingInfo.dump();
<b class="nc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="nc">&nbsp;      break;</b>
&nbsp;    case &#39;m&#39;:
<b class="fc">&nbsp;      pc = new BasicPatternConverter(formattingInfo, MESSAGE_CONVERTER);</b>
&nbsp;      //LogLog.debug(&quot;MESSAGE converter.&quot;);
&nbsp;      //formattingInfo.dump();
<b class="fc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="fc">&nbsp;      break;</b>
&nbsp;    case &#39;M&#39;:
<b class="nc">&nbsp;      pc = new LocationPatternConverter(formattingInfo,</b>
&nbsp;					METHOD_LOCATION_CONVERTER);
&nbsp;      //LogLog.debug(&quot;METHOD converter.&quot;);
&nbsp;      //formattingInfo.dump();
<b class="nc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="nc">&nbsp;      break;</b>
&nbsp;    case &#39;p&#39;:
<b class="fc">&nbsp;      pc = new BasicPatternConverter(formattingInfo, LEVEL_CONVERTER);</b>
&nbsp;      //LogLog.debug(&quot;LEVEL converter.&quot;);
&nbsp;      //formattingInfo.dump();
<b class="fc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="fc">&nbsp;      break;</b>
&nbsp;    case &#39;r&#39;:
<b class="nc">&nbsp;      pc = new BasicPatternConverter(formattingInfo,</b>
&nbsp;					 RELATIVE_TIME_CONVERTER);
&nbsp;      //LogLog.debug(&quot;RELATIVE time converter.&quot;);
&nbsp;      //formattingInfo.dump();
<b class="nc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="nc">&nbsp;      break;</b>
&nbsp;    case &#39;t&#39;:
<b class="fc">&nbsp;      pc = new BasicPatternConverter(formattingInfo, THREAD_CONVERTER);</b>
&nbsp;      //LogLog.debug(&quot;THREAD converter.&quot;);
&nbsp;      //formattingInfo.dump();
<b class="fc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="fc">&nbsp;      break;</b>
&nbsp;      /*case &#39;u&#39;:
&nbsp;      if(i &lt; patternLength) {
&nbsp;	char cNext = pattern.charAt(i);
&nbsp;	if(cNext &gt;= &#39;0&#39; &amp;&amp; cNext &lt;= &#39;9&#39;) {
&nbsp;	  pc = new UserFieldPatternConverter(formattingInfo, cNext - &#39;0&#39;);
&nbsp;	  LogLog.debug(&quot;USER converter [&quot;+cNext+&quot;].&quot;);
&nbsp;	  formattingInfo.dump();
&nbsp;	  currentLiteral.setLength(0);
&nbsp;	  i++;
&nbsp;	}
&nbsp;	else
&nbsp;	  LogLog.error(&quot;Unexpected char&quot; +cNext+&quot; at position &quot;+i);
&nbsp;      }
&nbsp;      break;*/
&nbsp;    case &#39;x&#39;:
<b class="nc">&nbsp;      pc = new BasicPatternConverter(formattingInfo, NDC_CONVERTER);</b>
&nbsp;      //LogLog.debug(&quot;NDC converter.&quot;);
<b class="nc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="nc">&nbsp;      break;</b>
&nbsp;    case &#39;X&#39;:
<b class="nc">&nbsp;      String xOpt = extractOption();</b>
<b class="nc">&nbsp;      pc = new MDCPatternConverter(formattingInfo, xOpt);</b>
<b class="nc">&nbsp;      currentLiteral.setLength(0);</b>
<b class="nc">&nbsp;      break;</b>
&nbsp;    default:
<b class="nc">&nbsp;      LogLog.error(&quot;Unexpected char [&quot; +c+&quot;] at position &quot;+i</b>
&nbsp;		   +&quot; in conversion patterrn.&quot;);
<b class="nc">&nbsp;      pc = new LiteralPatternConverter(currentLiteral.toString());</b>
<b class="nc">&nbsp;      currentLiteral.setLength(0);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    addConverter(pc);</b>
&nbsp;  }
&nbsp;
&nbsp;  protected
&nbsp;  void addConverter(PatternConverter pc) {
<b class="fc">&nbsp;    currentLiteral.setLength(0);</b>
&nbsp;    // Add the pattern converter to the list.
<b class="fc">&nbsp;    addToList(pc);</b>
&nbsp;    // Next pattern is assumed to be a literal.
<b class="fc">&nbsp;    state = LITERAL_STATE;</b>
&nbsp;    // Reset formatting info
<b class="fc">&nbsp;    formattingInfo.reset();</b>
&nbsp;  }
&nbsp;
&nbsp;  // ---------------------------------------------------------------------
&nbsp;  //                      PatternConverters
&nbsp;  // ---------------------------------------------------------------------
&nbsp;
&nbsp;  private static class BasicPatternConverter extends PatternConverter {
&nbsp;    int type;
&nbsp;
&nbsp;    BasicPatternConverter(FormattingInfo formattingInfo, int type) {
<b class="fc">&nbsp;      super(formattingInfo);</b>
<b class="fc">&nbsp;      this.type = type;</b>
&nbsp;    }
&nbsp;
&nbsp;    public
&nbsp;    String convert(LoggingEvent event) {
<b class="nc">&nbsp;      switch(type) {</b>
&nbsp;      case RELATIVE_TIME_CONVERTER:
<b class="nc">&nbsp;	return (Long.toString(event.timeStamp - LoggingEvent.getStartTime()));</b>
&nbsp;      case THREAD_CONVERTER:
<b class="nc">&nbsp;	return event.getThreadName();</b>
&nbsp;      case LEVEL_CONVERTER:
<b class="nc">&nbsp;	return event.getLevel().toString();</b>
&nbsp;      case NDC_CONVERTER:
<b class="nc">&nbsp;	return event.getNDC();</b>
&nbsp;      case MESSAGE_CONVERTER: {
<b class="nc">&nbsp;	return event.getRenderedMessage();</b>
&nbsp;      }
<b class="nc">&nbsp;      default: return null;</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static class LiteralPatternConverter extends PatternConverter {
&nbsp;    private String literal;
&nbsp;
<b class="fc">&nbsp;    LiteralPatternConverter(String value) {</b>
<b class="fc">&nbsp;      literal = value;</b>
&nbsp;    }
&nbsp;
&nbsp;    public
&nbsp;    final
&nbsp;    void format(StringBuffer sbuf, LoggingEvent event) {
<b class="nc">&nbsp;      sbuf.append(literal);</b>
&nbsp;    }
&nbsp;
&nbsp;    public
&nbsp;    String convert(LoggingEvent event) {
<b class="nc">&nbsp;      return literal;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static class DatePatternConverter extends PatternConverter {
&nbsp;    private DateFormat df;
&nbsp;    private Date date;
&nbsp;
&nbsp;    DatePatternConverter(FormattingInfo formattingInfo, DateFormat df) {
<b class="fc">&nbsp;      super(formattingInfo);</b>
<b class="fc">&nbsp;      date = new Date();</b>
<b class="fc">&nbsp;      this.df = df;</b>
&nbsp;    }
&nbsp;
&nbsp;    public
&nbsp;    String convert(LoggingEvent event) {
<b class="nc">&nbsp;      date.setTime(event.timeStamp);</b>
<b class="nc">&nbsp;      String converted = null;</b>
&nbsp;      try {
<b class="nc">&nbsp;        converted = df.format(date);</b>
&nbsp;      }
<b class="nc">&nbsp;      catch (Exception ex) {</b>
<b class="nc">&nbsp;        LogLog.error(&quot;Error occured while converting date.&quot;, ex);</b>
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      return converted;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static class MDCPatternConverter extends PatternConverter {
&nbsp;    private String key;
&nbsp;
&nbsp;    MDCPatternConverter(FormattingInfo formattingInfo, String key) {
<b class="nc">&nbsp;      super(formattingInfo);</b>
<b class="nc">&nbsp;      this.key = key;</b>
&nbsp;    }
&nbsp;
&nbsp;    public
&nbsp;    String convert(LoggingEvent event) {
<b class="nc">&nbsp;      if (key == null) {</b>
<b class="nc">&nbsp;          StringBuffer buf = new StringBuffer(&quot;{&quot;);</b>
<b class="nc">&nbsp;          Map properties = event.getProperties();</b>
<b class="nc">&nbsp;          if (properties.size() &gt; 0) {</b>
<b class="nc">&nbsp;            Object[] keys = properties.keySet().toArray();</b>
<b class="nc">&nbsp;            Arrays.sort(keys);</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; keys.length; i++) {</b>
<b class="nc">&nbsp;                buf.append(&#39;{&#39;);</b>
<b class="nc">&nbsp;                buf.append(keys[i]);</b>
<b class="nc">&nbsp;                buf.append(&#39;,&#39;);</b>
<b class="nc">&nbsp;                buf.append(properties.get(keys[i]));</b>
<b class="nc">&nbsp;                buf.append(&#39;}&#39;);</b>
&nbsp;            }
&nbsp;          }
<b class="nc">&nbsp;          buf.append(&#39;}&#39;);</b>
<b class="nc">&nbsp;          return buf.toString();</b>
&nbsp;      } else {
<b class="nc">&nbsp;        Object val = event.getMDC(key);</b>
<b class="nc">&nbsp;        if(val == null) {</b>
<b class="nc">&nbsp;	        return null;</b>
&nbsp;        } else {
<b class="nc">&nbsp;	        return val.toString();</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  private class LocationPatternConverter extends PatternConverter {
&nbsp;    int type;
&nbsp;
<b class="nc">&nbsp;    LocationPatternConverter(FormattingInfo formattingInfo, int type) {</b>
<b class="nc">&nbsp;      super(formattingInfo);</b>
<b class="nc">&nbsp;      this.type = type;</b>
&nbsp;    }
&nbsp;
&nbsp;    public
&nbsp;    String convert(LoggingEvent event) {
<b class="nc">&nbsp;      LocationInfo locationInfo = event.getLocationInformation();</b>
<b class="nc">&nbsp;      switch(type) {</b>
&nbsp;      case FULL_LOCATION_CONVERTER:
<b class="nc">&nbsp;	return locationInfo.fullInfo;</b>
&nbsp;      case METHOD_LOCATION_CONVERTER:
<b class="nc">&nbsp;	return locationInfo.getMethodName();</b>
&nbsp;      case LINE_LOCATION_CONVERTER:
<b class="nc">&nbsp;	return locationInfo.getLineNumber();</b>
&nbsp;      case FILE_LOCATION_CONVERTER:
<b class="nc">&nbsp;	return locationInfo.getFileName();</b>
<b class="nc">&nbsp;      default: return null;</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static abstract class NamedPatternConverter extends PatternConverter {
&nbsp;    int precision;
&nbsp;
&nbsp;    NamedPatternConverter(FormattingInfo formattingInfo, int precision) {
<b class="fc">&nbsp;      super(formattingInfo);</b>
<b class="fc">&nbsp;      this.precision =  precision;</b>
&nbsp;    }
&nbsp;
&nbsp;    abstract
&nbsp;    String getFullyQualifiedName(LoggingEvent event);
&nbsp;
&nbsp;    public
&nbsp;    String convert(LoggingEvent event) {
<b class="nc">&nbsp;      String n = getFullyQualifiedName(event);</b>
<b class="nc">&nbsp;      if(precision &lt;= 0)</b>
<b class="nc">&nbsp;	return n;</b>
&nbsp;      else {
<b class="nc">&nbsp;	int len = n.length();</b>
&nbsp;
&nbsp;	// We substract 1 from &#39;len&#39; when assigning to &#39;end&#39; to avoid out of
&nbsp;	// bounds exception in return r.substring(end+1, len). This can happen if
&nbsp;	// precision is 1 and the category name ends with a dot.
<b class="nc">&nbsp;	int end = len -1 ;</b>
<b class="nc">&nbsp;	for(int i = precision; i &gt; 0; i--) {</b>
<b class="nc">&nbsp;	  end = n.lastIndexOf(&#39;.&#39;, end-1);</b>
<b class="nc">&nbsp;	  if(end == -1)</b>
<b class="nc">&nbsp;	    return n;</b>
&nbsp;	}
<b class="nc">&nbsp;	return n.substring(end+1, len);</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private class ClassNamePatternConverter extends NamedPatternConverter {
&nbsp;
<b class="nc">&nbsp;    ClassNamePatternConverter(FormattingInfo formattingInfo, int precision) {</b>
<b class="nc">&nbsp;      super(formattingInfo, precision);</b>
&nbsp;    }
&nbsp;
&nbsp;    String getFullyQualifiedName(LoggingEvent event) {
<b class="nc">&nbsp;      return event.getLocationInformation().getClassName();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private class CategoryPatternConverter extends NamedPatternConverter {
&nbsp;
<b class="fc">&nbsp;    CategoryPatternConverter(FormattingInfo formattingInfo, int precision) {</b>
<b class="fc">&nbsp;      super(formattingInfo, precision);</b>
&nbsp;    }
&nbsp;
&nbsp;    String getFullyQualifiedName(LoggingEvent event) {
<b class="nc">&nbsp;      return event.getLoggerName();</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
