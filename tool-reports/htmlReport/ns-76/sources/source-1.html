


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > DOMConfigurator</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.apache.log4j.xml</a>
</div>

<h1>Coverage Summary for Class: DOMConfigurator (org.apache.log4j.xml)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DOMConfigurator</td>
<td class="coverageStat">
  <span class="percent">
    45,7%
  </span>
  <span class="absValue">
    (16/35)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26,7%
  </span>
  <span class="absValue">
    (54/202)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    39,1%
  </span>
  <span class="absValue">
    (152/389)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DOMConfigurator$1</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DOMConfigurator$ParseAction</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    47,4%
  </span>
  <span class="absValue">
    (18/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26,7%
  </span>
  <span class="absValue">
    (54/202)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    39,3%
  </span>
  <span class="absValue">
    (154/392)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
&nbsp; * contributor license agreements.  See the NOTICE file distributed with
&nbsp; * this work for additional information regarding copyright ownership.
&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
&nbsp; * the License.  You may obtain a copy of the License at
&nbsp; * 
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; * 
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package org.apache.log4j.xml;
&nbsp;
&nbsp;import org.apache.log4j.Appender;
&nbsp;import org.apache.log4j.Layout;
&nbsp;import org.apache.log4j.Level;
&nbsp;import org.apache.log4j.LogManager;
&nbsp;import org.apache.log4j.Logger;
&nbsp;import org.apache.log4j.config.PropertySetter;
&nbsp;import org.apache.log4j.helpers.FileWatchdog;
&nbsp;import org.apache.log4j.helpers.Loader;
&nbsp;import org.apache.log4j.helpers.LogLog;
&nbsp;import org.apache.log4j.helpers.OptionConverter;
&nbsp;import org.apache.log4j.or.RendererMap;
&nbsp;import org.apache.log4j.spi.AppenderAttachable;
&nbsp;import org.apache.log4j.spi.Configurator;
&nbsp;import org.apache.log4j.spi.ErrorHandler;
&nbsp;import org.apache.log4j.spi.Filter;
&nbsp;import org.apache.log4j.spi.LoggerFactory;
&nbsp;import org.apache.log4j.spi.LoggerRepository;
&nbsp;import org.apache.log4j.spi.RendererSupport;
&nbsp;import org.apache.log4j.spi.ThrowableRenderer;
&nbsp;import org.apache.log4j.spi.ThrowableRendererSupport;
&nbsp;import org.w3c.dom.Document;
&nbsp;import org.w3c.dom.Element;
&nbsp;import org.w3c.dom.NamedNodeMap;
&nbsp;import org.w3c.dom.Node;
&nbsp;import org.w3c.dom.NodeList;
&nbsp;import org.xml.sax.InputSource;
&nbsp;import org.xml.sax.SAXException;
&nbsp;
&nbsp;import javax.xml.parsers.DocumentBuilder;
&nbsp;import javax.xml.parsers.DocumentBuilderFactory;
&nbsp;import javax.xml.parsers.FactoryConfigurationError;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.InterruptedIOException;
&nbsp;import java.io.Reader;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLConnection;
&nbsp;import java.util.Hashtable;
&nbsp;import java.util.Properties;
&nbsp;
&nbsp;// Contributors:   Mark Womack
&nbsp;//                 Arun Katkere 
&nbsp;
&nbsp;/**
&nbsp;   Use this class to initialize the log4j environment using a DOM tree.
&nbsp;
&nbsp;   &lt;p&gt;The DTD is specified in &lt;a
&nbsp;   href=&quot;doc-files/log4j.dtd&quot;&gt;&lt;b&gt;log4j.dtd&lt;/b&gt;&lt;/a&gt;.
&nbsp;
&nbsp;   &lt;p&gt;Sometimes it is useful to see how log4j is reading configuration
&nbsp;   files. You can enable log4j internal logging by defining the
&nbsp;   &lt;b&gt;log4j.debug&lt;/b&gt; variable on the java command
&nbsp;   line. Alternatively, set the &lt;code&gt;debug&lt;/code&gt; attribute in the
&nbsp;   &lt;code&gt;log4j:configuration&lt;/code&gt; element. As in
&nbsp;&lt;pre&gt;
&nbsp;   &amp;lt;log4j:configuration &lt;b&gt;debug=&quot;true&quot;&lt;/b&gt; xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;
&nbsp;   ...
&nbsp;   &amp;lt;/log4j:configuration&gt;
&nbsp;&lt;/pre&gt;
&nbsp;
&nbsp;   &lt;p&gt;There are sample XML files included in the package.
&nbsp;   
&nbsp;   @author Christopher Taylor
&nbsp;   @author Ceki G&amp;uuml;lc&amp;uuml;
&nbsp;   @author Anders Kristensen
&nbsp;
&nbsp;   @since 0.8.3 */
&nbsp;public class DOMConfigurator implements Configurator {
&nbsp;
&nbsp;  static final String CONFIGURATION_TAG = &quot;log4j:configuration&quot;;
&nbsp;  static final String OLD_CONFIGURATION_TAG = &quot;configuration&quot;;
&nbsp;  static final String RENDERER_TAG      = &quot;renderer&quot;;
&nbsp;  private static final String THROWABLE_RENDERER_TAG = &quot;throwableRenderer&quot;;
&nbsp;  static final String APPENDER_TAG 	= &quot;appender&quot;;
&nbsp;  static final String APPENDER_REF_TAG 	= &quot;appender-ref&quot;;  
&nbsp;  static final String PARAM_TAG    	= &quot;param&quot;;
&nbsp;  static final String LAYOUT_TAG	= &quot;layout&quot;;
&nbsp;  static final String CATEGORY		= &quot;category&quot;;
&nbsp;  static final String LOGGER		= &quot;logger&quot;;
&nbsp;  static final String LOGGER_REF	= &quot;logger-ref&quot;;
&nbsp;  static final String CATEGORY_FACTORY_TAG  = &quot;categoryFactory&quot;;
&nbsp;  static final String LOGGER_FACTORY_TAG  = &quot;loggerFactory&quot;;
&nbsp;  static final String NAME_ATTR		= &quot;name&quot;;
&nbsp;  static final String CLASS_ATTR        = &quot;class&quot;;
&nbsp;  static final String VALUE_ATTR	= &quot;value&quot;;
&nbsp;  static final String ROOT_TAG		= &quot;root&quot;;
&nbsp;  static final String ROOT_REF		= &quot;root-ref&quot;;
&nbsp;  static final String LEVEL_TAG	        = &quot;level&quot;;
&nbsp;  static final String PRIORITY_TAG      = &quot;priority&quot;;
&nbsp;  static final String FILTER_TAG	= &quot;filter&quot;;
&nbsp;  static final String ERROR_HANDLER_TAG	= &quot;errorHandler&quot;;
&nbsp;  static final String REF_ATTR		= &quot;ref&quot;;
&nbsp;  static final String ADDITIVITY_ATTR    = &quot;additivity&quot;;  
&nbsp;  static final String THRESHOLD_ATTR       = &quot;threshold&quot;;
&nbsp;  static final String CONFIG_DEBUG_ATTR  = &quot;configDebug&quot;;
&nbsp;  static final String INTERNAL_DEBUG_ATTR  = &quot;debug&quot;;
&nbsp;  private static final String RESET_ATTR  = &quot;reset&quot;;
&nbsp;  static final String RENDERING_CLASS_ATTR = &quot;renderingClass&quot;;
&nbsp;  static final String RENDERED_CLASS_ATTR = &quot;renderedClass&quot;;
&nbsp;
&nbsp;  static final String EMPTY_STR = &quot;&quot;;
<b class="fc">&nbsp;  static final Class[] ONE_STRING_PARAM = new Class[] {String.class};</b>
&nbsp;
&nbsp;  final static String dbfKey = &quot;javax.xml.parsers.DocumentBuilderFactory&quot;;
&nbsp;
&nbsp;  
&nbsp;  // key: appenderName, value: appender
&nbsp;  Hashtable appenderBag;
&nbsp;
&nbsp;  Properties props;
&nbsp;  LoggerRepository repository;
&nbsp;
<b class="fc">&nbsp;  protected LoggerFactory catFactory = null;</b>
&nbsp;
&nbsp;  /**
&nbsp;     No argument constructor.
&nbsp;  */
&nbsp;  public
<b class="fc">&nbsp;  DOMConfigurator () { </b>
<b class="fc">&nbsp;    appenderBag = new Hashtable();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Used internally to parse appenders by IDREF name.
&nbsp;  */
&nbsp;  protected
&nbsp;  Appender findAppenderByName(Document doc, String appenderName)  {      
<b class="fc">&nbsp;    Appender appender = (Appender) appenderBag.get(appenderName);</b>
&nbsp;
<b class="pc">&nbsp;    if(appender != null) {</b>
<b class="nc">&nbsp;      return appender;</b>
&nbsp;    } else {
&nbsp;      // Doesn&#39;t work on DOM Level 1 :
&nbsp;      // Element element = doc.getElementById(appenderName);
&nbsp;                        
&nbsp;      // Endre&#39;s hack:
<b class="fc">&nbsp;      Element element = null;</b>
<b class="fc">&nbsp;      NodeList list = doc.getElementsByTagName(&quot;appender&quot;);</b>
<b class="pc">&nbsp;      for (int t=0; t &lt; list.getLength(); t++) {</b>
<b class="fc">&nbsp;	Node node = list.item(t);</b>
<b class="fc">&nbsp;	NamedNodeMap map= node.getAttributes();</b>
<b class="fc">&nbsp;	Node attrNode = map.getNamedItem(&quot;name&quot;);</b>
<b class="pc">&nbsp;	if (appenderName.equals(attrNode.getNodeValue())) {</b>
<b class="fc">&nbsp;	  element = (Element) node;</b>
<b class="fc">&nbsp;	  break;</b>
&nbsp;	}
&nbsp;      }
&nbsp;      // Hack finished.
&nbsp;
<b class="pc">&nbsp;      if(element == null) {</b>
<b class="nc">&nbsp;	LogLog.error(&quot;No appender named [&quot;+appenderName+&quot;] could be found.&quot;); </b>
<b class="nc">&nbsp;	return null;</b>
&nbsp;      } else {
<b class="fc">&nbsp;	      appender = parseAppender(element);</b>
<b class="pc">&nbsp;          if (appender != null) {</b>
<b class="fc">&nbsp;            appenderBag.put(appenderName, appender);</b>
&nbsp;          }
<b class="fc">&nbsp;    return appender;</b>
&nbsp;      }
&nbsp;    } 
&nbsp;  }
&nbsp;  /**
&nbsp;     Used internally to parse appenders by IDREF element.
&nbsp;   */
&nbsp;  protected
&nbsp;  Appender findAppenderByReference(Element appenderRef) {    
<b class="fc">&nbsp;    String appenderName = subst(appenderRef.getAttribute(REF_ATTR));    </b>
<b class="fc">&nbsp;    Document doc = appenderRef.getOwnerDocument();</b>
<b class="fc">&nbsp;    return findAppenderByName(doc, appenderName);</b>
&nbsp;  }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates unrecognized content to created instance if
&nbsp;     * it supports UnrecognizedElementParser.
&nbsp;     * @since 1.2.15
&nbsp;     * @param instance instance, may be null.
&nbsp;     * @param element element, may not be null.
&nbsp;     * @param props properties
&nbsp;     * @throws IOException thrown if configuration of owner object
&nbsp;     * should be abandoned.
&nbsp;     */
&nbsp;  private static void parseUnrecognizedElement(final Object instance,
&nbsp;                                        final Element element,
&nbsp;                                        final Properties props) throws Exception {
<b class="nc">&nbsp;      boolean recognized = false;</b>
<b class="nc">&nbsp;      if (instance instanceof UnrecognizedElementHandler) {</b>
<b class="nc">&nbsp;          recognized = ((UnrecognizedElementHandler) instance).parseUnrecognizedElement(</b>
&nbsp;                  element, props);
&nbsp;      }
<b class="nc">&nbsp;      if (!recognized) {</b>
<b class="nc">&nbsp;          LogLog.warn(&quot;Unrecognized element &quot; + element.getNodeName());</b>
&nbsp;      }
&nbsp;  }
&nbsp;
&nbsp;    /**
&nbsp;      * Delegates unrecognized content to created instance if
&nbsp;      * it supports UnrecognizedElementParser and catches and
&nbsp;     *  logs any exception.
&nbsp;      * @since 1.2.15
&nbsp;      * @param instance instance, may be null.
&nbsp;      * @param element element, may not be null.
&nbsp;      * @param props properties
&nbsp;      */
&nbsp;   private static void quietParseUnrecognizedElement(final Object instance,
&nbsp;                                          final Element element,
&nbsp;                                          final Properties props) {
&nbsp;      try {
<b class="nc">&nbsp;          parseUnrecognizedElement(instance, element, props);</b>
<b class="nc">&nbsp;      } catch (Exception ex) {</b>
<b class="nc">&nbsp;          if (ex instanceof InterruptedException || ex instanceof InterruptedIOException) {</b>
<b class="nc">&nbsp;              Thread.currentThread().interrupt();</b>
&nbsp;          }
<b class="nc">&nbsp;          LogLog.error(&quot;Error in extension content: &quot;, ex);</b>
<b class="nc">&nbsp;      }</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Used internally to parse an appender element.
&nbsp;   */
&nbsp;  protected
&nbsp;  Appender parseAppender (Element appenderElement) {
<b class="fc">&nbsp;    String className = subst(appenderElement.getAttribute(CLASS_ATTR));</b>
<b class="fc">&nbsp;    LogLog.debug(&quot;Class name: [&quot; + className+&#39;]&#39;);    </b>
&nbsp;    try {
<b class="fc">&nbsp;      Object instance 	= Loader.loadClass(className).newInstance();</b>
<b class="fc">&nbsp;      Appender appender	= (Appender)instance;</b>
<b class="fc">&nbsp;      PropertySetter propSetter = new PropertySetter(appender);</b>
&nbsp;
<b class="fc">&nbsp;      appender.setName(subst(appenderElement.getAttribute(NAME_ATTR)));</b>
&nbsp;      
<b class="fc">&nbsp;      NodeList children	= appenderElement.getChildNodes();</b>
<b class="fc">&nbsp;      final int length 	= children.getLength();</b>
&nbsp;
<b class="fc">&nbsp;      for (int loop = 0; loop &lt; length; loop++) {</b>
<b class="fc">&nbsp;	Node currentNode = children.item(loop);</b>
&nbsp;
&nbsp;	/* We&#39;re only interested in Elements */
<b class="fc">&nbsp;	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {</b>
<b class="fc">&nbsp;	  Element currentElement = (Element)currentNode;</b>
&nbsp;
&nbsp;	  // Parse appender parameters 
<b class="fc">&nbsp;	  if (currentElement.getTagName().equals(PARAM_TAG)) {</b>
<b class="fc">&nbsp;            setParameter(currentElement, propSetter);</b>
&nbsp;	  }
&nbsp;	  // Set appender layout
<b class="pc">&nbsp;	  else if (currentElement.getTagName().equals(LAYOUT_TAG)) {</b>
<b class="fc">&nbsp;	    appender.setLayout(parseLayout(currentElement));</b>
&nbsp;	  }
&nbsp;	  // Add filters
<b class="nc">&nbsp;	  else if (currentElement.getTagName().equals(FILTER_TAG)) {</b>
<b class="nc">&nbsp;	    parseFilters(currentElement, appender);</b>
&nbsp;	  }
<b class="nc">&nbsp;	  else if (currentElement.getTagName().equals(ERROR_HANDLER_TAG)) {</b>
<b class="nc">&nbsp;	    parseErrorHandler(currentElement, appender);</b>
&nbsp;	  }
<b class="nc">&nbsp;	  else if (currentElement.getTagName().equals(APPENDER_REF_TAG)) {</b>
<b class="nc">&nbsp;	    String refName = subst(currentElement.getAttribute(REF_ATTR));</b>
<b class="nc">&nbsp;	    if(appender instanceof AppenderAttachable) {</b>
<b class="nc">&nbsp;	      AppenderAttachable aa = (AppenderAttachable) appender;</b>
<b class="nc">&nbsp;	      LogLog.debug(&quot;Attaching appender named [&quot;+ refName+</b>
&nbsp;			   &quot;] to appender named [&quot;+ appender.getName()+&quot;].&quot;);
<b class="nc">&nbsp;	      aa.addAppender(findAppenderByReference(currentElement));</b>
<b class="nc">&nbsp;	    } else {</b>
<b class="nc">&nbsp;	      LogLog.error(&quot;Requesting attachment of appender named [&quot;+</b>
&nbsp;			   refName+ &quot;] to appender named [&quot;+ appender.getName()+
&nbsp;                &quot;] which does not implement org.apache.log4j.spi.AppenderAttachable.&quot;);
&nbsp;	    }
<b class="nc">&nbsp;	  } else {</b>
<b class="nc">&nbsp;          parseUnrecognizedElement(instance, currentElement, props);</b>
&nbsp;      }
&nbsp;	}
&nbsp;      }
<b class="fc">&nbsp;      propSetter.activate();</b>
<b class="fc">&nbsp;      return appender;</b>
&nbsp;    }
&nbsp;    /* Yes, it&#39;s ugly.  But all of these exceptions point to the same
&nbsp;       problem: we can&#39;t create an Appender */
<b class="nc">&nbsp;    catch (Exception oops) {</b>
<b class="nc">&nbsp;        if (oops instanceof InterruptedException || oops instanceof InterruptedIOException) {</b>
<b class="nc">&nbsp;            Thread.currentThread().interrupt();</b>
&nbsp;        }
<b class="nc">&nbsp;      LogLog.error(&quot;Could not create an Appender. Reported error follows.&quot;,</b>
&nbsp;		   oops);
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Used internally to parse an {@link ErrorHandler} element.
&nbsp;   */
&nbsp;  protected
&nbsp;  void parseErrorHandler(Element element, Appender appender) {
<b class="nc">&nbsp;    ErrorHandler eh = (ErrorHandler) OptionConverter.instantiateByClassName(</b>
&nbsp;                                       subst(element.getAttribute(CLASS_ATTR)),
&nbsp;                                       org.apache.log4j.spi.ErrorHandler.class, 
&nbsp; 				       null);
&nbsp;    
<b class="nc">&nbsp;    if(eh != null) {</b>
<b class="nc">&nbsp;      eh.setAppender(appender);</b>
&nbsp;
<b class="nc">&nbsp;      PropertySetter propSetter = new PropertySetter(eh);</b>
<b class="nc">&nbsp;      NodeList children = element.getChildNodes();</b>
<b class="nc">&nbsp;      final int length 	= children.getLength();</b>
&nbsp;
<b class="nc">&nbsp;      for (int loop = 0; loop &lt; length; loop++) {</b>
<b class="nc">&nbsp;	Node currentNode = children.item(loop);</b>
<b class="nc">&nbsp;	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {</b>
<b class="nc">&nbsp;	  Element currentElement = (Element) currentNode;</b>
<b class="nc">&nbsp;	  String tagName = currentElement.getTagName();</b>
<b class="nc">&nbsp;	  if(tagName.equals(PARAM_TAG)) {</b>
<b class="nc">&nbsp;            setParameter(currentElement, propSetter);</b>
<b class="nc">&nbsp;	  } else if(tagName.equals(APPENDER_REF_TAG)) {</b>
<b class="nc">&nbsp;	    eh.setBackupAppender(findAppenderByReference(currentElement));</b>
<b class="nc">&nbsp;	  } else if(tagName.equals(LOGGER_REF)) {</b>
<b class="nc">&nbsp;	    String loggerName = currentElement.getAttribute(REF_ATTR);	    </b>
<b class="nc">&nbsp;	    Logger logger = (catFactory == null) ? repository.getLogger(loggerName)</b>
&nbsp;                : repository.getLogger(loggerName, catFactory);
<b class="nc">&nbsp;	    eh.setLogger(logger);</b>
<b class="nc">&nbsp;	  } else if(tagName.equals(ROOT_REF)) {</b>
<b class="nc">&nbsp;	    Logger root = repository.getRootLogger();</b>
<b class="nc">&nbsp;	    eh.setLogger(root);</b>
<b class="nc">&nbsp;	  } else {</b>
<b class="nc">&nbsp;          quietParseUnrecognizedElement(eh, currentElement, props);</b>
&nbsp;      }
&nbsp;	}
&nbsp;      }
<b class="nc">&nbsp;      propSetter.activate();</b>
<b class="nc">&nbsp;      appender.setErrorHandler(eh);</b>
&nbsp;    }
&nbsp;  }
&nbsp;  
&nbsp;  /**
&nbsp;     Used internally to parse a filter element.
&nbsp;   */
&nbsp;  protected
&nbsp;  void parseFilters(Element element, Appender appender) {
<b class="nc">&nbsp;    String clazz = subst(element.getAttribute(CLASS_ATTR));</b>
<b class="nc">&nbsp;    Filter filter = (Filter) OptionConverter.instantiateByClassName(clazz,</b>
&nbsp;                                                Filter.class, null);
&nbsp;    
<b class="nc">&nbsp;    if(filter != null) {</b>
<b class="nc">&nbsp;      PropertySetter propSetter = new PropertySetter(filter);</b>
<b class="nc">&nbsp;      NodeList children = element.getChildNodes();</b>
<b class="nc">&nbsp;      final int length 	= children.getLength();</b>
&nbsp;
<b class="nc">&nbsp;      for (int loop = 0; loop &lt; length; loop++) {</b>
<b class="nc">&nbsp;	Node currentNode = children.item(loop);</b>
<b class="nc">&nbsp;	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {</b>
<b class="nc">&nbsp;	  Element currentElement = (Element) currentNode;</b>
<b class="nc">&nbsp;	  String tagName = currentElement.getTagName();</b>
<b class="nc">&nbsp;	  if(tagName.equals(PARAM_TAG)) {</b>
<b class="nc">&nbsp;            setParameter(currentElement, propSetter);</b>
&nbsp;	  } else {
<b class="nc">&nbsp;            quietParseUnrecognizedElement(filter, currentElement, props);</b>
&nbsp;      }
&nbsp;	}
&nbsp;      }
<b class="nc">&nbsp;      propSetter.activate();</b>
<b class="nc">&nbsp;      LogLog.debug(&quot;Adding filter of type [&quot;+filter.getClass()</b>
&nbsp;		   +&quot;] to appender named [&quot;+appender.getName()+&quot;].&quot;);
<b class="nc">&nbsp;      appender.addFilter(filter);</b>
&nbsp;    }    
&nbsp;  }
&nbsp;  
&nbsp;  /**
&nbsp;     Used internally to parse an category element.
&nbsp;  */
&nbsp;  protected
&nbsp;  void parseCategory (Element loggerElement) {
&nbsp;    // Create a new org.apache.log4j.Category object from the &lt;category&gt; element.
<b class="nc">&nbsp;    String catName = subst(loggerElement.getAttribute(NAME_ATTR));</b>
&nbsp;
&nbsp;    Logger cat;    
&nbsp;
<b class="nc">&nbsp;    String className = subst(loggerElement.getAttribute(CLASS_ATTR));</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;    if(EMPTY_STR.equals(className)) {</b>
<b class="nc">&nbsp;      LogLog.debug(&quot;Retreiving an instance of org.apache.log4j.Logger.&quot;);</b>
<b class="nc">&nbsp;      cat = (catFactory == null) ? repository.getLogger(catName) : repository.getLogger(catName, catFactory);</b>
&nbsp;    }
&nbsp;    else {
<b class="nc">&nbsp;      LogLog.debug(&quot;Desired logger sub-class: [&quot;+className+&#39;]&#39;);</b>
&nbsp;       try {	 
<b class="nc">&nbsp;	 Class clazz = Loader.loadClass(className);</b>
<b class="nc">&nbsp;	 Method getInstanceMethod = clazz.getMethod(&quot;getLogger&quot;, </b>
&nbsp;						    ONE_STRING_PARAM);
<b class="nc">&nbsp;	 cat = (Logger) getInstanceMethod.invoke(null, new Object[] {catName});</b>
<b class="nc">&nbsp;       } catch (InvocationTargetException oops) {</b>
<b class="nc">&nbsp;          if (oops.getTargetException() instanceof InterruptedException</b>
&nbsp;                  || oops.getTargetException() instanceof InterruptedIOException) {
<b class="nc">&nbsp;              Thread.currentThread().interrupt();</b>
&nbsp;          }
<b class="nc">&nbsp;          LogLog.error(&quot;Could not retrieve category [&quot;+catName+</b>
&nbsp;		      &quot;]. Reported error follows.&quot;, oops);
&nbsp;	      return;
<b class="nc">&nbsp;       } catch (Exception oops) {</b>
<b class="nc">&nbsp;	      LogLog.error(&quot;Could not retrieve category [&quot;+catName+</b>
&nbsp;		      &quot;]. Reported error follows.&quot;, oops);
&nbsp;	      return;
<b class="nc">&nbsp;       }</b>
&nbsp;    }
&nbsp;
&nbsp;    // Setting up a category needs to be an atomic operation, in order
&nbsp;    // to protect potential log operations while category
&nbsp;    // configuration is in progress.
<b class="nc">&nbsp;    synchronized(cat) {</b>
<b class="nc">&nbsp;      boolean additivity = OptionConverter.toBoolean(</b>
&nbsp;                           subst(loggerElement.getAttribute(ADDITIVITY_ATTR)),
&nbsp;			   true);
&nbsp;    
<b class="nc">&nbsp;      LogLog.debug(&quot;Setting [&quot;+cat.getName()+&quot;] additivity to [&quot;+additivity+&quot;].&quot;);</b>
<b class="nc">&nbsp;      cat.setAdditivity(additivity);</b>
<b class="nc">&nbsp;      parseChildrenOfLoggerElement(loggerElement, cat, false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Used internally to parse the category factory element.
&nbsp;  */
&nbsp;  protected
&nbsp;  void parseCategoryFactory(Element factoryElement) {
<b class="nc">&nbsp;    String className = subst(factoryElement.getAttribute(CLASS_ATTR));</b>
&nbsp;
<b class="nc">&nbsp;    if(EMPTY_STR.equals(className)) {</b>
<b class="nc">&nbsp;      LogLog.error(&quot;Category Factory tag &quot; + CLASS_ATTR + &quot; attribute not found.&quot;);</b>
<b class="nc">&nbsp;      LogLog.debug(&quot;No Category Factory configured.&quot;);</b>
&nbsp;    }
&nbsp;    else {
<b class="nc">&nbsp;      LogLog.debug(&quot;Desired category factory: [&quot;+className+&#39;]&#39;);</b>
<b class="nc">&nbsp;      Object factory = OptionConverter.instantiateByClassName(className,</b>
&nbsp;                                                                 LoggerFactory.class, 
&nbsp;                                                                 null);
<b class="nc">&nbsp;      if (factory instanceof LoggerFactory) {</b>
<b class="nc">&nbsp;          catFactory = (LoggerFactory) factory;</b>
&nbsp;      } else {
<b class="nc">&nbsp;          LogLog.error(&quot;Category Factory class &quot; + className + &quot; does not implement org.apache.log4j.LoggerFactory&quot;);</b>
&nbsp;      }
<b class="nc">&nbsp;      PropertySetter propSetter = new PropertySetter(factory);</b>
&nbsp;
<b class="nc">&nbsp;      Element  currentElement = null;</b>
<b class="nc">&nbsp;      Node     currentNode    = null;</b>
<b class="nc">&nbsp;      NodeList children       = factoryElement.getChildNodes();</b>
<b class="nc">&nbsp;      final int length        = children.getLength();</b>
&nbsp;
<b class="nc">&nbsp;      for (int loop=0; loop &lt; length; loop++) {</b>
<b class="nc">&nbsp;        currentNode = children.item(loop);</b>
<b class="nc">&nbsp;	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {</b>
<b class="nc">&nbsp;	  currentElement = (Element)currentNode;</b>
<b class="nc">&nbsp;	  if (currentElement.getTagName().equals(PARAM_TAG)) {</b>
<b class="nc">&nbsp;	    setParameter(currentElement, propSetter);</b>
&nbsp;	  } else {
<b class="nc">&nbsp;           quietParseUnrecognizedElement(factory, currentElement, props);</b>
&nbsp;      }
&nbsp;	}
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Used internally to parse the roor category element.
&nbsp;  */
&nbsp;  protected
&nbsp;  void parseRoot (Element rootElement) {
<b class="fc">&nbsp;    Logger root = repository.getRootLogger();</b>
&nbsp;    // category configuration needs to be atomic
<b class="fc">&nbsp;    synchronized(root) {    </b>
<b class="fc">&nbsp;      parseChildrenOfLoggerElement(rootElement, root, true);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Used internally to parse the children of a category element.
&nbsp;  */
&nbsp;  protected
&nbsp;  void parseChildrenOfLoggerElement(Element catElement,
&nbsp;				      Logger cat, boolean isRoot) {
&nbsp;    
<b class="fc">&nbsp;    PropertySetter propSetter = new PropertySetter(cat);</b>
&nbsp;    
&nbsp;    // Remove all existing appenders from cat. They will be
&nbsp;    // reconstructed if need be.
<b class="fc">&nbsp;    cat.removeAllAppenders();</b>
&nbsp;
&nbsp;
<b class="fc">&nbsp;    NodeList children 	= catElement.getChildNodes();</b>
<b class="fc">&nbsp;    final int length 	= children.getLength();</b>
&nbsp;    
<b class="fc">&nbsp;    for (int loop = 0; loop &lt; length; loop++) {</b>
<b class="fc">&nbsp;      Node currentNode = children.item(loop);</b>
&nbsp;
<b class="fc">&nbsp;      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {</b>
<b class="fc">&nbsp;	Element currentElement = (Element) currentNode;</b>
<b class="fc">&nbsp;	String tagName = currentElement.getTagName();</b>
&nbsp;	
<b class="fc">&nbsp;	if (tagName.equals(APPENDER_REF_TAG)) {</b>
<b class="fc">&nbsp;	  Element appenderRef = (Element) currentNode;</b>
<b class="fc">&nbsp;	  Appender appender = findAppenderByReference(appenderRef);</b>
<b class="fc">&nbsp;	  String refName =  subst(appenderRef.getAttribute(REF_ATTR));</b>
<b class="pc">&nbsp;	  if(appender != null)</b>
<b class="fc">&nbsp;	    LogLog.debug(&quot;Adding appender named [&quot;+ refName+ </b>
&nbsp;			 &quot;] to category [&quot;+cat.getName()+&quot;].&quot;);
&nbsp;	  else 
<b class="nc">&nbsp;	    LogLog.debug(&quot;Appender named [&quot;+ refName + &quot;] not found.&quot;);</b>
&nbsp;	    
<b class="fc">&nbsp;	  cat.addAppender(appender);</b>
&nbsp;	  
<b class="pc">&nbsp;	} else if(tagName.equals(LEVEL_TAG)) {</b>
<b class="fc">&nbsp;	  parseLevel(currentElement, cat, isRoot);	</b>
<b class="nc">&nbsp;	} else if(tagName.equals(PRIORITY_TAG)) {</b>
<b class="nc">&nbsp;	  parseLevel(currentElement, cat, isRoot);</b>
<b class="nc">&nbsp;	} else if(tagName.equals(PARAM_TAG)) {</b>
<b class="nc">&nbsp;          setParameter(currentElement, propSetter);</b>
&nbsp;	} else {
<b class="nc">&nbsp;        quietParseUnrecognizedElement(cat, currentElement, props);</b>
&nbsp;    }
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    propSetter.activate();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Used internally to parse a layout element.
&nbsp;  */  
&nbsp;  protected
&nbsp;  Layout parseLayout (Element layout_element) {
<b class="fc">&nbsp;    String className = subst(layout_element.getAttribute(CLASS_ATTR));</b>
<b class="fc">&nbsp;    LogLog.debug(&quot;Parsing layout of class: \&quot;&quot;+className+&quot;\&quot;&quot;);		 </b>
&nbsp;    try {
<b class="fc">&nbsp;      Object instance 	= Loader.loadClass(className).newInstance();</b>
<b class="fc">&nbsp;      Layout layout   	= (Layout)instance;</b>
<b class="fc">&nbsp;      PropertySetter propSetter = new PropertySetter(layout);</b>
&nbsp;      
<b class="fc">&nbsp;      NodeList params 	= layout_element.getChildNodes();</b>
<b class="fc">&nbsp;      final int length 	= params.getLength();</b>
&nbsp;
<b class="fc">&nbsp;      for (int loop = 0; loop &lt; length; loop++) {</b>
<b class="fc">&nbsp;	Node currentNode = (Node)params.item(loop);</b>
<b class="fc">&nbsp;	if (currentNode.getNodeType() == Node.ELEMENT_NODE) {</b>
<b class="fc">&nbsp;	  Element currentElement = (Element) currentNode;</b>
<b class="fc">&nbsp;	  String tagName = currentElement.getTagName();</b>
<b class="pc">&nbsp;	  if(tagName.equals(PARAM_TAG)) {</b>
<b class="fc">&nbsp;            setParameter(currentElement, propSetter);</b>
&nbsp;	  } else {
<b class="nc">&nbsp;          parseUnrecognizedElement(instance, currentElement, props);</b>
&nbsp;      }
&nbsp;	}
&nbsp;      }
&nbsp;      
<b class="fc">&nbsp;      propSetter.activate();</b>
<b class="fc">&nbsp;      return layout;</b>
&nbsp;    }
<b class="nc">&nbsp;    catch (Exception oops) {</b>
<b class="nc">&nbsp;        if (oops instanceof InterruptedException || oops instanceof InterruptedIOException) {</b>
<b class="nc">&nbsp;            Thread.currentThread().interrupt();</b>
&nbsp;        }
<b class="nc">&nbsp;      LogLog.error(&quot;Could not create the Layout. Reported error follows.&quot;,</b>
&nbsp;		   oops);
<b class="nc">&nbsp;      return null;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  protected 
&nbsp;  void parseRenderer(Element element) {
<b class="nc">&nbsp;    String renderingClass = subst(element.getAttribute(RENDERING_CLASS_ATTR));</b>
<b class="nc">&nbsp;    String renderedClass = subst(element.getAttribute(RENDERED_CLASS_ATTR));</b>
<b class="nc">&nbsp;    if(repository instanceof RendererSupport) {</b>
<b class="nc">&nbsp;      RendererMap.addRenderer((RendererSupport) repository, renderedClass, </b>
&nbsp;			      renderingClass);
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;    /**
&nbsp;     * Parses throwable renderer.
&nbsp;     * @param element throwableRenderer element.
&nbsp;     * @return configured throwable renderer.
&nbsp;     * @since 1.2.16.
&nbsp;     */
&nbsp;    protected ThrowableRenderer parseThrowableRenderer(final Element element) {
<b class="nc">&nbsp;        String className = subst(element.getAttribute(CLASS_ATTR));</b>
<b class="nc">&nbsp;        LogLog.debug(&quot;Parsing throwableRenderer of class: \&quot;&quot;+className+&quot;\&quot;&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;          Object instance 	= Loader.loadClass(className).newInstance();</b>
<b class="nc">&nbsp;          ThrowableRenderer tr   	= (ThrowableRenderer)instance;</b>
<b class="nc">&nbsp;          PropertySetter propSetter = new PropertySetter(tr);</b>
&nbsp;
<b class="nc">&nbsp;          NodeList params 	= element.getChildNodes();</b>
<b class="nc">&nbsp;          final int length 	= params.getLength();</b>
&nbsp;
<b class="nc">&nbsp;          for (int loop = 0; loop &lt; length; loop++) {</b>
<b class="nc">&nbsp;                Node currentNode = (Node)params.item(loop);</b>
<b class="nc">&nbsp;                if (currentNode.getNodeType() == Node.ELEMENT_NODE) {</b>
<b class="nc">&nbsp;                    Element currentElement = (Element) currentNode;</b>
<b class="nc">&nbsp;                    String tagName = currentElement.getTagName();</b>
<b class="nc">&nbsp;                    if(tagName.equals(PARAM_TAG)) {</b>
<b class="nc">&nbsp;                        setParameter(currentElement, propSetter);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        parseUnrecognizedElement(instance, currentElement, props);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          propSetter.activate();</b>
<b class="nc">&nbsp;          return tr;</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (Exception oops) {</b>
<b class="nc">&nbsp;            if (oops instanceof InterruptedException || oops instanceof InterruptedIOException) {</b>
<b class="nc">&nbsp;                Thread.currentThread().interrupt();</b>
&nbsp;            }
<b class="nc">&nbsp;            LogLog.error(&quot;Could not create the ThrowableRenderer. Reported error follows.&quot;,</b>
&nbsp;               oops);
<b class="nc">&nbsp;          return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;  /**
&nbsp;     Used internally to parse a level  element.
&nbsp;  */
&nbsp;  protected
&nbsp;  void parseLevel(Element element, Logger logger, boolean isRoot) {
<b class="fc">&nbsp;    String catName = logger.getName();</b>
<b class="pc">&nbsp;    if(isRoot) {</b>
<b class="fc">&nbsp;      catName = &quot;root&quot;;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    String priStr = subst(element.getAttribute(VALUE_ATTR));</b>
<b class="fc">&nbsp;    LogLog.debug(&quot;Level value for &quot;+catName+&quot; is  [&quot;+priStr+&quot;].&quot;);</b>
&nbsp;    
<b class="pc">&nbsp;    if(INHERITED.equalsIgnoreCase(priStr) || NULL.equalsIgnoreCase(priStr)) {</b>
<b class="nc">&nbsp;      if(isRoot) {</b>
<b class="nc">&nbsp;	LogLog.error(&quot;Root level cannot be inherited. Ignoring directive.&quot;);</b>
&nbsp;      } else {
<b class="nc">&nbsp;	logger.setLevel(null);</b>
&nbsp;      }
&nbsp;    } else {
<b class="fc">&nbsp;      String className = subst(element.getAttribute(CLASS_ATTR));      </b>
<b class="pc">&nbsp;      if(EMPTY_STR.equals(className)) {	</b>
<b class="fc">&nbsp;	logger.setLevel(OptionConverter.toLevel(priStr, Level.DEBUG));</b>
&nbsp;      } else {
<b class="nc">&nbsp;	LogLog.debug(&quot;Desired Level sub-class: [&quot;+className+&#39;]&#39;);</b>
&nbsp;	try {	 
<b class="nc">&nbsp;	  Class clazz = Loader.loadClass(className);</b>
<b class="nc">&nbsp;	  Method toLevelMethod = clazz.getMethod(&quot;toLevel&quot;, </b>
&nbsp;						    ONE_STRING_PARAM);
<b class="nc">&nbsp;	  Level pri = (Level) toLevelMethod.invoke(null, </b>
&nbsp;						    new Object[] {priStr});
<b class="nc">&nbsp;	  logger.setLevel(pri);</b>
<b class="nc">&nbsp;	} catch (Exception oops) {</b>
<b class="nc">&nbsp;        if (oops instanceof InterruptedException || oops instanceof InterruptedIOException) {</b>
<b class="nc">&nbsp;            Thread.currentThread().interrupt();</b>
&nbsp;        }
<b class="nc">&nbsp;	  LogLog.error(&quot;Could not create level [&quot;+priStr+</b>
&nbsp;		       &quot;]. Reported error follows.&quot;, oops);
&nbsp;	  return;
<b class="nc">&nbsp;	}</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    LogLog.debug(catName + &quot; level set to &quot; + logger.getLevel());    </b>
&nbsp;  }
&nbsp;
&nbsp;  protected
&nbsp;  void setParameter(Element elem, PropertySetter propSetter) {
<b class="fc">&nbsp;      String name = subst(elem.getAttribute(NAME_ATTR));</b>
<b class="fc">&nbsp;      String value = (elem.getAttribute(VALUE_ATTR));</b>
<b class="fc">&nbsp;      value = subst(OptionConverter.convertSpecialChars(value));</b>
<b class="fc">&nbsp;      propSetter.setProperty(name, value);</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;     Configure log4j using a &lt;code&gt;configuration&lt;/code&gt; element as
&nbsp;     defined in the log4j.dtd. 
&nbsp;
&nbsp;  */
&nbsp;  static
&nbsp;  public
&nbsp;  void configure (Element element) {
<b class="nc">&nbsp;    DOMConfigurator configurator = new DOMConfigurator();</b>
<b class="nc">&nbsp;    configurator.doConfigure(element,  LogManager.getLoggerRepository());</b>
&nbsp;  }
&nbsp;
&nbsp; /**
&nbsp;     Like {@link #configureAndWatch(String, long)} except that the
&nbsp;     default delay as defined by {@link FileWatchdog#DEFAULT_DELAY} is
&nbsp;     used. 
&nbsp;
&nbsp;     @param configFilename A log4j configuration file in XML format.
&nbsp;
&nbsp;  */
&nbsp;  static
&nbsp;  public
&nbsp;  void configureAndWatch(String configFilename) {
<b class="nc">&nbsp;    configureAndWatch(configFilename, FileWatchdog.DEFAULT_DELAY);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Read the configuration file &lt;code&gt;configFilename&lt;/code&gt; if it
&nbsp;     exists. Moreover, a thread will be created that will periodically
&nbsp;     check if &lt;code&gt;configFilename&lt;/code&gt; has been created or
&nbsp;     modified. The period is determined by the &lt;code&gt;delay&lt;/code&gt;
&nbsp;     argument. If a change or file creation is detected, then
&nbsp;     &lt;code&gt;configFilename&lt;/code&gt; is read to configure log4j.  
&nbsp;
&nbsp;      @param configFilename A log4j configuration file in XML format.
&nbsp;      @param delay The delay in milliseconds to wait between each check.
&nbsp;  */
&nbsp;  static
&nbsp;  public
&nbsp;  void configureAndWatch(String configFilename, long delay) {
<b class="fc">&nbsp;    XMLWatchdog xdog = new XMLWatchdog(configFilename);</b>
<b class="fc">&nbsp;    xdog.setDelay(delay);</b>
<b class="fc">&nbsp;    xdog.start();</b>
&nbsp;  }
&nbsp;  
&nbsp;  private interface ParseAction {
&nbsp;      Document parse(final DocumentBuilder parser) throws SAXException, IOException;
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  public
&nbsp;  void doConfigure(final String filename, LoggerRepository repository) {
<b class="fc">&nbsp;    ParseAction action = new ParseAction() {</b>
&nbsp;          public Document parse(final DocumentBuilder parser) throws SAXException, IOException {
<b class="fc">&nbsp;              return parser.parse(new File(filename));</b>
&nbsp;          }
&nbsp;          public String toString() { 
<b class="nc">&nbsp;              return &quot;file [&quot; + filename + &quot;]&quot;; </b>
&nbsp;          }
&nbsp;    };
<b class="fc">&nbsp;    doConfigure(action, repository);</b>
&nbsp;  }
&nbsp;  
&nbsp;
&nbsp;  public
&nbsp;  void doConfigure(final URL url, LoggerRepository repository) {
<b class="nc">&nbsp;      ParseAction action = new ParseAction() {</b>
&nbsp;          public Document parse(final DocumentBuilder parser) throws SAXException, IOException {
&nbsp;              URLConnection uConn = url.openConnection();
&nbsp;              uConn.setUseCaches(false);
&nbsp;              InputStream stream = uConn.getInputStream();
&nbsp;              try {
&nbsp;                InputSource src = new InputSource(stream);
&nbsp;                src.setSystemId(url.toString());
&nbsp;                return parser.parse(src);
&nbsp;              } finally {
&nbsp;                stream.close();
&nbsp;              }
&nbsp;          }
&nbsp;          public String toString() { 
&nbsp;              return &quot;url [&quot; + url.toString() + &quot;]&quot;; 
&nbsp;          }
&nbsp;      };
<b class="nc">&nbsp;      doConfigure(action, repository);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Configure log4j by reading in a log4j.dtd compliant XML
&nbsp;     configuration file.
&nbsp;
&nbsp;  */
&nbsp;  public
&nbsp;  void doConfigure(final InputStream inputStream, LoggerRepository repository) 
&nbsp;                                          throws FactoryConfigurationError {
<b class="nc">&nbsp;      ParseAction action = new ParseAction() {</b>
&nbsp;          public Document parse(final DocumentBuilder parser) throws SAXException, IOException {
&nbsp;              InputSource inputSource = new InputSource(inputStream);
&nbsp;              inputSource.setSystemId(&quot;dummy://log4j.dtd&quot;);
&nbsp;              return parser.parse(inputSource);
&nbsp;          }
&nbsp;          public String toString() { 
&nbsp;              return &quot;input stream [&quot; + inputStream.toString() + &quot;]&quot;; 
&nbsp;          }
&nbsp;      };
<b class="nc">&nbsp;      doConfigure(action, repository);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Configure log4j by reading in a log4j.dtd compliant XML
&nbsp;     configuration file.
&nbsp;
&nbsp;  */
&nbsp;  public
&nbsp;  void doConfigure(final Reader reader, LoggerRepository repository) 
&nbsp;                                          throws FactoryConfigurationError {
<b class="nc">&nbsp;      ParseAction action = new ParseAction() {</b>
&nbsp;          public Document parse(final DocumentBuilder parser) throws SAXException, IOException {
&nbsp;              InputSource inputSource = new InputSource(reader);
&nbsp;              inputSource.setSystemId(&quot;dummy://log4j.dtd&quot;);
&nbsp;              return parser.parse(inputSource);
&nbsp;          }
&nbsp;          public String toString() { 
&nbsp;              return &quot;reader [&quot; + reader.toString() + &quot;]&quot;; 
&nbsp;          }
&nbsp;      };
<b class="nc">&nbsp;    doConfigure(action, repository);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Configure log4j by reading in a log4j.dtd compliant XML
&nbsp;     configuration file.
&nbsp;
&nbsp;  */
&nbsp;  protected
&nbsp;  void doConfigure(final InputSource inputSource, LoggerRepository repository) 
&nbsp;                                          throws FactoryConfigurationError {
<b class="nc">&nbsp;      if (inputSource.getSystemId() == null) {</b>
<b class="nc">&nbsp;          inputSource.setSystemId(&quot;dummy://log4j.dtd&quot;);</b>
&nbsp;      }
<b class="nc">&nbsp;      ParseAction action = new ParseAction() {</b>
&nbsp;          public Document parse(final DocumentBuilder parser) throws SAXException, IOException {
&nbsp;              return parser.parse(inputSource);
&nbsp;          }
&nbsp;          public String toString() { 
&nbsp;              return &quot;input source [&quot; + inputSource.toString() + &quot;]&quot;; 
&nbsp;          }
&nbsp;      };
<b class="nc">&nbsp;      doConfigure(action, repository);</b>
&nbsp;    }
&nbsp;    
&nbsp;    
&nbsp;  private final void doConfigure(final ParseAction action, final LoggerRepository repository)
&nbsp;         throws FactoryConfigurationError {
<b class="fc">&nbsp;    DocumentBuilderFactory dbf = null;</b>
<b class="fc">&nbsp;    this.repository = repository;</b>
&nbsp;    try { 
<b class="fc">&nbsp;      LogLog.debug(&quot;System property is :&quot;+</b>
&nbsp;  	                        OptionConverter.getSystemProperty(dbfKey, 
&nbsp;								  null)); 
<b class="fc">&nbsp;      dbf = DocumentBuilderFactory.newInstance();</b>
<b class="fc">&nbsp;      LogLog.debug(&quot;Standard DocumentBuilderFactory search succeded.&quot;);</b>
<b class="fc">&nbsp;      LogLog.debug(&quot;DocumentBuilderFactory is: &quot;+dbf.getClass().getName());</b>
<b class="nc">&nbsp;    } catch(FactoryConfigurationError fce) {</b>
<b class="nc">&nbsp;      Exception e = fce.getException();</b>
<b class="nc">&nbsp;      LogLog.debug(&quot;Could not instantiate a DocumentBuilderFactory.&quot;, e);</b>
<b class="nc">&nbsp;      throw fce;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;      
&nbsp;    try {
<b class="fc">&nbsp;      dbf.setValidating(true);</b>
&nbsp;
<b class="fc">&nbsp;      DocumentBuilder docBuilder = dbf.newDocumentBuilder();</b>
&nbsp;
<b class="fc">&nbsp;      docBuilder.setErrorHandler(new SAXErrorHandler());      </b>
<b class="fc">&nbsp;      docBuilder.setEntityResolver(new Log4jEntityResolver());</b>
&nbsp;         
<b class="fc">&nbsp;      Document doc = action.parse(docBuilder);     </b>
<b class="fc">&nbsp;      parse(doc.getDocumentElement());</b>
<b class="nc">&nbsp;    } catch (Exception e) {</b>
<b class="nc">&nbsp;        if (e instanceof InterruptedException || e instanceof InterruptedIOException) {</b>
<b class="nc">&nbsp;            Thread.currentThread().interrupt();</b>
&nbsp;        }
&nbsp;      // I know this is miserable...
<b class="nc">&nbsp;      LogLog.error(&quot;Could not parse &quot;+ action.toString() + &quot;.&quot;, e);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Configure by taking in an DOM element. 
&nbsp;  */
&nbsp;  public void doConfigure(Element element, LoggerRepository repository) {
<b class="nc">&nbsp;    this.repository = repository;</b>
<b class="nc">&nbsp;    parse(element);</b>
&nbsp;  }
&nbsp;
&nbsp;  
&nbsp;  /**
&nbsp;     A static version of {@link #doConfigure(String, LoggerRepository)}.  */
&nbsp;  static
&nbsp;  public
&nbsp;  void configure(String filename) throws FactoryConfigurationError {
<b class="nc">&nbsp;    new DOMConfigurator().doConfigure(filename, </b>
&nbsp;				      LogManager.getLoggerRepository());
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     A static version of {@link #doConfigure(URL, LoggerRepository)}.
&nbsp;   */
&nbsp;  static
&nbsp;  public
&nbsp;  void configure(URL url) throws FactoryConfigurationError {
<b class="nc">&nbsp;    new DOMConfigurator().doConfigure(url, LogManager.getLoggerRepository());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Used internally to configure the log4j framework by parsing a DOM
&nbsp;     tree of XML elements based on &lt;a
&nbsp;     href=&quot;doc-files/log4j.dtd&quot;&gt;log4j.dtd&lt;/a&gt;.
&nbsp;     
&nbsp;  */
&nbsp;  protected
&nbsp;  void parse(Element element) {
&nbsp;
<b class="fc">&nbsp;    String rootElementName = element.getTagName();</b>
&nbsp;
<b class="pc">&nbsp;    if (!rootElementName.equals(CONFIGURATION_TAG)) {</b>
<b class="nc">&nbsp;      if(rootElementName.equals(OLD_CONFIGURATION_TAG)) {</b>
<b class="nc">&nbsp;	LogLog.warn(&quot;The &lt;&quot;+OLD_CONFIGURATION_TAG+</b>
&nbsp;		     &quot;&gt; element has been deprecated.&quot;);
<b class="nc">&nbsp;	LogLog.warn(&quot;Use the &lt;&quot;+CONFIGURATION_TAG+&quot;&gt; element instead.&quot;);</b>
&nbsp;      } else {
<b class="nc">&nbsp;	LogLog.error(&quot;DOM element is - not a &lt;&quot;+CONFIGURATION_TAG+&quot;&gt; element.&quot;);</b>
&nbsp;	return;
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;
<b class="fc">&nbsp;    String debugAttrib = subst(element.getAttribute(INTERNAL_DEBUG_ATTR));</b>
&nbsp;      
<b class="fc">&nbsp;    LogLog.debug(&quot;debug attribute= \&quot;&quot; + debugAttrib +&quot;\&quot;.&quot;);</b>
&nbsp;    // if the log4j.dtd is not specified in the XML file, then the
&nbsp;    // &quot;debug&quot; attribute is returned as the empty string.
<b class="pc">&nbsp;    if(!debugAttrib.equals(&quot;&quot;) &amp;&amp; !debugAttrib.equals(&quot;null&quot;)) {      </b>
<b class="nc">&nbsp;      LogLog.setInternalDebugging(OptionConverter.toBoolean(debugAttrib, true));</b>
&nbsp;    } else {
<b class="fc">&nbsp;      LogLog.debug(&quot;Ignoring &quot; + INTERNAL_DEBUG_ATTR + &quot; attribute.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;      //
&nbsp;      //   reset repository before configuration if reset=&quot;true&quot;
&nbsp;      //       on configuration element.
&nbsp;      //
<b class="fc">&nbsp;    String resetAttrib = subst(element.getAttribute(RESET_ATTR));</b>
<b class="fc">&nbsp;    LogLog.debug(&quot;reset attribute= \&quot;&quot; + resetAttrib +&quot;\&quot;.&quot;);</b>
<b class="pc">&nbsp;    if(!(&quot;&quot;.equals(resetAttrib))) {</b>
<b class="pc">&nbsp;         if (OptionConverter.toBoolean(resetAttrib, false)) {</b>
<b class="nc">&nbsp;             repository.resetConfiguration();</b>
&nbsp;         }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
<b class="fc">&nbsp;    String confDebug = subst(element.getAttribute(CONFIG_DEBUG_ATTR));</b>
<b class="pc">&nbsp;    if(!confDebug.equals(&quot;&quot;) &amp;&amp; !confDebug.equals(&quot;null&quot;)) {      </b>
<b class="nc">&nbsp;      LogLog.warn(&quot;The \&quot;&quot;+CONFIG_DEBUG_ATTR+&quot;\&quot; attribute is deprecated.&quot;);</b>
<b class="nc">&nbsp;      LogLog.warn(&quot;Use the \&quot;&quot;+INTERNAL_DEBUG_ATTR+&quot;\&quot; attribute instead.&quot;);</b>
<b class="nc">&nbsp;      LogLog.setInternalDebugging(OptionConverter.toBoolean(confDebug, true));</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    String thresholdStr = subst(element.getAttribute(THRESHOLD_ATTR));</b>
<b class="fc">&nbsp;    LogLog.debug(&quot;Threshold =\&quot;&quot; + thresholdStr +&quot;\&quot;.&quot;);</b>
<b class="pc">&nbsp;    if(!&quot;&quot;.equals(thresholdStr) &amp;&amp; !&quot;null&quot;.equals(thresholdStr)) {</b>
<b class="nc">&nbsp;      repository.setThreshold(thresholdStr);</b>
&nbsp;    }
&nbsp;
&nbsp;    //Hashtable appenderBag = new Hashtable(11);
&nbsp;
&nbsp;    /* Building Appender objects, placing them in a local namespace
&nbsp;       for future reference */
&nbsp;
&nbsp;    // First configure each category factory under the root element.
&nbsp;    // Category factories need to be configured before any of
&nbsp;    // categories they support.
&nbsp;    //
<b class="fc">&nbsp;    String   tagName = null;</b>
<b class="fc">&nbsp;    Element  currentElement = null;</b>
<b class="fc">&nbsp;    Node     currentNode = null;</b>
<b class="fc">&nbsp;    NodeList children = element.getChildNodes();</b>
<b class="fc">&nbsp;    final int length = children.getLength();</b>
&nbsp;
<b class="fc">&nbsp;    for (int loop = 0; loop &lt; length; loop++) {</b>
<b class="fc">&nbsp;      currentNode = children.item(loop);</b>
<b class="fc">&nbsp;      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {</b>
<b class="fc">&nbsp;	currentElement = (Element) currentNode;</b>
<b class="fc">&nbsp;	tagName = currentElement.getTagName();</b>
&nbsp;
<b class="pc">&nbsp;	if (tagName.equals(CATEGORY_FACTORY_TAG) || tagName.equals(LOGGER_FACTORY_TAG)) {</b>
<b class="nc">&nbsp;	  parseCategoryFactory(currentElement);</b>
&nbsp;	}
&nbsp;      }
&nbsp;    }
&nbsp;    
<b class="fc">&nbsp;    for (int loop = 0; loop &lt; length; loop++) {</b>
<b class="fc">&nbsp;      currentNode = children.item(loop);</b>
<b class="fc">&nbsp;      if (currentNode.getNodeType() == Node.ELEMENT_NODE) {</b>
<b class="fc">&nbsp;	currentElement = (Element) currentNode;</b>
<b class="fc">&nbsp;	tagName = currentElement.getTagName();</b>
&nbsp;
<b class="pc">&nbsp;	if (tagName.equals(CATEGORY) || tagName.equals(LOGGER)) {</b>
<b class="nc">&nbsp;	  parseCategory(currentElement);</b>
<b class="fc">&nbsp;	} else if (tagName.equals(ROOT_TAG)) {</b>
<b class="fc">&nbsp;	  parseRoot(currentElement);</b>
<b class="pc">&nbsp;	} else if(tagName.equals(RENDERER_TAG)) {</b>
<b class="nc">&nbsp;	  parseRenderer(currentElement);</b>
<b class="pc">&nbsp;    } else if(tagName.equals(THROWABLE_RENDERER_TAG)) {</b>
<b class="nc">&nbsp;        if (repository instanceof ThrowableRendererSupport) {</b>
<b class="nc">&nbsp;            ThrowableRenderer tr = parseThrowableRenderer(currentElement);</b>
<b class="nc">&nbsp;            if (tr != null) {</b>
<b class="nc">&nbsp;                ((ThrowableRendererSupport) repository).setThrowableRenderer(tr);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="pc">&nbsp;    } else if (!(tagName.equals(APPENDER_TAG)</b>
&nbsp;            || tagName.equals(CATEGORY_FACTORY_TAG)
&nbsp;            || tagName.equals(LOGGER_FACTORY_TAG))) {
<b class="nc">&nbsp;        quietParseUnrecognizedElement(repository, currentElement, props);</b>
&nbsp;    }
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  
&nbsp;  protected
&nbsp;  String subst(final String value) {
<b class="fc">&nbsp;      return subst(value, props);</b>
&nbsp;  }
&nbsp;
&nbsp;    /**
&nbsp;     * Substitutes property value for any references in expression.
&nbsp;     *
&nbsp;     * @param value value from configuration file, may contain
&nbsp;     *              literal text, property references or both
&nbsp;     * @param props properties.
&nbsp;     * @return evaluated expression, may still contain expressions
&nbsp;     *         if unable to expand.
&nbsp;     * @since 1.2.15
&nbsp;     */
&nbsp;    public static String subst(final String value, final Properties props) {
&nbsp;        try {
<b class="fc">&nbsp;            return OptionConverter.substVars(value, props);</b>
<b class="nc">&nbsp;        } catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;            LogLog.warn(&quot;Could not perform variable substitution.&quot;, e);</b>
<b class="nc">&nbsp;            return value;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Sets a parameter based from configuration file content.
&nbsp;     *
&nbsp;     * @param elem       param element, may not be null.
&nbsp;     * @param propSetter property setter, may not be null.
&nbsp;     * @param props      properties
&nbsp;     * @since 1.2.15
&nbsp;     */
&nbsp;    public static void setParameter(final Element elem,
&nbsp;                                    final PropertySetter propSetter,
&nbsp;                                    final Properties props) {
<b class="nc">&nbsp;        String name = subst(elem.getAttribute(&quot;name&quot;), props);</b>
<b class="nc">&nbsp;        String value = (elem.getAttribute(&quot;value&quot;));</b>
<b class="nc">&nbsp;        value = subst(OptionConverter.convertSpecialChars(value), props);</b>
<b class="nc">&nbsp;        propSetter.setProperty(name, value);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an object and processes any nested param elements
&nbsp;     * but does not call activateOptions.  If the class also supports
&nbsp;     * UnrecognizedElementParser, the parseUnrecognizedElement method
&nbsp;     * will be call for any child elements other than param.
&nbsp;     *
&nbsp;     * @param element       element, may not be null.
&nbsp;     * @param props         properties
&nbsp;     * @param expectedClass interface or class expected to be implemented
&nbsp;     *                      by created class
&nbsp;     * @return created class or null.
&nbsp;     * @throws Exception thrown if the contain object should be abandoned.
&nbsp;     * @since 1.2.15
&nbsp;     */
&nbsp;    public static Object parseElement(final Element element,
&nbsp;                                             final Properties props,
&nbsp;                                             final Class expectedClass) throws Exception {
<b class="nc">&nbsp;        String clazz = subst(element.getAttribute(&quot;class&quot;), props);</b>
<b class="nc">&nbsp;        Object instance = OptionConverter.instantiateByClassName(clazz,</b>
&nbsp;                expectedClass, null);
&nbsp;
<b class="nc">&nbsp;        if (instance != null) {</b>
<b class="nc">&nbsp;            PropertySetter propSetter = new PropertySetter(instance);</b>
<b class="nc">&nbsp;            NodeList children = element.getChildNodes();</b>
<b class="nc">&nbsp;            final int length = children.getLength();</b>
&nbsp;
<b class="nc">&nbsp;            for (int loop = 0; loop &lt; length; loop++) {</b>
<b class="nc">&nbsp;                Node currentNode = children.item(loop);</b>
<b class="nc">&nbsp;                if (currentNode.getNodeType() == Node.ELEMENT_NODE) {</b>
<b class="nc">&nbsp;                    Element currentElement = (Element) currentNode;</b>
<b class="nc">&nbsp;                    String tagName = currentElement.getTagName();</b>
<b class="nc">&nbsp;                    if (tagName.equals(&quot;param&quot;)) {</b>
<b class="nc">&nbsp;                        setParameter(currentElement, propSetter, props);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                         parseUnrecognizedElement(instance, currentElement, props);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return instance;</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;}
&nbsp;
&nbsp;
&nbsp;class XMLWatchdog extends FileWatchdog {
&nbsp;
&nbsp;    XMLWatchdog(String filename) {
&nbsp;    super(filename);
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;     Call {@link DOMConfigurator#configure(String)} with the
&nbsp;     &lt;code&gt;filename&lt;/code&gt; to reconfigure log4j. */
&nbsp;  public
&nbsp;  void doOnChange() {
&nbsp;    new DOMConfigurator().doConfigure(filename, 
&nbsp;				      LogManager.getLoggerRepository());
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
