


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Mockito</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.mockito</a>
</div>

<h1>Coverage Summary for Class: Mockito (org.mockito)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Mockito</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21,4%
  </span>
  <span class="absValue">
    (9/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31,5%
  </span>
  <span class="absValue">
    (17/54)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (c) 2007 Mockito contributors
&nbsp; * This program is made available under the terms of the MIT License.
&nbsp; */
&nbsp;package org.mockito;
&nbsp;
&nbsp;import org.mockito.exceptions.misusing.PotentialStubbingProblem;
&nbsp;import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
&nbsp;import org.mockito.internal.InternalMockHandler;
&nbsp;import org.mockito.internal.MockitoCore;
&nbsp;import org.mockito.internal.creation.MockSettingsImpl;
&nbsp;import org.mockito.internal.debugging.MockitoDebuggerImpl;
&nbsp;import org.mockito.internal.framework.DefaultMockitoFramework;
&nbsp;import org.mockito.internal.session.DefaultMockitoSessionBuilder;
&nbsp;import org.mockito.internal.verification.VerificationModeFactory;
&nbsp;import org.mockito.invocation.Invocation;
&nbsp;import org.mockito.invocation.InvocationFactory;
&nbsp;import org.mockito.invocation.MockHandler;
&nbsp;import org.mockito.junit.MockitoJUnit;
&nbsp;import org.mockito.junit.MockitoJUnitRunner;
&nbsp;import org.mockito.junit.MockitoRule;
&nbsp;import org.mockito.listeners.VerificationStartedEvent;
&nbsp;import org.mockito.listeners.VerificationStartedListener;
&nbsp;import org.mockito.mock.SerializableMode;
&nbsp;import org.mockito.plugins.MockMaker;
&nbsp;import org.mockito.plugins.MockitoPlugins;
&nbsp;import org.mockito.quality.MockitoHint;
&nbsp;import org.mockito.quality.Strictness;
&nbsp;import org.mockito.session.MockitoSessionBuilder;
&nbsp;import org.mockito.session.MockitoSessionLogger;
&nbsp;import org.mockito.stubbing.Answer;
&nbsp;import org.mockito.stubbing.Answer1;
&nbsp;import org.mockito.stubbing.LenientStubber;
&nbsp;import org.mockito.stubbing.OngoingStubbing;
&nbsp;import org.mockito.stubbing.Stubber;
&nbsp;import org.mockito.stubbing.Stubbing;
&nbsp;import org.mockito.stubbing.VoidAnswer1;
&nbsp;import org.mockito.verification.After;
&nbsp;import org.mockito.verification.Timeout;
&nbsp;import org.mockito.verification.VerificationAfterDelay;
&nbsp;import org.mockito.verification.VerificationMode;
&nbsp;import org.mockito.verification.VerificationWithTimeout;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;logo.png&quot; srcset=&quot;logo@2x.png 2x&quot; alt=&quot;Mockito logo&quot;/&gt;&lt;/p&gt;
&nbsp; * The Mockito library enables mock creation, verification and stubbing.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This javadoc content is also available on the &lt;a href=&quot;http://mockito.org&quot;&gt;http://mockito.org&lt;/a&gt; web page.
&nbsp; * All documentation is kept in javadocs because it guarantees consistency between what&#39;s on the web and what&#39;s in the source code.
&nbsp; * It allows access to documentation straight from the IDE even if you work offline.
&nbsp; * It motivates Mockito developers to keep documentation up-to-date with the code that they write,
&nbsp; * every day, with every commit.
&nbsp; *
&nbsp; * &lt;h1&gt;Contents&lt;/h1&gt;
&nbsp; *
&nbsp; * &lt;b&gt;
&nbsp; *      &lt;a href=&quot;#0&quot;&gt;0. Migrating to Mockito 2&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#0.1&quot;&gt;0.1 Mockito Android support&lt;/a&gt;&lt;/br/&gt;
&nbsp; *      &lt;a href=&quot;#0.2&quot;&gt;0.2 Configuration-free inline mock making&lt;/a&gt;&lt;/br/&gt;
&nbsp; *      &lt;a href=&quot;#1&quot;&gt;1. Let&#39;s verify some behaviour! &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#2&quot;&gt;2. How about some stubbing? &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#3&quot;&gt;3. Argument matchers &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#4&quot;&gt;4. Verifying exact number of invocations / at least once / never &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#5&quot;&gt;5. Stubbing void methods with exceptions &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#6&quot;&gt;6. Verification in order &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#7&quot;&gt;7. Making sure interaction(s) never happened on mock &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#8&quot;&gt;8. Finding redundant invocations &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#9&quot;&gt;9. Shorthand for mocks creation - &lt;code&gt;&amp;#064;Mock&lt;/code&gt; annotation &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#10&quot;&gt;10. Stubbing consecutive calls (iterator-style stubbing) &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#11&quot;&gt;11. Stubbing with callbacks &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#12&quot;&gt;12. &lt;code&gt;doReturn()&lt;/code&gt;|&lt;code&gt;doThrow()&lt;/code&gt;|&lt;code&gt;doAnswer()&lt;/code&gt;|&lt;code&gt;doNothing()&lt;/code&gt;|&lt;code&gt;doCallRealMethod()&lt;/code&gt; family of methods&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#13&quot;&gt;13. Spying on real objects &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#14&quot;&gt;14. Changing default return values of unstubbed invocations (Since 1.7) &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#15&quot;&gt;15. Capturing arguments for further assertions (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#16&quot;&gt;16. Real partial mocks (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#17&quot;&gt;17. Resetting mocks (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#18&quot;&gt;18. Troubleshooting &amp; validating framework usage (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#19&quot;&gt;19. Aliases for behavior driven development (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#20&quot;&gt;20. Serializable mocks (Since 1.8.1) &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#21&quot;&gt;21. New annotations: &lt;code&gt;&amp;#064;Captor&lt;/code&gt;, &lt;code&gt;&amp;#064;Spy&lt;/code&gt;, &lt;code&gt;&amp;#064;InjectMocks&lt;/code&gt; (Since 1.8.3) &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#22&quot;&gt;22. Verification with timeout (Since 1.8.5) &lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#23&quot;&gt;23. Automatic instantiation of &lt;code&gt;&amp;#064;Spies&lt;/code&gt;, &lt;code&gt;&amp;#064;InjectMocks&lt;/code&gt; and constructor injection goodness (Since 1.9.0)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#24&quot;&gt;24. One-liner stubs (Since 1.9.0)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#25&quot;&gt;25. Verification ignoring stubs (Since 1.9.0)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#26&quot;&gt;26. Mocking details (Improved in 2.2.x)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#27&quot;&gt;27. Delegate calls to real instance (Since 1.9.5)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#28&quot;&gt;28. &lt;code&gt;MockMaker&lt;/code&gt; API (Since 1.9.5)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#29&quot;&gt;29. BDD style verification (Since 1.10.0)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#30&quot;&gt;30. Spying or mocking abstract classes (Since 1.10.12, further enhanced in 2.7.13 and 2.7.14)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#31&quot;&gt;31. Mockito mocks can be &lt;em&gt;serialized&lt;/em&gt; / &lt;em&gt;deserialized&lt;/em&gt; across classloaders (Since 1.10.0)&lt;/a&gt;&lt;/h3&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#32&quot;&gt;32. Better generic support with deep stubs (Since 1.10.0)&lt;/a&gt;&lt;/h3&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#33&quot;&gt;33. Mockito JUnit rule (Since 1.10.17)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#34&quot;&gt;34. Switch &lt;em&gt;on&lt;/em&gt; or &lt;em&gt;off&lt;/em&gt; plugins (Since 1.10.15)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#35&quot;&gt;35. Custom verification failure message (Since 2.1.0)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#36&quot;&gt;36. Java 8 Lambda Matcher Support (Since 2.1.0)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#37&quot;&gt;37. Java 8 Custom Answer Support (Since 2.1.0)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#38&quot;&gt;38. Meta data and generic type retention (Since 2.1.0)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#39&quot;&gt;39. Mocking final types, enums and final methods (Since 2.1.0)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#40&quot;&gt;40. Improved productivity and cleaner tests with &quot;stricter&quot; Mockito (Since 2.+)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#41&quot;&gt;41. Advanced public API for framework integrations (Since 2.10.+)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#42&quot;&gt;42. New API for integrations: listening on verification start events (Since 2.11.+)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#43&quot;&gt;43. New API for integrations: &lt;code&gt;MockitoSession&lt;/code&gt; is usable by testing frameworks (Since 2.15.+)&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#44&quot;&gt;44. Deprecated &lt;code&gt;org.mockito.plugins.InstantiatorProvider&lt;/code&gt; as it was leaking internal API. it was replaced by &lt;code&gt;org.mockito.plugins.InstantiatorProvider2 (Since 2.15.4)&lt;/code&gt;&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#45&quot;&gt;45. New JUnit Jupiter (JUnit5+) extension&lt;/a&gt;&lt;br/&gt;
&nbsp; *      &lt;a href=&quot;#46&quot;&gt;46. New &lt;code&gt;Mockito.lenient()&lt;/code&gt; and &lt;code&gt;MockSettings.lenient()&lt;/code&gt; methods (Since 2.20.0&lt;/a&gt;&lt;br/&gt;
&nbsp; * &lt;/b&gt;
&nbsp; *
&nbsp; * &lt;h3 id=&quot;0&quot;&gt;0. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito2&quot; name=&quot;mockito2&quot;&gt;Migrating to Mockito 2&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * In order to continue improving Mockito and further improve the unit testing experience, we want you to upgrade to 2.1.0!
&nbsp; * Mockito follows &lt;a href=&quot;http://semver.org/&quot;&gt;semantic versioning&lt;/a&gt; and contains breaking changes only on major version upgrades.
&nbsp; * In the lifecycle of a library, breaking changes are necessary
&nbsp; * to roll out a set of brand new features that alter the existing behavior or even change the API.
&nbsp; * For a comprehensive guide on the new release including incompatible changes,
&nbsp; * see &#39;&lt;a href=&quot;https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2&quot;&gt;What&#39;s new in Mockito 2&lt;/a&gt;&#39; wiki page.
&nbsp; * We hope that you enjoy Mockito 2!
&nbsp; *
&nbsp; * &lt;h3 id=&quot;0.1&quot;&gt;0.1. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito-android&quot; name=&quot;mockito-android&quot;&gt;Mockito Android support&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * With Mockito version 2.6.1 we ship &quot;native&quot; Android support. To enable Android support, add the `mockito-android` library as dependency
&nbsp; * to your project. This artifact is published to the same Mockito organization and can be imported for Android as follows:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code&gt;
&nbsp; * repositories {
&nbsp; *   jcenter()
&nbsp; * }
&nbsp; * dependencies {
&nbsp; *   testCompile &quot;org.mockito:mockito-core:+&quot;
&nbsp; *   androidTestCompile &quot;org.mockito:mockito-android:+&quot;
&nbsp; * }
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * You can continue to run the same unit tests on a regular VM by using the `mockito-core` artifact in your &quot;testCompile&quot; scope as shown
&nbsp; * above. Be aware that you cannot use the &lt;a href=&quot;#39&quot;&gt;inline mock maker&lt;/a&gt; on Android due to limitations in the Android VM.
&nbsp; *
&nbsp; * If you encounter issues with mocking on Android, please open an issue
&nbsp; * &lt;a href=&quot;https://github.com/mockito/mockito/issues/new&quot;&gt;on the official issue tracker&lt;/a&gt;.
&nbsp; * Do provide the version of Android you are working on and dependencies of your project.
&nbsp; *
&nbsp; * &lt;h3 id=&quot;0.2&quot;&gt;0.2. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito-inline&quot; name=&quot;mockito-inline&quot;&gt;Configuration-free inline mock making&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * Starting with version 2.7.6, we offer the &#39;mockito-inline&#39; artifact that enables &lt;a href=&quot;#39&quot;&gt;inline mock making&lt;/a&gt; without configuring
&nbsp; * the MockMaker extension file. To use this, add the `mockito-inline` instead of the `mockito-core` artifact as follows:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code&gt;
&nbsp; * repositories {
&nbsp; *   jcenter()
&nbsp; * }
&nbsp; * dependencies {
&nbsp; *   testCompile &quot;org.mockito:mockito-inline:+&quot;
&nbsp; * }
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * Be aware that this artifact may be abolished when the inline mock making feature is integrated into the default mock maker.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * For more information about inline mock making, see &lt;a href=&quot;#39&quot;&gt;section 39&lt;/a&gt;.
&nbsp; *
&nbsp; * &lt;h3 id=&quot;1&quot;&gt;1. &lt;a class=&quot;meaningful_link&quot; href=&quot;#verification&quot; name=&quot;verification&quot;&gt;Let&#39;s verify some behaviour!&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * The following examples mock a List, because most people are familiar with the interface (such as the
&nbsp; * &lt;code&gt;add()&lt;/code&gt;, &lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;clear()&lt;/code&gt; methods). &lt;br&gt;
&nbsp; * In reality, please don&#39;t mock the List class. Use a real instance instead.
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * //Let&#39;s import Mockito statically so that the code looks clearer
&nbsp; * import static org.mockito.Mockito.*;
&nbsp; *
&nbsp; * //mock creation
&nbsp; * List mockedList = mock(List.class);
&nbsp; *
&nbsp; * //using mock object
&nbsp; * mockedList.add(&quot;one&quot;);
&nbsp; * mockedList.clear();
&nbsp; *
&nbsp; * //verification
&nbsp; * verify(mockedList).add(&quot;one&quot;);
&nbsp; * verify(mockedList).clear();
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Once created, a mock will remember all interactions. Then you can selectively
&nbsp; * verify whatever interactions you are interested in.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;2&quot;&gt;2. &lt;a class=&quot;meaningful_link&quot; href=&quot;#stubbing&quot; name=&quot;stubbing&quot;&gt;How about some stubbing?&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * //You can mock concrete classes, not just interfaces
&nbsp; * LinkedList mockedList = mock(LinkedList.class);
&nbsp; *
&nbsp; * //stubbing
&nbsp; * when(mockedList.get(0)).thenReturn(&quot;first&quot;);
&nbsp; * when(mockedList.get(1)).thenThrow(new RuntimeException());
&nbsp; *
&nbsp; * //following prints &quot;first&quot;
&nbsp; * System.out.println(mockedList.get(0));
&nbsp; *
&nbsp; * //following throws runtime exception
&nbsp; * System.out.println(mockedList.get(1));
&nbsp; *
&nbsp; * //following prints &quot;null&quot; because get(999) was not stubbed
&nbsp; * System.out.println(mockedList.get(999));
&nbsp; *
&nbsp; * //Although it is possible to verify a stubbed invocation, usually &lt;b&gt;it&#39;s just redundant&lt;/b&gt;
&nbsp; * //If your code cares what get(0) returns, then something else breaks (often even before verify() gets executed).
&nbsp; * //If your code doesn&#39;t care what get(0) returns, then it should not be stubbed. Not convinced? See &lt;a href=&quot;http://monkeyisland.pl/2008/04/26/asking-and-telling&quot;&gt;here&lt;/a&gt;.
&nbsp; * verify(mockedList).get(0);
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt; By default, for all methods that return a value, a mock will return either null,
&nbsp; * a primitive/primitive wrapper value, or an empty collection, as appropriate.
&nbsp; * For example 0 for an int/Integer and false for a boolean/Boolean. &lt;/li&gt;
&nbsp; *
&nbsp; * &lt;li&gt; Stubbing can be overridden: for example common stubbing can go to
&nbsp; * fixture setup but the test methods can override it.
&nbsp; * Please note that overridding stubbing is a potential code smell that points out too much stubbing&lt;/li&gt;
&nbsp; *
&nbsp; * &lt;li&gt; Once stubbed, the method will always return a stubbed value, regardless
&nbsp; * of how many times it is called. &lt;/li&gt;
&nbsp; *
&nbsp; * &lt;li&gt; Last stubbing is more important - when you stubbed the same method with
&nbsp; * the same arguments many times.
&nbsp; * Other words: &lt;b&gt;the order of stubbing matters&lt;/b&gt; but it is only meaningful rarely,
&nbsp; * e.g. when stubbing exactly the same method calls or sometimes when argument matchers are used, etc.&lt;/li&gt;
&nbsp; *
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;3&quot;&gt;3. &lt;a class=&quot;meaningful_link&quot; href=&quot;#argument_matchers&quot; name=&quot;argument_matchers&quot;&gt;Argument matchers&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * Mockito verifies argument values in natural java style: by using an &lt;code&gt;equals()&lt;/code&gt; method.
&nbsp; * Sometimes, when extra flexibility is required then you might use argument matchers:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * //stubbing using built-in anyInt() argument matcher
&nbsp; * when(mockedList.get(anyInt())).thenReturn(&quot;element&quot;);
&nbsp; *
&nbsp; * //stubbing using custom matcher (let&#39;s say isValid() returns your own matcher implementation):
&nbsp; * when(mockedList.contains(argThat(isValid()))).thenReturn(&quot;element&quot;);
&nbsp; *
&nbsp; * //following prints &quot;element&quot;
&nbsp; * System.out.println(mockedList.get(999));
&nbsp; *
&nbsp; * //&lt;b&gt;you can also verify using an argument matcher&lt;/b&gt;
&nbsp; * verify(mockedList).get(anyInt());
&nbsp; *
&nbsp; * //&lt;b&gt;argument matchers can also be written as Java 8 Lambdas&lt;/b&gt;
&nbsp; * verify(mockedList).add(argThat(someString -&gt; someString.length() &gt; 5));
&nbsp; *
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Argument matchers allow flexible verification or stubbing.
&nbsp; * {@link ArgumentMatchers Click here} {@link org.mockito.hamcrest.MockitoHamcrest or here} to see more built-in matchers
&nbsp; * and examples of &lt;b&gt;custom argument matchers / hamcrest matchers&lt;/b&gt;.
&nbsp; * &lt;p&gt;
&nbsp; * For information solely on &lt;b&gt;custom argument matchers&lt;/b&gt; check out javadoc for {@link ArgumentMatcher} class.
&nbsp; * &lt;p&gt;
&nbsp; * Be reasonable with using complicated argument matching.
&nbsp; * The natural matching style using &lt;code&gt;equals()&lt;/code&gt; with occasional &lt;code&gt;anyX()&lt;/code&gt; matchers tend to give clean &amp; simple tests.
&nbsp; * Sometimes it&#39;s just better to refactor the code to allow &lt;code&gt;equals()&lt;/code&gt; matching or even implement &lt;code&gt;equals()&lt;/code&gt; method to help out with testing.
&nbsp; * &lt;p&gt;
&nbsp; * Also, read &lt;a href=&quot;#15&quot;&gt;section 15&lt;/a&gt; or javadoc for {@link ArgumentCaptor} class.
&nbsp; * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Warning on argument matchers:&lt;/b&gt;
&nbsp; * &lt;p&gt;
&nbsp; * If you are using argument matchers, &lt;b&gt;all arguments&lt;/b&gt; have to be provided
&nbsp; * by matchers.
&nbsp; * &lt;p&gt;
&nbsp; The following example shows verification but the same applies to stubbing:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   verify(mock).someMethod(anyInt(), anyString(), &lt;b&gt;eq(&quot;third argument&quot;)&lt;/b&gt;);
&nbsp; *   //above is correct - eq() is also an argument matcher
&nbsp; *
&nbsp; *   verify(mock).someMethod(anyInt(), anyString(), &lt;b&gt;&quot;third argument&quot;&lt;/b&gt;);
&nbsp; *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Matcher methods like &lt;code&gt;anyObject()&lt;/code&gt;, &lt;code&gt;eq()&lt;/code&gt; &lt;b&gt;do not&lt;/b&gt; return matchers.
&nbsp; * Internally, they record a matcher on a stack and return a dummy value (usually null).
&nbsp; * This implementation is due to static type safety imposed by the java compiler.
&nbsp; * The consequence is that you cannot use &lt;code&gt;anyObject()&lt;/code&gt;, &lt;code&gt;eq()&lt;/code&gt; methods outside of verified/stubbed method.
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;4&quot;&gt;4. &lt;a class=&quot;meaningful_link&quot; href=&quot;#exact_verification&quot; name=&quot;exact_verification&quot;&gt;Verifying exact number of invocations&lt;/a&gt; /
&nbsp; * &lt;a class=&quot;meaningful_link&quot; href=&quot;#at_least_verification&quot; name=&quot;at_least_verification&quot;&gt;at least x&lt;/a&gt; / never&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * //using mock
&nbsp; * mockedList.add(&quot;once&quot;);
&nbsp; *
&nbsp; * mockedList.add(&quot;twice&quot;);
&nbsp; * mockedList.add(&quot;twice&quot;);
&nbsp; *
&nbsp; * mockedList.add(&quot;three times&quot;);
&nbsp; * mockedList.add(&quot;three times&quot;);
&nbsp; * mockedList.add(&quot;three times&quot;);
&nbsp; *
&nbsp; * //following two verifications work exactly the same - times(1) is used by default
&nbsp; * verify(mockedList).add(&quot;once&quot;);
&nbsp; * verify(mockedList, times(1)).add(&quot;once&quot;);
&nbsp; *
&nbsp; * //exact number of invocations verification
&nbsp; * verify(mockedList, times(2)).add(&quot;twice&quot;);
&nbsp; * verify(mockedList, times(3)).add(&quot;three times&quot;);
&nbsp; *
&nbsp; * //verification using never(). never() is an alias to times(0)
&nbsp; * verify(mockedList, never()).add(&quot;never happened&quot;);
&nbsp; *
&nbsp; * //verification using atLeast()/atMost()
&nbsp; * verify(mockedList, atLeastOnce()).add(&quot;three times&quot;);
&nbsp; * verify(mockedList, atLeast(2)).add(&quot;three times&quot;);
&nbsp; * verify(mockedList, atMost(5)).add(&quot;three times&quot;);
&nbsp; *
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;times(1) is the default.&lt;/b&gt; Therefore using times(1) explicitly can be
&nbsp; * omitted.
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;5&quot;&gt;5. &lt;a class=&quot;meaningful_link&quot; href=&quot;#stubbing_with_exceptions&quot; name=&quot;stubbing_with_exceptions&quot;&gt;Stubbing void methods with exceptions&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   doThrow(new RuntimeException()).when(mockedList).clear();
&nbsp; *
&nbsp; *   //following throws RuntimeException:
&nbsp; *   mockedList.clear();
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * Read more about &lt;code&gt;doThrow()&lt;/code&gt;|&lt;code&gt;doAnswer()&lt;/code&gt; family of methods in &lt;a href=&quot;#12&quot;&gt;section 12&lt;/a&gt;.
&nbsp; * &lt;p&gt;
&nbsp; *
&nbsp; * &lt;h3 id=&quot;6&quot;&gt;6. &lt;a class=&quot;meaningful_link&quot; href=&quot;#in_order_verification&quot; name=&quot;in_order_verification&quot;&gt;Verification in order&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * // A. Single mock whose methods must be invoked in a particular order
&nbsp; * List singleMock = mock(List.class);
&nbsp; *
&nbsp; * //using a single mock
&nbsp; * singleMock.add(&quot;was added first&quot;);
&nbsp; * singleMock.add(&quot;was added second&quot;);
&nbsp; *
&nbsp; * //create an inOrder verifier for a single mock
&nbsp; * InOrder inOrder = inOrder(singleMock);
&nbsp; *
&nbsp; * //following will make sure that add is first called with &quot;was added first, then with &quot;was added second&quot;
&nbsp; * inOrder.verify(singleMock).add(&quot;was added first&quot;);
&nbsp; * inOrder.verify(singleMock).add(&quot;was added second&quot;);
&nbsp; *
&nbsp; * // B. Multiple mocks that must be used in a particular order
&nbsp; * List firstMock = mock(List.class);
&nbsp; * List secondMock = mock(List.class);
&nbsp; *
&nbsp; * //using mocks
&nbsp; * firstMock.add(&quot;was called first&quot;);
&nbsp; * secondMock.add(&quot;was called second&quot;);
&nbsp; *
&nbsp; * //create inOrder object passing any mocks that need to be verified in order
&nbsp; * InOrder inOrder = inOrder(firstMock, secondMock);
&nbsp; *
&nbsp; * //following will make sure that firstMock was called before secondMock
&nbsp; * inOrder.verify(firstMock).add(&quot;was called first&quot;);
&nbsp; * inOrder.verify(secondMock).add(&quot;was called second&quot;);
&nbsp; *
&nbsp; * // Oh, and A + B can be mixed together at will
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * Verification in order is flexible - &lt;b&gt;you don&#39;t have to verify all
&nbsp; * interactions&lt;/b&gt; one-by-one but only those that you are interested in
&nbsp; * testing in order.
&nbsp; * &lt;p&gt;
&nbsp; * Also, you can create an InOrder object passing only the mocks that are relevant for
&nbsp; * in-order verification.
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;7&quot;&gt;7. &lt;a class=&quot;meaningful_link&quot; href=&quot;#never_verification&quot; name=&quot;never_verification&quot;&gt;Making sure interaction(s) never happened on mock&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * //using mocks - only mockOne is interacted
&nbsp; * mockOne.add(&quot;one&quot;);
&nbsp; *
&nbsp; * //ordinary verification
&nbsp; * verify(mockOne).add(&quot;one&quot;);
&nbsp; *
&nbsp; * //verify that method was never called on a mock
&nbsp; * verify(mockOne, never()).add(&quot;two&quot;);
&nbsp; *
&nbsp; * //verify that other mocks were not interacted
&nbsp; * verifyZeroInteractions(mockTwo, mockThree);
&nbsp; *
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;8&quot;&gt;8. &lt;a class=&quot;meaningful_link&quot; href=&quot;#finding_redundant_invocations&quot; name=&quot;finding_redundant_invocations&quot;&gt;Finding redundant invocations&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * //using mocks
&nbsp; * mockedList.add(&quot;one&quot;);
&nbsp; * mockedList.add(&quot;two&quot;);
&nbsp; *
&nbsp; * verify(mockedList).add(&quot;one&quot;);
&nbsp; *
&nbsp; * //following verification will fail
&nbsp; * verifyNoMoreInteractions(mockedList);
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * A word of &lt;b&gt;warning&lt;/b&gt;:
&nbsp; * Some users who did a lot of classic, expect-run-verify mocking tend to use &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; very often, even in every test method.
&nbsp; * &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; is not recommended to use in every test method.
&nbsp; * &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; is a handy assertion from the interaction testing toolkit. Use it only when it&#39;s relevant.
&nbsp; * Abusing it leads to &lt;strong&gt;overspecified&lt;/strong&gt;, &lt;strong&gt;less maintainable&lt;/strong&gt; tests. You can find further reading
&nbsp; * &lt;a href=&quot;http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/&quot;&gt;here&lt;/a&gt;.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * See also {@link Mockito#never()} - it is more explicit and
&nbsp; * communicates the intent well.
&nbsp; * &lt;p&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;9&quot;&gt;9. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mock_annotation&quot; name=&quot;mock_annotation&quot;&gt;Shorthand for mocks creation - &lt;code&gt;&amp;#064;Mock&lt;/code&gt; annotation&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;Minimizes repetitive mock creation code.&lt;/li&gt;
&nbsp; * &lt;li&gt;Makes the test class more readable.&lt;/li&gt;
&nbsp; * &lt;li&gt;Makes the verification error easier to read because the &lt;b&gt;field name&lt;/b&gt;
&nbsp; * is used to identify the mock.&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   public class ArticleManagerTest {
&nbsp; *
&nbsp; *       &amp;#064;Mock private ArticleCalculator calculator;
&nbsp; *       &amp;#064;Mock private ArticleDatabase database;
&nbsp; *       &amp;#064;Mock private UserProvider userProvider;
&nbsp; *
&nbsp; *       private ArticleManager manager;
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;b&gt;Important!&lt;/b&gt; This needs to be somewhere in the base class or a test
&nbsp; * runner:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * MockitoAnnotations.initMocks(testClass);
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * You can use built-in runner: {@link MockitoJUnitRunner} or a rule: {@link MockitoRule}.
&nbsp; * &lt;p&gt;
&nbsp; * Read more here: {@link MockitoAnnotations}
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;10&quot;&gt;10. &lt;a class=&quot;meaningful_link&quot; href=&quot;#stubbing_consecutive_calls&quot; name=&quot;stubbing_consecutive_calls&quot;&gt;Stubbing consecutive calls&lt;/a&gt; (iterator-style stubbing)&lt;/h3&gt;
&nbsp; *
&nbsp; * Sometimes we need to stub with different return value/exception for the same
&nbsp; * method call. Typical use case could be mocking iterators.
&nbsp; * Original version of Mockito did not have this feature to promote simple mocking.
&nbsp; * For example, instead of iterators one could use {@link Iterable} or simply
&nbsp; * collections. Those offer natural ways of stubbing (e.g. using real
&nbsp; * collections). In rare scenarios stubbing consecutive calls could be useful,
&nbsp; * though:
&nbsp; * &lt;p&gt;
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * when(mock.someMethod(&quot;some arg&quot;))
&nbsp; *   .thenThrow(new RuntimeException())
&nbsp; *   .thenReturn(&quot;foo&quot;);
&nbsp; *
&nbsp; * //First call: throws runtime exception:
&nbsp; * mock.someMethod(&quot;some arg&quot;);
&nbsp; *
&nbsp; * //Second call: prints &quot;foo&quot;
&nbsp; * System.out.println(mock.someMethod(&quot;some arg&quot;));
&nbsp; *
&nbsp; * //Any consecutive call: prints &quot;foo&quot; as well (last stubbing wins).
&nbsp; * System.out.println(mock.someMethod(&quot;some arg&quot;));
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * Alternative, shorter version of consecutive stubbing:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * when(mock.someMethod(&quot;some arg&quot;))
&nbsp; *   .thenReturn(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;strong&gt;Warning&lt;/strong&gt; : if instead of chaining {@code .thenReturn()} calls, multiple stubbing with the same matchers or arguments
&nbsp; * is used, then each stubbing will override the previous one:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * //All mock.someMethod(&quot;some arg&quot;) calls will return &quot;two&quot;
&nbsp; * when(mock.someMethod(&quot;some arg&quot;))
&nbsp; *   .thenReturn(&quot;one&quot;)
&nbsp; * when(mock.someMethod(&quot;some arg&quot;))
&nbsp; *   .thenReturn(&quot;two&quot;)
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;11&quot;&gt;11. &lt;a class=&quot;meaningful_link&quot; href=&quot;#answer_stubs&quot; name=&quot;answer_stubs&quot;&gt;Stubbing with callbacks&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * Allows stubbing with generic {@link Answer} interface.
&nbsp; * &lt;p&gt;
&nbsp; * Yet another controversial feature which was not included in Mockito
&nbsp; * originally. We recommend simply stubbing with &lt;code&gt;thenReturn()&lt;/code&gt; or
&nbsp; * &lt;code&gt;thenThrow()&lt;/code&gt;, which should be enough to test/test-drive
&nbsp; * any clean &amp; simple code. However, if you do have a need to stub with the generic Answer interface, here is an example:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * when(mock.someMethod(anyString())).thenAnswer(
&nbsp; *     new Answer() {
&nbsp; *         public Object answer(InvocationOnMock invocation) {
&nbsp; *             Object[] args = invocation.getArguments();
&nbsp; *             Object mock = invocation.getMock();
&nbsp; *             return &quot;called with arguments: &quot; + Arrays.toString(args);
&nbsp; *         }
&nbsp; * });
&nbsp; *
&nbsp; * //Following prints &quot;called with arguments: [foo]&quot;
&nbsp; * System.out.println(mock.someMethod(&quot;foo&quot;));
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;12&quot;&gt;12. &lt;a class=&quot;meaningful_link&quot; href=&quot;#do_family_methods_stubs&quot; name=&quot;do_family_methods_stubs&quot;&gt;&lt;code&gt;doReturn()&lt;/code&gt;|&lt;code&gt;doThrow()&lt;/code&gt;|
&nbsp; * &lt;code&gt;doAnswer()&lt;/code&gt;|&lt;code&gt;doNothing()&lt;/code&gt;|&lt;code&gt;doCallRealMethod()&lt;/code&gt; family of methods&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * Stubbing void methods requires a different approach from {@link Mockito#when(Object)} because the compiler does not
&nbsp; * like void methods inside brackets...
&nbsp; * &lt;p&gt;
&nbsp; * Use &lt;code&gt;doThrow()&lt;/code&gt; when you want to stub a void method with an exception:
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   doThrow(new RuntimeException()).when(mockedList).clear();
&nbsp; *
&nbsp; *   //following throws RuntimeException:
&nbsp; *   mockedList.clear();
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * You can use &lt;code&gt;doThrow()&lt;/code&gt;, &lt;code&gt;doAnswer()&lt;/code&gt;, &lt;code&gt;doNothing()&lt;/code&gt;, &lt;code&gt;doReturn()&lt;/code&gt;
&nbsp; * and &lt;code&gt;doCallRealMethod()&lt;/code&gt; in place of the corresponding call with &lt;code&gt;when()&lt;/code&gt;, for any method.
&nbsp; * It is necessary when you
&nbsp; * &lt;ul&gt;
&nbsp; *     &lt;li&gt;stub void methods&lt;/li&gt;
&nbsp; *     &lt;li&gt;stub methods on spy objects (see below)&lt;/li&gt;
&nbsp; *     &lt;li&gt;stub the same method more than once, to change the behaviour of a mock in the middle of a test.&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * but you may prefer to use these methods in place of the alternative with &lt;code&gt;when()&lt;/code&gt;, for all of your stubbing calls.
&nbsp; * &lt;p&gt;
&nbsp; * Read more about these methods:
&nbsp; * &lt;p&gt;
&nbsp; * {@link Mockito#doReturn(Object)}
&nbsp; * &lt;p&gt;
&nbsp; * {@link Mockito#doThrow(Throwable...)}
&nbsp; * &lt;p&gt;
&nbsp; * {@link Mockito#doThrow(Class)}
&nbsp; * &lt;p&gt;
&nbsp; * {@link Mockito#doAnswer(Answer)}
&nbsp; * &lt;p&gt;
&nbsp; * {@link Mockito#doNothing()}
&nbsp; * &lt;p&gt;
&nbsp; * {@link Mockito#doCallRealMethod()}
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;13&quot;&gt;13. &lt;a class=&quot;meaningful_link&quot; href=&quot;#spy&quot; name=&quot;spy&quot;&gt;Spying on real objects&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * You can create spies of real objects. When you use the spy then the &lt;b&gt;real&lt;/b&gt; methods are called
&nbsp; * (unless a method was stubbed).
&nbsp; * &lt;p&gt;
&nbsp; * Real spies should be used &lt;b&gt;carefully and occasionally&lt;/b&gt;, for example when dealing with legacy code.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Spying on real objects can be associated with &quot;partial mocking&quot; concept.
&nbsp; * &lt;b&gt;Before the release 1.8&lt;/b&gt;, Mockito spies were not real partial mocks.
&nbsp; * The reason was we thought partial mock is a code smell.
&nbsp; * At some point we found legitimate use cases for partial mocks
&nbsp; * (3rd party interfaces, interim refactoring of legacy code, the full article is
&nbsp; * &lt;a href=&quot;http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring&quot;&gt;here&lt;/a&gt;)
&nbsp; * &lt;p&gt;
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   List list = new LinkedList();
&nbsp; *   List spy = spy(list);
&nbsp; *
&nbsp; *   //optionally, you can stub out some methods:
&nbsp; *   when(spy.size()).thenReturn(100);
&nbsp; *
&nbsp; *   //using the spy calls &lt;b&gt;*real*&lt;/b&gt; methods
&nbsp; *   spy.add(&quot;one&quot;);
&nbsp; *   spy.add(&quot;two&quot;);
&nbsp; *
&nbsp; *   //prints &quot;one&quot; - the first element of a list
&nbsp; *   System.out.println(spy.get(0));
&nbsp; *
&nbsp; *   //size() method was stubbed - 100 is printed
&nbsp; *   System.out.println(spy.size());
&nbsp; *
&nbsp; *   //optionally, you can verify
&nbsp; *   verify(spy).add(&quot;one&quot;);
&nbsp; *   verify(spy).add(&quot;two&quot;);
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;h4&gt;Important gotcha on spying real objects!&lt;/h4&gt;
&nbsp; * &lt;ol&gt;
&nbsp; * &lt;li&gt;Sometimes it&#39;s impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.
&nbsp; * Therefore when using spies please consider &lt;code&gt;doReturn&lt;/code&gt;|&lt;code&gt;Answer&lt;/code&gt;|&lt;code&gt;Throw()&lt;/code&gt; family of
&nbsp; * methods for stubbing. Example:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   List list = new LinkedList();
&nbsp; *   List spy = spy(list);
&nbsp; *
&nbsp; *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
&nbsp; *   when(spy.get(0)).thenReturn(&quot;foo&quot;);
&nbsp; *
&nbsp; *   //You have to use doReturn() for stubbing
&nbsp; *   doReturn(&quot;foo&quot;).when(spy).get(0);
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; * &lt;/li&gt;
&nbsp; *
&nbsp; * &lt;li&gt;Mockito &lt;b&gt;*does not*&lt;/b&gt; delegate calls to the passed real instance, instead it actually creates a copy of it.
&nbsp; * So if you keep the real instance and interact with it, don&#39;t expect the spied to be aware of those interaction
&nbsp; * and their effect on real instance state.
&nbsp; * The corollary is that when an &lt;b&gt;*unstubbed*&lt;/b&gt; method is called &lt;b&gt;*on the spy*&lt;/b&gt; but &lt;b&gt;*not on the real instance*&lt;/b&gt;,
&nbsp; * you won&#39;t see any effects on the real instance.
&nbsp; * &lt;/li&gt;
&nbsp; *
&nbsp; * &lt;li&gt;Watch out for final methods.
&nbsp; * Mockito doesn&#39;t mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
&nbsp; * Also you won&#39;t be able to verify those method as well.
&nbsp; * &lt;/li&gt;
&nbsp; * &lt;/ol&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;14&quot;&gt;14. Changing &lt;a class=&quot;meaningful_link&quot; href=&quot;#defaultreturn&quot; name=&quot;defaultreturn&quot;&gt;default return values of unstubbed invocations&lt;/a&gt; (Since 1.7)&lt;/h3&gt;
&nbsp; *
&nbsp; * You can create a mock with specified strategy for its return values.
&nbsp; * It&#39;s quite an advanced feature and typically you don&#39;t need it to write decent tests.
&nbsp; * However, it can be helpful for working with &lt;b&gt;legacy systems&lt;/b&gt;.
&nbsp; * &lt;p&gt;
&nbsp; * It is the default answer so it will be used &lt;b&gt;only when you don&#39;t&lt;/b&gt; stub the method call.
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
&nbsp; *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Read more about this interesting implementation of &lt;i&gt;Answer&lt;/i&gt;: {@link Mockito#RETURNS_SMART_NULLS}
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;15&quot;&gt;15. &lt;a class=&quot;meaningful_link&quot; href=&quot;#captors&quot; name=&quot;captors&quot;&gt;Capturing arguments&lt;/a&gt; for further assertions (Since 1.8.0)&lt;/h3&gt;
&nbsp; *
&nbsp; * Mockito verifies argument values in natural java style: by using an &lt;code&gt;equals()&lt;/code&gt; method.
&nbsp; * This is also the recommended way of matching arguments because it makes tests clean &amp; simple.
&nbsp; * In some situations though, it is helpful to assert on certain arguments after the actual verification.
&nbsp; * For example:
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   ArgumentCaptor&amp;lt;Person&amp;gt; argument = ArgumentCaptor.forClass(Person.class);
&nbsp; *   verify(mock).doSomething(argument.capture());
&nbsp; *   assertEquals(&quot;John&quot;, argument.getValue().getName());
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;b&gt;Warning:&lt;/b&gt; it is recommended to use ArgumentCaptor with verification &lt;b&gt;but not&lt;/b&gt; with stubbing.
&nbsp; * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or &#39;then&#39;) block.
&nbsp; * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.
&nbsp; * &lt;p&gt;
&nbsp; * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).
&nbsp; * Both techniques can be used for making sure certain arguments where passed to mocks.
&nbsp; * However, ArgumentCaptor may be a better fit if:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;custom argument matcher is not likely to be reused&lt;/li&gt;
&nbsp; * &lt;li&gt;you just need it to assert on argument values to complete verification&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;16&quot;&gt;16. &lt;a class=&quot;meaningful_link&quot; href=&quot;#partial_mocks&quot; name=&quot;partial_mocks&quot;&gt;Real partial mocks&lt;/a&gt; (Since 1.8.0)&lt;/h3&gt;
&nbsp; *
&nbsp; *  Finally, after many internal debates &amp; discussions on the mailing list, partial mock support was added to Mockito.
&nbsp; *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:
&nbsp; *  &lt;a href=&quot;http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring&quot;&gt;here&lt;/a&gt;
&nbsp; *  &lt;p&gt;
&nbsp; *  &lt;b&gt;Before release 1.8&lt;/b&gt; &lt;code&gt;spy()&lt;/code&gt; was not producing real partial mocks and it was confusing for some users.
&nbsp; *  Read more about spying: &lt;a href=&quot;#13&quot;&gt;here&lt;/a&gt; or in javadoc for {@link Mockito#spy(Object)} method.
&nbsp; *  &lt;p&gt;
&nbsp; *  &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *    //you can create partial mock with spy() method:
&nbsp; *    List list = spy(new LinkedList());
&nbsp; *
&nbsp; *    //you can enable partial mock capabilities selectively on mocks:
&nbsp; *    Foo mock = mock(Foo.class);
&nbsp; *    //Be sure the real implementation is &#39;safe&#39;.
&nbsp; *    //If real implementation throws exceptions or depends on specific state of the object then you&#39;re in trouble.
&nbsp; *    when(mock.someMethod()).thenCallRealMethod();
&nbsp; *  &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * As usual you are going to read &lt;b&gt;the partial mock warning&lt;/b&gt;:
&nbsp; * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
&nbsp; * How does partial mock fit into this paradigm? Well, it just doesn&#39;t...
&nbsp; * Partial mock usually means that the complexity has been moved to a different method on the same object.
&nbsp; * In most cases, this is not the way you want to design your application.
&nbsp; * &lt;p&gt;
&nbsp; * However, there are rare cases when partial mocks come handy:
&nbsp; * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
&nbsp; * However, I wouldn&#39;t use partial mocks for new, test-driven &amp; well-designed code.
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;17&quot;&gt;17. &lt;a class=&quot;meaningful_link&quot; href=&quot;#resetting_mocks&quot; name=&quot;resetting_mocks&quot;&gt;Resetting mocks&lt;/a&gt; (Since 1.8.0)&lt;/h3&gt;
&nbsp; *
&nbsp; * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
&nbsp; * Normally, you don&#39;t need to reset your mocks, just create new mocks for each test method.
&nbsp; * &lt;p&gt;
&nbsp; * Instead of &lt;code&gt;reset()&lt;/code&gt; please consider writing simple, small and focused test methods over lengthy, over-specified tests.
&nbsp; * &lt;b&gt;First potential code smell is &lt;code&gt;reset()&lt;/code&gt; in the middle of the test method.&lt;/b&gt; This probably means you&#39;re testing too much.
&nbsp; * Follow the whisper of your test methods: &quot;Please keep us small &amp; focused on single behavior&quot;.
&nbsp; * There are several threads about it on mockito mailing list.
&nbsp; * &lt;p&gt;
&nbsp; * The only reason we added &lt;code&gt;reset()&lt;/code&gt; method is to
&nbsp; * make it possible to work with container-injected mocks.
&nbsp; * For more information see FAQ (&lt;a href=&quot;https://github.com/mockito/mockito/wiki/FAQ&quot;&gt;here&lt;/a&gt;).
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Don&#39;t harm yourself.&lt;/b&gt; &lt;code&gt;reset()&lt;/code&gt; in the middle of the test method is a code smell (you&#39;re probably testing too much).
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   List mock = mock(List.class);
&nbsp; *   when(mock.size()).thenReturn(10);
&nbsp; *   mock.add(1);
&nbsp; *
&nbsp; *   reset(mock);
&nbsp; *   //at this point the mock forgot any interactions &amp; stubbing
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;18&quot;&gt;18. &lt;a class=&quot;meaningful_link&quot; href=&quot;#framework_validation&quot; name=&quot;framework_validation&quot;&gt;Troubleshooting &amp; validating framework usage&lt;/a&gt; (Since 1.8.0)&lt;/h3&gt;
&nbsp; *
&nbsp; * First of all, in case of any trouble, I encourage you to read the Mockito FAQ:
&nbsp; * &lt;a href=&quot;https://github.com/mockito/mockito/wiki/FAQ&quot;&gt;https://github.com/mockito/mockito/wiki/FAQ&lt;/a&gt;
&nbsp; * &lt;p&gt;
&nbsp; * In case of questions you may also post to mockito mailing list:
&nbsp; * &lt;a href=&quot;http://groups.google.com/group/mockito&quot;&gt;http://groups.google.com/group/mockito&lt;/a&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Next, you should know that Mockito validates if you use it correctly &lt;b&gt;all the time&lt;/b&gt;.
&nbsp; * However, there&#39;s a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;19&quot;&gt;19. &lt;a class=&quot;meaningful_link&quot; href=&quot;#bdd_mockito&quot; name=&quot;bdd_mockito&quot;&gt;Aliases for behavior driven development&lt;/a&gt; (Since 1.8.0)&lt;/h3&gt;
&nbsp; *
&nbsp; * Behavior Driven Development style of writing tests uses &lt;b&gt;//given //when //then&lt;/b&gt; comments as fundamental parts of your test methods.
&nbsp; * This is exactly how we write our tests and we warmly encourage you to do so!
&nbsp; * &lt;p&gt;
&nbsp; * Start learning about BDD here: &lt;a href=&quot;http://en.wikipedia.org/wiki/Behavior_Driven_Development&quot;&gt;http://en.wikipedia.org/wiki/Behavior_Driven_Development&lt;/a&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The problem is that current stubbing api with canonical role of &lt;b&gt;when&lt;/b&gt; word does not integrate nicely with &lt;b&gt;//given //when //then&lt;/b&gt; comments.
&nbsp; * It&#39;s because stubbing belongs to &lt;b&gt;given&lt;/b&gt; component of the test and not to the &lt;b&gt;when&lt;/b&gt; component of the test.
&nbsp; * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method.
&nbsp; * Now it really nicely integrates with the &lt;b&gt;given&lt;/b&gt; component of a BDD style test!
&nbsp; * &lt;p&gt;
&nbsp; * Here is how the test might look like:
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * import static org.mockito.BDDMockito.*;
&nbsp; *
&nbsp; * Seller seller = mock(Seller.class);
&nbsp; * Shop shop = new Shop(seller);
&nbsp; *
&nbsp; * public void shouldBuyBread() throws Exception {
&nbsp; *   //given
&nbsp; *   given(seller.askForBread()).willReturn(new Bread());
&nbsp; *
&nbsp; *   //when
&nbsp; *   Goods goods = shop.buyBread();
&nbsp; *
&nbsp; *   //then
&nbsp; *   assertThat(goods, containBread());
&nbsp; * }
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;20&quot;&gt;20. &lt;a class=&quot;meaningful_link&quot; href=&quot;#serializable_mocks&quot; name=&quot;serializable_mocks&quot;&gt;Serializable mocks&lt;/a&gt; (Since 1.8.1)&lt;/h3&gt;
&nbsp; *
&nbsp; * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.
&nbsp; * &lt;p&gt;
&nbsp; * WARNING: This should be rarely used in unit testing.
&nbsp; * &lt;p&gt;
&nbsp; * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This
&nbsp; * was in a web environment and the objects from the external dependency were being serialized to pass between layers.
&nbsp; * &lt;p&gt;
&nbsp; * To create serializable mock use {@link MockSettings#serializable()}:
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   List serializableMock = mock(List.class, withSettings().serializable());
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The mock can be serialized assuming all the normal &lt;a href=&#39;http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html&#39;&gt;
&nbsp; * serialization requirements&lt;/a&gt; are met by the class.
&nbsp; * &lt;p&gt;
&nbsp; * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version
&nbsp; * which accepts MockSettings. No worries, you will hardly ever use it.
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;Object&amp;gt;();
&nbsp; * List&amp;lt;Object&amp;gt; spy = mock(ArrayList.class, withSettings()
&nbsp; *                 .spiedInstance(list)
&nbsp; *                 .defaultAnswer(CALLS_REAL_METHODS)
&nbsp; *                 .serializable());
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;21&quot;&gt;21. New annotations: &lt;a class=&quot;meaningful_link&quot; href=&quot;#captor_annotation&quot; name=&quot;captor_annotation&quot;&gt;&lt;code&gt;&amp;#064;Captor&lt;/code&gt;&lt;/a&gt;,
&nbsp; * &lt;a class=&quot;meaningful_link&quot; href=&quot;#spy_annotation&quot; name=&quot;spy_annotation&quot;&gt;&lt;code&gt;&amp;#064;Spy&lt;/code&gt;&lt;/a&gt;,
&nbsp; * &lt;a class=&quot;meaningful_link&quot; href=&quot;#injectmocks_annotation&quot; name=&quot;injectmocks_annotation&quot;&gt;&lt;code&gt;&amp;#064;InjectMocks&lt;/code&gt;&lt;/a&gt; (Since 1.8.3)&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Release 1.8.3 brings new annotations that may be helpful on occasion:
&nbsp; *
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;&amp;#064;{@link Captor} simplifies creation of {@link ArgumentCaptor}
&nbsp; * - useful when the argument to capture is a nasty generic class and you want to avoid compiler warnings
&nbsp; * &lt;li&gt;&amp;#064;{@link Spy} - you can use it instead {@link Mockito#spy(Object)}.
&nbsp; * &lt;li&gt;&amp;#064;{@link InjectMocks} - injects mock or spy fields into tested object automatically.
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Note that &amp;#064;{@link InjectMocks} can also be used in combination with the &amp;#064;{@link Spy} annotation, it means
&nbsp; * that Mockito will inject mocks into the partial mock under test. This complexity is another good reason why you
&nbsp; * should only use partial mocks as a last resort. See point 16 about partial mocks.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * All new annotations are &lt;b&gt;*only*&lt;/b&gt; processed on {@link MockitoAnnotations#initMocks(Object)}.
&nbsp; * Just like for &amp;#064;{@link Mock} annotation you can use the built-in runner: {@link MockitoJUnitRunner} or rule:
&nbsp; * {@link MockitoRule}.
&nbsp; * &lt;p&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;22&quot;&gt;22. &lt;a class=&quot;meaningful_link&quot; href=&quot;#verification_timeout&quot; name=&quot;verification_timeout&quot;&gt;Verification with timeout&lt;/a&gt; (Since 1.8.5)&lt;/h3&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired
&nbsp; * interaction rather than fails immediately if had not already happened. May be useful for testing in concurrent
&nbsp; * conditions.
&nbsp; * &lt;p&gt;
&nbsp; * This feature should be used rarely - figure out a better way of testing your multi-threaded system.
&nbsp; * &lt;p&gt;
&nbsp; * Not yet implemented to work with InOrder verification.
&nbsp; * &lt;p&gt;
&nbsp; * Examples:
&nbsp; * &lt;p&gt;
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   //passes when someMethod() is called no later than within 100 ms
&nbsp; *   //exits immediately when verification is satisfied (e.g. may not wait full 100 ms)
&nbsp; *   verify(mock, timeout(100)).someMethod();
&nbsp; *   //above is an alias to:
&nbsp; *   verify(mock, timeout(100).times(1)).someMethod();
&nbsp; *
&nbsp; *   //passes as soon as someMethod() has been called 2 times under 100 ms
&nbsp; *   verify(mock, timeout(100).times(2)).someMethod();
&nbsp; *
&nbsp; *   //equivalent: this also passes as soon as someMethod() has been called 2 times under 100 ms
&nbsp; *   verify(mock, timeout(100).atLeast(2)).someMethod();
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;23&quot;&gt;23. &lt;a class=&quot;meaningful_link&quot; href=&quot;#automatic_instantiation&quot; name=&quot;automatic_instantiation&quot;&gt;Automatic instantiation of &lt;code&gt;&amp;#064;Spies&lt;/code&gt;,
&nbsp; * &lt;code&gt;&amp;#064;InjectMocks&lt;/code&gt;&lt;/a&gt; and &lt;a class=&quot;meaningful_link&quot; href=&quot;#constructor_injection&quot; name=&quot;constructor_injection&quot;&gt;constructor injection goodness&lt;/a&gt; (Since 1.9.0)&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Mockito will now try to instantiate &amp;#064;{@link Spy} and will instantiate &amp;#064;{@link InjectMocks} fields
&nbsp; * using &lt;b&gt;constructor&lt;/b&gt; injection, &lt;b&gt;setter&lt;/b&gt; injection, or &lt;b&gt;field&lt;/b&gt; injection.
&nbsp; * &lt;p&gt;
&nbsp; * To take advantage of this feature you need to use {@link MockitoAnnotations#initMocks(Object)}, {@link MockitoJUnitRunner}
&nbsp; * or {@link MockitoRule}.
&nbsp; * &lt;p&gt;
&nbsp; * Read more about available tricks and the rules of injection in the javadoc for {@link InjectMocks}
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * //instead:
&nbsp; * &amp;#064;Spy BeerDrinker drinker = new BeerDrinker();
&nbsp; * //you can write:
&nbsp; * &amp;#064;Spy BeerDrinker drinker;
&nbsp; *
&nbsp; * //same applies to &amp;#064;InjectMocks annotation:
&nbsp; * &amp;#064;InjectMocks LocalPub;
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;24&quot;&gt;24. &lt;a class=&quot;meaningful_link&quot; href=&quot;#one_liner_stub&quot; name=&quot;one_liner_stub&quot;&gt;One-liner stubs&lt;/a&gt; (Since 1.9.0)&lt;/h3&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Mockito will now allow you to create mocks when stubbing.
&nbsp; * Basically, it allows to create a stub in one line of code.
&nbsp; * This can be helpful to keep test code clean.
&nbsp; * For example, some boring stub can be created &amp; stubbed at field initialization in a test:
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * public class CarTest {
&nbsp; *   Car boringStubbedCar = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();
&nbsp; *
&nbsp; *   &amp;#064;Test public void should... {}
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;25&quot;&gt;25. &lt;a class=&quot;meaningful_link&quot; href=&quot;#ignore_stubs_verification&quot; name=&quot;ignore_stubs_verification&quot;&gt;Verification ignoring stubs&lt;/a&gt; (Since 1.9.0)&lt;/h3&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Mockito will now allow to ignore stubbing for the sake of verification.
&nbsp; * Sometimes useful when coupled with &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; or verification &lt;code&gt;inOrder()&lt;/code&gt;.
&nbsp; * Helps avoiding redundant verification of stubbed calls - typically we&#39;re not interested in verifying stubs.
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Warning&lt;/b&gt;, &lt;code&gt;ignoreStubs()&lt;/code&gt; might lead to overuse of verifyNoMoreInteractions(ignoreStubs(...));
&nbsp; * Bear in mind that Mockito does not recommend bombarding every test with &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt;
&nbsp; * for the reasons outlined in javadoc for {@link Mockito#verifyNoMoreInteractions(Object...)}
&nbsp; * &lt;p&gt;Some examples:
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * verify(mock).foo();
&nbsp; * verify(mockTwo).bar();
&nbsp; *
&nbsp; * //ignores all stubbed methods:
&nbsp; * verifyNoMoreInteractions(ignoreStubs(mock, mockTwo));
&nbsp; *
&nbsp; * //creates InOrder that will ignore stubbed
&nbsp; * InOrder inOrder = inOrder(ignoreStubs(mock, mockTwo));
&nbsp; * inOrder.verify(mock).foo();
&nbsp; * inOrder.verify(mockTwo).bar();
&nbsp; * inOrder.verifyNoMoreInteractions();
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Advanced examples and more details can be found in javadoc for {@link Mockito#ignoreStubs(Object...)}
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;26&quot;&gt;26. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mocking_details&quot; name=&quot;mocking_details&quot;&gt;Mocking details&lt;/a&gt; (Improved in 2.2.x)&lt;/h3&gt;
&nbsp; * &lt;p&gt;
&nbsp; *
&nbsp; * Mockito offers API to inspect the details of a mock object.
&nbsp; * This API is useful for advanced users and mocking framework integrators.
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   //To identify whether a particular object is a mock or a spy:
&nbsp; *   Mockito.mockingDetails(someObject).isMock();
&nbsp; *   Mockito.mockingDetails(someObject).isSpy();
&nbsp; *
&nbsp; *   //Getting details like type to mock or default answer:
&nbsp; *   MockingDetails details = mockingDetails(mock);
&nbsp; *   details.getMockCreationSettings().getTypeToMock();
&nbsp; *   details.getMockCreationSettings().getDefaultAnswer();
&nbsp; *
&nbsp; *   //Getting invocations and stubbings of the mock:
&nbsp; *   MockingDetails details = mockingDetails(mock);
&nbsp; *   details.getInvocations();
&nbsp; *   details.getStubbings();
&nbsp; *
&nbsp; *   //Printing all interactions (including stubbing, unused stubs)
&nbsp; *   System.out.println(mockingDetails(mock).printInvocations());
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * For more information see javadoc for {@link MockingDetails}.
&nbsp; *
&nbsp; * &lt;h3 id=&quot;27&quot;&gt;27. &lt;a class=&quot;meaningful_link&quot; href=&quot;#delegating_call_to_real_instance&quot; name=&quot;delegating_call_to_real_instance&quot;&gt;Delegate calls to real instance&lt;/a&gt; (Since 1.9.5)&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;p&gt;Useful for spies or partial mocks of objects &lt;strong&gt;that are difficult to mock or spy&lt;/strong&gt; using the usual spy API.
&nbsp; * Since Mockito 1.10.11, the delegate may or may not be of the same type as the mock.
&nbsp; * If the type is different, a matching method needs to be found on delegate type otherwise an exception is thrown.
&nbsp; *
&nbsp; * Possible use cases for this feature:
&nbsp; * &lt;ul&gt;
&nbsp; *     &lt;li&gt;Final classes but with an interface&lt;/li&gt;
&nbsp; *     &lt;li&gt;Already custom proxied object&lt;/li&gt;
&nbsp; *     &lt;li&gt;Special objects with a finalize method, i.e. to avoid executing it 2 times&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;p&gt;The difference with the regular spy:
&nbsp; * &lt;ul&gt;
&nbsp; *   &lt;li&gt;
&nbsp; *     The regular spy ({@link #spy(Object)}) contains &lt;strong&gt;all&lt;/strong&gt; state from the spied instance
&nbsp; *     and the methods are invoked on the spy. The spied instance is only used at mock creation to copy the state from.
&nbsp; *     If you call a method on a regular spy and it internally calls other methods on this spy, those calls are remembered
&nbsp; *     for verifications, and they can be effectively stubbed.
&nbsp; *   &lt;/li&gt;
&nbsp; *   &lt;li&gt;
&nbsp; *     The mock that delegates simply delegates all methods to the delegate.
&nbsp; *     The delegate is used all the time as methods are delegated onto it.
&nbsp; *     If you call a method on a mock that delegates and it internally calls other methods on this mock,
&nbsp; *     those calls are &lt;strong&gt;not&lt;/strong&gt; remembered for verifications, stubbing does not have effect on them, too.
&nbsp; *     Mock that delegates is less powerful than the regular spy but it is useful when the regular spy cannot be created.
&nbsp; *   &lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * See more information in docs for {@link AdditionalAnswers#delegatesTo(Object)}.
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;28&quot;&gt;28. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mock_maker_plugin&quot; name=&quot;mock_maker_plugin&quot;&gt;&lt;code&gt;MockMaker&lt;/code&gt; API&lt;/a&gt; (Since 1.9.5)&lt;/h3&gt;
&nbsp; * &lt;p&gt;Driven by requirements and patches from Google Android guys Mockito now offers an extension point
&nbsp; *   that allows replacing the proxy generation engine. By default, Mockito uses &lt;a href=&quot;https://github.com/raphw/byte-buddy&quot;&gt;Byte Buddy&lt;/a&gt;
&nbsp; *   to create dynamic proxies.
&nbsp; * &lt;p&gt;The extension point is for advanced users that want to extend Mockito. For example, it is now possible
&nbsp; *   to use Mockito for Android testing with a help of &lt;a href=&quot;https://github.com/crittercism/dexmaker&quot;&gt;dexmaker&lt;/a&gt;.
&nbsp; * &lt;p&gt;For more details, motivations and examples please refer to
&nbsp; * the docs for {@link org.mockito.plugins.MockMaker}.
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;29&quot;&gt;29. &lt;a class=&quot;meaningful_link&quot; href=&quot;#BDD_behavior_verification&quot; name=&quot;BDD_behavior_verification&quot;&gt;BDD style verification&lt;/a&gt; (Since 1.10.0)&lt;/h3&gt;
&nbsp; *
&nbsp; * Enables Behavior Driven Development (BDD) style verification by starting verification with the BDD &lt;b&gt;then&lt;/b&gt; keyword.
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * given(dog.bark()).willReturn(2);
&nbsp; *
&nbsp; * // when
&nbsp; * ...
&nbsp; *
&nbsp; * then(person).should(times(2)).ride(bike);
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * For more information and an example see {@link BDDMockito#then(Object)}
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;30&quot;&gt;30. &lt;a class=&quot;meaningful_link&quot; href=&quot;#spying_abstract_classes&quot; name=&quot;spying_abstract_classes&quot;&gt;Spying or mocking abstract classes (Since 1.10.12, further enhanced in 2.7.13 and 2.7.14)&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * It is now possible to conveniently spy on abstract classes. Note that overusing spies hints at code design smells (see {@link #spy(Object)}).
&nbsp; * &lt;p&gt;
&nbsp; * Previously, spying was only possible on instances of objects.
&nbsp; * New API makes it possible to use constructor when creating an instance of the mock.
&nbsp; * This is particularly useful for mocking abstract classes because the user is no longer required to provide an instance of the abstract class.
&nbsp; * At the moment, only parameter-less constructor is supported, let us know if it is not enough.
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * //convenience API, new overloaded spy() method:
&nbsp; * SomeAbstract spy = spy(SomeAbstract.class);
&nbsp; *
&nbsp; * //Mocking abstract methods, spying default methods of an interface (only available since 2.7.13)
&nbsp; * Function&lt;Foo, Bar&gt; function = spy(Function.class);
&nbsp; *
&nbsp; * //Robust API, via settings builder:
&nbsp; * OtherAbstract spy = mock(OtherAbstract.class, withSettings()
&nbsp; *    .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
&nbsp; *
&nbsp; * //Mocking an abstract class with constructor arguments (only available since 2.7.14)
&nbsp; * SomeAbstract spy = mock(SomeAbstract.class, withSettings()
&nbsp; *   .useConstructor(&quot;arg1&quot;, 123).defaultAnswer(CALLS_REAL_METHODS));
&nbsp; *
&nbsp; * //Mocking a non-static inner abstract class:
&nbsp; * InnerAbstract spy = mock(InnerAbstract.class, withSettings()
&nbsp; *    .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * For more information please see {@link MockSettings#useConstructor(Object...)}.
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;31&quot;&gt;31. &lt;a class=&quot;meaningful_link&quot; href=&quot;#serilization_across_classloader&quot; name=&quot;serilization_across_classloader&quot;&gt;Mockito mocks can be &lt;em&gt;serialized&lt;/em&gt; / &lt;em&gt;deserialized&lt;/em&gt; across classloaders (Since 1.10.0)&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * Mockito introduces serialization across classloader.
&nbsp; *
&nbsp; * Like with any other form of serialization, all types in the mock hierarchy have to serializable, inclusing answers.
&nbsp; * As this serialization mode require considerably more work, this is an opt-in setting.
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * // use regular serialization
&nbsp; * mock(Book.class, withSettings().serializable());
&nbsp; *
&nbsp; * // use serialization across classloaders
&nbsp; * mock(Book.class, withSettings().serializable(ACROSS_CLASSLOADERS));
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * For more details see {@link MockSettings#serializable(SerializableMode)}.
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;32&quot;&gt;32. &lt;a class=&quot;meaningful_link&quot; href=&quot;#better_generic_support_with_deep_stubs&quot; name=&quot;better_generic_support_with_deep_stubs&quot;&gt;Better generic support with deep stubs (Since 1.10.0)&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * Deep stubbing has been improved to find generic information if available in the class.
&nbsp; * That means that classes like this can be used without having to mock the behavior.
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * class Lines extends List&amp;lt;Line&amp;gt; {
&nbsp; *     // ...
&nbsp; * }
&nbsp; *
&nbsp; * lines = mock(Lines.class, RETURNS_DEEP_STUBS);
&nbsp; *
&nbsp; * // Now Mockito understand this is not an Object but a Line
&nbsp; * Line line = lines.iterator().next();
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * Please note that in most scenarios a mock returning a mock is wrong.
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;33&quot;&gt;33. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito_junit_rule&quot; name=&quot;mockito_junit_rule&quot;&gt;Mockito JUnit rule (Since 1.10.17)&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * Mockito now offers a JUnit rule. Until now in JUnit there were two ways to initialize fields annotated by Mockito annotations
&nbsp; * such as &lt;code&gt;&amp;#064;{@link Mock}&lt;/code&gt;, &lt;code&gt;&amp;#064;{@link Spy}&lt;/code&gt;, &lt;code&gt;&amp;#064;{@link InjectMocks}&lt;/code&gt;, etc.
&nbsp; *
&nbsp; * &lt;ul&gt;
&nbsp; *     &lt;li&gt;Annotating the JUnit test class with a &lt;code&gt;&amp;#064;{@link org.junit.runner.RunWith}({@link MockitoJUnitRunner}.class)&lt;/code&gt;&lt;/li&gt;
&nbsp; *     &lt;li&gt;Invoking &lt;code&gt;{@link MockitoAnnotations#initMocks(Object)}&lt;/code&gt; in the &lt;code&gt;&amp;#064;{@link org.junit.Before}&lt;/code&gt; method&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * Now you can choose to use a rule :
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * &amp;#064;RunWith(YetAnotherRunner.class)
&nbsp; * public class TheTest {
&nbsp; *     &amp;#064;Rule public MockitoRule mockito = MockitoJUnit.rule();
&nbsp; *     // ...
&nbsp; * }
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * For more information see {@link MockitoJUnit#rule()}.
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;34&quot;&gt;34. &lt;a class=&quot;meaningful_link&quot; href=&quot;#plugin_switch&quot; name=&quot;plugin_switch&quot;&gt;Switch &lt;em&gt;on&lt;/em&gt; or &lt;em&gt;off&lt;/em&gt; plugins (Since 1.10.15)&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * An incubating feature made it&#39;s way in mockito that will allow to toggle a mockito-plugin.
&nbsp; *
&nbsp; * More information here {@link org.mockito.plugins.PluginSwitch}.
&nbsp; *
&nbsp; *
&nbsp; * &lt;h3 id=&quot;35&quot;&gt;35. &lt;a class=&quot;meaningful_link&quot; href=&quot;#Custom_verification_failure_message&quot; name=&quot;Custom_verification_failure_message&quot;&gt;Custom verification failure message&lt;/a&gt; (Since 2.1.0)&lt;/h3&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Allows specifying a custom message to be printed if verification fails.
&nbsp; * &lt;p&gt;
&nbsp; * Examples:
&nbsp; * &lt;p&gt;
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *
&nbsp; * // will print a custom message on verification failure
&nbsp; * verify(mock, description(&quot;This will print on failure&quot;)).someMethod();
&nbsp; *
&nbsp; * // will work with any verification mode
&nbsp; * verify(mock, times(2).description(&quot;someMethod should be called twice&quot;)).someMethod();
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;h3 id=&quot;36&quot;&gt;36. &lt;a class=&quot;meaningful_link&quot; href=&quot;#Java_8_Lambda_Matching&quot; name=&quot;Java_8_Lambda_Matching&quot;&gt;Java 8 Lambda Matcher Support&lt;/a&gt; (Since 2.1.0)&lt;/h3&gt;
&nbsp; * &lt;p&gt;
&nbsp; * You can use Java 8 lambda expressions with {@link ArgumentMatcher} to reduce the dependency on {@link ArgumentCaptor}.
&nbsp; * If you need to verify that the input to a function call on a mock was correct, then you would normally
&nbsp; * use the {@link ArgumentCaptor} to find the operands used and then do subsequent assertions on them. While
&nbsp; * for complex examples this can be useful, it&#39;s also long-winded.&lt;p&gt;
&nbsp; * Writing a lambda to express the match is quite easy. The argument to your function, when used in conjunction
&nbsp; * with argThat, will be passed to the ArgumentMatcher as a strongly typed object, so it is possible
&nbsp; * to do anything with it.
&nbsp; * &lt;p&gt;
&nbsp; * Examples:
&nbsp; * &lt;p&gt;
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *
&nbsp; * // verify a list only had strings of a certain length added to it
&nbsp; * // note - this will only compile under Java 8
&nbsp; * verify(list, times(2)).add(argThat(string -&gt; string.length() &lt; 5));
&nbsp; *
&nbsp; * // Java 7 equivalent - not as neat
&nbsp; * verify(list, times(2)).add(argThat(new ArgumentMatcher&lt;String&gt;(){
&nbsp; *     public boolean matches(String arg) {
&nbsp; *         return arg.length() &lt; 5;
&nbsp; *     }
&nbsp; * }));
&nbsp; *
&nbsp; * // more complex Java 8 example - where you can specify complex verification behaviour functionally
&nbsp; * verify(target, times(1)).receiveComplexObject(argThat(obj -&gt; obj.getSubObject().get(0).equals(&quot;expected&quot;)));
&nbsp; *
&nbsp; * // this can also be used when defining the behaviour of a mock under different inputs
&nbsp; * // in this case if the input list was fewer than 3 items the mock returns null
&nbsp; * when(mock.someMethod(argThat(list -&gt; list.size()&lt;3))).thenReturn(null);
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;h3 id=&quot;37&quot;&gt;37. &lt;a class=&quot;meaningful_link&quot; href=&quot;#Java_8_Custom_Answers&quot; name=&quot;Java_8_Custom_Answers&quot;&gt;Java 8 Custom Answer Support&lt;/a&gt; (Since 2.1.0)&lt;/h3&gt;
&nbsp; * &lt;p&gt;
&nbsp; * As the {@link Answer} interface has just one method it is already possible to implement it in Java 8 using
&nbsp; * a lambda expression for very simple situations. The more you need to use the parameters of the method call,
&nbsp; * the more you need to typecast the arguments from {@link org.mockito.invocation.InvocationOnMock}.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Examples:
&nbsp; * &lt;p&gt;
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * // answer by returning 12 every time
&nbsp; * doAnswer(invocation -&gt; 12).when(mock).doSomething();
&nbsp; *
&nbsp; * // answer by using one of the parameters - converting into the right
&nbsp; * // type as your go - in this case, returning the length of the second string parameter
&nbsp; * // as the answer. This gets long-winded quickly, with casting of parameters.
&nbsp; * doAnswer(invocation -&gt; ((String)invocation.getArgument(1)).length())
&nbsp; *     .when(mock).doSomething(anyString(), anyString(), anyString());
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * For convenience it is possible to write custom answers/actions, which use the parameters to the method call,
&nbsp; * as Java 8 lambdas. Even in Java 7 and lower these custom answers based on a typed interface can reduce boilerplate.
&nbsp; * In particular, this approach will make it easier to test functions which use callbacks.
&nbsp; *
&nbsp; * The methods {@link AdditionalAnswers#answer(Answer1) answer} and {@link AdditionalAnswers#answerVoid(VoidAnswer1) answerVoid}
&nbsp; * can be used to create the answer. They rely on the related answer interfaces in {@link org.mockito.stubbing} that
&nbsp; * support answers up to 5 parameters.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Examples:
&nbsp; * &lt;p&gt;
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *
&nbsp; * // Example interface to be mocked has a function like:
&nbsp; * void execute(String operand, Callback callback);
&nbsp; *
&nbsp; * // the example callback has a function and the class under test
&nbsp; * // will depend on the callback being invoked
&nbsp; * void receive(String item);
&nbsp; *
&nbsp; * // Java 8 - style 1
&nbsp; * doAnswer(AdditionalAnswers.&lt;String,Callback&gt;answerVoid((operand, callback) -&gt; callback.receive(&quot;dummy&quot;))
&nbsp; *     .when(mock).execute(anyString(), any(Callback.class));
&nbsp; *
&nbsp; * // Java 8 - style 2 - assuming static import of AdditionalAnswers
&nbsp; * doAnswer(answerVoid((String operand, Callback callback) -&gt; callback.receive(&quot;dummy&quot;))
&nbsp; *     .when(mock).execute(anyString(), any(Callback.class));
&nbsp; *
&nbsp; * // Java 8 - style 3 - where mocking function to is a static member of test class
&nbsp; * private static void dummyCallbackImpl(String operation, Callback callback) {
&nbsp; *     callback.receive(&quot;dummy&quot;);
&nbsp; * }
&nbsp; *
&nbsp; * doAnswer(answerVoid(TestClass::dummyCallbackImpl)
&nbsp; *     .when(mock).execute(anyString(), any(Callback.class));
&nbsp; *
&nbsp; * // Java 7
&nbsp; * doAnswer(answerVoid(new VoidAnswer2&lt;String, Callback&gt;() {
&nbsp; *     public void answer(String operation, Callback callback) {
&nbsp; *         callback.receive(&quot;dummy&quot;);
&nbsp; *     }})).when(mock).execute(anyString(), any(Callback.class));
&nbsp; *
&nbsp; * // returning a value is possible with the answer() function
&nbsp; * // and the non-void version of the functional interfaces
&nbsp; * // so if the mock interface had a method like
&nbsp; * boolean isSameString(String input1, String input2);
&nbsp; *
&nbsp; * // this could be mocked
&nbsp; * // Java 8
&nbsp; * doAnswer(AdditionalAnswers.&lt;Boolean,String,String&gt;answer((input1, input2) -&gt; input1.equals(input2))))
&nbsp; *     .when(mock).execute(anyString(), anyString());
&nbsp; *
&nbsp; * // Java 7
&nbsp; * doAnswer(answer(new Answer2&lt;String, String, String&gt;() {
&nbsp; *     public String answer(String input1, String input2) {
&nbsp; *         return input1 + input2;
&nbsp; *     }})).when(mock).execute(anyString(), anyString());
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;h3 id=&quot;38&quot;&gt;38. &lt;a class=&quot;meaningful_link&quot; href=&quot;#Meta_Data_And_Generics&quot; name=&quot;Meta_Data_And_Generics&quot;&gt;Meta data and generic type retention&lt;/a&gt; (Since 2.1.0)&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Mockito now preserves annotations on mocked methods and types as well as generic meta data. Previously, a mock type did not preserve
&nbsp; * annotations on types unless they were explicitly inherited and never retained annotations on methods. As a consequence, the following
&nbsp; * conditions now hold true:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; * {@literal @}{@code MyAnnotation
&nbsp; *  class Foo {
&nbsp; *    List&lt;String&gt; bar() { ... }
&nbsp; *  }
&nbsp; *
&nbsp; *  Class&lt;?&gt; mockType = mock(Foo.class).getClass();
&nbsp; *  assert mockType.isAnnotationPresent(MyAnnotation.class);
&nbsp; *  assert mockType.getDeclaredMethod(&quot;bar&quot;).getGenericReturnType() instanceof ParameterizedType;
&nbsp; * }&lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * When using Java 8, Mockito now also preserves type annotations. This is default behavior and might not hold &lt;a href=&quot;#28&quot;&gt;if an
&nbsp; * alternative {@link org.mockito.plugins.MockMaker} is used&lt;/a&gt;.
&nbsp; *
&nbsp; * &lt;h3 id=&quot;39&quot;&gt;39. &lt;a class=&quot;meaningful_link&quot; href=&quot;#Mocking_Final&quot; name=&quot;Mocking_Final&quot;&gt;Mocking final types, enums and final methods&lt;/a&gt; (Since 2.1.0)&lt;/h3&gt;
&nbsp; *
&nbsp; * Mockito now offers an {@link Incubating}, optional support for mocking final classes and methods.
&nbsp; * This is a fantastic improvement that demonstrates Mockito&#39;s everlasting quest for improving testing experience.
&nbsp; * Our ambition is that Mockito &quot;just works&quot; with final classes and methods.
&nbsp; * Previously they were considered &lt;em&gt;unmockable&lt;/em&gt;, preventing the user from mocking.
&nbsp; * We already started discussing how to make this feature enabled by default.
&nbsp; * Currently, the feature is still optional as we wait for more feedback from the community.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This alternative mock maker which uses
&nbsp; * a combination of both Java instrumentation API and sub-classing rather than creating a new class to represent
&nbsp; * a mock. This way, it becomes possible to mock final types and methods.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This mock maker is &lt;strong&gt;turned off by default&lt;/strong&gt; because it is based on completely different mocking mechanism
&nbsp; * that requires more feedback from the community. It can be activated explicitly by the mockito extension mechanism,
&nbsp; * just create in the classpath a file &lt;code&gt;/mockito-extensions/org.mockito.plugins.MockMaker&lt;/code&gt;
&nbsp; * containing the value &lt;code&gt;mock-maker-inline&lt;/code&gt;.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * As a convenience, the Mockito team provides an artifact where this mock maker is preconfigured. Instead of using the
&nbsp; * &lt;i&gt;mockito-core&lt;/i&gt; artifact, include the &lt;i&gt;mockito-inline&lt;/i&gt; artifact in your project. Note that this artifact is
&nbsp; * likely to be discontinued once mocking of final classes and methods gets integrated into the default mock maker.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Some noteworthy notes about this mock maker:
&nbsp; * &lt;ul&gt;
&nbsp; *     &lt;li&gt;Mocking final types and enums is incompatible with mock settings like :
&nbsp; *     &lt;ul&gt;
&nbsp; *         &lt;li&gt;explicitly serialization support &lt;code&gt;withSettings().serializable()&lt;/code&gt;&lt;/li&gt;
&nbsp; *         &lt;li&gt;extra-interfaces &lt;code&gt;withSettings().extraInterfaces()&lt;/code&gt;&lt;/li&gt;
&nbsp; *     &lt;/ul&gt;
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;Some methods cannot be mocked
&nbsp; *         &lt;ul&gt;
&nbsp; *              &lt;li&gt;Package-visible methods of &lt;code&gt;java.*&lt;/code&gt;&lt;/li&gt;
&nbsp; *              &lt;li&gt;&lt;code&gt;native&lt;/code&gt; methods&lt;/li&gt;
&nbsp; *         &lt;/ul&gt;
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;This mock maker has been designed around Java Agent runtime attachment ; this require a compatible JVM,
&nbsp; *     that is part of the JDK (or Java 9 VM). When running on a non-JDK VM prior to Java 9, it is however possible to
&nbsp; *     manually add the &lt;a href=&quot;http://bytebuddy.net&quot;&gt;Byte Buddy Java agent jar&lt;/a&gt; using the &lt;code&gt;-javaagent&lt;/code&gt;
&nbsp; *     parameter upon starting the JVM.
&nbsp; *     &lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * If you are interested in more details of this feature please read the javadoc of
&nbsp; * &lt;code&gt;org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker&lt;/code&gt;
&nbsp; *
&nbsp; * &lt;h3 id=&quot;40&quot;&gt;40. &lt;a class=&quot;meaningful_link&quot; href=&quot;#strict_mockito&quot; name=&quot;strict_mockito&quot;&gt;
&nbsp; *     Improved productivity and cleaner tests with &quot;stricter&quot; Mockito&lt;/a&gt; (Since 2.+)&lt;/h3&gt;
&nbsp; *
&nbsp; * To quickly find out how &quot;stricter&quot; Mockito can make you more productive and get your tests cleaner, see:
&nbsp; * &lt;ul&gt;
&nbsp; *     &lt;li&gt;Strict stubbing with JUnit Rules - {@link MockitoRule#strictness(Strictness)} with {@link Strictness#STRICT_STUBS}&lt;/li&gt;
&nbsp; *     &lt;li&gt;Strict stubbing with JUnit Runner - {@link MockitoJUnitRunner.StrictStubs}&lt;/li&gt;
&nbsp; *     &lt;li&gt;Strict stubbing if you cannot use runner/rule (like TestNG) - {@link MockitoSession}&lt;/li&gt;
&nbsp; *     &lt;li&gt;Unnecessary stubbing detection with {@link MockitoJUnitRunner}&lt;/li&gt;
&nbsp; *     &lt;li&gt;Stubbing argument mismatch warnings, documented in {@link MockitoHint}&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * Mockito is a &quot;loose&quot; mocking framework by default.
&nbsp; * Mocks can be interacted with without setting any expectations beforehand.
&nbsp; * This is intentional and it improves the quality of tests by forcing users to be explicit about what they want to stub / verify.
&nbsp; * It is also very intuitive, easy to use and blends nicely with &quot;given&quot;, &quot;when&quot;, &quot;then&quot; template of clean test code.
&nbsp; * This is also different from the classic mocking frameworks of the past, they were &quot;strict&quot; by default.
&nbsp; * &lt;p&gt;
&nbsp; * Being &quot;loose&quot; by default makes Mockito tests harder to debug at times.
&nbsp; * There are scenarios where misconfigured stubbing (like using a wrong argument) forces the user to run the test with a debugger.
&nbsp; * Ideally, tests failures are immediately obvious and don&#39;t require debugger to identify the root cause.
&nbsp; * Starting with version 2.1 Mockito has been getting new features that nudge the framework towards &quot;strictness&quot;.
&nbsp; * We want Mockito to offer fantastic debuggability while not losing its core mocking style, optimized for
&nbsp; * intuitiveness, explicitness and clean test code.
&nbsp; * &lt;p&gt;
&nbsp; * Help Mockito! Try the new features, give us feedback, join the discussion about Mockito strictness at GitHub
&nbsp; * &lt;a href=&quot;https://github.com/mockito/mockito/issues/769&quot;&gt;issue 769&lt;/a&gt;.
&nbsp; *
&nbsp; * &lt;h3 id=&quot;41&quot;&gt;41. &lt;a class=&quot;meaningful_link&quot; href=&quot;#framework_integrations_api&quot; name=&quot;framework_integrations_api&quot;&gt;
&nbsp; *      Advanced public API for framework integrations (Since 2.10.+)&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * In Summer 2017 we decided that Mockito
&nbsp; * &lt;a href=&quot;https://www.linkedin.com/pulse/mockito-vs-powermock-opinionated-dogmatic-static-mocking-faber&quot;&gt;
&nbsp; * should offer better API
&nbsp; * &lt;/a&gt;
&nbsp; * for advanced framework integrations.
&nbsp; * The new API is not intended for users who want to write unit tests.
&nbsp; * It is intended for other test tools and mocking frameworks that need to extend or wrap Mockito with some custom logic.
&nbsp; * During the design and implementation process (&lt;a href=&quot;https://github.com/mockito/mockito/issues/1110&quot;&gt;issue 1110&lt;/a&gt;)
&nbsp; * we have developed and changed following public API elements:
&nbsp; * &lt;ul&gt;
&nbsp; *     &lt;li&gt;New {@link MockitoPlugins} -
&nbsp; *      Enables framework integrators to get access to default Mockito plugins.
&nbsp; *      Useful when one needs to implement custom plugin such as {@link MockMaker}
&nbsp; *      and delegate some behavior to the default Mockito implementation.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;New {@link MockSettings#build(Class)} -
&nbsp; *      Creates immutable view of mock settings used later by Mockito.
&nbsp; *      Useful for creating invocations with {@link InvocationFactory} or when implementing custom {@link MockHandler}.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;New {@link MockingDetails#getMockHandler()} -
&nbsp; *      Other frameworks may use the mock handler to programmatically simulate invocations on mock objects.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;New {@link MockHandler#getMockSettings()} -
&nbsp; *      Useful to get hold of the setting the mock object was created with.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;New {@link InvocationFactory} -
&nbsp; *      Provides means to create instances of {@link Invocation} objects.
&nbsp; *      Useful for framework integrations that need to programmatically simulate method calls on mock objects.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;New {@link MockHandler#getInvocationContainer()} -
&nbsp; *      Provides access to invocation container object which has no methods (marker interface).
&nbsp; *      Container is needed to hide the internal implementation and avoid leaking it to the public API.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;Changed {@link Stubbing} -
&nbsp; *      it now extends {@link Answer} interface.
&nbsp; *      It is backwards compatible because Stubbing interface is not extensible (see {@link NotExtensible}).
&nbsp; *      The change should be seamless to our users.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;Deprecated {@link InternalMockHandler} -
&nbsp; *       In order to accommodate API changes we needed to deprecate this interface.
&nbsp; *       The interface was always documented as internal, we don&#39;t have evidence it was used by the community.
&nbsp; *       The deprecation should be completely seamless for our users.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;{@link NotExtensible} -
&nbsp; *       Public annotation that indicates to the user that she should not provide custom implementations of given type.
&nbsp; *       Helps framework integrators and our users understand how to use Mockito API safely.
&nbsp; *     &lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * Do you have feedback? Please leave comment in &lt;a href=&quot;https://github.com/mockito/mockito/issues/1110&quot;&gt;issue 1110&lt;/a&gt;.
&nbsp; *
&nbsp; * &lt;h3 id=&quot;42&quot;&gt;42. &lt;a class=&quot;meaningful_link&quot; href=&quot;#verifiation_started_listener&quot; name=&quot;verifiation_started_listener&quot;&gt;
&nbsp; *       New API for integrations: listening on verification start events (Since 2.11.+)&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * Framework integrations such as &lt;a href=&quot;https://projects.spring.io/spring-boot&quot;&gt;Spring Boot&lt;/a&gt; needs public API to tackle double-proxy use case
&nbsp; * (&lt;a href=&quot;https://github.com/mockito/mockito/issues/1191&quot;&gt;issue 1191&lt;/a&gt;).
&nbsp; * We added:
&nbsp; * &lt;ul&gt;
&nbsp; *     &lt;li&gt;New {@link VerificationStartedListener} and {@link VerificationStartedEvent}
&nbsp; *      enable framework integrators to replace the mock object for verification.
&nbsp; *      The main driving use case is &lt;a href=&quot;https://projects.spring.io/spring-boot/&quot;&gt;Spring Boot&lt;/a&gt; integration.
&nbsp; *      For details see Javadoc for {@link VerificationStartedListener}.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;New public method {@link MockSettings#verificationStartedListeners(VerificationStartedListener...)}
&nbsp; *     allows to supply verification started listeners at mock creation time.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;New handy method {@link MockingDetails#getMock()} was added to make the {@code MockingDetails} API more complete.
&nbsp; *     We found this method useful during the implementation.
&nbsp; *     &lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;h3 id=&quot;43&quot;&gt;43. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito_session_testing_frameworks&quot; name=&quot;mockito_session_testing_frameworks&quot;&gt;
&nbsp; *       New API for integrations: &lt;code&gt;MockitoSession&lt;/code&gt; is usable by testing frameworks (Since 2.15.+)&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;p&gt;{@link MockitoSessionBuilder} and {@link MockitoSession} were enhanced to enable reuse by testing framework
&nbsp; * integrations (e.g. {@link MockitoRule} for JUnit):&lt;/p&gt;
&nbsp; * &lt;ul&gt;
&nbsp; *     &lt;li&gt;{@link MockitoSessionBuilder#initMocks(Object...)} allows to pass in multiple test class instances for
&nbsp; *      initialization of fields annotated with Mockito annotations like {@link org.mockito.Mock}.
&nbsp; *      This method is useful for advanced framework integrations (e.g. JUnit Jupiter), when a test uses multiple,
&nbsp; *      e.g. nested, test class instances.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;{@link MockitoSessionBuilder#name(String)} allows to pass a name from the testing framework to the
&nbsp; *      {@link MockitoSession} that will be used for printing warnings when {@link Strictness#WARN} is used.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;{@link MockitoSessionBuilder#logger(MockitoSessionLogger)} makes it possible to customize the logger used
&nbsp; *      for hints/warnings produced when finishing mocking (useful for testing and to connect reporting capabilities
&nbsp; *      provided by testing frameworks such as JUnit Jupiter).
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;{@link MockitoSession#setStrictness(Strictness)} allows to change the strictness of a {@link MockitoSession}
&nbsp; *      for one-off scenarios, e.g. it enables configuring a default strictness for all tests in a class but makes it
&nbsp; *      possible to change the strictness for a single or a few tests.
&nbsp; *     &lt;/li&gt;
&nbsp; *     &lt;li&gt;{@link MockitoSession#finishMocking(Throwable)} was added to avoid confusion that may arise because
&nbsp; *      there are multiple competing failures. It will disable certain checks when the supplied &lt;em&gt;failure&lt;/em&gt;
&nbsp; *      is not {@code null}.
&nbsp; *     &lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;h3 id=&quot;44&quot;&gt;44. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito_instantiator_provider_deprecation&quot; name=&quot;mockito_instantiator_provider_deprecation&quot;&gt;
&nbsp; *       Deprecated &lt;code&gt;org.mockito.plugins.InstantiatorProvider&lt;/code&gt; as it was leaking internal API. it was
&nbsp; *       replaced by &lt;code&gt;org.mockito.plugins.InstantiatorProvider2 (Since 2.15.4)&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * &lt;p&gt;{@link org.mockito.plugins.InstantiatorProvider} returned an internal API. Hence it was deprecated and replaced
&nbsp; * by {@link org.mockito.plugins.InstantiatorProvider2}. Old {@link org.mockito.plugins.InstantiatorProvider
&nbsp; * instantiator providers} will continue to work, but it is recommended to switch to the new API.&lt;/p&gt;
&nbsp; *
&nbsp; * &lt;h3 id=&quot;45&quot;&gt;45. &lt;a class=&quot;meaningful_link&quot; href=&quot;#junit5_mockito&quot; name=&quot;junit5_mockito&quot;&gt;New JUnit Jupiter (JUnit5+) extension&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * For integration with JUnit Jupiter (JUnit5+), use the `org.mockito:mockito-junit-jupiter` artifact.
&nbsp; * For more information about the usage of the integration, see &lt;a href=&quot;http://javadoc.io/page/org.mockito/mockito-junit-jupiter/latest/org/mockito/junit/jupiter/MockitoExtension.html&quot;&gt;the JavaDoc of &lt;code&gt;MockitoExtension&lt;/code&gt;&lt;/a&gt;.
&nbsp; *
&nbsp; * &lt;h3 id=&quot;46&quot;&gt;46. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito_lenient&quot; name=&quot;mockito_lenient&quot;&gt;
&nbsp; *       New &lt;code&gt;Mockito.lenient()&lt;/code&gt; and &lt;code&gt;MockSettings.lenient()&lt;/code&gt; methods (Since 2.20.0)&lt;/a&gt;&lt;/h3&gt;
&nbsp; *
&nbsp; * Strict stubbing feature is available since early Mockito 2.
&nbsp; * It is very useful because it drives cleaner tests and improved productivity.
&nbsp; * Strict stubbing reports unnecessary stubs, detects stubbing argument mismatch and makes the tests more DRY ({@link Strictness#STRICT_STUBS}).
&nbsp; * This comes with a trade-off: in some cases, you may get false negatives from strict stubbing.
&nbsp; * To remedy those scenarios you can now configure specific stubbing to be lenient, while all the other stubbings and mocks use strict stubbing:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   lenient().when(mock.foo()).thenReturn(&quot;ok&quot;);
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * If you want all the stubbings on a given mock to be lenient, you can configure the mock accordingly:
&nbsp; *
&nbsp; * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp; *   Foo mock = Mockito.mock(Foo.class, withSettings().lenient());
&nbsp; * &lt;/code&gt;&lt;/pre&gt;
&nbsp; *
&nbsp; * For more information refer to {@link Mockito#lenient()}.
&nbsp; * Let us know how do you find the new feature by opening a GitHub issue to discuss!
&nbsp; */
&nbsp;@SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;public class Mockito extends ArgumentMatchers {</b>
&nbsp;
<b class="fc">&nbsp;    static final MockitoCore MOCKITO_CORE = new MockitoCore();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The default &lt;code&gt;Answer&lt;/code&gt; of every mock &lt;b&gt;if&lt;/b&gt; the mock was not stubbed.
&nbsp;     *
&nbsp;     * Typically it just returns some empty value.
&nbsp;     * &lt;p&gt;
&nbsp;     * {@link Answer} can be used to define the return values of unstubbed invocations.
&nbsp;     * &lt;p&gt;
&nbsp;     * This implementation first tries the global configuration and if there is no global configuration then
&nbsp;     * it will use a default answer that returns zeros, empty collections, nulls, etc.
&nbsp;     */
<b class="fc">&nbsp;    public static final Answer&lt;Object&gt; RETURNS_DEFAULTS = Answers.RETURNS_DEFAULTS;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}.
&nbsp;     * &lt;p&gt;
&nbsp;     * {@link Answer} can be used to define the return values of unstubbed invocations.
&nbsp;     * &lt;p&gt;
&nbsp;     * This implementation can be helpful when working with legacy code.
&nbsp;     * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.
&nbsp;     * This implementation of Answer &lt;b&gt;returns SmartNull instead of null&lt;/b&gt;.
&nbsp;     * &lt;code&gt;SmartNull&lt;/code&gt; gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;code&gt;ReturnsSmartNulls&lt;/code&gt; first tries to return ordinary values (zeros, empty collections, empty string, etc.)
&nbsp;     * then it tries to return SmartNull. If the return type is final then plain &lt;code&gt;null&lt;/code&gt; is returned.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;code&gt;ReturnsSmartNulls&lt;/code&gt; will be probably the default return values strategy in Mockito 3.0.0
&nbsp;     * &lt;p&gt;
&nbsp;     * Example:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
&nbsp;     *
&nbsp;     *   //calling unstubbed method here:
&nbsp;     *   Stuff stuff = mock.getStuff();
&nbsp;     *
&nbsp;     *   //using object returned by unstubbed call:
&nbsp;     *   stuff.doSomething();
&nbsp;     *
&nbsp;     *   //Above doesn&#39;t yield NullPointerException this time!
&nbsp;     *   //Instead, SmartNullPointerException is thrown.
&nbsp;     *   //Exception&#39;s cause links to unstubbed &lt;i&gt;mock.getStuff()&lt;/i&gt; - just click on the stack trace.
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     */
<b class="fc">&nbsp;    public static final Answer&lt;Object&gt; RETURNS_SMART_NULLS = Answers.RETURNS_SMART_NULLS;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}
&nbsp;     * &lt;p&gt;
&nbsp;     * {@link Answer} can be used to define the return values of unstubbed invocations.
&nbsp;     * &lt;p&gt;
&nbsp;     * This implementation can be helpful when working with legacy code.
&nbsp;     * &lt;p&gt;
&nbsp;     * ReturnsMocks first tries to return ordinary values (zeros, empty collections, empty string, etc.)
&nbsp;     * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain &lt;code&gt;null&lt;/code&gt; is returned.
&nbsp;     * &lt;p&gt;
&nbsp;     */
<b class="fc">&nbsp;    public static final Answer&lt;Object&gt; RETURNS_MOCKS = Answers.RETURNS_MOCKS;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}.
&nbsp;     * &lt;p&gt;
&nbsp;     * Example that shows how deep stub works:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);
&nbsp;     *
&nbsp;     *   // note that we&#39;re stubbing a chain of methods here: getBar().getName()
&nbsp;     *   when(mock.getBar().getName()).thenReturn(&quot;deep&quot;);
&nbsp;     *
&nbsp;     *   // note that we&#39;re chaining method calls: getBar().getName()
&nbsp;     *   assertEquals(&quot;deep&quot;, mock.getBar().getName());
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;strong&gt;WARNING: &lt;/strong&gt;
&nbsp;     * This feature should rarely be required for regular clean code! Leave it for legacy code.
&nbsp;     * Mocking a mock to return a mock, to return a mock, (...), to return something meaningful
&nbsp;     * hints at violation of Law of Demeter or mocking a value object (a well known anti-pattern).
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Good quote I&#39;ve seen one day on the web: &lt;strong&gt;every time a mock returns a mock a fairy dies&lt;/strong&gt;.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Please note that this answer will return existing mocks that matches the stub. This
&nbsp;     * behavior is ok with deep stubs and allows verification to work on the last mock of the chain.
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   when(mock.getBar(anyString()).getThingy().getName()).thenReturn(&quot;deep&quot;);
&nbsp;     *
&nbsp;     *   mock.getBar(&quot;candy bar&quot;).getThingy().getName();
&nbsp;     *
&nbsp;     *   assertSame(mock.getBar(anyString()).getThingy().getName(), mock.getBar(anyString()).getThingy().getName());
&nbsp;     *   verify(mock.getBar(&quot;candy bar&quot;).getThingy()).getName();
&nbsp;     *   verify(mock.getBar(anyString()).getThingy()).getName();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Verification only works with the last mock in the chain. You can use verification modes.
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   when(person.getAddress(anyString()).getStreet().getName()).thenReturn(&quot;deep&quot;);
&nbsp;     *   when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn(&quot;deep&quot;);
&nbsp;     *   when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn(&quot;deep&quot;);
&nbsp;     *
&nbsp;     *   person.getAddress(&quot;the docks&quot;).getStreet().getName();
&nbsp;     *   person.getAddress(&quot;the docks&quot;).getStreet().getLongName();
&nbsp;     *   person.getAddress(&quot;the docks&quot;).getStreet(Locale.ITALIAN).getName();
&nbsp;     *   person.getAddress(&quot;the docks&quot;).getStreet(Locale.CHINESE).getName();
&nbsp;     *
&nbsp;     *   // note that we are actually referring to the very last mock in the stubbing chain.
&nbsp;     *   InOrder inOrder = inOrder(
&nbsp;     *       person.getAddress(&quot;the docks&quot;).getStreet(),
&nbsp;     *       person.getAddress(&quot;the docks&quot;).getStreet(Locale.CHINESE),
&nbsp;     *       person.getAddress(&quot;the docks&quot;).getStreet(Locale.ITALIAN)
&nbsp;     *   );
&nbsp;     *   inOrder.verify(person.getAddress(&quot;the docks&quot;).getStreet(), times(1)).getName();
&nbsp;     *   inOrder.verify(person.getAddress(&quot;the docks&quot;).getStreet()).getLongName();
&nbsp;     *   inOrder.verify(person.getAddress(&quot;the docks&quot;).getStreet(Locale.ITALIAN), atLeast(1)).getName();
&nbsp;     *   inOrder.verify(person.getAddress(&quot;the docks&quot;).getStreet(Locale.CHINESE)).getName();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * How deep stub work internally?
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   //this:
&nbsp;     *   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);
&nbsp;     *   when(mock.getBar().getName(), &quot;deep&quot;);
&nbsp;     *
&nbsp;     *   //is equivalent of
&nbsp;     *   Foo foo = mock(Foo.class);
&nbsp;     *   Bar bar = mock(Bar.class);
&nbsp;     *   when(foo.getBar()).thenReturn(bar);
&nbsp;     *   when(bar.getName()).thenReturn(&quot;deep&quot;);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This feature will not work when any return type of methods included in the chain cannot be mocked
&nbsp;     * (for example: is a primitive or a final class). This is because of java type system.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
<b class="fc">&nbsp;    public static final Answer&lt;Object&gt; RETURNS_DEEP_STUBS = Answers.RETURNS_DEEP_STUBS;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}
&nbsp;     * &lt;p&gt;
&nbsp;     * {@link Answer} can be used to define the return values of unstubbed invocations.
&nbsp;     * &lt;p&gt;
&nbsp;     * This implementation can be helpful when working with legacy code.
&nbsp;     * When this implementation is used, unstubbed methods will delegate to the real implementation.
&nbsp;     * This is a way to create a partial mock object that calls real methods by default.
&nbsp;     * &lt;p&gt;
&nbsp;     * As usual you are going to read &lt;b&gt;the partial mock warning&lt;/b&gt;:
&nbsp;     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
&nbsp;     * How does partial mock fit into this paradigm? Well, it just doesn&#39;t...
&nbsp;     * Partial mock usually means that the complexity has been moved to a different method on the same object.
&nbsp;     * In most cases, this is not the way you want to design your application.
&nbsp;     * &lt;p&gt;
&nbsp;     * However, there are rare cases when partial mocks come handy:
&nbsp;     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
&nbsp;     * However, I wouldn&#39;t use partial mocks for new, test-driven &amp; well-designed code.
&nbsp;     * &lt;p&gt;
&nbsp;     * Example:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);
&nbsp;     *
&nbsp;     * // this calls the real implementation of Foo.getSomething()
&nbsp;     * value = mock.getSomething();
&nbsp;     *
&nbsp;     * doReturn(fakeValue).when(mock).getSomething();
&nbsp;     *
&nbsp;     * // now fakeValue is returned
&nbsp;     * value = mock.getSomething();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;u&gt;Note:&lt;/u&gt; Stubbing partial mocks using &lt;code&gt;when(mock.getSomething()).thenReturn(fakeValue)&lt;/code&gt;
&nbsp;     * syntax will call the real method. For partial mock it&#39;s recommended to use &lt;code&gt;doReturn&lt;/code&gt; syntax.
&nbsp;     */
<b class="fc">&nbsp;    public static final Answer&lt;Object&gt; CALLS_REAL_METHODS = Answers.CALLS_REAL_METHODS;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}.
&nbsp;     *
&nbsp;     * Allows Builder mocks to return itself whenever a method is invoked that returns a Type equal
&nbsp;     * to the class or a superclass.
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;b&gt;Keep in mind this answer uses the return type of a method.
&nbsp;     * If this type is assignable to the class of the mock, it will return the mock.
&nbsp;     * Therefore if you have a method returning a superclass (for example {@code Object}) it will match and return the mock.&lt;/b&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * Consider a HttpBuilder used in a HttpRequesterWithHeaders.
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     * public class HttpRequesterWithHeaders {
&nbsp;     *
&nbsp;     *      private HttpBuilder builder;
&nbsp;     *
&nbsp;     *      public HttpRequesterWithHeaders(HttpBuilder builder) {
&nbsp;     *          this.builder = builder;
&nbsp;     *      }
&nbsp;     *
&nbsp;     *      public String request(String uri) {
&nbsp;     *          return builder.withUrl(uri)
&nbsp;     *                  .withHeader(&quot;Content-type: application/json&quot;)
&nbsp;     *                  .withHeader(&quot;Authorization: Bearer&quot;)
&nbsp;     *                  .request();
&nbsp;     *      }
&nbsp;     *  }
&nbsp;     *
&nbsp;     *  private static class HttpBuilder {
&nbsp;     *
&nbsp;     *      private String uri;
&nbsp;     *      private List&amp;lt;String&amp;gt; headers;
&nbsp;     *
&nbsp;     *      public HttpBuilder() {
&nbsp;     *          this.headers = new ArrayList&amp;lt;String&amp;gt;();
&nbsp;     *      }
&nbsp;     *
&nbsp;     *       public HttpBuilder withUrl(String uri) {
&nbsp;     *           this.uri = uri;
&nbsp;     *           return this;
&nbsp;     *       }
&nbsp;     *
&nbsp;     *       public HttpBuilder withHeader(String header) {
&nbsp;     *           this.headers.add(header);
&nbsp;     *           return this;
&nbsp;     *       }
&nbsp;     *
&nbsp;     *       public String request() {
&nbsp;     *          return uri + headers.toString();
&nbsp;     *       }
&nbsp;     *  }
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * The following test will succeed
&nbsp;     *
&nbsp;     * &lt;pre&gt;&lt;code&gt;
&nbsp;     * &amp;#064;Test
&nbsp;     *  public void use_full_builder_with_terminating_method() {
&nbsp;     *      HttpBuilder builder = mock(HttpBuilder.class, RETURNS_SELF);
&nbsp;     *      HttpRequesterWithHeaders requester = new HttpRequesterWithHeaders(builder);
&nbsp;     *      String response = &quot;StatusCode: 200&quot;;
&nbsp;     *
&nbsp;     *      when(builder.request()).thenReturn(response);
&nbsp;     *
&nbsp;     *      assertThat(requester.request(&quot;URI&quot;)).isEqualTo(response);
&nbsp;     *  }
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     */
<b class="fc">&nbsp;    public static final Answer&lt;Object&gt; RETURNS_SELF = Answers.RETURNS_SELF;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates mock object of given class or interface.
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param classToMock class or interface to mock
&nbsp;     * @return mock object
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static &lt;T&gt; T mock(Class&lt;T&gt; classToMock) {
<b class="fc">&nbsp;        return mock(classToMock, withSettings());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.
&nbsp;     * &lt;p&gt;
&nbsp;     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.
&nbsp;     * &lt;b&gt;If you have too many mocks then refactor the code&lt;/b&gt; so that it&#39;s easy to test/debug without necessity of naming mocks.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;If you use &lt;code&gt;&amp;#064;Mock&lt;/code&gt; annotation then you&#39;ve got naming mocks for free!&lt;/b&gt; &lt;code&gt;&amp;#064;Mock&lt;/code&gt; uses field name as mock name. {@link Mock Read more.}
&nbsp;     * &lt;p&gt;
&nbsp;     *
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param classToMock class or interface to mock
&nbsp;     * @param name of the mock
&nbsp;     * @return mock object
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static &lt;T&gt; T mock(Class&lt;T&gt; classToMock, String name) {
<b class="nc">&nbsp;        return mock(classToMock, withSettings()</b>
<b class="nc">&nbsp;                .name(name)</b>
<b class="nc">&nbsp;                .defaultAnswer(RETURNS_DEFAULTS));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a MockingDetails instance that enables inspecting a particular object for Mockito related information.
&nbsp;     * Can be used to find out if given object is a Mockito mock
&nbsp;     * or to find out if a given mock is a spy or mock.
&nbsp;     * &lt;p&gt;
&nbsp;     * In future Mockito versions MockingDetails may grow and provide other useful information about the mock,
&nbsp;     * e.g. invocations, stubbing info, etc.
&nbsp;     *
&nbsp;     * @param toInspect - object to inspect. null input is allowed.
&nbsp;     * @return A {@link org.mockito.MockingDetails} instance.
&nbsp;     * @since 1.9.5
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static MockingDetails mockingDetails(Object toInspect) {
<b class="nc">&nbsp;        return MOCKITO_CORE.mockingDetails(toInspect);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates mock with a specified strategy for its answers to interactions.
&nbsp;     * It&#39;s quite an advanced feature and typically you don&#39;t need it to write decent tests.
&nbsp;     * However it can be helpful when working with legacy systems.
&nbsp;     * &lt;p&gt;
&nbsp;     * It is the default answer so it will be used &lt;b&gt;only when you don&#39;t&lt;/b&gt; stub the method call.
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
&nbsp;     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;See examples in javadoc for {@link Mockito} class&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param classToMock class or interface to mock
&nbsp;     * @param defaultAnswer default answer for unstubbed methods
&nbsp;     *
&nbsp;     * @return mock object
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static &lt;T&gt; T mock(Class&lt;T&gt; classToMock, Answer defaultAnswer) {
<b class="nc">&nbsp;        return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a mock with some non-standard settings.
&nbsp;     * &lt;p&gt;
&nbsp;     * The number of configuration points for a mock grows
&nbsp;     * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods.
&nbsp;     * Hence {@link MockSettings}.
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   Listener mock = mock(Listener.class, withSettings()
&nbsp;     *     .name(&quot;firstListner&quot;).defaultBehavior(RETURNS_SMART_NULLS));
&nbsp;     *   );
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;b&gt;Use it carefully and occasionally&lt;/b&gt;. What might be reason your test needs non-standard mocks?
&nbsp;     * Is the code under test so complicated that it requires non-standard mocks?
&nbsp;     * Wouldn&#39;t you prefer to refactor the code under test so it is testable in a simple way?
&nbsp;     * &lt;p&gt;
&nbsp;     * See also {@link Mockito#withSettings()}
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param classToMock class or interface to mock
&nbsp;     * @param mockSettings additional mock settings
&nbsp;     * @return mock object
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static &lt;T&gt; T mock(Class&lt;T&gt; classToMock, MockSettings mockSettings) {
<b class="fc">&nbsp;        return MOCKITO_CORE.mock(classToMock, mockSettings);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a spy of the real object. The spy calls &lt;b&gt;real&lt;/b&gt; methods unless they are stubbed.
&nbsp;     * &lt;p&gt;
&nbsp;     * Real spies should be used &lt;b&gt;carefully and occasionally&lt;/b&gt;, for example when dealing with legacy code.
&nbsp;     * &lt;p&gt;
&nbsp;     * As usual you are going to read &lt;b&gt;the partial mock warning&lt;/b&gt;:
&nbsp;     * Object oriented programming tackles complexity by dividing the complexity into separate, specific, SRPy objects.
&nbsp;     * How does partial mock fit into this paradigm? Well, it just doesn&#39;t...
&nbsp;     * Partial mock usually means that the complexity has been moved to a different method on the same object.
&nbsp;     * In most cases, this is not the way you want to design your application.
&nbsp;     * &lt;p&gt;
&nbsp;     * However, there are rare cases when partial mocks come handy:
&nbsp;     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
&nbsp;     * However, I wouldn&#39;t use partial mocks for new, test-driven &amp; well-designed code.
&nbsp;     * &lt;p&gt;
&nbsp;     * Example:
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   List list = new LinkedList();
&nbsp;     *   List spy = spy(list);
&nbsp;     *
&nbsp;     *   //optionally, you can stub out some methods:
&nbsp;     *   when(spy.size()).thenReturn(100);
&nbsp;     *
&nbsp;     *   //using the spy calls &lt;b&gt;real&lt;/b&gt; methods
&nbsp;     *   spy.add(&quot;one&quot;);
&nbsp;     *   spy.add(&quot;two&quot;);
&nbsp;     *
&nbsp;     *   //prints &quot;one&quot; - the first element of a list
&nbsp;     *   System.out.println(spy.get(0));
&nbsp;     *
&nbsp;     *   //size() method was stubbed - 100 is printed
&nbsp;     *   System.out.println(spy.size());
&nbsp;     *
&nbsp;     *   //optionally, you can verify
&nbsp;     *   verify(spy).add(&quot;one&quot;);
&nbsp;     *   verify(spy).add(&quot;two&quot;);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;h4&gt;Important gotcha on spying real objects!&lt;/h4&gt;
&nbsp;     * &lt;ol&gt;
&nbsp;     * &lt;li&gt;Sometimes it&#39;s impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.
&nbsp;     * Therefore for spies it is recommended to always use &lt;code&gt;doReturn&lt;/code&gt;|&lt;code&gt;Answer&lt;/code&gt;|&lt;code&gt;Throw()&lt;/code&gt;|&lt;code&gt;CallRealMethod&lt;/code&gt;
&nbsp;     * family of methods for stubbing. Example:
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   List list = new LinkedList();
&nbsp;     *   List spy = spy(list);
&nbsp;     *
&nbsp;     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
&nbsp;     *   when(spy.get(0)).thenReturn(&quot;foo&quot;);
&nbsp;     *
&nbsp;     *   //You have to use doReturn() for stubbing
&nbsp;     *   doReturn(&quot;foo&quot;).when(spy).get(0);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;/li&gt;
&nbsp;     *
&nbsp;     * &lt;li&gt;Mockito &lt;b&gt;*does not*&lt;/b&gt; delegate calls to the passed real instance, instead it actually creates a copy of it.
&nbsp;     * So if you keep the real instance and interact with it, don&#39;t expect the spied to be aware of those interaction
&nbsp;     * and their effect on real instance state.
&nbsp;     * The corollary is that when an &lt;b&gt;*unstubbed*&lt;/b&gt; method is called &lt;b&gt;*on the spy*&lt;/b&gt; but &lt;b&gt;*not on the real instance*&lt;/b&gt;,
&nbsp;     * you won&#39;t see any effects on the real instance.&lt;/li&gt;
&nbsp;     *
&nbsp;     * &lt;li&gt;Watch out for final methods.
&nbsp;     * Mockito doesn&#39;t mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
&nbsp;     * Also you won&#39;t be able to verify those method as well.
&nbsp;     * &lt;/li&gt;
&nbsp;     * &lt;/ol&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * &lt;p&gt;Note that the spy won&#39;t have any annotations of the spied type, because CGLIB won&#39;t rewrite them.
&nbsp;     * It may troublesome for code that rely on the spy to have these annotations.&lt;/p&gt;
&nbsp;     *
&nbsp;     *
&nbsp;     * @param object
&nbsp;     *            to spy on
&nbsp;     * @return a spy of the real object
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static &lt;T&gt; T spy(T object) {
<b class="fc">&nbsp;        return MOCKITO_CORE.mock((Class&lt;T&gt;) object.getClass(), withSettings()</b>
<b class="fc">&nbsp;                .spiedInstance(object)</b>
<b class="fc">&nbsp;                .defaultAnswer(CALLS_REAL_METHODS));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Please refer to the documentation of {@link #spy(Object)}.
&nbsp;     * Overusing spies hints at code design smells.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method, in contrast to the original {@link #spy(Object)}, creates a spy based on class instead of an object.
&nbsp;     * Sometimes it is more convenient to create spy based on the class and avoid providing an instance of a spied object.
&nbsp;     * This is particularly useful for spying on abstract classes because they cannot be instantiated.
&nbsp;     * See also {@link MockSettings#useConstructor(Object...)}.
&nbsp;     * &lt;p&gt;
&nbsp;     * Examples:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   SomeAbstract spy = spy(SomeAbstract.class);
&nbsp;     *
&nbsp;     *   //Robust API, via settings builder:
&nbsp;     *   OtherAbstract spy = mock(OtherAbstract.class, withSettings()
&nbsp;     *      .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
&nbsp;     *
&nbsp;     *   //Mocking a non-static inner abstract class:
&nbsp;     *   InnerAbstract spy = mock(InnerAbstract.class, withSettings()
&nbsp;     *      .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param classToSpy the class to spy
&nbsp;     * @param &lt;T&gt; type of the spy
&nbsp;     * @return a spy of the provided class
&nbsp;     * @since 1.10.12
&nbsp;     */
&nbsp;    @Incubating
&nbsp;    @CheckReturnValue
&nbsp;    public static &lt;T&gt; T spy(Class&lt;T&gt; classToSpy) {
<b class="nc">&nbsp;        return MOCKITO_CORE.mock(classToSpy, withSettings()</b>
<b class="nc">&nbsp;                .useConstructor()</b>
<b class="nc">&nbsp;                .defaultAnswer(CALLS_REAL_METHODS));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called.
&nbsp;     * &lt;p&gt;
&nbsp;     * Simply put: &quot;&lt;b&gt;When&lt;/b&gt; the x method is called &lt;b&gt;then&lt;/b&gt; return y&quot;.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Examples:
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     * &lt;b&gt;when&lt;/b&gt;(mock.someMethod()).&lt;b&gt;thenReturn&lt;/b&gt;(10);
&nbsp;     *
&nbsp;     * //you can use flexible argument matchers, e.g:
&nbsp;     * when(mock.someMethod(&lt;b&gt;anyString()&lt;/b&gt;)).thenReturn(10);
&nbsp;     *
&nbsp;     * //setting exception to be thrown:
&nbsp;     * when(mock.someMethod(&quot;some arg&quot;)).thenThrow(new RuntimeException());
&nbsp;     *
&nbsp;     * //you can set different behavior for consecutive method calls.
&nbsp;     * //Last stubbing (e.g: thenReturn(&quot;foo&quot;)) determines the behavior of further consecutive calls.
&nbsp;     * when(mock.someMethod(&quot;some arg&quot;))
&nbsp;     *  .thenThrow(new RuntimeException())
&nbsp;     *  .thenReturn(&quot;foo&quot;);
&nbsp;     *
&nbsp;     * //Alternative, shorter version for consecutive stubbing:
&nbsp;     * when(mock.someMethod(&quot;some arg&quot;))
&nbsp;     *  .thenReturn(&quot;one&quot;, &quot;two&quot;);
&nbsp;     * //is the same as:
&nbsp;     * when(mock.someMethod(&quot;some arg&quot;))
&nbsp;     *  .thenReturn(&quot;one&quot;)
&nbsp;     *  .thenReturn(&quot;two&quot;);
&nbsp;     *
&nbsp;     * //shorter version for consecutive method calls throwing exceptions:
&nbsp;     * when(mock.someMethod(&quot;some arg&quot;))
&nbsp;     *  .thenThrow(new RuntimeException(), new NullPointerException();
&nbsp;     *
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable...)}
&nbsp;     * &lt;p&gt;
&nbsp;     * Stubbing can be overridden: for example common stubbing can go to fixture
&nbsp;     * setup but the test methods can override it.
&nbsp;     * Please note that overridding stubbing is a potential code smell that points out too much stubbing.
&nbsp;     * &lt;p&gt;
&nbsp;     * Once stubbed, the method will always return stubbed value regardless
&nbsp;     * of how many times it is called.
&nbsp;     * &lt;p&gt;
&nbsp;     * Last stubbing is more important - when you stubbed the same method with
&nbsp;     * the same arguments many times.
&nbsp;     * &lt;p&gt;
&nbsp;     * Although it is possible to verify a stubbed invocation, usually &lt;b&gt;it&#39;s just redundant&lt;/b&gt;.
&nbsp;     * Let&#39;s say you&#39;ve stubbed &lt;code&gt;foo.bar()&lt;/code&gt;.
&nbsp;     * If your code cares what &lt;code&gt;foo.bar()&lt;/code&gt; returns then something else breaks(often before even &lt;code&gt;verify()&lt;/code&gt; gets executed).
&nbsp;     * If your code doesn&#39;t care what &lt;code&gt;get(0)&lt;/code&gt; returns then it should not be stubbed.
&nbsp;     * Not convinced? See &lt;a href=&quot;http://monkeyisland.pl/2008/04/26/asking-and-telling&quot;&gt;here&lt;/a&gt;.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     * @param methodCall method to be stubbed
&nbsp;     * @return OngoingStubbing object used to stub fluently.
&nbsp;     *         &lt;strong&gt;Do not&lt;/strong&gt; create a reference to this returned object.
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static &lt;T&gt; OngoingStubbing&lt;T&gt; when(T methodCall) {
<b class="fc">&nbsp;        return MOCKITO_CORE.when(methodCall);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Verifies certain behavior &lt;b&gt;happened once&lt;/b&gt;.
&nbsp;     * &lt;p&gt;
&nbsp;     * Alias to &lt;code&gt;verify(mock, times(1))&lt;/code&gt; E.g:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   verify(mock).someMethod(&quot;some arg&quot;);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * Above is equivalent to:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   verify(mock, times(1)).someMethod(&quot;some arg&quot;);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Arguments passed are compared using &lt;code&gt;equals()&lt;/code&gt; method.
&nbsp;     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.
&nbsp;     * &lt;p&gt;
&nbsp;     * Although it is possible to verify a stubbed invocation, usually &lt;b&gt;it&#39;s just redundant&lt;/b&gt;.
&nbsp;     * Let&#39;s say you&#39;ve stubbed &lt;code&gt;foo.bar()&lt;/code&gt;.
&nbsp;     * If your code cares what &lt;code&gt;foo.bar()&lt;/code&gt; returns then something else breaks(often before even &lt;code&gt;verify()&lt;/code&gt; gets executed).
&nbsp;     * If your code doesn&#39;t care what &lt;code&gt;get(0)&lt;/code&gt; returns then it should not be stubbed.
&nbsp;     * Not convinced? See &lt;a href=&quot;http://monkeyisland.pl/2008/04/26/asking-and-telling&quot;&gt;here&lt;/a&gt;.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param mock to be verified
&nbsp;     * @return mock object itself
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static &lt;T&gt; T verify(T mock) {
<b class="nc">&nbsp;        return MOCKITO_CORE.verify(mock, times(1));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Verifies certain behavior happened at least once / exact number of times / never. E.g:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   verify(mock, times(5)).someMethod(&quot;was called five times&quot;);
&nbsp;     *
&nbsp;     *   verify(mock, atLeast(2)).someMethod(&quot;was called at least two times&quot;);
&nbsp;     *
&nbsp;     *   //you can use flexible argument matchers, e.g:
&nbsp;     *   verify(mock, atLeastOnce()).someMethod(&lt;b&gt;anyString()&lt;/b&gt;);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;b&gt;times(1) is the default&lt;/b&gt; and can be omitted
&nbsp;     * &lt;p&gt;
&nbsp;     * Arguments passed are compared using &lt;code&gt;equals()&lt;/code&gt; method.
&nbsp;     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.
&nbsp;     * &lt;p&gt;
&nbsp;     *
&nbsp;     * @param mock to be verified
&nbsp;     * @param mode times(x), atLeastOnce() or never()
&nbsp;     *
&nbsp;     * @return mock object itself
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static &lt;T&gt; T verify(T mock, VerificationMode mode) {
<b class="nc">&nbsp;        return MOCKITO_CORE.verify(mock, mode);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
&nbsp;     * Normally, you don&#39;t need to reset your mocks, just create new mocks for each test method.
&nbsp;     * &lt;p&gt;
&nbsp;     * Instead of &lt;code&gt;#reset()&lt;/code&gt; please consider writing simple, small and focused test methods over lengthy, over-specified tests.
&nbsp;     * &lt;b&gt;First potential code smell is &lt;code&gt;reset()&lt;/code&gt; in the middle of the test method.&lt;/b&gt; This probably means you&#39;re testing too much.
&nbsp;     * Follow the whisper of your test methods: &quot;Please keep us small &amp; focused on single behavior&quot;.
&nbsp;     * There are several threads about it on mockito mailing list.
&nbsp;     * &lt;p&gt;
&nbsp;     * The only reason we added &lt;code&gt;reset()&lt;/code&gt; method is to
&nbsp;     * make it possible to work with container-injected mocks.
&nbsp;     * For more information see the FAQ (&lt;a href=&quot;https://github.com/mockito/mockito/wiki/FAQ&quot;&gt;here&lt;/a&gt;).
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Don&#39;t harm yourself.&lt;/b&gt; &lt;code&gt;reset()&lt;/code&gt; in the middle of the test method is a code smell (you&#39;re probably testing too much).
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   List mock = mock(List.class);
&nbsp;     *   when(mock.size()).thenReturn(10);
&nbsp;     *   mock.add(1);
&nbsp;     *
&nbsp;     *   reset(mock);
&nbsp;     *   //at this point the mock forgot any interactions &amp; stubbing
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The Type of the mocks
&nbsp;     * @param mocks to be reset
&nbsp;     */
&nbsp;    public static &lt;T&gt; void reset(T ... mocks) {
<b class="nc">&nbsp;        MOCKITO_CORE.reset(mocks);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Use this method in order to only clear invocations, when stubbing is non-trivial. Use-cases can be:
&nbsp;     * &lt;ul&gt;
&nbsp;     *     &lt;li&gt;You are using a dependency injection framework to inject your mocks.&lt;/li&gt;
&nbsp;     *     &lt;li&gt;The mock is used in a stateful scenario. For example a class is Singleton which depends on your mock.&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     *
&nbsp;     * &lt;b&gt;Try to avoid this method at all costs. Only clear invocations if you are unable to efficiently test your program.&lt;/b&gt;
&nbsp;     * @param &lt;T&gt; The type of the mocks
&nbsp;     * @param mocks The mocks to clear the invocations for
&nbsp;     */
&nbsp;    public static &lt;T&gt; void clearInvocations(T ... mocks) {
<b class="nc">&nbsp;        MOCKITO_CORE.clearInvocations(mocks);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if any of given mocks has any unverified interaction.
&nbsp;     * &lt;p&gt;
&nbsp;     * You can use this method after you verified your mocks - to make sure that nothing
&nbsp;     * else was invoked on your mocks.
&nbsp;     * &lt;p&gt;
&nbsp;     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.
&nbsp;     * &lt;p&gt;
&nbsp;     * Stubbed invocations (if called) are also treated as interactions.
&nbsp;     * If you want stubbed invocations automatically verified, check out {@link Strictness#STRICT_STUBS} feature
&nbsp;     * introduced in Mockito 2.3.0.
&nbsp;     * If you want to ignore stubs for verification, see {@link #ignoreStubs(Object...)}.
&nbsp;     * &lt;p&gt;
&nbsp;     * A word of &lt;b&gt;warning&lt;/b&gt;:
&nbsp;     * Some users who did a lot of classic, expect-run-verify mocking tend to use &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; very often, even in every test method.
&nbsp;     * &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; is not recommended to use in every test method.
&nbsp;     * &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; is a handy assertion from the interaction testing toolkit. Use it only when it&#39;s relevant.
&nbsp;     * Abusing it leads to overspecified, less maintainable tests. You can find further reading
&nbsp;     * &lt;a href=&quot;http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/&quot;&gt;here&lt;/a&gt;.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method will also detect unverified invocations that occurred before the test method,
&nbsp;     * for example: in &lt;code&gt;setUp()&lt;/code&gt;, &lt;code&gt;&amp;#064;Before&lt;/code&gt; method or in constructor.
&nbsp;     * Consider writing nice code that makes interactions only in test methods.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Example:
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     * //interactions
&nbsp;     * mock.doSomething();
&nbsp;     * mock.doSomethingUnexpected();
&nbsp;     *
&nbsp;     * //verification
&nbsp;     * verify(mock).doSomething();
&nbsp;     *
&nbsp;     * //following will fail because &#39;doSomethingUnexpected()&#39; is unexpected
&nbsp;     * verifyNoMoreInteractions(mock);
&nbsp;     *
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param mocks to be verified
&nbsp;     */
&nbsp;    public static void verifyNoMoreInteractions(Object... mocks) {
<b class="nc">&nbsp;        MOCKITO_CORE.verifyNoMoreInteractions(mocks);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Verifies that no interactions happened on given mocks beyond the previously verified interactions.&lt;br/&gt;
&nbsp;     * This method has the same behavior as {@link #verifyNoMoreInteractions(Object...)}.
&nbsp;     *
&nbsp;     * @param mocks to be verified
&nbsp;     */
&nbsp;    public static void verifyZeroInteractions(Object... mocks) {
<b class="nc">&nbsp;        MOCKITO_CORE.verifyNoMoreInteractions(mocks);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Use &lt;code&gt;doThrow()&lt;/code&gt; when you want to stub the void method with an exception.
&nbsp;     * &lt;p&gt;
&nbsp;     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler
&nbsp;     * does not like void methods inside brackets...
&nbsp;     * &lt;p&gt;
&nbsp;     * Example:
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   doThrow(new RuntimeException()).when(mock).someVoidMethod();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param toBeThrown to be thrown when the stubbed method is called
&nbsp;     * @return stubber - to select a method for stubbing
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static Stubber doThrow(Throwable... toBeThrown) {
<b class="nc">&nbsp;        return MOCKITO_CORE.stubber().doThrow(toBeThrown);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Use &lt;code&gt;doThrow()&lt;/code&gt; when you want to stub the void method with an exception.
&nbsp;     * &lt;p&gt;
&nbsp;     * A new exception instance will be created for each method invocation.
&nbsp;     * &lt;p&gt;
&nbsp;     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler
&nbsp;     * does not like void methods inside brackets...
&nbsp;     * &lt;p&gt;
&nbsp;     * Example:
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   doThrow(RuntimeException.class).when(mock).someVoidMethod();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param toBeThrown to be thrown when the stubbed method is called
&nbsp;     * @return stubber - to select a method for stubbing
&nbsp;     * @since 2.1.0
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static Stubber doThrow(Class&lt;? extends Throwable&gt; toBeThrown) {
<b class="nc">&nbsp;        return MOCKITO_CORE.stubber().doThrow(toBeThrown);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Same as {@link #doThrow(Class)} but sets consecutive exception classes to be thrown. Remember to use
&nbsp;     * &lt;code&gt;doThrow()&lt;/code&gt; when you want to stub the void method to throw several exception of specified class.
&nbsp;     * &lt;p&gt;
&nbsp;     * A new exception instance will be created for each method invocation.
&nbsp;     * &lt;p&gt;
&nbsp;     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler
&nbsp;     * does not like void methods inside brackets...
&nbsp;     * &lt;p&gt;
&nbsp;     * Example:
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   doThrow(RuntimeException.class, BigFailure.class).when(mock).someVoidMethod();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * @param toBeThrown to be thrown when the stubbed method is called
&nbsp;     * @param toBeThrownNext next to be thrown when the stubbed method is called
&nbsp;     * @return stubber - to select a method for stubbing
&nbsp;     * @since 2.1.0
&nbsp;     */
&nbsp;    // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array creation
&nbsp;    @SuppressWarnings ({&quot;unchecked&quot;, &quot;varargs&quot;})
&nbsp;    @CheckReturnValue
&nbsp;    public static Stubber doThrow(Class&lt;? extends Throwable&gt; toBeThrown, Class&lt;? extends Throwable&gt;... toBeThrownNext) {
<b class="nc">&nbsp;        return MOCKITO_CORE.stubber().doThrow(toBeThrown, toBeThrownNext);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Use &lt;code&gt;doCallRealMethod()&lt;/code&gt; when you want to call the real implementation of a method.
&nbsp;     * &lt;p&gt;
&nbsp;     * As usual you are going to read &lt;b&gt;the partial mock warning&lt;/b&gt;:
&nbsp;     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
&nbsp;     * How does partial mock fit into this paradigm? Well, it just doesn&#39;t...
&nbsp;     * Partial mock usually means that the complexity has been moved to a different method on the same object.
&nbsp;     * In most cases, this is not the way you want to design your application.
&nbsp;     * &lt;p&gt;
&nbsp;     * However, there are rare cases when partial mocks come handy:
&nbsp;     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
&nbsp;     * However, I wouldn&#39;t use partial mocks for new, test-driven &amp; well-designed code.
&nbsp;     * &lt;p&gt;
&nbsp;     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks.
&nbsp;     * &lt;b&gt;Mockito.spy() is a recommended way of creating partial mocks.&lt;/b&gt;
&nbsp;     * The reason is it guarantees real methods are called against correctly constructed object because you&#39;re responsible for constructing the object passed to spy() method.
&nbsp;     * &lt;p&gt;
&nbsp;     * Example:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   Foo mock = mock(Foo.class);
&nbsp;     *   doCallRealMethod().when(mock).someVoidMethod();
&nbsp;     *
&nbsp;     *   // this will call the real implementation of Foo.someVoidMethod()
&nbsp;     *   mock.someVoidMethod();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @return stubber - to select a method for stubbing
&nbsp;     * @since 1.9.5
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static Stubber doCallRealMethod() {
<b class="fc">&nbsp;        return MOCKITO_CORE.stubber().doCallRealMethod();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Use &lt;code&gt;doAnswer()&lt;/code&gt; when you want to stub a void method with generic {@link Answer}.
&nbsp;     * &lt;p&gt;
&nbsp;     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...
&nbsp;     * &lt;p&gt;
&nbsp;     * Example:
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *  doAnswer(new Answer() {
&nbsp;     *      public Object answer(InvocationOnMock invocation) {
&nbsp;     *          Object[] args = invocation.getArguments();
&nbsp;     *          Mock mock = invocation.getMock();
&nbsp;     *          return null;
&nbsp;     *      }})
&nbsp;     *  .when(mock).someMethod();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param answer to answer when the stubbed method is called
&nbsp;     * @return stubber - to select a method for stubbing
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static Stubber doAnswer(Answer answer) {
<b class="nc">&nbsp;        return MOCKITO_CORE.stubber().doAnswer(answer);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Use &lt;code&gt;doNothing()&lt;/code&gt; for setting void methods to do nothing. &lt;b&gt;Beware that void methods on mocks do nothing by default!&lt;/b&gt;
&nbsp;     * However, there are rare situations when doNothing() comes handy:
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;ol&gt;
&nbsp;     * &lt;li&gt;Stubbing consecutive calls on a void method:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   doNothing().
&nbsp;     *   doThrow(new RuntimeException())
&nbsp;     *   .when(mock).someVoidMethod();
&nbsp;     *
&nbsp;     *   //does nothing the first time:
&nbsp;     *   mock.someVoidMethod();
&nbsp;     *
&nbsp;     *   //throws RuntimeException the next time:
&nbsp;     *   mock.someVoidMethod();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;/li&gt;
&nbsp;     * &lt;li&gt;When you spy real objects and you want the void method to do nothing:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   List list = new LinkedList();
&nbsp;     *   List spy = spy(list);
&nbsp;     *
&nbsp;     *   //let&#39;s make clear() do nothing
&nbsp;     *   doNothing().when(spy).clear();
&nbsp;     *
&nbsp;     *   spy.add(&quot;one&quot;);
&nbsp;     *
&nbsp;     *   //clear() does nothing, so the list still contains &quot;one&quot;
&nbsp;     *   spy.clear();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;/li&gt;
&nbsp;     * &lt;/ol&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @return stubber - to select a method for stubbing
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static Stubber doNothing() {
<b class="fc">&nbsp;        return MOCKITO_CORE.stubber().doNothing();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Use &lt;code&gt;doReturn()&lt;/code&gt; in those rare occasions when you cannot use {@link Mockito#when(Object)}.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe
&nbsp;     * and more readable&lt;/b&gt; (especially when stubbing consecutive calls).
&nbsp;     * &lt;p&gt;
&nbsp;     * Here are those rare occasions when doReturn() comes handy:
&nbsp;     * &lt;p&gt;
&nbsp;     *
&nbsp;     * &lt;ol&gt;
&nbsp;     * &lt;li&gt;When spying real objects and calling real methods on a spy brings side effects
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   List list = new LinkedList();
&nbsp;     *   List spy = spy(list);
&nbsp;     *
&nbsp;     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
&nbsp;     *   when(spy.get(0)).thenReturn(&quot;foo&quot;);
&nbsp;     *
&nbsp;     *   //You have to use doReturn() for stubbing:
&nbsp;     *   doReturn(&quot;foo&quot;).when(spy).get(0);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;/li&gt;
&nbsp;     *
&nbsp;     * &lt;li&gt;Overriding a previous exception-stubbing:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   when(mock.foo()).thenThrow(new RuntimeException());
&nbsp;     *
&nbsp;     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.
&nbsp;     *   when(mock.foo()).thenReturn(&quot;bar&quot;);
&nbsp;     *
&nbsp;     *   //You have to use doReturn() for stubbing:
&nbsp;     *   doReturn(&quot;bar&quot;).when(mock).foo();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;/li&gt;
&nbsp;     * &lt;/ol&gt;
&nbsp;     *
&nbsp;     * Above scenarios shows a tradeoff of Mockito&#39;s elegant syntax. Note that the scenarios are very rare, though.
&nbsp;     * Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general
&nbsp;     * overridding stubbing is a potential code smell that points out too much stubbing.
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param toBeReturned to be returned when the stubbed method is called
&nbsp;     * @return stubber - to select a method for stubbing
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static Stubber doReturn(Object toBeReturned) {
<b class="fc">&nbsp;        return MOCKITO_CORE.stubber().doReturn(toBeReturned);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Same as {@link #doReturn(Object)} but sets consecutive values to be returned. Remember to use
&nbsp;     * &lt;code&gt;doReturn()&lt;/code&gt; in those rare occasions when you cannot use {@link Mockito#when(Object)}.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe
&nbsp;     * and more readable&lt;/b&gt; (especially when stubbing consecutive calls).
&nbsp;     * &lt;p&gt;
&nbsp;     * Here are those rare occasions when doReturn() comes handy:
&nbsp;     * &lt;p&gt;
&nbsp;     *
&nbsp;     * &lt;ol&gt;
&nbsp;     * &lt;li&gt;When spying real objects and calling real methods on a spy brings side effects
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   List list = new LinkedList();
&nbsp;     *   List spy = spy(list);
&nbsp;     *
&nbsp;     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
&nbsp;     *   when(spy.get(0)).thenReturn(&quot;foo&quot;, &quot;bar&quot;, &quot;qix&quot;);
&nbsp;     *
&nbsp;     *   //You have to use doReturn() for stubbing:
&nbsp;     *   doReturn(&quot;foo&quot;, &quot;bar&quot;, &quot;qix&quot;).when(spy).get(0);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;/li&gt;
&nbsp;     *
&nbsp;     * &lt;li&gt;Overriding a previous exception-stubbing:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   when(mock.foo()).thenThrow(new RuntimeException());
&nbsp;     *
&nbsp;     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.
&nbsp;     *   when(mock.foo()).thenReturn(&quot;bar&quot;, &quot;foo&quot;, &quot;qix&quot;);
&nbsp;     *
&nbsp;     *   //You have to use doReturn() for stubbing:
&nbsp;     *   doReturn(&quot;bar&quot;, &quot;foo&quot;, &quot;qix&quot;).when(mock).foo();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;/li&gt;
&nbsp;     * &lt;/ol&gt;
&nbsp;     *
&nbsp;     * Above scenarios shows a trade-off of Mockito&#39;s elegant syntax. Note that the scenarios are very rare, though.
&nbsp;     * Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general
&nbsp;     * overridding stubbing is a potential code smell that points out too much stubbing.
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param toBeReturned to be returned when the stubbed method is called
&nbsp;     * @param toBeReturnedNext to be returned in consecutive calls when the stubbed method is called
&nbsp;     * @return stubber - to select a method for stubbing
&nbsp;     * @since 2.1.0
&nbsp;     */
&nbsp;    @SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})
&nbsp;    @CheckReturnValue
&nbsp;    public static Stubber doReturn(Object toBeReturned, Object... toBeReturnedNext) {
<b class="nc">&nbsp;        return MOCKITO_CORE.stubber().doReturn(toBeReturned, toBeReturnedNext);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates {@link org.mockito.InOrder} object that allows verifying mocks in order.
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   InOrder inOrder = inOrder(firstMock, secondMock);
&nbsp;     *
&nbsp;     *   inOrder.verify(firstMock).add(&quot;was called first&quot;);
&nbsp;     *   inOrder.verify(secondMock).add(&quot;was called second&quot;);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * Verification in order is flexible - &lt;b&gt;you don&#39;t have to verify all interactions&lt;/b&gt; one-by-one
&nbsp;     * but only those that you are interested in testing in order.
&nbsp;     * &lt;p&gt;
&nbsp;     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;code&gt;InOrder&lt;/code&gt; verification is &#39;greedy&#39;, but you will hardly ever notice it.
&nbsp;     * If you want to find out more, read
&nbsp;     * &lt;a href=&quot;https://github.com/mockito/mockito/wiki/Greedy-algorithm-of-verfication-InOrder&quot;&gt;this wiki page&lt;/a&gt;.
&nbsp;     * &lt;p&gt;
&nbsp;     * As of Mockito 1.8.4 you can verifyNoMoreInvocations() in order-sensitive way. Read more: {@link InOrder#verifyNoMoreInteractions()}
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param mocks to be verified in order
&nbsp;     *
&nbsp;     * @return InOrder object to be used to verify in order
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static InOrder inOrder(Object... mocks) {
<b class="nc">&nbsp;        return MOCKITO_CORE.inOrder(mocks);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Ignores stubbed methods of given mocks for the sake of verification.
&nbsp;     * Sometimes useful when coupled with &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; or verification &lt;code&gt;inOrder()&lt;/code&gt;.
&nbsp;     * Helps avoiding redundant verification of stubbed calls - typically we&#39;re not interested in verifying stubs.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Warning&lt;/b&gt;, &lt;code&gt;ignoreStubs()&lt;/code&gt; might lead to overuse of &lt;code&gt;verifyNoMoreInteractions(ignoreStubs(...));&lt;/code&gt;
&nbsp;     * Bear in mind that Mockito does not recommend bombarding every test with &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt;
&nbsp;     * for the reasons outlined in javadoc for {@link Mockito#verifyNoMoreInteractions(Object...)}
&nbsp;     * Other words: all &lt;b&gt;*stubbed*&lt;/b&gt; methods of given mocks are marked &lt;b&gt;*verified*&lt;/b&gt; so that they don&#39;t get in a way during verifyNoMoreInteractions().
&nbsp;     * &lt;p&gt;
&nbsp;     * This method &lt;b&gt;changes the input mocks&lt;/b&gt;! This method returns input mocks just for convenience.
&nbsp;     * &lt;p&gt;
&nbsp;     * Ignored stubs will also be ignored for verification inOrder, including {@link org.mockito.InOrder#verifyNoMoreInteractions()}.
&nbsp;     * See the second example.
&nbsp;     * &lt;p&gt;
&nbsp;     * Example:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *  //mocking lists for the sake of the example (if you mock List in real you will burn in hell)
&nbsp;     *  List mock1 = mock(List.class), mock2 = mock(List.class);
&nbsp;     *
&nbsp;     *  //stubbing mocks:
&nbsp;     *  when(mock1.get(0)).thenReturn(10);
&nbsp;     *  when(mock2.get(0)).thenReturn(20);
&nbsp;     *
&nbsp;     *  //using mocks by calling stubbed get(0) methods:
&nbsp;     *  System.out.println(mock1.get(0)); //prints 10
&nbsp;     *  System.out.println(mock2.get(0)); //prints 20
&nbsp;     *
&nbsp;     *  //using mocks by calling clear() methods:
&nbsp;     *  mock1.clear();
&nbsp;     *  mock2.clear();
&nbsp;     *
&nbsp;     *  //verification:
&nbsp;     *  verify(mock1).clear();
&nbsp;     *  verify(mock2).clear();
&nbsp;     *
&nbsp;     *  //verifyNoMoreInteractions() fails because get() methods were not accounted for.
&nbsp;     *  try { verifyNoMoreInteractions(mock1, mock2); } catch (NoInteractionsWanted e);
&nbsp;     *
&nbsp;     *  //However, if we ignore stubbed methods then we can verifyNoMoreInteractions()
&nbsp;     *  verifyNoMoreInteractions(ignoreStubs(mock1, mock2));
&nbsp;     *
&nbsp;     *  //Remember that ignoreStubs() &lt;b&gt;*changes*&lt;/b&gt; the input mocks and returns them for convenience.
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * Ignoring stubs can be used with &lt;b&gt;verification in order&lt;/b&gt;:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *  List list = mock(List.class);
&nbsp;     *  when(list.get(0)).thenReturn(&quot;foo&quot;);
&nbsp;     *
&nbsp;     *  list.add(0);
&nbsp;     *  list.clear();
&nbsp;     *  System.out.println(list.get(0)); //we don&#39;t want to verify this
&nbsp;     *
&nbsp;     *  InOrder inOrder = inOrder(ignoreStubs(list));
&nbsp;     *  inOrder.verify(list).add(0);
&nbsp;     *  inOrder.verify(list).clear();
&nbsp;     *  inOrder.verifyNoMoreInteractions();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * @since 1.9.0
&nbsp;     * @param mocks input mocks that will be changed
&nbsp;     * @return the same mocks that were passed in as parameters
&nbsp;     */
&nbsp;    public static Object[] ignoreStubs(Object... mocks) {
<b class="nc">&nbsp;        return MOCKITO_CORE.ignoreStubs(mocks);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows verifying exact number of invocations. E.g:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   verify(mock, times(2)).someMethod(&quot;some arg&quot;);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param wantedNumberOfInvocations wanted number of invocations
&nbsp;     *
&nbsp;     * @return verification mode
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static VerificationMode times(int wantedNumberOfInvocations) {
<b class="nc">&nbsp;        return VerificationModeFactory.times(wantedNumberOfInvocations);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Alias to &lt;code&gt;times(0)&lt;/code&gt;, see {@link Mockito#times(int)}
&nbsp;     * &lt;p&gt;
&nbsp;     * Verifies that interaction did not happen. E.g:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   verify(mock, never()).someMethod();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * If you want to verify there were NO interactions with the mock
&nbsp;     * check out {@link Mockito#verifyZeroInteractions(Object...)}
&nbsp;     * or {@link Mockito#verifyNoMoreInteractions(Object...)}
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @return verification mode
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static VerificationMode never() {
<b class="nc">&nbsp;        return times(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows at-least-once verification. E.g:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   verify(mock, atLeastOnce()).someMethod(&quot;some arg&quot;);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * Alias to &lt;code&gt;atLeast(1)&lt;/code&gt;.
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @return verification mode
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static VerificationMode atLeastOnce() {
<b class="nc">&nbsp;        return VerificationModeFactory.atLeastOnce();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows at-least-x verification. E.g:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   verify(mock, atLeast(3)).someMethod(&quot;some arg&quot;);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param minNumberOfInvocations minimum number of invocations
&nbsp;     *
&nbsp;     * @return verification mode
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static VerificationMode atLeast(int minNumberOfInvocations) {
<b class="nc">&nbsp;        return VerificationModeFactory.atLeast(minNumberOfInvocations);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows at-most-x verification. E.g:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   verify(mock, atMost(3)).someMethod(&quot;some arg&quot;);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param maxNumberOfInvocations max number of invocations
&nbsp;     *
&nbsp;     * @return verification mode
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static VerificationMode atMost(int maxNumberOfInvocations) {
<b class="nc">&nbsp;        return VerificationModeFactory.atMost(maxNumberOfInvocations);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows non-greedy verification in order.  For example
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   inOrder.verify( mock, calls( 2 )).someMethod( &quot;some arg&quot; );
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;will not fail if the method is called 3 times, unlike times( 2 )&lt;/li&gt;
&nbsp;     * &lt;li&gt;will not mark the third invocation as verified, unlike atLeast( 2 )&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * This verification mode can only be used with in order verification.
&nbsp;     * @param wantedNumberOfInvocations number of invocations to verify
&nbsp;     * @return  verification mode
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static VerificationMode calls( int wantedNumberOfInvocations ){
<b class="nc">&nbsp;        return VerificationModeFactory.calls( wantedNumberOfInvocations );</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows checking if given method was the only one invoked. E.g:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   verify(mock, only()).someMethod();
&nbsp;     *   //above is a shorthand for following 2 lines of code:
&nbsp;     *   verify(mock).someMethod();
&nbsp;     *   verifyNoMoreInvocations(mock);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * See also {@link Mockito#verifyNoMoreInteractions(Object...)}
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @return verification mode
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static VerificationMode only() {
<b class="nc">&nbsp;        return VerificationModeFactory.only();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Verification will be triggered after given amount of millis, allowing testing of async code.
&nbsp;     * Useful when interactions with the mock object did not happened yet.
&nbsp;     * Extensive use of after() method can be a code smell - there are better ways of testing concurrent code.
&nbsp;     * &lt;p&gt;
&nbsp;     * See also {@link #after(long)} method for testing async code.
&nbsp;     * Differences between {@code timeout()} and {@code after} are explained in Javadoc for {@link #after(long)}.
&nbsp;     * &lt;p&gt;
&nbsp;     * Extensive use of {@code timeout()} method can be a code smell - there are better ways of testing concurrent code.
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   //passes when someMethod() is called no later than within 100 ms
&nbsp;     *   //exits immediately when verification is satisfied (e.g. may not wait full 100 ms)
&nbsp;     *   verify(mock, timeout(100)).someMethod();
&nbsp;     *   //above is an alias to:
&nbsp;     *   verify(mock, timeout(100).times(1)).someMethod();
&nbsp;     *
&nbsp;     *   //passes as soon as someMethod() has been called 2 times under 100 ms
&nbsp;     *   verify(mock, timeout(100).times(2)).someMethod();
&nbsp;     *
&nbsp;     *   //equivalent: this also passes as soon as someMethod() has been called 2 times under 100 ms
&nbsp;     *   verify(mock, timeout(100).atLeast(2)).someMethod();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param millis - duration in milliseconds
&nbsp;     *
&nbsp;     * @return object that allows fluent specification of the verification (times(x), atLeast(y), etc.)
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static VerificationWithTimeout timeout(long millis) {
<b class="nc">&nbsp;        return new Timeout(millis, VerificationModeFactory.times(1));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Verification will be triggered after given amount of millis, allowing testing of async code.
&nbsp;     * Useful when interactions with the mock object did not happened yet.
&nbsp;     * Extensive use of after() method can be a code smell - there are better ways of testing concurrent code.
&nbsp;     * &lt;p&gt;
&nbsp;     * Not yet implemented to work with InOrder verification.
&nbsp;     * &lt;p&gt;
&nbsp;     * See also {@link #timeout(long)} method for testing async code.
&nbsp;     * Differences between {@code timeout()} and {@code after()} are explained below.
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   //passes after 100ms, if someMethod() has only been called once at that time.
&nbsp;     *   verify(mock, after(100)).someMethod();
&nbsp;     *   //above is an alias to:
&nbsp;     *   verify(mock, after(100).times(1)).someMethod();
&nbsp;     *
&nbsp;     *   //passes if someMethod() is called &lt;b&gt;*exactly*&lt;/b&gt; 2 times, as tested after 100 millis
&nbsp;     *   verify(mock, after(100).times(2)).someMethod();
&nbsp;     *
&nbsp;     *   //passes if someMethod() has not been called, as tested after 100 millis
&nbsp;     *   verify(mock, after(100).never()).someMethod();
&nbsp;     *
&nbsp;     *   //verifies someMethod() after a given time span using given verification mode
&nbsp;     *   //useful only if you have your own custom verification modes.
&nbsp;     *   verify(mock, new After(100, yourOwnVerificationMode)).someMethod();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;strong&gt;timeout() vs. after()&lt;/strong&gt;
&nbsp;     * &lt;ul&gt;
&nbsp;     *     &lt;li&gt;timeout() exits immediately with success when verification passes&lt;/li&gt;
&nbsp;     *     &lt;li&gt;after() awaits full duration to check if verification passes&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * Examples:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   //1.
&nbsp;     *   mock.foo();
&nbsp;     *   verify(mock, after(1000)).foo();
&nbsp;     *   //waits 1000 millis and succeeds
&nbsp;     *
&nbsp;     *   //2.
&nbsp;     *   mock.foo();
&nbsp;     *   verify(mock, timeout(1000)).foo();
&nbsp;     *   //succeeds immediately
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     *
&nbsp;     * @param millis - duration in milliseconds
&nbsp;     *
&nbsp;     * @return object that allows fluent specification of the verification
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static VerificationAfterDelay after(long millis) {
<b class="nc">&nbsp;        return new After(millis, VerificationModeFactory.times(1));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: &lt;a href=&quot;https://github.com/mockito/mockito/wiki/FAQ&quot;&gt;https://github.com/mockito/mockito/wiki/FAQ&lt;/a&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * In case of questions you may also post to mockito mailing list: &lt;a href=&quot;http://groups.google.com/group/mockito&quot;&gt;http://groups.google.com/group/mockito&lt;/a&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;code&gt;validateMockitoUsage()&lt;/code&gt; &lt;b&gt;explicitly validates&lt;/b&gt; the framework state to detect invalid use of Mockito.
&nbsp;     * However, this feature is optional &lt;b&gt;because Mockito validates the usage all the time...&lt;/b&gt; but there is a gotcha so read on.
&nbsp;     * &lt;p&gt;
&nbsp;     * Examples of incorrect use:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     * //Oops, thenReturn() part is missing:
&nbsp;     * when(mock.get());
&nbsp;     *
&nbsp;     * //Oops, verified method call is inside verify() where it should be on the outside:
&nbsp;     * verify(mock.execute());
&nbsp;     *
&nbsp;     * //Oops, missing method to verify:
&nbsp;     * verify(mock);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * Mockito throws exceptions if you misuse it so that you know if your tests are written correctly.
&nbsp;     * The gotcha is that Mockito does the validation &lt;b&gt;next time&lt;/b&gt; you use the framework (e.g. next time you verify, stub, call mock etc.).
&nbsp;     * But even though the exception might be thrown in the next test,
&nbsp;     * the exception &lt;b&gt;message contains a navigable stack trace element&lt;/b&gt; with location of the defect.
&nbsp;     * Hence you can click and find the place where Mockito was misused.
&nbsp;     * &lt;p&gt;
&nbsp;     * Sometimes though, you might want to validate the framework usage explicitly.
&nbsp;     * For example, one of the users wanted to put &lt;code&gt;validateMockitoUsage()&lt;/code&gt; in his &lt;code&gt;&amp;#064;After&lt;/code&gt; method
&nbsp;     * so that he knows immediately when he misused Mockito.
&nbsp;     * Without it, he would have known about it not sooner than &lt;b&gt;next time&lt;/b&gt; he used the framework.
&nbsp;     * One more benefit of having &lt;code&gt;validateMockitoUsage()&lt;/code&gt; in &lt;code&gt;&amp;#064;After&lt;/code&gt; is that jUnit runner and rule will always fail in the test method with defect
&nbsp;     * whereas ordinary &#39;next-time&#39; validation might fail the &lt;b&gt;next&lt;/b&gt; test method.
&nbsp;     * But even though JUnit might report next test as red, don&#39;t worry about it
&nbsp;     * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Both built-in runner: {@link MockitoJUnitRunner} and rule: {@link MockitoRule}&lt;/b&gt; do validateMockitoUsage() after each test method.
&nbsp;     * &lt;p&gt;
&nbsp;     * Bear in mind that &lt;b&gt;usually you don&#39;t have to &lt;code&gt;validateMockitoUsage()&lt;/code&gt;&lt;/b&gt;
&nbsp;     * and framework validation triggered on next-time basis should be just enough,
&nbsp;     * mainly because of enhanced exception message with clickable location of defect.
&nbsp;     * However, I would recommend validateMockitoUsage() if you already have sufficient test infrastructure
&nbsp;     * (like your own runner or base class for all tests) because adding a special action to &lt;code&gt;&amp;#064;After&lt;/code&gt; has zero cost.
&nbsp;     * &lt;p&gt;
&nbsp;     * See examples in javadoc for {@link Mockito} class
&nbsp;     */
&nbsp;    public static void validateMockitoUsage() {
<b class="nc">&nbsp;        MOCKITO_CORE.validateMockitoUsage();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows mock creation with additional mock settings.
&nbsp;     * &lt;p&gt;
&nbsp;     * Don&#39;t use it too often.
&nbsp;     * Consider writing simple tests that use simple mocks.
&nbsp;     * Repeat after me: simple tests push simple, KISSy, readable &amp; maintainable code.
&nbsp;     * If you cannot write a test in a simple way - refactor the code under test.
&nbsp;     * &lt;p&gt;
&nbsp;     * Examples of mock settings:
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   //Creates mock with different default answer &amp; name
&nbsp;     *   Foo mock = mock(Foo.class, withSettings()
&nbsp;     *       .defaultAnswer(RETURNS_SMART_NULLS)
&nbsp;     *       .name(&quot;cool mockie&quot;));
&nbsp;     *
&nbsp;     *   //Creates mock with different default answer, descriptive name and extra interfaces
&nbsp;     *   Foo mock = mock(Foo.class, withSettings()
&nbsp;     *       .defaultAnswer(RETURNS_SMART_NULLS)
&nbsp;     *       .name(&quot;cool mockie&quot;)
&nbsp;     *       .extraInterfaces(Bar.class));
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * {@link MockSettings} has been introduced for two reasons.
&nbsp;     * Firstly, to make it easy to add another mock settings when the demand comes.
&nbsp;     * Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods.
&nbsp;     * &lt;p&gt;
&nbsp;     * See javadoc for {@link MockSettings} to learn about possible mock settings.
&nbsp;     * &lt;p&gt;
&nbsp;     *
&nbsp;     * @return mock settings instance with defaults.
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static MockSettings withSettings() {
<b class="fc">&nbsp;        return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a description to be printed if verification fails.
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     * verify(mock, description(&quot;This will print on failure&quot;)).someMethod(&quot;some arg&quot;);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     * @param description The description to print on failure.
&nbsp;     * @return verification mode
&nbsp;     * @since 2.1.0
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public static VerificationMode description(String description) {
<b class="nc">&nbsp;        return times(1).description(description);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated - please use {@link MockingDetails#printInvocations()} instead.
&nbsp;     * An instance of {@code MockingDetails} can be retrieved via {@link #mockingDetails(Object)}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    @CheckReturnValue
&nbsp;    static MockitoDebugger debug() {
<b class="nc">&nbsp;        return new MockitoDebuggerImpl();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * For advanced users or framework integrators. See {@link MockitoFramework} class.
&nbsp;     *
&nbsp;     * @since 2.1.0
&nbsp;     */
&nbsp;    @Incubating
&nbsp;    @CheckReturnValue
&nbsp;    public static MockitoFramework framework() {
<b class="nc">&nbsp;        return new DefaultMockitoFramework();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@code MockitoSession} is an optional, highly recommended feature
&nbsp;     * that helps driving cleaner tests by eliminating boilerplate code and adding extra validation.
&nbsp;     * &lt;p&gt;
&nbsp;     * For more information, including use cases and sample code, see the javadoc for {@link MockitoSession}.
&nbsp;     *
&nbsp;     * @since 2.7.0
&nbsp;     */
&nbsp;    @Incubating
&nbsp;    @CheckReturnValue
&nbsp;    public static MockitoSessionBuilder mockitoSession() {
<b class="nc">&nbsp;        return new DefaultMockitoSessionBuilder();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Lenient stubs bypass &quot;strict stubbing&quot; validation (see {@link Strictness#STRICT_STUBS}).
&nbsp;     * When stubbing is declared as lenient, it will not be checked for potential stubbing problems such as
&nbsp;     * &#39;unnecessary stubbing&#39; ({@link UnnecessaryStubbingException}) or for &#39;stubbing argument mismatch&#39; {@link PotentialStubbingProblem}.
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     *   lenient().when(mock.foo()).thenReturn(&quot;ok&quot;);
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * Most mocks in most tests don&#39;t need leniency and should happily prosper with {@link Strictness#STRICT_STUBS}.
&nbsp;     * &lt;ul&gt;
&nbsp;     *     &lt;li&gt;If a specific stubbing needs to be lenient - use this method&lt;/li&gt;
&nbsp;     *     &lt;li&gt;If a specific mock need to have stubbings lenient - use {@link MockSettings#lenient()}&lt;/li&gt;
&nbsp;     *     &lt;li&gt;If a specific test method / test class needs to have all stubbings lenient
&nbsp;     *          - configure strictness using our JUnit support ({@link MockitoJUnit} or Mockito Session ({@link MockitoSession})&lt;/li&gt;
&nbsp;     *
&nbsp;     * &lt;h3&gt;Elaborate example&lt;/h3&gt;
&nbsp;     *
&nbsp;     * In below example, &#39;foo.foo()&#39; is a stubbing that was moved to &#39;before()&#39; method to avoid duplication.
&nbsp;     * Doing so makes one of the test methods (&#39;test3()&#39;) fail with &#39;unnecessary stubbing&#39;.
&nbsp;     * To resolve it we can configure &#39;foo.foo()&#39; stubbing in &#39;before()&#39; method to be lenient.
&nbsp;     * Alternatively, we can configure entire &#39;foo&#39; mock as lenient.
&nbsp;     * &lt;p&gt;
&nbsp;     * This example is simplified and not realistic.
&nbsp;     * Pushing stubbings to &#39;before()&#39; method may cause tests to be less readable.
&nbsp;     * Some repetition in tests is OK, use your own judgement to write great tests!
&nbsp;     * It is not desired to eliminate all possible duplication from the test code
&nbsp;     * because it may add complexity and conceal important test information.
&nbsp;     *
&nbsp;     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
&nbsp;     * public class SomeTest {
&nbsp;     *
&nbsp;     *     &amp;#064;Rule public MockitoRule mockito = MockitoJUnit.rule().strictness(STRICT_STUBS);
&nbsp;     *
&nbsp;     *     &amp;#064;Mock Foo foo;
&nbsp;     *     &amp;#064;Mock Bar bar;
&nbsp;     *
&nbsp;     *     &amp;#064;Before public void before() {
&nbsp;     *         when(foo.foo()).thenReturn(&quot;ok&quot;);
&nbsp;     *
&nbsp;     *         // it is better to configure the stubbing to be lenient:
&nbsp;     *         // lenient().when(foo.foo()).thenReturn(&quot;ok&quot;);
&nbsp;     *
&nbsp;     *         // or the entire mock to be lenient:
&nbsp;     *         // foo = mock(Foo.class, withSettings().lenient());
&nbsp;     *     }
&nbsp;     *
&nbsp;     *     &amp;#064;Test public void test1() {
&nbsp;     *         foo.foo();
&nbsp;     *     }
&nbsp;     *
&nbsp;     *     &amp;#064;Test public void test2() {
&nbsp;     *         foo.foo();
&nbsp;     *     }
&nbsp;     *
&nbsp;     *     &amp;#064;Test public void test3() {
&nbsp;     *         bar.bar();
&nbsp;     *     }
&nbsp;     * }
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * @since 2.20.0
&nbsp;     */
&nbsp;    @Incubating
&nbsp;    public static LenientStubber lenient() {
<b class="nc">&nbsp;        return MOCKITO_CORE.lenient();</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-13 20:58</div>
</div>
</body>
</html>
